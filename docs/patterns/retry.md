---
title: Retry
description: Engedélyezheti egy alkalmazás számára a szolgáltatásokhoz vagy hálózati erőforrásokhoz való csatlakozáskor jelentkező előre jelzett, átmeneti meghibásodások kezelését egy korábban meghiúsult művelet transzparens módon való ismételt megkísérlésével.
keywords: Kialakítási mintája
author: dragon119
ms.date: 06/23/2017
pnp.series.title: Cloud Design Patterns
pnp.pattern.categories:
- resiliency
ms.openlocfilehash: 73fdcbcc2bd75593a4c8e33dc2259c90593e14db
ms.sourcegitcommit: 3d9ee03e2dda23753661a80c7106d1789f5223bb
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 02/23/2018
---
# <a name="retry-pattern"></a><span data-ttu-id="81609-104">Ismételje meg a minta</span><span class="sxs-lookup"><span data-stu-id="81609-104">Retry pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="81609-105">Átmeneti hibák kezeléséhez, ha csatlakozik egy szolgáltatás vagy a hálózati erőforráshoz, a sikertelen művelettel transzparens módon megpróbálásával alkalmazás engedélyezése.</span><span class="sxs-lookup"><span data-stu-id="81609-105">Enable an application to handle transient failures when it tries to connect to a service or network resource, by transparently retrying a failed operation.</span></span> <span data-ttu-id="81609-106">Ez javítja az alkalmazás stabilitását.</span><span class="sxs-lookup"><span data-stu-id="81609-106">This can improve the stability of the application.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="81609-107">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="81609-107">Context and problem</span></span>

<span data-ttu-id="81609-108">Egy alkalmazás, amely kommunikál a felhőben futó elemek nem lehet az átmeneti hibák ebben a környezetben felmerülő-és nagybetűket.</span><span class="sxs-lookup"><span data-stu-id="81609-108">An application that communicates with elements running in the cloud has to be sensitive to the transient faults that can occur in this environment.</span></span> <span data-ttu-id="81609-109">Hibák a következők: hálózati összetevőkkel és szolgáltatásokkal kapcsolatban a pillanatnyi elvesztését, egy szolgáltatás, vagy előforduló fordulhat elő, amikor egy szolgáltatás foglalt ideiglenes elérhetetlensége.</span><span class="sxs-lookup"><span data-stu-id="81609-109">Faults include the momentary loss of network connectivity to components and services, the temporary unavailability of a service, or timeouts that occur when a service is busy.</span></span>

<span data-ttu-id="81609-110">Ezek a hibák általában önállóan korrigálja, és ha a hibát kiváltó műveletet meg kell ismételni megfelelő késleltetéssel is valószínűleg sikeres lesz.</span><span class="sxs-lookup"><span data-stu-id="81609-110">These faults are typically self-correcting, and if the action that triggered a fault is repeated after a suitable delay it's likely to be successful.</span></span> <span data-ttu-id="81609-111">Például egy adatbázis-szolgáltatás, amely sok egyidejű kérés feldolgozása folyamatban van a sávszélesség-szabályozási stratégia, amely ideiglenesen kódszegmensek semmilyen további mindaddig, amíg a munkaterhelés rendelkezik megkönnyítését is létrehozható.</span><span class="sxs-lookup"><span data-stu-id="81609-111">For example, a database service that's processing a large number of concurrent requests can implement a throttling strategy that temporarily rejects any further requests until its workload has eased.</span></span> <span data-ttu-id="81609-112">Egy alkalmazás, az adatbázis elérésére tett kísérlet sikertelen lehet a kapcsolat, de ismét várakozás után próbálja azt sikeres lehet.</span><span class="sxs-lookup"><span data-stu-id="81609-112">An application trying to access the database might fail to connect, but if it tries again after a delay it might succeed.</span></span>

## <a name="solution"></a><span data-ttu-id="81609-113">Megoldás</span><span class="sxs-lookup"><span data-stu-id="81609-113">Solution</span></span>

<span data-ttu-id="81609-114">A felhőben átmeneti nem ritka, és egy alkalmazást úgy kell megtervezni, elegantly és transzparens módon kezelje őket.</span><span class="sxs-lookup"><span data-stu-id="81609-114">In the cloud, transient faults aren't uncommon and an application should be designed to handle them elegantly and transparently.</span></span> <span data-ttu-id="81609-115">Ez minimalizálja a hibák lehet az üzleti feladatok működik-e az alkalmazás által okozott hatások.</span><span class="sxs-lookup"><span data-stu-id="81609-115">This minimizes the effects faults can have on the business tasks the application is performing.</span></span>

<span data-ttu-id="81609-116">Ha egy alkalmazás hibát észlel, amikor megpróbálja kérelmet küld a távoli szolgáltatás, a hiba a következő stratégiák használata is képes kezelni:</span><span class="sxs-lookup"><span data-stu-id="81609-116">If an application detects a failure when it tries to send a request to a remote service, it can handle the failure using the following strategies:</span></span>

- <span data-ttu-id="81609-117">**Szakítsa meg**.</span><span class="sxs-lookup"><span data-stu-id="81609-117">**Cancel**.</span></span> <span data-ttu-id="81609-118">Ha a hiba azt jelzi, hogy a probléma nem átmeneti, vagy nem valószínű, hogy sikeres, ha ismétlődő, az alkalmazás kell a művelet megszakításához és kivétel jelentéséhez.</span><span class="sxs-lookup"><span data-stu-id="81609-118">If the fault indicates that the failure isn't transient or is unlikely to be successful if repeated, the application should cancel the operation and report an exception.</span></span> <span data-ttu-id="81609-119">Például érvénytelen hitelesítő adatok megadása által okozott hitelesítési hiba oka nem kísérlet sikeres függetlenül attól, hogy hány alkalommal azt.</span><span class="sxs-lookup"><span data-stu-id="81609-119">For example, an authentication failure caused by providing invalid credentials is not likely to succeed no matter how many times it's attempted.</span></span>

- <span data-ttu-id="81609-120">**Próbálja meg újra**.</span><span class="sxs-lookup"><span data-stu-id="81609-120">**Retry**.</span></span> <span data-ttu-id="81609-121">Ha a konkrét hibát jelentett szokatlan vagy ritka, akkor előfordulhat, hogy által okozott megszokottól például egy hálózati csomag sérülésének, amíg a továbbítás.</span><span class="sxs-lookup"><span data-stu-id="81609-121">If the specific fault reported is unusual or rare, it might have been caused by unusual circumstances such as a network packet becoming corrupted while it was being transmitted.</span></span> <span data-ttu-id="81609-122">Ebben az esetben az alkalmazás sikerült próbálja meg újra a sikertelen kérelem újra azonnal mert megszokott hiba valószínűleg nem ismételhető meg, és a kérés valószínűleg sikeres lesz.</span><span class="sxs-lookup"><span data-stu-id="81609-122">In this case, the application could retry the failing request again immediately because the same failure is unlikely to be repeated and the request will probably be successful.</span></span>

- <span data-ttu-id="81609-123">**Újrapróbálkozás késleltetése.**</span><span class="sxs-lookup"><span data-stu-id="81609-123">**Retry after delay.**</span></span> <span data-ttu-id="81609-124">Ha egy több alkotómunkájának kapcsolat vagy foglalt hibák okozza a hibát, a hálózat vagy a szolgáltatás szükség lehet rövid időn belül során a problémák kijavítására sor vagy a hátralékos munkák nincs bejelölve.</span><span class="sxs-lookup"><span data-stu-id="81609-124">If the fault is caused by one of the more commonplace connectivity or busy failures, the network or service might need a short period while the connectivity issues are corrected or the backlog of work is cleared.</span></span> <span data-ttu-id="81609-125">Az alkalmazás várakoznia kell egy megfelelő idő, mielőtt megpróbálná megismételni a kérelmet.</span><span class="sxs-lookup"><span data-stu-id="81609-125">The application should wait for a suitable time before retrying the request.</span></span>

<span data-ttu-id="81609-126">A gyakori átmeneti hibák újrapróbálkozások között az alkalmazás több példánya kérelmeinek lehetőség szerint egyenletes terjesztésére kell kiválasztani.</span><span class="sxs-lookup"><span data-stu-id="81609-126">For the more common transient failures, the period between retries should be chosen to spread requests from multiple instances of the application as evenly as possible.</span></span> <span data-ttu-id="81609-127">Ez csökkenti a túlterhelt folytatása foglalt szolgáltatás esélyét.</span><span class="sxs-lookup"><span data-stu-id="81609-127">This reduces the chance of a busy service continuing to be overloaded.</span></span> <span data-ttu-id="81609-128">Ha egy alkalmazás hány példánya van folyamatosan overwhelming újrapróbálkozási által érintett szolgáltatás, ez vesz igénybe a szolgáltatás hosszabb helyreállításához.</span><span class="sxs-lookup"><span data-stu-id="81609-128">If many instances of an application are continually overwhelming a service with retry requests, it'll take the service longer to recover.</span></span>

<span data-ttu-id="81609-129">Ha a kérés továbbra is sikertelen, az alkalmazás várja meg, és megismétléséhez.</span><span class="sxs-lookup"><span data-stu-id="81609-129">If the request still fails, the application can wait and make another attempt.</span></span> <span data-ttu-id="81609-130">Ha szükséges, ez a folyamat megismételhető végezzenek újrapróbálkozások, amíg néhány kérelmek maximális számát kísérletek közötti üzenetváltás miatti késésekre.</span><span class="sxs-lookup"><span data-stu-id="81609-130">If necessary, this process can be repeated with increasing delays between retry attempts, until some maximum number of requests have been attempted.</span></span> <span data-ttu-id="81609-131">A késleltetés növelhető Növekményesen vagy exponenciálisan növekszik, attól függően, hogy milyen típusú hibával és a valószínűsége annak, hogy azt fogja javítani ebben az időszakban.</span><span class="sxs-lookup"><span data-stu-id="81609-131">The delay can be increased incrementally or exponentially, depending on the type of failure and the probability that it'll be corrected during this time.</span></span>

<span data-ttu-id="81609-132">A következő ábra szemlélteti ezt a mintát használja egy üzemeltetett szolgáltatás művelet meghívása.</span><span class="sxs-lookup"><span data-stu-id="81609-132">The following diagram illustrates invoking an operation in a hosted service using this pattern.</span></span> <span data-ttu-id="81609-133">Ha egy előre meghatározott számú kísérlet után a kérelem sikertelen, az alkalmazás kell kezelje a tartalék kivétel és ennek megfelelően kezelnie.</span><span class="sxs-lookup"><span data-stu-id="81609-133">If the request is unsuccessful after a predefined number of attempts, the application should treat the fault as an exception and handle it accordingly.</span></span>

![1. ábra – olyan üzemeltett szolgáltatásban, az újrapróbálkozási minta használatával a művelet meghívása](./_images/retry-pattern.png)

<span data-ttu-id="81609-135">Az alkalmazás összes próbálja meg elérni a távoli szolgáltatás, amely megfelelő a fent felsorolt stratégiák egyikét újrapróbálkozási házirendje kódban sortörés.</span><span class="sxs-lookup"><span data-stu-id="81609-135">The application should wrap all attempts to access a remote service in code that implements a retry policy matching one of the strategies listed above.</span></span> <span data-ttu-id="81609-136">Különböző szolgáltatások küldött kérelmeket a különböző házirend lehet.</span><span class="sxs-lookup"><span data-stu-id="81609-136">Requests sent to different services can be subject to different policies.</span></span> <span data-ttu-id="81609-137">Egyes szállítók adja meg a szalagtár szerepel, amely alkalmazhatja újrapróbálkozási házirendeket, ahol az alkalmazás adhat meg a maximális számú újrapróbálkozást, az ismételt kísérletek számát, és más paramétereket közötti idő.</span><span class="sxs-lookup"><span data-stu-id="81609-137">Some vendors provide libraries that implement retry policies, where the application can specify the maximum number of retries, the time between retry attempts, and other parameters.</span></span>

<span data-ttu-id="81609-138">Az alkalmazás adatainak hibák, de sikertelenül műveletek kell naplózása.</span><span class="sxs-lookup"><span data-stu-id="81609-138">An application should log the details of faults and failing operations.</span></span> <span data-ttu-id="81609-139">Ez az információ operátorok.</span><span class="sxs-lookup"><span data-stu-id="81609-139">This information is useful to operators.</span></span> <span data-ttu-id="81609-140">Egy szolgáltatás, a rendszer gyakran nem érhető el vagy foglalt esetén gyakran, mert a szolgáltatás kimerítette erőforrásait.</span><span class="sxs-lookup"><span data-stu-id="81609-140">If a service is frequently unavailable or busy, it's often because the service has exhausted its resources.</span></span> <span data-ttu-id="81609-141">A gyakorisága, ezek csökkentheti, ha a szolgáltatás kiterjesztése.</span><span class="sxs-lookup"><span data-stu-id="81609-141">You can reduce the frequency of these faults by scaling out the service.</span></span> <span data-ttu-id="81609-142">Például ha egy adatbázis-szolgáltatás folyamatosan túl van terhelve, annak lehet hasznos az adatbázis partícióazonosító és a terhelés elosztva több kiszolgáló között.</span><span class="sxs-lookup"><span data-stu-id="81609-142">For example, if a database service is continually overloaded, it might be beneficial to partition the database and spread the load across multiple servers.</span></span>

> <span data-ttu-id="81609-143">[Microsoft Entity Framework](https://docs.microsoft.com/ef/) újra próbálkozik a Helyadatbázis-műveletekhez szolgáltatásokat tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="81609-143">[Microsoft Entity Framework](https://docs.microsoft.com/ef/) provides facilities for retrying database operations.</span></span> <span data-ttu-id="81609-144">Is az Azure-szolgáltatások és az ügyfél SDK-k tartalmaznak egy újrapróbálkozási mechanizmus.</span><span class="sxs-lookup"><span data-stu-id="81609-144">Also, most Azure services and client SDKs include a retry mechanism.</span></span> <span data-ttu-id="81609-145">További információkért lásd: [ismételje meg az adott szolgáltatások útmutatást](https://docs.microsoft.com/azure/architecture/best-practices/retry-service-specific).</span><span class="sxs-lookup"><span data-stu-id="81609-145">For more information, see [Retry guidance for specific services](https://docs.microsoft.com/azure/architecture/best-practices/retry-service-specific).</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="81609-146">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="81609-146">Issues and considerations</span></span>

<span data-ttu-id="81609-147">Ebben a mintában megvalósításához meghatározásakor vegye figyelembe a következő szempontokat.</span><span class="sxs-lookup"><span data-stu-id="81609-147">You should consider the following points when deciding how to implement this pattern.</span></span>

<span data-ttu-id="81609-148">Az újrapróbálkozási házirendet kell kell beállítani, hogy megfelel-e az alkalmazás az üzleti követelmények és a hibaüzeneteket a hiba természetének.</span><span class="sxs-lookup"><span data-stu-id="81609-148">The retry policy should be tuned to match the business requirements of the application and the nature of the failure.</span></span> <span data-ttu-id="81609-149">Egyes nem kritikus műveletek esetében érdemes gyors sikertelen helyett több alkalommal újra, és hatással lehet az alkalmazás átviteli.</span><span class="sxs-lookup"><span data-stu-id="81609-149">For some noncritical operations, it's better to fail fast rather than retry several times and impact the throughput of the application.</span></span> <span data-ttu-id="81609-150">Például egy interaktív webes alkalmazásban fér hozzá a távoli szolgáltatás, érdemes kisebb számú újrapróbálkozások újrapróbálkozások között csak rövid késleltetés után nem sikerül, és a megfelelő üzenetet jelenít meg, a felhasználónak (például "próbálkozzon újra később").</span><span class="sxs-lookup"><span data-stu-id="81609-150">For example, in an interactive web application accessing a remote service, it's better to fail after a smaller number of retries with only a short delay between retry attempts, and display a suitable message to the user (for example, “please try again later”).</span></span> <span data-ttu-id="81609-151">Kötegelt alkalmazáshoz akkor célszerű több exponenciálisan növekszik késleltetéssel a kísérletek között újrapróbálkozások számának növeléséhez.</span><span class="sxs-lookup"><span data-stu-id="81609-151">For a batch application, it might be more appropriate to increase the number of retry attempts with an exponentially increasing delay between attempts.</span></span>

<span data-ttu-id="81609-152">Egy kísérletet, és számos, az újrapróbálkozásokat minimális késleltetés agresszív újrapróbálkozási házirendje további ronthatja a közeli vagy kapacitással futó foglalt szolgáltatást.</span><span class="sxs-lookup"><span data-stu-id="81609-152">An aggressive retry policy with minimal delay between attempts, and a large number of retries, could further degrade a busy service that's running close to or at capacity.</span></span> <span data-ttu-id="81609-153">Az újrapróbálkozási házirendje is befolyásolhatják a figyelt alkalmazás, ha folyamatosan próbál a sikertelen műveletet.</span><span class="sxs-lookup"><span data-stu-id="81609-153">This retry policy could also affect the responsiveness of the application if it's continually trying to perform a failing operation.</span></span>

<span data-ttu-id="81609-154">Egy kérelem jelentős számú ismételt próbálkozás után továbbra is sikertelen, akkor jobb, ha az alkalmazás további erőforrást fog kérelmek megakadályozása, és egyszerűen a hibáról jelentés azonnal.</span><span class="sxs-lookup"><span data-stu-id="81609-154">If a request still fails after a significant number of retries, it's better for the application to prevent further requests going to the same resource and simply report a failure immediately.</span></span> <span data-ttu-id="81609-155">Az időszak lejár, ha az alkalmazás feltételesen lehetővé tehetik keresztül egy vagy több kérést a tudni, hogy azok sikeres.</span><span class="sxs-lookup"><span data-stu-id="81609-155">When the period expires, the application can tentatively allow one or more requests through to see whether they're successful.</span></span> <span data-ttu-id="81609-156">Ezt a stratégiát további részletekért lásd: a [áramköri megszakító mintát](circuit-breaker.md).</span><span class="sxs-lookup"><span data-stu-id="81609-156">For more details of this strategy, see the [Circuit Breaker pattern](circuit-breaker.md).</span></span>

<span data-ttu-id="81609-157">Vegye figyelembe, hogy-e a művelet az idempotent.</span><span class="sxs-lookup"><span data-stu-id="81609-157">Consider whether the operation is idempotent.</span></span> <span data-ttu-id="81609-158">Ha igen, az eleve biztonságos, majd ismételje meg.</span><span class="sxs-lookup"><span data-stu-id="81609-158">If so, it's inherently safe to retry.</span></span> <span data-ttu-id="81609-159">Ellenkező esetben az újrapróbálkozások támadó egynél többször nem kívánt mellékhatással működő hajthatnak végre a műveletet.</span><span class="sxs-lookup"><span data-stu-id="81609-159">Otherwise, retries could cause the operation to be executed more than once, with unintended side effects.</span></span> <span data-ttu-id="81609-160">Például egy szolgáltatás előfordulhat, hogy a kérés fogadásához, sikeresen feldolgozni a kérelmet, de nem választ küld.</span><span class="sxs-lookup"><span data-stu-id="81609-160">For example, a service might receive the request, process the request successfully, but fail to send a response.</span></span> <span data-ttu-id="81609-161">Ezen a ponton az újrapróbálkozási logika előfordulhat, hogy újra elküldeni a kérést, feltéve, hogy az első kérésre nem érkezett.</span><span class="sxs-lookup"><span data-stu-id="81609-161">At that point, the retry logic might re-send the request, assuming that the first request wasn't received.</span></span>

<span data-ttu-id="81609-162">A szolgáltatásnak küldött kérelemben számos okból a hiba természetétől függően különböző kivételt váltson ki lehet sikertelen.</span><span class="sxs-lookup"><span data-stu-id="81609-162">A request to a service can fail for a variety of reasons raising different exceptions depending on the nature of the failure.</span></span> <span data-ttu-id="81609-163">Néhány kivétel, amely feloldható gyorsan, míg mások azt jelzi, hogy a hiba már tovább tartó hibájára utalhat.</span><span class="sxs-lookup"><span data-stu-id="81609-163">Some exceptions indicate a failure that can be resolved quickly, while others indicate that the failure is longer lasting.</span></span> <span data-ttu-id="81609-164">Akkor érdemes használni az újrapróbálkozási házirendet úgy, hogy a kivétel típusa alapján újrapróbálkozási kísérletek között eltelt idő.</span><span class="sxs-lookup"><span data-stu-id="81609-164">It's useful for the retry policy to adjust the time between retry attempts based on the type of the exception.</span></span>

<span data-ttu-id="81609-165">Vegye figyelembe, hogy egy művelet, amely része egy tranzakció milyen hatással lesz a teljes tranzakció konzisztencia.</span><span class="sxs-lookup"><span data-stu-id="81609-165">Consider how retrying an operation that's part of a transaction will affect the overall transaction consistency.</span></span> <span data-ttu-id="81609-166">Konfigurálva finomhangolhatják a tranzakciós műveletek maximalizálhatja a siker esélye, visszavonja a tranzakció lépéseket kell csökkentse az újrapróbálkozási házirendet.</span><span class="sxs-lookup"><span data-stu-id="81609-166">Fine tune the retry policy for transactional operations to maximize the chance of success and reduce the need to undo all the transaction steps.</span></span>

<span data-ttu-id="81609-167">Győződjön meg arról, hogy az összes újrapróbálkozási kód teljes körűen tesztelve meghibásodás számos ellen.</span><span class="sxs-lookup"><span data-stu-id="81609-167">Ensure that all retry code is fully tested against a variety of failure conditions.</span></span> <span data-ttu-id="81609-168">Ellenőrizze, hogy nem súlyosan hatással lehet a teljesítmény- vagy az alkalmazás megbízhatóságát, a szolgáltatások és erőforrások túlterhelés miatt, vagy hozzon létre versenyhelyzetek vagy szűk keresztmetszetek.</span><span class="sxs-lookup"><span data-stu-id="81609-168">Check that it doesn't severely impact the performance or reliability of the application, cause excessive load on services and resources, or generate race conditions or bottlenecks.</span></span>

<span data-ttu-id="81609-169">Alkalmazzon újrapróbálkozási logika csak ha a sikertelen művelet teljes környezetében értendő.</span><span class="sxs-lookup"><span data-stu-id="81609-169">Implement retry logic only where the full context of a failing operation is understood.</span></span> <span data-ttu-id="81609-170">Például egy feladatot, amely tartalmazza az újrapróbálkozási házirendje hív meg egy másik feladat újrapróbálkozási házirendje is tartalmazó, a további réteget újrapróbálkozások adhat hozzá nagy késleltetéseket feldolgozását.</span><span class="sxs-lookup"><span data-stu-id="81609-170">For example, if a task that contains a retry policy invokes another task that also contains a retry policy, this extra layer of retries can add long delays to the processing.</span></span> <span data-ttu-id="81609-171">Jobb, ha a gyors sikertelen, és a hiba okát jelentést a feladat aktiváló alacsonyabb szintű feladat lehet.</span><span class="sxs-lookup"><span data-stu-id="81609-171">It might be better to configure the lower-level task to fail fast and report the reason for the failure back to the task that invoked it.</span></span> <span data-ttu-id="81609-172">A magasabb szintű tevékenység majd kezelik a saját házirend alapján hiba.</span><span class="sxs-lookup"><span data-stu-id="81609-172">This higher-level task can then handle the failure based on its own policy.</span></span>

<span data-ttu-id="81609-173">Fontos, hogy az azonosítható legyen az alapul szolgáló problémák az alkalmazáshoz, a szolgáltatások vagy az erőforrások ismételt próbálkozással okozó összes kapcsolathibái bejelentkezni.</span><span class="sxs-lookup"><span data-stu-id="81609-173">It's important to log all connectivity failures that cause a retry so that underlying problems with the application, services, or resources can be identified.</span></span>

<span data-ttu-id="81609-174">Vizsgálja meg a hibákat, amelyek egy szolgáltatás vagy egy erőforrást derítsen fel, ha fontosságúak valószínű, hogy mennyi ideig tartós vagy a Terminálszolgáltatások fordulhat elő.</span><span class="sxs-lookup"><span data-stu-id="81609-174">Investigate the faults that are most likely to occur for a service or a resource to discover if they're likely to be long lasting or terminal.</span></span> <span data-ttu-id="81609-175">Ha igen, célszerű a tartalék kivételként kezeli.</span><span class="sxs-lookup"><span data-stu-id="81609-175">If they are, it's better to handle the fault as an exception.</span></span> <span data-ttu-id="81609-176">Az alkalmazás jelentést vagy jelentkezzen a kivétel, és próbálja meghívása alternatív szolgáltatás (Ha ilyen), vagy funkciókat kínáló csökkentett teljesítményű folytatja.</span><span class="sxs-lookup"><span data-stu-id="81609-176">The application can report or log the exception, and then try to continue either by invoking an alternative service (if one is available), or by offering degraded functionality.</span></span> <span data-ttu-id="81609-177">Észlelése és a hosszú ideig tart hibák kezeléséhez további információkért tekintse meg a [áramköri megszakító mintát](circuit-breaker.md).</span><span class="sxs-lookup"><span data-stu-id="81609-177">For more information on how to detect and handle long-lasting faults, see the [Circuit Breaker pattern](circuit-breaker.md).</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="81609-178">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="81609-178">When to use this pattern</span></span>

<span data-ttu-id="81609-179">Ezt a mintát használja, ha egy alkalmazás sikerült átmeneti tapasztal, egy távoli szolgáltatással együttműködő, vagy egy távoli erőforráshoz fér hozzá.</span><span class="sxs-lookup"><span data-stu-id="81609-179">Use this pattern when an application could experience transient faults as it interacts with a remote service or accesses a remote resource.</span></span> <span data-ttu-id="81609-180">Ezek a hibák kellene lennie a rövid élt, majd ismételje meg a kérelmeket, amelyek korábban nem sikerült a következő kísérlet volt sikeres.</span><span class="sxs-lookup"><span data-stu-id="81609-180">These faults are expected to be short lived, and repeating a request that has previously failed could succeed on a subsequent attempt.</span></span>

<span data-ttu-id="81609-181">Ez a minta nem lehet hasznos:</span><span class="sxs-lookup"><span data-stu-id="81609-181">This pattern might not be useful:</span></span>

- <span data-ttu-id="81609-182">Amikor egy hiba valószínű, hogy hosszú ideig tartó, mert ez befolyásolhatja az alkalmazások válaszkészségét.</span><span class="sxs-lookup"><span data-stu-id="81609-182">When a fault is likely to be long lasting, because this can affect the responsiveness of an application.</span></span> <span data-ttu-id="81609-183">Az alkalmazás előfordulhat, hogy jelentős, időt és erőforrásokat próbál ismételje meg a kérelmeket, amelyek valószínűleg sikertelen lesz.</span><span class="sxs-lookup"><span data-stu-id="81609-183">The application might be wasting time and resources trying to repeat a request that's likely to fail.</span></span>
- <span data-ttu-id="81609-184">Kezelése, amelyek nem átmeneti, például a belső kivételek az üzleti logika egy alkalmazás szereplő hibák által okozott hibák miatt sikertelen.</span><span class="sxs-lookup"><span data-stu-id="81609-184">For handling failures that aren't due to transient faults, such as internal exceptions caused by errors in the business logic of an application.</span></span>
- <span data-ttu-id="81609-185">Méretezhetőségi problémájára címzési rendszerekben helyett.</span><span class="sxs-lookup"><span data-stu-id="81609-185">As an alternative to addressing scalability issues in a system.</span></span> <span data-ttu-id="81609-186">Ha egy alkalmazás gyakori foglalt hibákat észlel, akkor gyakran a jele, hogy a szolgáltatás vagy az éppen elért erőforrás kell kiterjesztett.</span><span class="sxs-lookup"><span data-stu-id="81609-186">If an application experiences frequent busy faults, it's often a sign that the service or resource being accessed should be scaled up.</span></span>

## <a name="example"></a><span data-ttu-id="81609-187">Példa</span><span class="sxs-lookup"><span data-stu-id="81609-187">Example</span></span>

<span data-ttu-id="81609-188">Ebben a példában a C# az újrapróbálkozási minta megvalósítását mutatja be.</span><span class="sxs-lookup"><span data-stu-id="81609-188">This example in C# illustrates an implementation of the Retry pattern.</span></span> <span data-ttu-id="81609-189">A `OperationWithBasicRetryAsync` metódust, az alábbi meghívja az aszinkron módon történik a külső szolgáltatást a `TransientOperationAsync` metódust.</span><span class="sxs-lookup"><span data-stu-id="81609-189">The `OperationWithBasicRetryAsync` method, shown below, invokes an external service asynchronously through the `TransientOperationAsync` method.</span></span> <span data-ttu-id="81609-190">Részletes adatait a `TransientOperationAsync` metódus a szolgáltatásra vonatkozó lesz, és a mintakódot hiányoznak.</span><span class="sxs-lookup"><span data-stu-id="81609-190">The details of the `TransientOperationAsync` method will be specific to the service and are omitted from the sample code.</span></span>

```csharp
private int retryCount = 3;
private readonly TimeSpan delay = TimeSpan.FromSeconds(5);

public async Task OperationWithBasicRetryAsync()
{
  int currentRetry = 0;

  for (;;)
  {
    try
    {
      // Call external service.
      await TransientOperationAsync();

      // Return or break.
      break;
    }
    catch (Exception ex)
    {
      Trace.TraceError("Operation Exception");

      currentRetry++;

      // Check if the exception thrown was a transient exception
      // based on the logic in the error detection strategy.
      // Determine whether to retry the operation, as well as how
      // long to wait, based on the retry strategy.
      if (currentRetry > this.retryCount || !IsTransient(ex))
      {
        // If this isn't a transient error or we shouldn't retry, 
        // rethrow the exception.
        throw;
      }
    }

    // Wait to retry the operation.
    // Consider calculating an exponential delay here and
    // using a strategy best suited for the operation and fault.
    await Task.Delay(delay);
  }
}

// Async method that wraps a call to a remote service (details not shown).
private async Task TransientOperationAsync()
{
  ...
}
```

<span data-ttu-id="81609-191">Egy try vagy catch blokkon csomagolni tartalmazza az utasítást, amely hívja meg ezt a módszert a hurok.</span><span class="sxs-lookup"><span data-stu-id="81609-191">The statement that invokes this method is contained in a try/catch block wrapped in a for loop.</span></span> <span data-ttu-id="81609-192">Az a hurok kilépjen, ha hívása a `TransientOperationAsync` metódus végrehajtása sikeres, nem jelez kivételt.</span><span class="sxs-lookup"><span data-stu-id="81609-192">The for loop exits if the call to the `TransientOperationAsync` method succeeds without throwing an exception.</span></span> <span data-ttu-id="81609-193">Ha a `TransientOperationAsync` metódus sikertelen, a catch blokk megvizsgálja a hiba okát.</span><span class="sxs-lookup"><span data-stu-id="81609-193">If the `TransientOperationAsync` method fails, the catch block examines the reason for the failure.</span></span> <span data-ttu-id="81609-194">Ha az rendelkezik feltételezhetően olyan átmeneti hibát a kód megvárja, rövid késleltetés mielőtt megpróbálná megismételni a műveletet.</span><span class="sxs-lookup"><span data-stu-id="81609-194">If it's believed to be a transient error the code waits for a short delay before retrying the operation.</span></span>

<span data-ttu-id="81609-195">A hurok is nyomon követi a száma, hogy a művelet végrehajtására történt kísérlet, és ha a kód három alkalommal nem sikerül a kivétel adottnak további hosszú tartós.</span><span class="sxs-lookup"><span data-stu-id="81609-195">The for loop also tracks the number of times that the operation has been attempted, and if the code fails three times the exception is assumed to be more long lasting.</span></span> <span data-ttu-id="81609-196">Ha a kivétel nem átmeneti, vagy hosszú tartós, a catch kezelő kivételt jelez.</span><span class="sxs-lookup"><span data-stu-id="81609-196">If the exception isn't transient or it's long lasting, the catch handler throws an exception.</span></span> <span data-ttu-id="81609-197">Ez a kivétel lép ki a hurok és kell lennie a kóddal, amely hívja meg a `OperationWithBasicRetryAsync` metódust.</span><span class="sxs-lookup"><span data-stu-id="81609-197">This exception exits the for loop and should be caught by the code that invokes the `OperationWithBasicRetryAsync` method.</span></span>

<span data-ttu-id="81609-198">A `IsTransient` metódust, az alábbi ellenőrzi az egy adott készletét, amely kapcsolódik a környezet a kódot a kivételeket futtatása.</span><span class="sxs-lookup"><span data-stu-id="81609-198">The `IsTransient` method, shown below, checks for a specific set of exceptions that are relevant to the environment the code is run in.</span></span> <span data-ttu-id="81609-199">Egy átmeneti kivétel meghatározása az éppen elért erőforrás attól függően változnak, és a környezet a művelet végrehajtása folyamatban van a.</span><span class="sxs-lookup"><span data-stu-id="81609-199">The definition of a transient exception will vary according to the resources being accessed and the environment the operation is being performed in.</span></span>

```csharp
private bool IsTransient(Exception ex)
{
  // Determine if the exception is transient.
  // In some cases this is as simple as checking the exception type, in other
  // cases it might be necessary to inspect other properties of the exception.
  if (ex is OperationTransientException)
    return true;

  var webException = ex as WebException;
  if (webException != null)
  {
    // If the web exception contains one of the following status values
    // it might be transient.
    return new[] {WebExceptionStatus.ConnectionClosed,
                  WebExceptionStatus.Timeout,
                  WebExceptionStatus.RequestCanceled }.
            Contains(webException.Status);
  }

  // Additional exception checking logic goes here.
  return false;
}
```

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="81609-200">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="81609-200">Related patterns and guidance</span></span>

- <span data-ttu-id="81609-201">[Áramköri megszakító mintát](circuit-breaker.md).</span><span class="sxs-lookup"><span data-stu-id="81609-201">[Circuit Breaker pattern](circuit-breaker.md).</span></span> <span data-ttu-id="81609-202">A újrapróbálkozási minta nem hasznos, ha átmeneti kezelése.</span><span class="sxs-lookup"><span data-stu-id="81609-202">The Retry pattern is useful for handling transient faults.</span></span> <span data-ttu-id="81609-203">Ha hiba várhatóan több hosszú tartós, több megfelelő áramköri megszakító minta végrehajtásához lehet.</span><span class="sxs-lookup"><span data-stu-id="81609-203">If a failure is expected to be more long lasting, it might be more appropriate to implement the Circuit Breaker pattern.</span></span> <span data-ttu-id="81609-204">Az újrapróbálkozási mintát is használható egy áramköri megszakító együtt arra, hogy egy átfogó megközelítés hibák kezelnek.</span><span class="sxs-lookup"><span data-stu-id="81609-204">The Retry pattern can also be used in conjunction with a circuit breaker to provide a comprehensive approach to handling faults.</span></span>
- [<span data-ttu-id="81609-205">Ismételje meg az adott szolgáltatások útmutató</span><span class="sxs-lookup"><span data-stu-id="81609-205">Retry guidance for specific services</span></span>](https://docs.microsoft.com/azure/architecture/best-practices/retry-service-specific)
- [<span data-ttu-id="81609-206">Kapcsolat rugalmassága</span><span class="sxs-lookup"><span data-stu-id="81609-206">Connection Resiliency</span></span>](https://docs.microsoft.com/ef/core/miscellaneous/connection-resiliency)
