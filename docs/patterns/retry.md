---
title: Újrapróbálkozási minta
titleSuffix: Cloud Design Patterns
description: Engedélyezheti egy alkalmazás számára a szolgáltatásokhoz vagy hálózati erőforrásokhoz való csatlakozáskor jelentkező előre jelzett, átmeneti meghibásodások kezelését egy korábban meghiúsult művelet transzparens módon való ismételt megkísérlésével.
keywords: tervezési minta
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 28e840d31a0df063edce82ef52f11064da3b17fb
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 01/23/2019
ms.locfileid: "54483377"
---
# <a name="retry-pattern"></a><span data-ttu-id="f2993-104">Újrapróbálkozási minta</span><span class="sxs-lookup"><span data-stu-id="f2993-104">Retry pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="f2993-105">Engedélyezheti egy alkalmazás számára a szolgáltatásokhoz vagy hálózati erőforrásokhoz való csatlakozáskor jelentkező átmeneti meghibásodások kezelését egy meghiúsult művelet transzparens módon való ismételt megkísérlésével.</span><span class="sxs-lookup"><span data-stu-id="f2993-105">Enable an application to handle transient failures when it tries to connect to a service or network resource, by transparently retrying a failed operation.</span></span> <span data-ttu-id="f2993-106">Ez javíthatja az alkalmazás stabilitását.</span><span class="sxs-lookup"><span data-stu-id="f2993-106">This can improve the stability of the application.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="f2993-107">Kontextus és probléma</span><span class="sxs-lookup"><span data-stu-id="f2993-107">Context and problem</span></span>

<span data-ttu-id="f2993-108">A felhőben futó elemekkel kommunikáló alkalmazásoknak érzékenynek kell lenniük az ebben a környezetben előforduló átmeneti hibákra.</span><span class="sxs-lookup"><span data-stu-id="f2993-108">An application that communicates with elements running in the cloud has to be sensitive to the transient faults that can occur in this environment.</span></span> <span data-ttu-id="f2993-109">Ilyen hiba lehet az összetevők és szolgáltatások hálózati kapcsolatának pillanatnyi megszakadása, a szolgáltatások átmeneti elérhetetlensége, valamint a foglalt szolgáltatás miatti időtúllépés.</span><span class="sxs-lookup"><span data-stu-id="f2993-109">Faults include the momentary loss of network connectivity to components and services, the temporary unavailability of a service, or timeouts that occur when a service is busy.</span></span>

<span data-ttu-id="f2993-110">Ezek a hibák gyakran maguktól megoldódnak, és ha megfelelő idő múlva megismételik a hibát kiváltó műveletet, az valószínűleg sikeresen végbemegy.</span><span class="sxs-lookup"><span data-stu-id="f2993-110">These faults are typically self-correcting, and if the action that triggered a fault is repeated after a suitable delay it's likely to be successful.</span></span> <span data-ttu-id="f2993-111">Egy számos egyidejű kérést feldolgozó adatbázis-szolgáltatás például olyan szabályozási stratégiát valósíthat meg, amely ideiglenesen elutasítja a további kéréseket, amíg nem enyhül a terhelés.</span><span class="sxs-lookup"><span data-stu-id="f2993-111">For example, a database service that's processing a large number of concurrent requests can implement a throttling strategy that temporarily rejects any further requests until its workload has eased.</span></span> <span data-ttu-id="f2993-112">Az adatbázist elérni próbáló alkalmazás csatlakozása sikertelen lehet, de ha később próbálkozik, sikerülhet a csatlakozás.</span><span class="sxs-lookup"><span data-stu-id="f2993-112">An application trying to access the database might fail to connect, but if it tries again after a delay it might succeed.</span></span>

## <a name="solution"></a><span data-ttu-id="f2993-113">Megoldás</span><span class="sxs-lookup"><span data-stu-id="f2993-113">Solution</span></span>

<span data-ttu-id="f2993-114">A felhőben nem ritkák az átmeneti hibák, és az alkalmazásokat úgy kell kialakítani, hogy elegánsan és átlátható módon kezelje azokat.</span><span class="sxs-lookup"><span data-stu-id="f2993-114">In the cloud, transient faults aren't uncommon and an application should be designed to handle them elegantly and transparently.</span></span> <span data-ttu-id="f2993-115">Így minimálisra csökkenthető a hibák az alkalmazás által végzett üzleti feladatokra gyakorolt hatása.</span><span class="sxs-lookup"><span data-stu-id="f2993-115">This minimizes the effects faults can have on the business tasks the application is performing.</span></span>

<span data-ttu-id="f2993-116">Ha egy alkalmazás hibát észlel, amikor kéréseket próbál küldeni egy távoli szolgáltatásnak, a következő stratégiákkal kezelheti a hibát:</span><span class="sxs-lookup"><span data-stu-id="f2993-116">If an application detects a failure when it tries to send a request to a remote service, it can handle the failure using the following strategies:</span></span>

- <span data-ttu-id="f2993-117">**Megszakítás**.</span><span class="sxs-lookup"><span data-stu-id="f2993-117">**Cancel**.</span></span> <span data-ttu-id="f2993-118">Ha a hiba azt jelzi, hogy a probléma nem átmeneti vagy nem valószínű, hogy a művelet a megismétlésekor sikeres lesz, az alkalmazásnak meg kell szakítania a műveletet, és kivételt kell jelentenie.</span><span class="sxs-lookup"><span data-stu-id="f2993-118">If the fault indicates that the failure isn't transient or is unlikely to be successful if repeated, the application should cancel the operation and report an exception.</span></span> <span data-ttu-id="f2993-119">Az érvénytelen hitelesítő adatok megadása miatti hitelesítési hiba például valószínűleg további kísérletek esetén sem fog megoldódni.</span><span class="sxs-lookup"><span data-stu-id="f2993-119">For example, an authentication failure caused by providing invalid credentials is not likely to succeed no matter how many times it's attempted.</span></span>

- <span data-ttu-id="f2993-120">**Újrapróbálkozás**.</span><span class="sxs-lookup"><span data-stu-id="f2993-120">**Retry**.</span></span> <span data-ttu-id="f2993-121">Ha a jelentett hiba szokatlan vagy ritka, akkor előfordulhat, hogy szokatlan körülmények okozták, például egy hálózati csomag megsérült a továbbítás során.</span><span class="sxs-lookup"><span data-stu-id="f2993-121">If the specific fault reported is unusual or rare, it might have been caused by unusual circumstances such as a network packet becoming corrupted while it was being transmitted.</span></span> <span data-ttu-id="f2993-122">Ebben az esetben az alkalmazás azonnal újrapróbálkozhat a sikertelen kéréssel, mert nem valószínű, hogy ugyanez a hiba meg fog ismétlődni, és a kérés valószínűleg sikeres lesz.</span><span class="sxs-lookup"><span data-stu-id="f2993-122">In this case, the application could retry the failing request again immediately because the same failure is unlikely to be repeated and the request will probably be successful.</span></span>

- <span data-ttu-id="f2993-123">**Újrapróbálkozás később**.</span><span class="sxs-lookup"><span data-stu-id="f2993-123">**Retry after delay**.</span></span> <span data-ttu-id="f2993-124">Ha a hibát egy vagy több gyakori kapcsolati vagy foglaltsági hiba okozza, lehet, hogy a hálózatnak vagy a szolgáltatásnak rövid időre van szüksége a kapcsolati hibák kijavításához vagy a várólistán lévő munkák kiürítéséhez.</span><span class="sxs-lookup"><span data-stu-id="f2993-124">If the fault is caused by one of the more commonplace connectivity or busy failures, the network or service might need a short period while the connectivity issues are corrected or the backlog of work is cleared.</span></span> <span data-ttu-id="f2993-125">Az alkalmazásnak várnia kell egy ideig a kérés újbóli megkísérlése előtt.</span><span class="sxs-lookup"><span data-stu-id="f2993-125">The application should wait for a suitable time before retrying the request.</span></span>

<span data-ttu-id="f2993-126">A gyakori átmeneti hibák esetén úgy kell kiválasztani az újrapróbálkozások között eltelt időtartamot, hogy az alkalmazás több példányáról érkező kérések a lehető legegyenletesebben legyenek elosztva.</span><span class="sxs-lookup"><span data-stu-id="f2993-126">For the more common transient failures, the period between retries should be chosen to spread requests from multiple instances of the application as evenly as possible.</span></span> <span data-ttu-id="f2993-127">Ez csökkenti annak az esélyét, hogy egy foglalt szolgáltatás folyamatosan túlterhelt legyen.</span><span class="sxs-lookup"><span data-stu-id="f2993-127">This reduces the chance of a busy service continuing to be overloaded.</span></span> <span data-ttu-id="f2993-128">Ha egy alkalmazás számos példánya folyamatosan túlterhel egy szolgáltatást a kérések újrapróbálásával, több időt vesz igénybe a szolgáltatás helyreállítása.</span><span class="sxs-lookup"><span data-stu-id="f2993-128">If many instances of an application are continually overwhelming a service with retry requests, it'll take the service longer to recover.</span></span>

<span data-ttu-id="f2993-129">Ha a kérés továbbra is sikertelen, az alkalmazás várhat és megismételheti a kísérletet.</span><span class="sxs-lookup"><span data-stu-id="f2993-129">If the request still fails, the application can wait and make another attempt.</span></span> <span data-ttu-id="f2993-130">Szükség esetén ez a folyamat megismételhető az újrapróbálkozások közötti késleltetések növelésével, amíg a rendszer el nem éri a kísérletek maximális számát.</span><span class="sxs-lookup"><span data-stu-id="f2993-130">If necessary, this process can be repeated with increasing delays between retry attempts, until some maximum number of requests have been attempted.</span></span> <span data-ttu-id="f2993-131">A késleltetés növekményesen vagy exponenciálisan növelhető a hiba típusától és annak valószínűségétől függően, hogy ezen idő alatt megoldódik-e.</span><span class="sxs-lookup"><span data-stu-id="f2993-131">The delay can be increased incrementally or exponentially, depending on the type of failure and the probability that it'll be corrected during this time.</span></span>

<span data-ttu-id="f2993-132">A következő ábra szemlélteti egy művelet ezzel a mintával való aktiválását egy üzemeltetett szolgáltatásban.</span><span class="sxs-lookup"><span data-stu-id="f2993-132">The following diagram illustrates invoking an operation in a hosted service using this pattern.</span></span> <span data-ttu-id="f2993-133">Ha a kérés a kísérletek előre meghatározott száma után is sikertelen, az alkalmazásnak kivételként kell kezelnie a hibát.</span><span class="sxs-lookup"><span data-stu-id="f2993-133">If the request is unsuccessful after a predefined number of attempts, the application should treat the fault as an exception and handle it accordingly.</span></span>

![1. ábra – Művelet meghívása üzemeltetett szolgáltatásban az újrapróbálkozási mintával](./_images/retry-pattern.png)

<span data-ttu-id="f2993-135">Az alkalmazásnak olyan kódba kell csomagolnia a távoli szolgáltatások elérési kísérleteit, amely a fent felsorolt stratégiák egyikének megfelelő újrapróbálkozási szabályzatot valósít meg.</span><span class="sxs-lookup"><span data-stu-id="f2993-135">The application should wrap all attempts to access a remote service in code that implements a retry policy matching one of the strategies listed above.</span></span> <span data-ttu-id="f2993-136">A különböző szolgáltatásoknak küldött kérésekre különböző szabályzatok lehetnek érvényesek.</span><span class="sxs-lookup"><span data-stu-id="f2993-136">Requests sent to different services can be subject to different policies.</span></span> <span data-ttu-id="f2993-137">Néhány gyártó újrapróbálkozási szabályzatokat alkalmazó kódtárakat biztosít, ahol az alkalmazás meghatározhatja az újrapróbálkozások maximális számát, az újrapróbálkozási kísérletek között eltelt időt és más paramétereket.</span><span class="sxs-lookup"><span data-stu-id="f2993-137">Some vendors provide libraries that implement retry policies, where the application can specify the maximum number of retries, the time between retry attempts, and other parameters.</span></span>

<span data-ttu-id="f2993-138">Az alkalmazásoknak naplózniuk kell a hibák és a sikertelen műveletek részleteit.</span><span class="sxs-lookup"><span data-stu-id="f2993-138">An application should log the details of faults and failing operations.</span></span> <span data-ttu-id="f2993-139">Ez az információ hasznos az operátorok számára.</span><span class="sxs-lookup"><span data-stu-id="f2993-139">This information is useful to operators.</span></span> <span data-ttu-id="f2993-140">Ha egy szolgáltatás gyakran elérhetetlen vagy foglalt, azt leggyakrabban a szolgáltatás erőforrásainak kimerülése okozza.</span><span class="sxs-lookup"><span data-stu-id="f2993-140">If a service is frequently unavailable or busy, it's often because the service has exhausted its resources.</span></span> <span data-ttu-id="f2993-141">A szolgáltatás horizontális felskálázásával csökkentheti ezeknek a hibáknak a gyakoriságát.</span><span class="sxs-lookup"><span data-stu-id="f2993-141">You can reduce the frequency of these faults by scaling out the service.</span></span> <span data-ttu-id="f2993-142">Ha például egy adatbázis-szolgáltatás folyamatosan túlterhelt, érdemes lehet particionálni az adatbázist, és több kiszolgáló között elosztani a terhelést.</span><span class="sxs-lookup"><span data-stu-id="f2993-142">For example, if a database service is continually overloaded, it might be beneficial to partition the database and spread the load across multiple servers.</span></span>

> <span data-ttu-id="f2993-143">A [Microsoft Entity Framework](https://docs.microsoft.com/ef/) számos eszközt nyújt az adatbázis-műveletek újrapróbálásához.</span><span class="sxs-lookup"><span data-stu-id="f2993-143">[Microsoft Entity Framework](https://docs.microsoft.com/ef/) provides facilities for retrying database operations.</span></span> <span data-ttu-id="f2993-144">Emellett a legtöbb Azure-szolgáltatás és ügyféloldali SDK is tartalmaz újrapróbálkozási mechanizmust.</span><span class="sxs-lookup"><span data-stu-id="f2993-144">Also, most Azure services and client SDKs include a retry mechanism.</span></span> <span data-ttu-id="f2993-145">További információkért tekintse meg [az adott szolgáltatásokra vonatkozó újrapróbálkozási útmutatást](https://docs.microsoft.com/azure/architecture/best-practices/retry-service-specific).</span><span class="sxs-lookup"><span data-stu-id="f2993-145">For more information, see [Retry guidance for specific services](https://docs.microsoft.com/azure/architecture/best-practices/retry-service-specific).</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="f2993-146">Problémák és megfontolandó szempontok</span><span class="sxs-lookup"><span data-stu-id="f2993-146">Issues and considerations</span></span>

<span data-ttu-id="f2993-147">A minta megvalósítása során az alábbi pontokat vegye figyelembe.</span><span class="sxs-lookup"><span data-stu-id="f2993-147">You should consider the following points when deciding how to implement this pattern.</span></span>

<span data-ttu-id="f2993-148">Az újrapróbálkozási szabályzatot úgy kell beállítani, hogy megfeleljen az alkalmazás az üzleti követelményeinek és a hiba természetének.</span><span class="sxs-lookup"><span data-stu-id="f2993-148">The retry policy should be tuned to match the business requirements of the application and the nature of the failure.</span></span> <span data-ttu-id="f2993-149">Egyes nem kritikus műveletek esetében jobb a gyors sikertelenség, mint a többszöri újrapróbálkozás, amely befolyásolja az alkalmazás teljesítményét.</span><span class="sxs-lookup"><span data-stu-id="f2993-149">For some noncritical operations, it's better to fail fast rather than retry several times and impact the throughput of the application.</span></span> <span data-ttu-id="f2993-150">Egy távoli szolgáltatást elérő interaktív webes alkalmazásban például jobb a kevesebb újrapróbálkozás utáni sikertelen eredmény, ahol csak kis késleltetés van az újrapróbálkozási kísérletek között, és egy megfelelő üzenet jelenik meg a felhasználók számára (például „próbálkozzon újra később”).</span><span class="sxs-lookup"><span data-stu-id="f2993-150">For example, in an interactive web application accessing a remote service, it's better to fail after a smaller number of retries with only a short delay between retry attempts, and display a suitable message to the user (for example, “please try again later”).</span></span> <span data-ttu-id="f2993-151">Kötegelt alkalmazásokhoz érdemes lehet növelni az újrapróbálkozási kísérletek számát, ezzel exponenciálisan növelve a kísérletek közötti késleltetést.</span><span class="sxs-lookup"><span data-stu-id="f2993-151">For a batch application, it might be more appropriate to increase the number of retry attempts with an exponentially increasing delay between attempts.</span></span>

<span data-ttu-id="f2993-152">A kísérletek között minimális késleltetést használó agresszív újrapróbálkozási szabályzat és a számos újrapróbálkozás tovább ronthat az elfoglalt szolgáltatás állapotán, amely maximális vagy közel maximális kapacitással fut.</span><span class="sxs-lookup"><span data-stu-id="f2993-152">An aggressive retry policy with minimal delay between attempts, and a large number of retries, could further degrade a busy service that's running close to or at capacity.</span></span> <span data-ttu-id="f2993-153">Az újrapróbálkozási szabályzat az alkalmazás válaszkészségét is befolyásolhatja, ha folyamatosan sikertelen műveletet próbál végezni.</span><span class="sxs-lookup"><span data-stu-id="f2993-153">This retry policy could also affect the responsiveness of the application if it's continually trying to perform a failing operation.</span></span>

<span data-ttu-id="f2993-154">Ha egy kérés jelentős számú újrapróbálkozás után is sikertelen, akkor jobb, ha az alkalmazás meggátolja, hogy további kérések jussanak el ugyanarra az erőforrásra, és egyszerűen azonnal hibát jelent.</span><span class="sxs-lookup"><span data-stu-id="f2993-154">If a request still fails after a significant number of retries, it's better for the application to prevent further requests going to the same resource and simply report a failure immediately.</span></span> <span data-ttu-id="f2993-155">Amikor az időszak lejár, az alkalmazás feltételesen átengedhet egy vagy több kérést, hogy megállapítsa, azok sikeresek-e.</span><span class="sxs-lookup"><span data-stu-id="f2993-155">When the period expires, the application can tentatively allow one or more requests through to see whether they're successful.</span></span> <span data-ttu-id="f2993-156">A stratégiáról további részletekért lásd az [áramkör-megszakítási mintát](./circuit-breaker.md).</span><span class="sxs-lookup"><span data-stu-id="f2993-156">For more details of this strategy, see the [Circuit Breaker pattern](./circuit-breaker.md).</span></span>

<span data-ttu-id="f2993-157">Gondolja át, hogy a művelet idempotens-e.</span><span class="sxs-lookup"><span data-stu-id="f2993-157">Consider whether the operation is idempotent.</span></span> <span data-ttu-id="f2993-158">Ha igen, alapvetően biztonságos az újrapróbálkozás.</span><span class="sxs-lookup"><span data-stu-id="f2993-158">If so, it's inherently safe to retry.</span></span> <span data-ttu-id="f2993-159">Más esetekben az újrapróbálkozások miatt előfordulhat, hogy a művelet többször lesz végrehajtva, nem kívánt mellékhatásokkal.</span><span class="sxs-lookup"><span data-stu-id="f2993-159">Otherwise, retries could cause the operation to be executed more than once, with unintended side effects.</span></span> <span data-ttu-id="f2993-160">Egy szolgáltatás például fogadhatja a kérést, sikeresen feldolgozhatja a kérést, de lehet, hogy nem tud választ küldeni.</span><span class="sxs-lookup"><span data-stu-id="f2993-160">For example, a service might receive the request, process the request successfully, but fail to send a response.</span></span> <span data-ttu-id="f2993-161">Ezen a ponton az újrapróbálkozási logika újraküldheti a kérést, feltételezve, hogy a szolgáltatás nem kapta meg az első kérést.</span><span class="sxs-lookup"><span data-stu-id="f2993-161">At that point, the retry logic might re-send the request, assuming that the first request wasn't received.</span></span>

<span data-ttu-id="f2993-162">A szolgáltatásoknak küldött kérések számos okból hiúsulhatnak meg, és a hiba természetétől függően különböző kivételeket váltanak ki.</span><span class="sxs-lookup"><span data-stu-id="f2993-162">A request to a service can fail for a variety of reasons raising different exceptions depending on the nature of the failure.</span></span> <span data-ttu-id="f2993-163">Néhány kivétel gyorsan megoldható hibát jelez, míg mások azt jelzik, hogy a hiba hosszabb ideig tart.</span><span class="sxs-lookup"><span data-stu-id="f2993-163">Some exceptions indicate a failure that can be resolved quickly, while others indicate that the failure is longer lasting.</span></span> <span data-ttu-id="f2993-164">Hasznos lehet, ha az újrapróbálkozási szabályzat a kivétel típusa alapján állítja be az újrapróbálkozási kísérletek közötti időt.</span><span class="sxs-lookup"><span data-stu-id="f2993-164">It's useful for the retry policy to adjust the time between retry attempts based on the type of the exception.</span></span>

<span data-ttu-id="f2993-165">Fontolja meg, hogy egy tranzakció részét képező művelet újrapróbálása milyen hatással lesz a tranzakció teljes konzisztenciájára.</span><span class="sxs-lookup"><span data-stu-id="f2993-165">Consider how retrying an operation that's part of a transaction will affect the overall transaction consistency.</span></span> <span data-ttu-id="f2993-166">Finomhangolja az újrapróbálkozási szabályzatot a tranzakciós műveletekhez, hogy a műveletek minél nagyobb eséllyel sikeresek legyenek, és ne kelljen visszavonni a tranzakció összes lépését.</span><span class="sxs-lookup"><span data-stu-id="f2993-166">Fine tune the retry policy for transactional operations to maximize the chance of success and reduce the need to undo all the transaction steps.</span></span>

<span data-ttu-id="f2993-167">Győződjön meg arról, hogy az összes újrapróbálkozási kód teljes körűen tesztelve lett különböző hibafeltételekre.</span><span class="sxs-lookup"><span data-stu-id="f2993-167">Ensure that all retry code is fully tested against a variety of failure conditions.</span></span> <span data-ttu-id="f2993-168">Ellenőrizze, hogy ne legyen jelentős hatással az alkalmazás teljesítményére vagy megbízhatóságára, ne okozzon túlzott terhelést a szolgáltatásokon és az erőforrásokon és ne hozzon létre versenyhelyzeteket vagy szűk keresztmetszeteket.</span><span class="sxs-lookup"><span data-stu-id="f2993-168">Check that it doesn't severely impact the performance or reliability of the application, cause excessive load on services and resources, or generate race conditions or bottlenecks.</span></span>

<span data-ttu-id="f2993-169">Csak ott alkalmazzon újrapróbálkozási logikát, ahol a meghiúsuló műveletek teljes kontextusa érthető.</span><span class="sxs-lookup"><span data-stu-id="f2993-169">Implement retry logic only where the full context of a failing operation is understood.</span></span> <span data-ttu-id="f2993-170">Ha például egy újrapróbálkozási szabályzatot tartalmazó feladat egy újrapróbálkozási szabályzatot tartalmazó másik feladatot hív meg, az újrapróbálkozások extra rétege miatt a feldolgozás során hosszú késések lesznek tapasztalhatóak.</span><span class="sxs-lookup"><span data-stu-id="f2993-170">For example, if a task that contains a retry policy invokes another task that also contains a retry policy, this extra layer of retries can add long delays to the processing.</span></span> <span data-ttu-id="f2993-171">Érdemes úgy konfigurálni az alacsonyabb szintű feladatot, hogy gyorsan hiúsuljon meg és jelentse a hiba okát az azt elindító feladatnak.</span><span class="sxs-lookup"><span data-stu-id="f2993-171">It might be better to configure the lower-level task to fail fast and report the reason for the failure back to the task that invoked it.</span></span> <span data-ttu-id="f2993-172">Ez a magasabb szintű feladat ezután a saját szabályzata alapján kezelheti a hibát.</span><span class="sxs-lookup"><span data-stu-id="f2993-172">This higher-level task can then handle the failure based on its own policy.</span></span>

<span data-ttu-id="f2993-173">Fontos az újrapróbálkozást okozó összes csatlakozási hibát naplózni, hogy azonosíthatók legyenek az alkalmazással, a szolgáltatásokkal vagy az erőforrásokkal kapcsolatos alapvető hibák.</span><span class="sxs-lookup"><span data-stu-id="f2993-173">It's important to log all connectivity failures that cause a retry so that underlying problems with the application, services, or resources can be identified.</span></span>

<span data-ttu-id="f2993-174">Vizsgálja meg egy szolgáltatás vagy erőforrás legvalószínűbb hibáit annak felderítése érdekében, hogy valószínűleg tartósak vagy végzetesek-e.</span><span class="sxs-lookup"><span data-stu-id="f2993-174">Investigate the faults that are most likely to occur for a service or a resource to discover if they're likely to be long lasting or terminal.</span></span> <span data-ttu-id="f2993-175">Ha igen, jobb kivételként kezelni a hibát.</span><span class="sxs-lookup"><span data-stu-id="f2993-175">If they are, it's better to handle the fault as an exception.</span></span> <span data-ttu-id="f2993-176">Az alkalmazás jelentheti vagy naplózhatja a kivételt, majd a folytatáshoz megpróbálhat alternatív szolgáltatást elindítani (ha van elérhető) vagy csökkentett teljesítményű funkciókat alkalmazni.</span><span class="sxs-lookup"><span data-stu-id="f2993-176">The application can report or log the exception, and then try to continue either by invoking an alternative service (if one is available), or by offering degraded functionality.</span></span> <span data-ttu-id="f2993-177">A tartós hibák észlelésével és kezelésével kapcsolatos további információkért lásd az [áramkör-megszakítási mintát](./circuit-breaker.md).</span><span class="sxs-lookup"><span data-stu-id="f2993-177">For more information on how to detect and handle long-lasting faults, see the [Circuit Breaker pattern](./circuit-breaker.md).</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="f2993-178">Mikor érdemes ezt a mintát használni?</span><span class="sxs-lookup"><span data-stu-id="f2993-178">When to use this pattern</span></span>

<span data-ttu-id="f2993-179">Ezt a mintát használja, ha egy alkalmazás átmeneti hibákat tapasztalhat, amikor távoli szolgáltatással kommunikál, vagy távoli erőforráshoz fér hozzá.</span><span class="sxs-lookup"><span data-stu-id="f2993-179">Use this pattern when an application could experience transient faults as it interacts with a remote service or accesses a remote resource.</span></span> <span data-ttu-id="f2993-180">Ezek a hibák várhatóan rövid életűek, és a korábban meghiúsult kérések megismétlése egy későbbi kísérlet során sikeres lehet.</span><span class="sxs-lookup"><span data-stu-id="f2993-180">These faults are expected to be short lived, and repeating a request that has previously failed could succeed on a subsequent attempt.</span></span>

<span data-ttu-id="f2993-181">Nem érdemes ezt a mintát használni a következő esetekben:</span><span class="sxs-lookup"><span data-stu-id="f2993-181">This pattern might not be useful:</span></span>

- <span data-ttu-id="f2993-182">Amikor egy hiba valószínűleg tartós, mert ez befolyásolhatja az alkalmazások válaszkészségét.</span><span class="sxs-lookup"><span data-stu-id="f2993-182">When a fault is likely to be long lasting, because this can affect the responsiveness of an application.</span></span> <span data-ttu-id="f2993-183">Előfordulhat, hogy az alkalmazás időt és erőforrásokat pazarol egy olyan kérés megismétlésére, amely valószínűleg sikertelen lesz.</span><span class="sxs-lookup"><span data-stu-id="f2993-183">The application might be wasting time and resources trying to repeat a request that's likely to fail.</span></span>
- <span data-ttu-id="f2993-184">A nem átmeneti hibák által okozott hibák kezeléséhez, például amikor egy alkalmazás üzleti logikájában lévő hibák belső kivételeket okoznak.</span><span class="sxs-lookup"><span data-stu-id="f2993-184">For handling failures that aren't due to transient faults, such as internal exceptions caused by errors in the business logic of an application.</span></span>
- <span data-ttu-id="f2993-185">A rendszer skálázhatósági hibáinak kezelési alternatívájaként.</span><span class="sxs-lookup"><span data-stu-id="f2993-185">As an alternative to addressing scalability issues in a system.</span></span> <span data-ttu-id="f2993-186">Ha egy alkalmazás gyakori foglaltsági hibákat észlel, az gyakran azt jelzi, hogy az elért szolgáltatást vagy erőforrást vertikálisan fel kell skálázni.</span><span class="sxs-lookup"><span data-stu-id="f2993-186">If an application experiences frequent busy faults, it's often a sign that the service or resource being accessed should be scaled up.</span></span>

## <a name="example"></a><span data-ttu-id="f2993-187">Példa</span><span class="sxs-lookup"><span data-stu-id="f2993-187">Example</span></span>

<span data-ttu-id="f2993-188">Ez a C# nyelven írt példa az újrapróbálkozási minta implementálását mutatja be.</span><span class="sxs-lookup"><span data-stu-id="f2993-188">This example in C# illustrates an implementation of the Retry pattern.</span></span> <span data-ttu-id="f2993-189">Az alább látható `OperationWithBasicRetryAsync` metódus aszinkron módon hív meg egy külső szolgáltatást a `TransientOperationAsync` metóduson keresztül.</span><span class="sxs-lookup"><span data-stu-id="f2993-189">The `OperationWithBasicRetryAsync` method, shown below, invokes an external service asynchronously through the `TransientOperationAsync` method.</span></span> <span data-ttu-id="f2993-190">A `TransientOperationAsync` metódus részletei a szolgáltatásra jellemzőek, és kimaradnak a mintakódból.</span><span class="sxs-lookup"><span data-stu-id="f2993-190">The details of the `TransientOperationAsync` method will be specific to the service and are omitted from the sample code.</span></span>

```csharp
private int retryCount = 3;
private readonly TimeSpan delay = TimeSpan.FromSeconds(5);

public async Task OperationWithBasicRetryAsync()
{
  int currentRetry = 0;

  for (;;)
  {
    try
    {
      // Call external service.
      await TransientOperationAsync();

      // Return or break.
      break;
    }
    catch (Exception ex)
    {
      Trace.TraceError("Operation Exception");

      currentRetry++;

      // Check if the exception thrown was a transient exception
      // based on the logic in the error detection strategy.
      // Determine whether to retry the operation, as well as how
      // long to wait, based on the retry strategy.
      if (currentRetry > this.retryCount || !IsTransient(ex))
      {
        // If this isn't a transient error or we shouldn't retry,
        // rethrow the exception.
        throw;
      }
    }

    // Wait to retry the operation.
    // Consider calculating an exponential delay here and
    // using a strategy best suited for the operation and fault.
    await Task.Delay(delay);
  }
}

// Async method that wraps a call to a remote service (details not shown).
private async Task TransientOperationAsync()
{
  ...
}
```

<span data-ttu-id="f2993-191">Az ezt a metódust meghívó utasítás egy for ciklusba csomagolt try/catch blokkban szerepel.</span><span class="sxs-lookup"><span data-stu-id="f2993-191">The statement that invokes this method is contained in a try/catch block wrapped in a for loop.</span></span> <span data-ttu-id="f2993-192">A for ciklus kilép, ha a `TransientOperationAsync` metódus hívása kivétel nélkül sikerül.</span><span class="sxs-lookup"><span data-stu-id="f2993-192">The for loop exits if the call to the `TransientOperationAsync` method succeeds without throwing an exception.</span></span> <span data-ttu-id="f2993-193">Ha a `TransientOperationAsync` metódus sikertelen, a catch blokk megvizsgálja a hiba okát.</span><span class="sxs-lookup"><span data-stu-id="f2993-193">If the `TransientOperationAsync` method fails, the catch block examines the reason for the failure.</span></span> <span data-ttu-id="f2993-194">Ha ez feltételezhetően átmeneti hiba, a kód vár egy rövid ideig a művelet újrapróbálása előtt.</span><span class="sxs-lookup"><span data-stu-id="f2993-194">If it's believed to be a transient error the code waits for a short delay before retrying the operation.</span></span>

<span data-ttu-id="f2993-195">A for ciklus a művelet megkísérléseinek számát is nyomon követi, és ha a kód három alkalommal sikertelen, tartósabbnak feltételezi a kivételt.</span><span class="sxs-lookup"><span data-stu-id="f2993-195">The for loop also tracks the number of times that the operation has been attempted, and if the code fails three times the exception is assumed to be more long lasting.</span></span> <span data-ttu-id="f2993-196">Ha a kivétel nem átmeneti, vagy ha tartós, a catch kezelő kivételt jelez.</span><span class="sxs-lookup"><span data-stu-id="f2993-196">If the exception isn't transient or it's long lasting, the catch handler throws an exception.</span></span> <span data-ttu-id="f2993-197">Ez a kivétel kilép a for ciklusból, és az `OperationWithBasicRetryAsync` metódust meghívó kódnak el kell kapnia.</span><span class="sxs-lookup"><span data-stu-id="f2993-197">This exception exits the for loop and should be caught by the code that invokes the `OperationWithBasicRetryAsync` method.</span></span>

<span data-ttu-id="f2993-198">Az alább látható `IsTransient` metódus a kódot futtató környezetre jellemző adott kivételeket keres.</span><span class="sxs-lookup"><span data-stu-id="f2993-198">The `IsTransient` method, shown below, checks for a specific set of exceptions that are relevant to the environment the code is run in.</span></span> <span data-ttu-id="f2993-199">Az átmeneti kivételek meghatározása az elért erőforrásoktól és a művelet elvégzéséhez használt környezettől függően változik.</span><span class="sxs-lookup"><span data-stu-id="f2993-199">The definition of a transient exception will vary according to the resources being accessed and the environment the operation is being performed in.</span></span>

```csharp
private bool IsTransient(Exception ex)
{
  // Determine if the exception is transient.
  // In some cases this is as simple as checking the exception type, in other
  // cases it might be necessary to inspect other properties of the exception.
  if (ex is OperationTransientException)
    return true;

  var webException = ex as WebException;
  if (webException != null)
  {
    // If the web exception contains one of the following status values
    // it might be transient.
    return new[] {WebExceptionStatus.ConnectionClosed,
                  WebExceptionStatus.Timeout,
                  WebExceptionStatus.RequestCanceled }.
            Contains(webException.Status);
  }

  // Additional exception checking logic goes here.
  return false;
}
```

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="f2993-200">Kapcsolódó minták és útmutatók</span><span class="sxs-lookup"><span data-stu-id="f2993-200">Related patterns and guidance</span></span>

- <span data-ttu-id="f2993-201">[Áramkör-megszakítási minta](./circuit-breaker.md).</span><span class="sxs-lookup"><span data-stu-id="f2993-201">[Circuit Breaker pattern](./circuit-breaker.md).</span></span> <span data-ttu-id="f2993-202">Az újrapróbálkozási minta átmeneti hibák kezeléséhez hasznos.</span><span class="sxs-lookup"><span data-stu-id="f2993-202">The Retry pattern is useful for handling transient faults.</span></span> <span data-ttu-id="f2993-203">Ha egy hiba várhatóan tartósabb, célszerűbb lehet az áramkör-megszakítási mintát implementálni.</span><span class="sxs-lookup"><span data-stu-id="f2993-203">If a failure is expected to be more long lasting, it might be more appropriate to implement the Circuit Breaker pattern.</span></span> <span data-ttu-id="f2993-204">Az újrapróbálkozási minta áramkör-megszakítási mintával együtt is használható a hibák átfogóbb kezelése érdekében.</span><span class="sxs-lookup"><span data-stu-id="f2993-204">The Retry pattern can also be used in conjunction with a circuit breaker to provide a comprehensive approach to handling faults.</span></span>
- [<span data-ttu-id="f2993-205">Újrapróbálkozási útmutatás adott szolgáltatásoknál</span><span class="sxs-lookup"><span data-stu-id="f2993-205">Retry guidance for specific services</span></span>](https://docs.microsoft.com/azure/architecture/best-practices/retry-service-specific)
- [<span data-ttu-id="f2993-206">Kapcsolat rugalmassága</span><span class="sxs-lookup"><span data-stu-id="f2993-206">Connection Resiliency</span></span>](https://docs.microsoft.com/ef/core/miscellaneous/connection-resiliency)
