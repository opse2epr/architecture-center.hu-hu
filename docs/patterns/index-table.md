---
title: Indextábla minta
titleSuffix: Cloud Design Patterns
description: Indexeket hozhat létre a lekérdezések által gyakran hivatkozott adattárbeli mezőkről.
keywords: tervezési minta
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: e3373a50ba6298f7985182b7be244db5f6eaa703
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 01/23/2019
ms.locfileid: "54487185"
---
# <a name="index-table-pattern"></a><span data-ttu-id="a6bdc-104">Indextábla minta</span><span class="sxs-lookup"><span data-stu-id="a6bdc-104">Index Table pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="a6bdc-105">Indexeket hozhat létre a lekérdezések által gyakran hivatkozott adattárbeli mezőkről.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-105">Create indexes over the fields in data stores that are frequently referenced by queries.</span></span> <span data-ttu-id="a6bdc-106">Ez a minta javíthat a lekérdezési teljesítményen, mivel engedélyezi az alkalmazások részére, hogy gyorsabban azonosíthassanak egy adattárból lekérni kívánt adatot.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-106">This pattern can improve query performance by allowing applications to more quickly locate the data to retrieve from a data store.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="a6bdc-107">Kontextus és probléma</span><span class="sxs-lookup"><span data-stu-id="a6bdc-107">Context and problem</span></span>

<span data-ttu-id="a6bdc-108">Számos adattároló egy entitásgyűjteménybe rendezi az adatokat az elsődleges kulcs használatával.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-108">Many data stores organize the data for a collection of entities using the primary key.</span></span> <span data-ttu-id="a6bdc-109">Egy alkalmazás használhatja ezt a kulcsot az adatok megkeresésére és kinyerésére.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-109">An application can use this key to locate and retrieve data.</span></span> <span data-ttu-id="a6bdc-110">Az ábra egy példát mutat be, amikor egy adattár ügyfél-információkat tárol.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-110">The figure shows an example of a data store holding customer information.</span></span> <span data-ttu-id="a6bdc-111">Az elsődleges kulcs az ügyfél azonosítója.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-111">The primary key is the Customer ID.</span></span> <span data-ttu-id="a6bdc-112">Az ábra az elsődleges kulcs (az ügyfél-azonosító) által rendezett ügyfél-információt mutatja.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-112">The figure shows customer information organized by the primary key (Customer ID).</span></span>

![1. ábra – Az elsődleges kulcs (ügyfél-azonosító) által rendszerezett ügyfél-információ](./_images/index-table-figure-1.png)

<span data-ttu-id="a6bdc-114">Míg az elsődleges kulcs értékes olyan lekérdezések esetén, amelyek a kulcs értéke alapján szereznek be adatokat, elképzelhető, hogy egy alkalmazás nem tudja használni az elsődleges kulcsot, ha más területről kell kinyernie az adatokat.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-114">While the primary key is valuable for queries that fetch data based on the value of this key, an application might not be able to use the primary key if it needs to retrieve data based on some other field.</span></span> <span data-ttu-id="a6bdc-115">Az ügyfélpéldában egy alkalmazás nem tudja használni az ügyfél-azonosító elsődleges kulcsot az ügyfelek kinyerésére, ha csak egy másik attribútum, például az ügyfél székhelyeként szolgáló város értékére történő hivatkozással kérdez le adatokat.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-115">In the customers example, an application can't use the Customer ID primary key to retrieve customers if it queries data solely by referencing the value of some other attribute, such as the town in which the customer is located.</span></span> <span data-ttu-id="a6bdc-116">Egy ilyen lekérdezés elvégzéséhez az alkalmazásnak valószínűleg minden ügyfélrekordot be kell gyűjtenie és meg kell vizsgálnia, ami elég lassú folyamat lehet.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-116">To perform a query such as this, the application might have to fetch and examine every customer record, which could be a slow process.</span></span>

<span data-ttu-id="a6bdc-117">Számos relációs adatbáziskezelő-rendszer támogatja a másodlagos indexeket.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-117">Many relational database management systems support secondary indexes.</span></span> <span data-ttu-id="a6bdc-118">A másodlagos index egy elkülönülő adatszerkezet, amelyet egy vagy több nem elsődleges (másodlagos) kulcsmező rendszerez. Azt jelzi, hogy hol tárolódnak az egyes indexelt értékek adatai.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-118">A secondary index is a separate data structure that's organized by one or more nonprimary (secondary) key fields, and it indicates where the data for each indexed value is stored.</span></span> <span data-ttu-id="a6bdc-119">A másodlagos indexek elemei általában a másodlagos kulcsok értékei szerint vannak rendezve, így lehetővé válik az adatok gyors keresése.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-119">The items in a secondary index are typically sorted by the value of the secondary keys to enable fast lookup of data.</span></span> <span data-ttu-id="a6bdc-120">Ezeket az indexeket általában automatikusan tartja karban az adatbázis-kezelő rendszer.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-120">These indexes are usually maintained automatically by the database management system.</span></span>

<span data-ttu-id="a6bdc-121">Annyi másodlagos indexet hozhat létre, amennyire csak szükség van az alkalmazás által végrehajtott különböző lekérdezése támogatásához.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-121">You can create as many secondary indexes as you need to support the different queries that your application performs.</span></span> <span data-ttu-id="a6bdc-122">Például, ha egy relációs adatbázis ügyfelek táblájában az ügyfél-azonosító az elsődleges kulcs, érdemes hozzáadni egy másodlagos indexet a város mezőhöz, ha az alkalmazás gyakran keres az ügyfelekre a tartózkodási város alapján.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-122">For example, in a Customers table in a relational database where the Customer ID is the primary key, it's beneficial to add a secondary index over the town field if the application frequently looks up customers by the town where they reside.</span></span>

<span data-ttu-id="a6bdc-123">Ugyanakkor, noha a másodlagos indexek gyakoriak a relációs rendszerekben, a felhőalkalmazások által használt legtöbb NoSQL-adattároló nem biztosít ennek megfelelő szolgáltatást.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-123">However, although secondary indexes are common in relational systems, most NoSQL data stores used by cloud applications don't provide an equivalent feature.</span></span>

## <a name="solution"></a><span data-ttu-id="a6bdc-124">Megoldás</span><span class="sxs-lookup"><span data-stu-id="a6bdc-124">Solution</span></span>

<span data-ttu-id="a6bdc-125">Ha az adattároló nem támogatja a másodlagos indexeket, emulálhatja őket úgy is, ha manuálisan létrehozza saját indextábláit.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-125">If the data store doesn't support secondary indexes, you can emulate them manually by creating your own index tables.</span></span> <span data-ttu-id="a6bdc-126">Az indextáblák egy adott kulcs alapján rendezik az adatokat.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-126">An index table organizes the data by a specified key.</span></span> <span data-ttu-id="a6bdc-127">Ezeket a stratégiákat az igényelt másodlagos indexek számától és az alkalmazás által végrehajtott lekérdezések jellegétől függően gyakran használják az indextáblák strukturálására.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-127">Three strategies are commonly used for structuring an index table, depending on the number of secondary indexes that are required and the nature of the queries that an application performs.</span></span>

<span data-ttu-id="a6bdc-128">Az első stratégia az adatok duplikálása minden egyes indextáblában, majd a rendezésük különféle kulcsok szerint (teljes denormalizáció).</span><span class="sxs-lookup"><span data-stu-id="a6bdc-128">The first strategy is to duplicate the data in each index table but organize it by different keys (complete denormalization).</span></span> <span data-ttu-id="a6bdc-129">A következő ábra olyan indextáblákat mutat be, amelyek ugyanezeket az ügyfél-információkat rendezik város és vezetéknév szerint.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-129">The next figure shows index tables that organize the same customer information by Town and LastName.</span></span>

![2. ábra – Az adatok duplikáltak az egyes indextáblákban](./_images/index-table-figure-2.png)

<span data-ttu-id="a6bdc-131">Ez a stratégia akkor megfelelő, ha az adatok viszonylag statikusak ahhoz képest, hogy hányszor vannak lekérdezve az adott kulcsok használatával.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-131">This strategy is appropriate if the data is relatively static compared to the number of times it's queried using each key.</span></span> <span data-ttu-id="a6bdc-132">Ha az adatok dinamikusabbak, az egyes indextáblák feldolgozási többletterhelése túl nagy lesz ahhoz, hogy a módszert hatékonyan lehessen használni.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-132">If the data is more dynamic, the processing overhead of maintaining each index table becomes too large for this approach to be useful.</span></span> <span data-ttu-id="a6bdc-133">Ha az adatok mennyisége túl nagy, a duplikált adatok tárolásához szükséges lemezterület mennyisége is jelentős.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-133">Also, if the volume of data is very large, the amount of space required to store the duplicate data is significant.</span></span>

<span data-ttu-id="a6bdc-134">A második stratégia szerint normalizált indextáblákat kell létrehozni, amelyeket különböző kulcsok rendeznek. Ezek a táblák az eredeti adatokra hivatkoznak az elsődleges kulcsot használatával, nem pedig duplikálják azt, ahogy az alábbi képen is látható.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-134">The second strategy is to create normalized index tables organized by different keys and reference the original data by using the primary key rather than duplicating it, as shown in the following figure.</span></span> <span data-ttu-id="a6bdc-135">Az eredeti adat neve „fact table” (ténytábla).</span><span class="sxs-lookup"><span data-stu-id="a6bdc-135">The original data is called a fact table.</span></span>

![3. ábra – Az adatokra mindegyik indextábla hivatkozik](./_images/index-table-figure-3.png)

<span data-ttu-id="a6bdc-137">Ez a technika helyet takarít meg, és csökkenti a duplikált adatok fenntartása jelentette terhelést.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-137">This technique saves space and reduces the overhead of maintaining duplicate data.</span></span> <span data-ttu-id="a6bdc-138">Hátránya, hogy az alkalmazásnak egy másodlagos kulcs használatával két keresési műveletet kell végrehajtania az adatok kereséséhez.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-138">The disadvantage is that an application has to perform two lookup operations to find data using a secondary key.</span></span> <span data-ttu-id="a6bdc-139">Meg kell találnia az adat elsődleges kulcsát az indextáblában, majd használnia az elsődleges kulcsot, hogy megtalálja az adatot a ténytáblában.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-139">It has to find the primary key for the data in the index table, and then use the primary key to look up the data in the fact table.</span></span>

<span data-ttu-id="a6bdc-140">A harmadik stratégia részlegesen normalizált indextáblák létrehozása, amelyeket különböző, a gyakran kinyert mezőket duplikáló kulcsok rendszereznek.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-140">The third strategy is to create partially normalized index tables organized by different keys that duplicate frequently retrieved fields.</span></span> <span data-ttu-id="a6bdc-141">Hivatkozzon a ténytáblára a ritkábban elért mezők eléréséhez.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-141">Reference the fact table to access less frequently accessed fields.</span></span> <span data-ttu-id="a6bdc-142">Az alábbi ábra bemutatja, hogyan duplikálódnak a gyakran hozzáfért adatok minden indextáblában.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-142">The next figure shows how commonly accessed data is duplicated in each index table.</span></span>

![4. ábra – A gyakran hozzáfért adatok duplikálódnak minden egyes indextáblában](./_images/index-table-figure-4.png)

<span data-ttu-id="a6bdc-144">Ezzel a stratégiával kiegyensúlyozható az első két módszer.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-144">With this strategy, you can strike a balance between the first two approaches.</span></span> <span data-ttu-id="a6bdc-145">A gyakori lekérdezések adatai egy egyszerű kereséssel megtalálhatóak, ugyanakkor a helyhasználat és a karbantartási terhelés nem annyira jelentős, mintha a teljes adatkészletet duplikálná.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-145">The data for common queries can be retrieved quickly by using a single lookup, while the space and maintenance overhead isn't as significant as duplicating the entire data set.</span></span>

<span data-ttu-id="a6bdc-146">Ha egy alkalmazás rendszeresen több érték kombinációjával kérdez le adatokat (például „Az összes Smith vezetéknevű, Redmondban élő felhasználó keresése”), a kulcsokat a város attribútum és a vezetéknév attribútum összefűzésével implementálhatja az indextábla elemeihez.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-146">If an application frequently queries data by specifying a combination of values (for example, “Find all customers that live in Redmond and that have a last name of Smith”), you could implement the keys to the items in the index table as a concatenation of the Town attribute and the LastName attribute.</span></span> <span data-ttu-id="a6bdc-147">A következő ábra egy kompozit kulcsokon alapuló indextáblát mutat be.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-147">The next figure shows an index table based on composite keys.</span></span> <span data-ttu-id="a6bdc-148">A kulcsok város szerint vannak rendezve, majd pedig vezetéknév szerint azon rekordok esetén, amelyek ugyanazzal az értékkel rendelkeznek a városra.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-148">The keys are sorted by Town, and then by LastName for records that have the same value for Town.</span></span>

![5. ábra – Kompozit kulcsokon alapuló indextábla](./_images/index-table-figure-5.png)

<span data-ttu-id="a6bdc-150">Az indextáblák felgyorsíthatják a lekérdezési műveleteket a horizontálisan skálázott adatok között, és különösen hasznosak, ha a szegmenskulcs kivonatolt.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-150">Index tables can speed up query operations over sharded data, and are especially useful where the shard key is hashed.</span></span> <span data-ttu-id="a6bdc-151">A következő ábra egy példát mutat be, ahol a szegmenskulcs az ügyfél-azonosító kivonata.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-151">The next figure shows an example where the shard key is a hash of the Customer ID.</span></span> <span data-ttu-id="a6bdc-152">Az indextábla a nem kivonatolt érték (város és vezetéknév) szerint rendszerezheti az adatokat, és a kivonatolt szegmenskulcsot biztosíthatja keresési adatként.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-152">The index table can organize data by the nonhashed value (Town and LastName), and provide the hashed shard key as the lookup data.</span></span> <span data-ttu-id="a6bdc-153">Ez megelőzi, hogy az alkalmazás ismételten kiszámolja a kivonatolt kulcsokat (ami költséges művelet), ha csak egy tartományon belüli adatot kell kinyernie vagy ha a nem kivonatolt kulcs szerint kell az adatokat lekérnie.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-153">This can save the application from repeatedly calculating hash keys (an expensive operation) if it needs to retrieve data that falls within a range, or it needs to fetch data in order of the nonhashed key.</span></span> <span data-ttu-id="a6bdc-154">Például egy „Minden Redmondban élő ügyfél keresése” vagy hasonló lekérdezés gyorsan megoldható a megfelelő elemek megkeresésével az indextáblában, ahol egy egybefüggő blokkban tárolódnak.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-154">For example, a query such as “Find all customers that live in Redmond” can be quickly resolved by locating the matching items in the index table, where they're all stored in a contiguous block.</span></span> <span data-ttu-id="a6bdc-155">Ezután kövesse a hivatkozásokat az ügyféladatokra a szegmenskulcs használatával, amely az indextáblában tárolódik.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-155">Then, follow the references to the customer data using the shard keys stored in the index table.</span></span>

![6. ábra – Horizontálisan skálázott adatok gyors keresését biztosító indextábla](./_images/index-table-figure-6.png)

## <a name="issues-and-considerations"></a><span data-ttu-id="a6bdc-157">Problémák és megfontolandó szempontok</span><span class="sxs-lookup"><span data-stu-id="a6bdc-157">Issues and considerations</span></span>

<span data-ttu-id="a6bdc-158">A minta megvalósítása során az alábbi pontokat vegye figyelembe:</span><span class="sxs-lookup"><span data-stu-id="a6bdc-158">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="a6bdc-159">A másodlagos indexek karbantartása által jelentett terhelés jelentős lehet.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-159">The overhead of maintaining secondary indexes can be significant.</span></span> <span data-ttu-id="a6bdc-160">Elemeznie és értenie kell az alkalmazás által használt lekérdezéseket.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-160">You must analyze and understand the queries that your application uses.</span></span> <span data-ttu-id="a6bdc-161">Csak akkor hozzon létre indextáblákat, ha valószínűleg gyakran lesznek használatban.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-161">Only create index tables when they're likely to be used regularly.</span></span> <span data-ttu-id="a6bdc-162">Ne hozzon létre spekulatív indextáblákat olyan lekérdezések támogatására, amelyeket az alkalmazás sosem vagy csak alkalmanként hajt végre.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-162">Don't create speculative index tables to support queries that an application doesn't perform, or performs only occasionally.</span></span>
- <span data-ttu-id="a6bdc-163">Az indextáblák adatainak duplikálása jelentős többletterhelést jelenthet a tárolási költségek és a többszörös adatmásolatok fenntartására irányuló erőfeszítések tekintetében.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-163">Duplicating data in an index table can add significant overhead in storage costs and the effort required to maintain multiple copies of data.</span></span>
- <span data-ttu-id="a6bdc-164">Az indextábláknak az eredeti adatokra hivatkozó normalizált szerkezetként való implementálása azt igényli az alkalmazástól, hogy két keresési művelettel keressen adatokat.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-164">Implementing an index table as a normalized structure that references the original data requires an application to perform two lookup operations to find data.</span></span> <span data-ttu-id="a6bdc-165">Az első művelet az indextáblából keresi ki az elsődleges kulcsot, a második az elsődleges kulccsal kéri le az adatot.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-165">The first operation searches the index table to retrieve the primary key, and the second uses the primary key to fetch the data.</span></span>
- <span data-ttu-id="a6bdc-166">Ha egy rendszer számos indextáblát használ nagyon nagy adathalmazokhoz, nehéz lehet fenntartani a konzisztenciát az indextáblák és az eredeti adatok között.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-166">If a system incorporates a number of index tables over very large data sets, it can be difficult to maintain consistency between index tables and the original data.</span></span> <span data-ttu-id="a6bdc-167">Elképzelhető, hogy lehetséges a végül konzisztens modell köré megtervezni az alkalmazást.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-167">It might be possible to design the application around the eventual consistency model.</span></span> <span data-ttu-id="a6bdc-168">Például egy adat beszúrásához, frissítéséhez vagy törléséhez egy alkalmazás elküldhet egy üzenetet egy üzenetsorba, és engedheti, hogy egy külön feladat hajtsa végre a műveletet, és tartsa karban az indextáblákat, amelyek aszinkron módon hivatkoznak ezekre az adatokra.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-168">For example, to insert, update, or delete data, an application could post a message to a queue and let a separate task perform the operation and maintain the index tables that reference this data asynchronously.</span></span> <span data-ttu-id="a6bdc-169">A végül bekövetkező konzisztenciával kapcsolatos további információkat az [adatkonzisztenciát ismertető](https://msdn.microsoft.com/library/dn589800.aspx) szakaszban találja.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-169">For more information about implementing eventual consistency, see the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

   >  <span data-ttu-id="a6bdc-170">A Microsoft Azure Storage-táblák támogatják az ugyanazon a partíción tárolt adatokon végzett módosítások tranzakciós frissítéseit (entitáscsoport-tranzakciók).</span><span class="sxs-lookup"><span data-stu-id="a6bdc-170">Microsoft Azure storage tables support transactional updates for changes made to data held in the same partition (referred to as entity group transactions).</span></span> <span data-ttu-id="a6bdc-171">Ha egy ténytáblát és egy vagy több indextáblát ugyanazon a partíción tud tárolni, ennek a szolgáltatásnak a használatával biztosíthatja a konzisztenciát.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-171">If you can store the data for a fact table and one or more index tables in the same partition, you can use this feature to help ensure consistency.</span></span>

- <span data-ttu-id="a6bdc-172">Maguk az indextáblák lehetnek particionáltak vagy horizontálisan skálázottak.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-172">Index tables might themselves be partitioned or sharded.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="a6bdc-173">Mikor érdemes ezt a mintát használni?</span><span class="sxs-lookup"><span data-stu-id="a6bdc-173">When to use this pattern</span></span>

<span data-ttu-id="a6bdc-174">Ennek a mintának a használatával javíthatja a lekérdezési teljesítményt, ha egy alkalmazásnak rendszeresen az elsődleges kulcstól eltérő (vagy horizontálisan skálázott) kulccsal kell adatokat keresnie.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-174">Use this pattern to improve query performance when an application frequently needs to retrieve data by using a key other than the primary (or shard) key.</span></span>

<span data-ttu-id="a6bdc-175">Nem érdemes ezt a mintát használni, ha:</span><span class="sxs-lookup"><span data-stu-id="a6bdc-175">This pattern might not be useful when:</span></span>

- <span data-ttu-id="a6bdc-176">Az adatok ideiglenesek.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-176">Data is volatile.</span></span> <span data-ttu-id="a6bdc-177">Egy indextábla gyorsan idejétmúlttá, és ezáltal nem hatékonnyá válhat, illetve az indextábla karbantartása által jelentett terhelése nagyobb, mint a használatával megtakarított erőforrások.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-177">An index table can become out of date very quickly, making it ineffective or making the overhead of maintaining the index table greater than any savings made by using it.</span></span>
- <span data-ttu-id="a6bdc-178">Egy indextábla számára másodlagos kulcsként kiválasztott mező nem tesz különbséget, és csak kis értékkészlettel rendelkezhet (például: nem).</span><span class="sxs-lookup"><span data-stu-id="a6bdc-178">A field selected as the secondary key for an index table is nondiscriminating and can only have a small set of values (for example, gender).</span></span>
- <span data-ttu-id="a6bdc-179">Az indextábla számára másodlagos kulcsként kiválasztott mező adatértékeinek egyensúlya nagyon el van tolódva.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-179">The balance of the data values for a field selected as the secondary key for an index table are highly skewed.</span></span> <span data-ttu-id="a6bdc-180">Például ha a rekordok 90%-a egy mezőben ugyanazt az értéket tartalmazza, akkor az ezen a mezőn alapuló, adatok keresése céljából létrehozott és fenntartott indextábla több terhelést jelenthet, mintha sorrendben végignézné a rendszer az adatokat.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-180">For example, if 90% of the records contain the same value in a field, then creating and maintaining an index table to look up data based on this field might create more overhead than scanning sequentially through the data.</span></span> <span data-ttu-id="a6bdc-181">Azonban ha a lekérdezés gyakran érint olyan értékeket, amelyek a maradék 10 %-ba tartoznak, ez az index hasznos lehet.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-181">However, if queries very frequently target values that lie in the remaining 10%, this index can be useful.</span></span> <span data-ttu-id="a6bdc-182">Legyen tisztában vele, hogy milyen lekérdezéseket és milyen gyakran hajt végre az alkalmazás.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-182">You should understand the queries that your application is performing, and how frequently they're performed.</span></span>

## <a name="example"></a><span data-ttu-id="a6bdc-183">Példa</span><span class="sxs-lookup"><span data-stu-id="a6bdc-183">Example</span></span>

<span data-ttu-id="a6bdc-184">Az Azure Storage-táblák jól skálázható kulcs/érték adattárolót biztosítanak a felhőben futó alkalmazások számára.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-184">Azure storage tables provide a highly scalable key/value data store for applications running in the cloud.</span></span> <span data-ttu-id="a6bdc-185">Az alkalmazások a kulcs használatával tárolják és kérik le az adatértékeket.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-185">Applications store and retrieve data values by specifying a key.</span></span> <span data-ttu-id="a6bdc-186">Az adatértékek több mezőt is tartalmazhatnak, de egy adatelem struktúrája átlátszatlan a táblatároló számára, amely egyszerűen bitek tömbjeként kezeli az adatelemet.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-186">The data values can contain multiple fields, but the structure of a data item is opaque to table storage, which simply handles a data item as an array of bytes.</span></span>

<span data-ttu-id="a6bdc-187">Az Azure Storage-táblák a horizontális skálázást is támogatják.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-187">Azure storage tables also support sharding.</span></span> <span data-ttu-id="a6bdc-188">A horizontális skálázási kulcs két elemet tartalmaz: egy partíciókulcsot és egy sorkulcsot.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-188">The sharding key includes two elements, a partition key and a row key.</span></span> <span data-ttu-id="a6bdc-189">Az ugyanazon partíciós kulccsal rendelkező elemek ugyanazon a partíción (horizontálisan skálázáson) tárolódnak, az elemek pedig sorkulcsrendben tárolódnak a horizontális skálázáson belül.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-189">Items that have the same partition key are stored in the same partition (shard), and the items are stored in row key order within a shard.</span></span> <span data-ttu-id="a6bdc-190">A táblatároló olyan keresések végrehajtására van optimalizálva, amelyek egy összefüggő sorkulcsérték-tartományon belül eső adatokra irányulnak egy partíción belül.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-190">Table storage is optimized for performing queries that fetch data falling within a contiguous range of row key values within a partition.</span></span> <span data-ttu-id="a6bdc-191">Ha Azure-táblákban információkat tároló felhőalkalmazásokat fejleszt, tartsa ezt szem előtt, amikor az adatokat strukturálja.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-191">If you're building cloud applications that store information in Azure tables, you should structure your data with this feature in mind.</span></span>

<span data-ttu-id="a6bdc-192">Például vegyünk egy alkalmazást, amely filmekről tárol információkat.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-192">For example, consider an application that stores information about movies.</span></span> <span data-ttu-id="a6bdc-193">Az alkalmazás rendszeresen kérdezi le műfaj szerint a filmeket (akció, dokumentum, történelmi vígjáték, dráma stb.).</span><span class="sxs-lookup"><span data-stu-id="a6bdc-193">The application frequently queries movies by genre (action, documentary, historical, comedy, drama, and so on).</span></span> <span data-ttu-id="a6bdc-194">Létrehozhat egy Azure-táblát mindegyik műfajhoz egy partícióval, ha a műfajt használja partíciókulcsként és a film címét adja meg sorkulcsként, ahogy a következő ábrán látható.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-194">You could create an Azure table with partitions for each genre by using the genre as the partition key, and specifying the movie name as the row key, as shown in the next figure.</span></span>

![7. ábra – Filmek adatai egy Azure-táblában](./_images/index-table-figure-7.png)

<span data-ttu-id="a6bdc-196">Ez a megközelítés kevésbé hatékony, ha az alkalmazásnak ugyanakkor a főszereplő színészt is le kell kérdeznie.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-196">This approach is less effective if the application also needs to query movies by starring actor.</span></span> <span data-ttu-id="a6bdc-197">Ebben az esetben létrehozható egy elkülönített Azure-tábla, amely indextáblaként működik.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-197">In this case, you can create a separate Azure table that acts as an index table.</span></span> <span data-ttu-id="a6bdc-198">A partíciókulcs a színész, a sorkulcs pedig a film címe.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-198">The partition key is the actor and the row key is the movie name.</span></span> <span data-ttu-id="a6bdc-199">Minden egyes színész adatai külön partícióban tárolódnak.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-199">The data for each actor will be stored in separate partitions.</span></span> <span data-ttu-id="a6bdc-200">Ha egy filmben egynél több színész szerepel, ugyanaz a filmcím több partícióban is megjelenik.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-200">If a movie stars more than one actor, the same movie will occur in multiple partitions.</span></span>

<span data-ttu-id="a6bdc-201">A fenti Megoldás részben leírt első megközelítés alkalmazásával duplikálhatja a film adatait az egyes partíciók értékeiben.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-201">You can duplicate the movie data in the values held by each partition by adopting the first approach described in the Solution section above.</span></span> <span data-ttu-id="a6bdc-202">Ugyanakkor valószínű, hogy minden film többször is másolódik (minden színész esetében egyszer), így valószínűleg hatékonyabb megoldás, ha részlegesen denormalizálja az adatokat a leggyakoribb lekérdezések támogatására (például a többi színész neve), és engedélyezi, hogy egy alkalmazás lekérhessen bármilyen egyéb részletet. Ez úgy lehetséges, hogy a műfaj-partíciókhoz hozzáadja a teljes információ megtalálásához szükséges partíciókulcsot.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-202">However, it's likely that each movie will be replicated several times (once for each actor), so it might be more efficient to partially denormalize the data to support the most common queries (such as the names of the other actors) and enable an application to retrieve any remaining details by including the partition key necessary to find the complete information in the genre partitions.</span></span> <span data-ttu-id="a6bdc-203">Erről a megközelítésről a Megoldás szakasz harmadik pontjában talál leírást.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-203">This approach is described by the third option in the Solution section.</span></span> <span data-ttu-id="a6bdc-204">A következő ábra ezt a módszert ábrázolja.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-204">The next figure shows this approach.</span></span>

![8. ábra – A színészpartíciók indextáblaként működnek a filmadatokhoz](./_images/index-table-figure-8.png)

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="a6bdc-206">Kapcsolódó minták és útmutatók</span><span class="sxs-lookup"><span data-stu-id="a6bdc-206">Related patterns and guidance</span></span>

<span data-ttu-id="a6bdc-207">Az alábbi minták és útmutatók szintén hasznosak lehetnek a minta megvalósításakor:</span><span class="sxs-lookup"><span data-stu-id="a6bdc-207">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="a6bdc-208">[Adatkonzisztencia – Ismertető](https://msdn.microsoft.com/library/dn589800.aspx).</span><span class="sxs-lookup"><span data-stu-id="a6bdc-208">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span> <span data-ttu-id="a6bdc-209">Az indextáblákat karban kell tartani, mivel az általuk indexelt adatok változnak.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-209">An index table must be maintained as the data that it indexes changes.</span></span> <span data-ttu-id="a6bdc-210">Elképzelhető, hogy a felhőben nem lehetséges vagy megfelelő olyan műveleteket elvégezni, amelyek ugyanazon tranzakció keretében frissítik is az indexet, mint amellyel módosítják az adatot.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-210">In the cloud, it might not be possible or appropriate to perform operations that update an index as part of the same transaction that modifies the data.</span></span> <span data-ttu-id="a6bdc-211">Ebben az esetben a végül konzisztens megközelítés megfelelő.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-211">In that case, an eventually consistent approach is more suitable.</span></span> <span data-ttu-id="a6bdc-212">Információt szolgáltat a végül bekövetkező konzisztenciát érintő kérdésekről.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-212">Provides information on the issues surrounding eventual consistency.</span></span>
- <span data-ttu-id="a6bdc-213">[Horizontális skálázási minta](./sharding.md).</span><span class="sxs-lookup"><span data-stu-id="a6bdc-213">[Sharding pattern](./sharding.md).</span></span> <span data-ttu-id="a6bdc-214">Az indextábla minta gyakran használják együtt a horizontális skálázással particionált adatokkal.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-214">The Index Table pattern is frequently used in conjunction with data partitioned by using shards.</span></span> <span data-ttu-id="a6bdc-215">A horizontális skálázási minta további információkkal szolgál arról, hogyan oszthat el egy adattárolót horizontálisan skálázott készletekbe.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-215">The Sharding pattern provides more information on how to divide a data store into a set of shards.</span></span>
- <span data-ttu-id="a6bdc-216">[Tényleges táblán alapuló nézet minta](./materialized-view.md).</span><span class="sxs-lookup"><span data-stu-id="a6bdc-216">[Materialized View pattern](./materialized-view.md).</span></span> <span data-ttu-id="a6bdc-217">Ahelyett, hogy indexelné az adatokat összegző lekérdezéseket támogató adatokat, megfelelőbb lehet tényleges táblán alapuló nézetet létrehozni az adatokról.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-217">Instead of indexing data to support queries that summarize data, it might be more appropriate to create a materialized view of the data.</span></span> <span data-ttu-id="a6bdc-218">Ez a szakasz bemutatja, hogyan támogathatóak a hatékony összegző lekérdezések az előfeltöltött nézetek létrehozásával az adatokról.</span><span class="sxs-lookup"><span data-stu-id="a6bdc-218">Describes how to support efficient summary queries by generating prepopulated views over data.</span></span>
