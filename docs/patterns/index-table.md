---
title: Index táblázat
description: Indexek létrehozása gyakran lekérdezések által hivatkozott adattárolókhoz mezőinek keresztül.
keywords: Kialakítási mintája
author: dragon119
ms.date: 06/23/2017
pnp.series.title: Cloud Design Patterns
pnp.pattern.categories:
- data-management
- performance-scalability
ms.openlocfilehash: 24a1061349af84d13f05f88a1698b4efe4b0f449
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 11/14/2017
ms.locfileid: "24541785"
---
# <a name="index-table-pattern"></a><span data-ttu-id="561e2-104">Index táblázat minta</span><span class="sxs-lookup"><span data-stu-id="561e2-104">Index Table pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="561e2-105">Indexek létrehozása gyakran lekérdezések által hivatkozott adattárolókhoz mezőinek keresztül.</span><span class="sxs-lookup"><span data-stu-id="561e2-105">Create indexes over the fields in data stores that are frequently referenced by queries.</span></span> <span data-ttu-id="561e2-106">Ebben a mintában lekérdezés jobb teljesítmény érdekében az alkalmazások gyorsabban keresse meg az adatok lekérése a tárolóban történő engedélyezése.</span><span class="sxs-lookup"><span data-stu-id="561e2-106">This pattern can improve query performance by allowing applications to more quickly locate the data to retrieve from a data store.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="561e2-107">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="561e2-107">Context and problem</span></span>

<span data-ttu-id="561e2-108">Sok adattárolókhoz rendezheti az adatokat az elsődleges kulcs használatával entitások gyűjteményét.</span><span class="sxs-lookup"><span data-stu-id="561e2-108">Many data stores organize the data for a collection of entities using the primary key.</span></span> <span data-ttu-id="561e2-109">Egy alkalmazás ezt a kulcsot segítségével keresse meg és adatok lekérdezéséhez.</span><span class="sxs-lookup"><span data-stu-id="561e2-109">An application can use this key to locate and retrieve data.</span></span> <span data-ttu-id="561e2-110">Az ábra ügyféladatok okozó adattárat példáját mutatja be.</span><span class="sxs-lookup"><span data-stu-id="561e2-110">The figure shows an example of a data store holding customer information.</span></span> <span data-ttu-id="561e2-111">Az elsődleges kulcs, az ügyfél-azonosító.</span><span class="sxs-lookup"><span data-stu-id="561e2-111">The primary key is the Customer ID.</span></span> <span data-ttu-id="561e2-112">Az ábrán látható ügyfél adatait az elsődleges kulcsot (ügyfél-azonosító) szerint vannak rendezve.</span><span class="sxs-lookup"><span data-stu-id="561e2-112">The figure shows customer information organized by the primary key (Customer ID).</span></span>

![1. ábra - ügyfél adatait az elsődleges kulcsot (ügyfél-azonosító) szerint vannak rendezve](./_images/index-table-figure-1.png)


<span data-ttu-id="561e2-114">Míg az elsődleges kulcs értékes adatlehívás, ennek a kulcsnak az értéke alapján lekérdezésekhez, az alkalmazás nem feltétlenül tudni használni az elsődleges kulcs, ha néhány többi mező alapján adatainak beolvasása.</span><span class="sxs-lookup"><span data-stu-id="561e2-114">While the primary key is valuable for queries that fetch data based on the value of this key, an application might not be able to use the primary key if it needs to retrieve data based on some other field.</span></span> <span data-ttu-id="561e2-115">Az ügyfelek a példában az alkalmazás nem használható a felhasználói azonosító elsődleges kulcs beolvasásához ügyfelek Ha néhány attribútum a város, ahol az ügyfél például értéke kizárólag Vezérlőpultjának adatokat lekérdezi.</span><span class="sxs-lookup"><span data-stu-id="561e2-115">In the customers example, an application can't use the Customer ID primary key to retrieve customers if it queries data solely by referencing the value of some other attribute, such as the town in which the customer is located.</span></span> <span data-ttu-id="561e2-116">Ez például-lekérdezést végrehajtani, az alkalmazás beolvasásához, és vizsgálja meg a minden felhasználói rekord, amely lassú folyamat sikerült előfordulhat, hogy rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="561e2-116">To perform a query such as this, the application might have to fetch and examine every customer record, which could be a slow process.</span></span>

<span data-ttu-id="561e2-117">Számos relációs adatbázis-felügyeleti rendszer támogatja a másodlagos indexek.</span><span class="sxs-lookup"><span data-stu-id="561e2-117">Many relational database management systems support secondary indexes.</span></span> <span data-ttu-id="561e2-118">Egy másodlagos index egy külön adatszerkezet, amely egy vagy több nonprimary (másodlagos) kulcs mező szerint van rendezve, és azt jelzi, hogy minden egyes indexelt értékre adatok tárolására.</span><span class="sxs-lookup"><span data-stu-id="561e2-118">A secondary index is a separate data structure that's organized by one or more nonprimary (secondary) key fields, and it indicates where the data for each indexed value is stored.</span></span> <span data-ttu-id="561e2-119">Egy másodlagos index elemeinek általában a másodlagos kulcsok ahhoz, hogy az adatok gyors keresési érték szerint vannak rendezve.</span><span class="sxs-lookup"><span data-stu-id="561e2-119">The items in a secondary index are typically sorted by the value of the secondary keys to enable fast lookup of data.</span></span> <span data-ttu-id="561e2-120">Ezek az indexek általában automatikusan kezeli az adatbázis-kezelő rendszer által.</span><span class="sxs-lookup"><span data-stu-id="561e2-120">These indexes are usually maintained automatically by the database management system.</span></span>

<span data-ttu-id="561e2-121">Tetszőleges számú másodlagos indexek csak szeretne, amely az alkalmazás végrehajtja a különböző lekérdezéseket hozhat létre.</span><span class="sxs-lookup"><span data-stu-id="561e2-121">You can create as many secondary indexes as you need to support the different queries that your application performs.</span></span> <span data-ttu-id="561e2-122">Például egy ügyfél tábla egy relációs adatbázisban, ahol az ügyfél-azonosító-e az elsődleges kulcs, célszerű egy másodlagos index hozzáadása a Város mezőre az, ha az alkalmazás által a város, hol találhatók azok az ügyfelek gyakran keres.</span><span class="sxs-lookup"><span data-stu-id="561e2-122">For example, in a Customers table in a relational database where the Customer ID is the primary key, it's beneficial to add a secondary index over the town field if the application frequently looks up customers by the town where they reside.</span></span>

<span data-ttu-id="561e2-123">Azonban annak ellenére, hogy másodlagos indexek közös relációs rendszerekben, felhőalapú alkalmazások által használt legtöbb NoSQL adattároló nem ad meg egy egyenértékű szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="561e2-123">However, although secondary indexes are common in relational systems, most NoSQL data stores used by cloud applications don't provide an equivalent feature.</span></span>

## <a name="solution"></a><span data-ttu-id="561e2-124">Megoldás</span><span class="sxs-lookup"><span data-stu-id="561e2-124">Solution</span></span>

<span data-ttu-id="561e2-125">Az adattár nem támogatja a másodlagos indexek, ha azokat manuálisan emulálni saját index táblák létrehozásával.</span><span class="sxs-lookup"><span data-stu-id="561e2-125">If the data store doesn't support secondary indexes, you can emulate them manually by creating your own index tables.</span></span> <span data-ttu-id="561e2-126">Az index táblázat által a megadott kulcs rendezi az adatokat.</span><span class="sxs-lookup"><span data-stu-id="561e2-126">An index table organizes the data by a specified key.</span></span> <span data-ttu-id="561e2-127">Három stratégiák gyakran használják az index táblázat szükséges másodlagos indexek száma és a lekérdezések egy alkalmazás végző jellegétől függően rendszerezésére szolgál.</span><span class="sxs-lookup"><span data-stu-id="561e2-127">Three strategies are commonly used for structuring an index table, depending on the number of secondary indexes that are required and the nature of the queries that an application performs.</span></span>

<span data-ttu-id="561e2-128">Az első stratégia, hogy minden index tábla duplikált, de szervezheti, különböző kulccsal (teljes denormalization).</span><span class="sxs-lookup"><span data-stu-id="561e2-128">The first strategy is to duplicate the data in each index table but organize it by different keys (complete denormalization).</span></span> <span data-ttu-id="561e2-129">Az alábbi ábrán látható város és a Vezetéknév ügyfélinformációkat rendszerezése index táblákhoz.</span><span class="sxs-lookup"><span data-stu-id="561e2-129">The next figure shows index tables that organize the same customer information by Town and LastName.</span></span>

![2. ábra - adatok ismétlődik minden index tábla](./_images/index-table-figure-2.png)


<span data-ttu-id="561e2-131">Ezt a stratégiát, ha az adatok viszonylag statikus minden kulcs segítségével kérnek tőle hányszor képest.</span><span class="sxs-lookup"><span data-stu-id="561e2-131">This strategy is appropriate if the data is relatively static compared to the number of times it's queried using each key.</span></span> <span data-ttu-id="561e2-132">Ha az adatok több dinamikus, a feldolgozási terhelést növelni az egyes index táblázatot karbantartó túl nagyra nő esetében ez a megközelítés hasznos lehet.</span><span class="sxs-lookup"><span data-stu-id="561e2-132">If the data is more dynamic, the processing overhead of maintaining each index table becomes too large for this approach to be useful.</span></span> <span data-ttu-id="561e2-133">Ha az adatok mennyisége túl nagy, az ismétlődő adatok tárolásához szükséges lemezterület mennyisége is jelentős.</span><span class="sxs-lookup"><span data-stu-id="561e2-133">Also, if the volume of data is very large, the amount of space required to store the duplicate data is significant.</span></span>

<span data-ttu-id="561e2-134">A második stratégia, ha a normalizált index táblák szerint vannak rendezve különböző kulcsokat és az eredeti adatok referencia elsődleges kulcs használatával így nem szükséges megkettőzni, az alábbi ábrán látható módon.</span><span class="sxs-lookup"><span data-stu-id="561e2-134">The second strategy is to create normalized index tables organized by different keys and reference the original data by using the primary key rather than duplicating it, as shown in the following figure.</span></span> <span data-ttu-id="561e2-135">Az eredeti adatok egy ténytábla nevezik.</span><span class="sxs-lookup"><span data-stu-id="561e2-135">The original data is called a fact table.</span></span>

![3. ábra - adatok minden index tábla által hivatkozott](./_images/index-table-figure-3.png)


<span data-ttu-id="561e2-137">Ez a módszer helyet takarít meg, és csökkenti a duplikált adatok kezelése.</span><span class="sxs-lookup"><span data-stu-id="561e2-137">This technique saves space and reduces the overhead of maintaining duplicate data.</span></span> <span data-ttu-id="561e2-138">A hátránya, hogy rendelkezik-e egy alkalmazás egy másodlagos kulcs használatával adatok kereséséhez két keresési műveletek végrehajtásához.</span><span class="sxs-lookup"><span data-stu-id="561e2-138">The disadvantage is that an application has to perform two lookup operations to find data using a secondary key.</span></span> <span data-ttu-id="561e2-139">Keresse meg az elsődleges kulcs az adatok az index táblázat, és az elsődleges kulcs segítségével megkeresheti az adatokat a ténytábla rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="561e2-139">It has to find the primary key for the data in the index table, and then use the primary key to look up the data in the fact table.</span></span>

<span data-ttu-id="561e2-140">A harmadik stratégia, ha a részlegesen normalizált index táblák, különböző kulccsal, hogy a gyakran lekért mezők szerint vannak rendezve.</span><span class="sxs-lookup"><span data-stu-id="561e2-140">The third strategy is to create partially normalized index tables organized by different keys that duplicate frequently retrieved fields.</span></span> <span data-ttu-id="561e2-141">A ténytábla ritkábban hozzáférés mezőkre hivatkozhatnak.</span><span class="sxs-lookup"><span data-stu-id="561e2-141">Reference the fact table to access less frequently accessed fields.</span></span> <span data-ttu-id="561e2-142">A következő ábra azt mutatja be milyen gyakran használt adatokhoz minden index táblázat ismétlődik.</span><span class="sxs-lookup"><span data-stu-id="561e2-142">The next figure shows how commonly accessed data is duplicated in each index table.</span></span>

![4. ábra - gyakran elért adatok ismétlődik minden index tábla](./_images/index-table-figure-4.png)


<span data-ttu-id="561e2-144">Az ezt a stratégiát akkor is egyensúlyt biztosítanak az első két megközelítés között.</span><span class="sxs-lookup"><span data-stu-id="561e2-144">With this strategy, you can strike a balance between the first two approaches.</span></span> <span data-ttu-id="561e2-145">Az általános lekérdezések lehet adatokat beolvasni gyorsan egy egyetlen keresési használatával, amíg a lemezterület és a karbantartás többletterhelés nincs olyan jelentős, mint a teljes adatkészlet duplikálásakor.</span><span class="sxs-lookup"><span data-stu-id="561e2-145">The data for common queries can be retrieved quickly by using a single lookup, while the space and maintenance overhead isn't as significant as duplicating the entire data set.</span></span>

<span data-ttu-id="561e2-146">Ha egy alkalmazás gyakran adatokat (például "Található összes ügyfél számára, hogy a Redmond, és amelyek a vezetékneve Smith") értékek kombinációja megadásával, sikerült megvalósítása a kulcsokat az elemeket az index táblázatban, a város összefűzése attribútum és a Vezetéknév attribútum.</span><span class="sxs-lookup"><span data-stu-id="561e2-146">If an application frequently queries data by specifying a combination of values (for example, “Find all customers that live in Redmond and that have a last name of Smith”), you could implement the keys to the items in the index table as a concatenation of the Town attribute and the LastName attribute.</span></span> <span data-ttu-id="561e2-147">Az alábbi ábrán látható egy index táblázat összetett kulcsok alapján.</span><span class="sxs-lookup"><span data-stu-id="561e2-147">The next figure shows an index table based on composite keys.</span></span> <span data-ttu-id="561e2-148">A kulcsok az rekordokat, amelyek a város tartozhat azonos érték rendezi a város, majd Vezetéknév szerint.</span><span class="sxs-lookup"><span data-stu-id="561e2-148">The keys are sorted by Town, and then by LastName for records that have the same value for Town.</span></span>

![5. ábra – egy index táblázat összetett kulcsok alapján](./_images/index-table-figure-5.png)


<span data-ttu-id="561e2-150">Index táblák felgyorsíthatja a lekérdezési műveletek felett horizontálisan skálázott adatok, és különösen hasznosak, ahol a shard kulcs kivonat készül.</span><span class="sxs-lookup"><span data-stu-id="561e2-150">Index tables can speed up query operations over sharded data, and are especially useful where the shard key is hashed.</span></span> <span data-ttu-id="561e2-151">A következő ábra azt szemlélteti, ahol a shard kulcsa kivonatát, az ügyfél-azonosító.</span><span class="sxs-lookup"><span data-stu-id="561e2-151">The next figure shows an example where the shard key is a hash of the Customer ID.</span></span> <span data-ttu-id="561e2-152">Az index táblázat adatok rendezése nonhashed értéke (a város és a Vezetéknév), és adja meg a keresési Data a kivonatolt shard kulcsát.</span><span class="sxs-lookup"><span data-stu-id="561e2-152">The index table can organize data by the nonhashed value (Town and LastName), and provide the hashed shard key as the lookup data.</span></span> <span data-ttu-id="561e2-153">Ezt az alkalmazást ismételten kiszámítása a kivonat-kulcsok (drága művelet), ha egy tartományba eső adatok beolvasásához szükséges is mentheti, vagy adatlehívás nonhashed kulcs sorrendben kell.</span><span class="sxs-lookup"><span data-stu-id="561e2-153">This can save the application from repeatedly calculating hash keys (an expensive operation) if it needs to retrieve data that falls within a range, or it needs to fetch data in order of the nonhashed key.</span></span> <span data-ttu-id="561e2-154">Például lekérdezés például a "Található összes ügyfél számára, hogy Redmond" gyorsan megoldhatók a egyező elemek megkeresése az index táblázatban, ahol minden fontosságúak tárolt összefüggő blokkban.</span><span class="sxs-lookup"><span data-stu-id="561e2-154">For example, a query such as “Find all customers that live in Redmond” can be quickly resolved by locating the matching items in the index table, where they're all stored in a contiguous block.</span></span> <span data-ttu-id="561e2-155">Ezután kövesse az ügyféladatokat, a index tábla tárolja a shard kulcsokkal hivatkozik.</span><span class="sxs-lookup"><span data-stu-id="561e2-155">Then, follow the references to the customer data using the shard keys stored in the index table.</span></span>

![6. ábra – egy index táblázat gyors keresési horizontálisan skálázott adatok megadása](./_images/index-table-figure-6.png)


## <a name="issues-and-considerations"></a><span data-ttu-id="561e2-157">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="561e2-157">Issues and considerations</span></span>

<span data-ttu-id="561e2-158">Ebben a mintában megvalósításához meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="561e2-158">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="561e2-159">A terhelés, másodlagos indexek fenntartásának jelentős lehet.</span><span class="sxs-lookup"><span data-stu-id="561e2-159">The overhead of maintaining secondary indexes can be significant.</span></span> <span data-ttu-id="561e2-160">Kell elemezni és megérteni, hogy az alkalmazás által lekérdezéseket.</span><span class="sxs-lookup"><span data-stu-id="561e2-160">You must analyze and understand the queries that your application uses.</span></span> <span data-ttu-id="561e2-161">Index táblák csak létrehozása, ha azok rendszeresen felhasználásra.</span><span class="sxs-lookup"><span data-stu-id="561e2-161">Only create index tables when they're likely to be used regularly.</span></span> <span data-ttu-id="561e2-162">Támogatja az alkalmazás nem hajtja végre, vagy hajt végre csak esetenként spekulatív index táblák ne hozzon létre.</span><span class="sxs-lookup"><span data-stu-id="561e2-162">Don't create speculative index tables to support queries that an application doesn't perform, or performs only occasionally.</span></span>
- <span data-ttu-id="561e2-163">Az index táblázat adatainak duplikálása adhat hozzá jelentős terhelés tárolási költségek és az adatok többszörös lemásolását, karbantartásához szükséges beavatkozást.</span><span class="sxs-lookup"><span data-stu-id="561e2-163">Duplicating data in an index table can add significant overhead in storage costs and the effort required to maintain multiple copies of data.</span></span>
- <span data-ttu-id="561e2-164">Egy alkalmazás adatok kereséséhez két keresési műveletek végrehajtásához, az eredeti adatok hivatkozó normalizált struktúra egy index táblázat végrehajtási szükséges.</span><span class="sxs-lookup"><span data-stu-id="561e2-164">Implementing an index table as a normalized structure that references the original data requires an application to perform two lookup operations to find data.</span></span> <span data-ttu-id="561e2-165">Az első művelet index tábla elsődleges kulcsa keres, és a második elsődleges kulcsot használja az adatok beolvasása.</span><span class="sxs-lookup"><span data-stu-id="561e2-165">The first operation searches the index table to retrieve the primary key, and the second uses the primary key to fetch the data.</span></span>
- <span data-ttu-id="561e2-166">Ha a rendszer a szerződés magában foglalja egy index táblák számát keresztül nagyon nagy méretű adatkészletekhez, biztosítja az egységességet index táblák és az eredeti adatok közötti nehézkes lehet.</span><span class="sxs-lookup"><span data-stu-id="561e2-166">If a system incorporates a number of index tables over very large data sets, it can be difficult to maintain consistency between index tables and the original data.</span></span> <span data-ttu-id="561e2-167">A végleges konzisztencia modell körül alkalmazás is lehet.</span><span class="sxs-lookup"><span data-stu-id="561e2-167">It might be possible to design the application around the eventual consistency model.</span></span> <span data-ttu-id="561e2-168">Insert, update vagy törli az adatokat, például egy alkalmazás képes annak a várólistára üzenetet és lehetővé teszik egy külön feladat végrehajtani a műveletet, és aszinkron módon referenciaadatok index táblákhoz karbantartása.</span><span class="sxs-lookup"><span data-stu-id="561e2-168">For example, to insert, update, or delete data, an application could post a message to a queue and let a separate task perform the operation and maintain the index tables that reference this data asynchronously.</span></span> <span data-ttu-id="561e2-169">A végleges konzisztencia kapcsolatos további információkért lásd: a [adatok konzisztencia ismertetése](https://msdn.microsoft.com/library/dn589800.aspx).</span><span class="sxs-lookup"><span data-stu-id="561e2-169">For more information about implementing eventual consistency, see the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

   >  <span data-ttu-id="561e2-170">A Microsoft Azure storage-táblákat tranzakciós frissítések támogatása (néven entitás csoport tranzakciók) azonos partíciójában végzett módosításokat.</span><span class="sxs-lookup"><span data-stu-id="561e2-170">Microsoft Azure storage tables support transactional updates for changes made to data held in the same partition (referred to as entity group transactions).</span></span> <span data-ttu-id="561e2-171">Ha egyazon partícióra kerüljenek a egy ténytábla és egy vagy több index táblák adatait tárolhatja, ez a szolgáltatás segítségével konzisztencia érdekében.</span><span class="sxs-lookup"><span data-stu-id="561e2-171">If you can store the data for a fact table and one or more index tables in the same partition, you can use this feature to help ensure consistency.</span></span>

- <span data-ttu-id="561e2-172">Index táblák maguk lehet particionált vagy szilánkos.</span><span class="sxs-lookup"><span data-stu-id="561e2-172">Index tables might themselves be partitioned or sharded.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="561e2-173">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="561e2-173">When to use this pattern</span></span>

<span data-ttu-id="561e2-174">Ez a minta segítségével javíthatja a lekérdezések teljesítményét, ha egy alkalmazás gyakran kell kulccsal kívül az elsődleges (vagy a shard) kulcs adatainak beolvasása.</span><span class="sxs-lookup"><span data-stu-id="561e2-174">Use this pattern to improve query performance when an application frequently needs to retrieve data by using a key other than the primary (or shard) key.</span></span>

<span data-ttu-id="561e2-175">Ebben a mintában előfordulhat, hogy nem lehet hasznos:</span><span class="sxs-lookup"><span data-stu-id="561e2-175">This pattern might not be useful when:</span></span>

- <span data-ttu-id="561e2-176">A adata "volatile".</span><span class="sxs-lookup"><span data-stu-id="561e2-176">Data is volatile.</span></span> <span data-ttu-id="561e2-177">Egy index táblázat válhat elavult nagyon gyorsan hatástalanná teszik vagy a fenntartásának az index táblázat nagyobb, mint bármely megtakarított azt a terhelést.</span><span class="sxs-lookup"><span data-stu-id="561e2-177">An index table can become out of date very quickly, making it ineffective or making the overhead of maintaining the index table greater than any savings made by using it.</span></span>
- <span data-ttu-id="561e2-178">A kiválasztott másodlagos kulcs egy index táblázat mező nondiscriminating és egyszerre csak egy kis készletét értékek (például nemét).</span><span class="sxs-lookup"><span data-stu-id="561e2-178">A field selected as the secondary key for an index table is nondiscriminating and can only have a small set of values (for example, gender).</span></span>
- <span data-ttu-id="561e2-179">Egy másodlagos kulcs egy index táblázat kiválasztott mező alapján az adatértékek egyenlege magas ferde vannak.</span><span class="sxs-lookup"><span data-stu-id="561e2-179">The balance of the data values for a field selected as the secondary key for an index table are highly skewed.</span></span> <span data-ttu-id="561e2-180">Ha a rekordokat a 90 %-a mezője azonos értéket tartalmaz, majd létrehozása, és ez a mező alapján adatokat kereshet egy index táblázatot karbantartó előfordulhat, hogy hozzon létre például további terhet jelentenek, mint egymás után keresztül az adatok vizsgálatát.</span><span class="sxs-lookup"><span data-stu-id="561e2-180">For example, if 90% of the records contain the same value in a field, then creating and maintaining an index table to look up data based on this field might create more overhead than scanning sequentially through the data.</span></span> <span data-ttu-id="561e2-181">Azonban ha lekérdezések nagyon gyakran célértéket, melyek a fennmaradó 10 %-ban, ez az index hasznos lehet.</span><span class="sxs-lookup"><span data-stu-id="561e2-181">However, if queries very frequently target values that lie in the remaining 10%, this index can be useful.</span></span> <span data-ttu-id="561e2-182">Ismerje meg, hogy működik-e az alkalmazás, és milyen gyakran által végrehajtott lekérdezéseket.</span><span class="sxs-lookup"><span data-stu-id="561e2-182">You should understand the queries that your application is performing, and how frequently they're performed.</span></span>

## <a name="example"></a><span data-ttu-id="561e2-183">Példa</span><span class="sxs-lookup"><span data-stu-id="561e2-183">Example</span></span>

<span data-ttu-id="561e2-184">Az Azure storage táblázatokban egy kiválóan méretezhető kulcs/érték adattár a felhőben futó alkalmazások.</span><span class="sxs-lookup"><span data-stu-id="561e2-184">Azure storage tables provide a highly scalable key/value data store for applications running in the cloud.</span></span> <span data-ttu-id="561e2-185">Alkalmazások tárolásához, és az adatértékek lekéréséhez kulcs megadásával.</span><span class="sxs-lookup"><span data-stu-id="561e2-185">Applications store and retrieve data values by specifying a key.</span></span> <span data-ttu-id="561e2-186">Az adatok értékek tartalmazhatnak több mező, de adatelemet szerkezete fedett, a table storage, amely egyszerűen végzi, bájttömb adatelemet.</span><span class="sxs-lookup"><span data-stu-id="561e2-186">The data values can contain multiple fields, but the structure of a data item is opaque to table storage, which simply handles a data item as an array of bytes.</span></span>

<span data-ttu-id="561e2-187">Az Azure storage-táblákat horizontális is támogatja.</span><span class="sxs-lookup"><span data-stu-id="561e2-187">Azure storage tables also support sharding.</span></span> <span data-ttu-id="561e2-188">A horizontális két elemet, egy partíciót és sor kulcsot tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="561e2-188">The sharding key includes two elements, a partition key and a row key.</span></span> <span data-ttu-id="561e2-189">Ugyanazzal a partíciókulccsal rendelkező elemek (szilánkok) tartalmazó partícióra vannak tárolva, és az elemek sor kulcs sorrendje a shard belül vannak tárolva.</span><span class="sxs-lookup"><span data-stu-id="561e2-189">Items that have the same partition key are stored in the same partition (shard), and the items are stored in row key order within a shard.</span></span> <span data-ttu-id="561e2-190">A TABLE storage a partíción belül sor kulcsértékei összefüggő számos alá tartozó adatlehívás lekérdezések végrehajtása van optimalizálva.</span><span class="sxs-lookup"><span data-stu-id="561e2-190">Table storage is optimized for performing queries that fetch data falling within a contiguous range of row key values within a partition.</span></span> <span data-ttu-id="561e2-191">Ha felhőalapú alkalmazásokhoz, Azure-táblákban információt tároló most felépítése, ez a szolgáltatás szem előtt az adatok szerkezetét.</span><span class="sxs-lookup"><span data-stu-id="561e2-191">If you're building cloud applications that store information in Azure tables, you should structure your data with this feature in mind.</span></span>

<span data-ttu-id="561e2-192">Vegye figyelembe például olyan alkalmazás, amely filmek kapcsolatos információkat tárolja.</span><span class="sxs-lookup"><span data-stu-id="561e2-192">For example, consider an application that stores information about movies.</span></span> <span data-ttu-id="561e2-193">Az alkalmazás gyakran lekérdezi filmek által genre (a művelet, dokumentált, korábbi, comedy, tragédiát, és így tovább).</span><span class="sxs-lookup"><span data-stu-id="561e2-193">The application frequently queries movies by genre (action, documentary, historical, comedy, drama, and so on).</span></span> <span data-ttu-id="561e2-194">Egy Azure-tábla segítségével létrehozhat minden genre partíciók használatával a genre partíciókulcsnak, és a sorkulcs, mint a movie név megadásával a következő ábrán látható módon.</span><span class="sxs-lookup"><span data-stu-id="561e2-194">You could create an Azure table with partitions for each genre by using the genre as the partition key, and specifying the movie name as the row key, as shown in the next figure.</span></span>

![7. ábra - Movie adataihoz az Azure tábla](./_images/index-table-figure-7.png)


<span data-ttu-id="561e2-196">Erre akkor kevésbé hatékony, ha az alkalmazást is kell lekérdezés filmek szereplő Főszerepben által.</span><span class="sxs-lookup"><span data-stu-id="561e2-196">This approach is less effective if the application also needs to query movies by starring actor.</span></span> <span data-ttu-id="561e2-197">Ebben az esetben az Azure táblájába, amely különbséglemezként funkcionál egy index táblázat is létrehozhat.</span><span class="sxs-lookup"><span data-stu-id="561e2-197">In this case, you can create a separate Azure table that acts as an index table.</span></span> <span data-ttu-id="561e2-198">A partíciós kulcs a szereplő, és a sorkulcs movie nevét.</span><span class="sxs-lookup"><span data-stu-id="561e2-198">The partition key is the actor and the row key is the movie name.</span></span> <span data-ttu-id="561e2-199">Minden egyes szereplő adatok külön partíciók tárolódnak.</span><span class="sxs-lookup"><span data-stu-id="561e2-199">The data for each actor will be stored in separate partitions.</span></span> <span data-ttu-id="561e2-200">Ha film csillaggal egynél több szereplő, az azonos movie több partíciót történik.</span><span class="sxs-lookup"><span data-stu-id="561e2-200">If a movie stars more than one actor, the same movie will occur in multiple partitions.</span></span>

<span data-ttu-id="561e2-201">Mindegyik partíció tartja az első módszer a megoldást a fenti szakaszban leírt elfogadásával értékek movie adatainak másolhatja.</span><span class="sxs-lookup"><span data-stu-id="561e2-201">You can duplicate the movie data in the values held by each partition by adopting the first approach described in the Solution section above.</span></span> <span data-ttu-id="561e2-202">Azonban valószínű, hogy minden movie többször replikálja (egyszer az egyes aktor), ezért előfordulhat, hogy hatékonyabb, ha részben denormalize az adatokat (például a más szereplője nevének) a leggyakoribb lekérdezések támogatja, és lehetővé teszik az alkalmazások beolvasása fennmaradó adatokat a meg nem találja a teljes körű információkat a genre partíciókat a partíciókulcs-ot.</span><span class="sxs-lookup"><span data-stu-id="561e2-202">However, it's likely that each movie will be replicated several times (once for each actor), so it might be more efficient to partially denormalize the data to support the most common queries (such as the names of the other actors) and enable an application to retrieve any remaining details by including the partition key necessary to find the complete information in the genre partitions.</span></span> <span data-ttu-id="561e2-203">Ez a megközelítés a harmadik lehetőség a megoldás szakaszban írja le.</span><span class="sxs-lookup"><span data-stu-id="561e2-203">This approach is described by the third option in the Solution section.</span></span> <span data-ttu-id="561e2-204">A következő ábrán látható ezt a módszert használja.</span><span class="sxs-lookup"><span data-stu-id="561e2-204">The next figure shows this approach.</span></span>

![8. ábra - index táblák movie adatok működött szereplő partíciók](./_images/index-table-figure-8.png)


## <a name="related-patterns-and-guidance"></a><span data-ttu-id="561e2-206">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="561e2-206">Related patterns and guidance</span></span>

<span data-ttu-id="561e2-207">A következő mintákat és útmutatókat is lehet releváns ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="561e2-207">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="561e2-208">[Adatok konzisztencia ismertetése](https://msdn.microsoft.com/library/dn589800.aspx).</span><span class="sxs-lookup"><span data-stu-id="561e2-208">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span> <span data-ttu-id="561e2-209">Az index táblázat fenn kell tartani a Data azt indexeli a módosításokat.</span><span class="sxs-lookup"><span data-stu-id="561e2-209">An index table must be maintained as the data that it indexes changes.</span></span> <span data-ttu-id="561e2-210">A felhőben nem lehet vagy nem megfelelő index frissítése ugyanabban a tranzakcióban, amely módosítja az adatok részeként műveleteket.</span><span class="sxs-lookup"><span data-stu-id="561e2-210">In the cloud, it might not be possible or appropriate to perform operations that update an index as part of the same transaction that modifies the data.</span></span> <span data-ttu-id="561e2-211">Ebben az esetben egy idővel konzisztenssé megoldás, megfelelő.</span><span class="sxs-lookup"><span data-stu-id="561e2-211">In that case, an eventually consistent approach is more suitable.</span></span> <span data-ttu-id="561e2-212">A végleges konzisztencia körülvevő problémákat ismerteti.</span><span class="sxs-lookup"><span data-stu-id="561e2-212">Provides information on the issues surrounding eventual consistency.</span></span>
- <span data-ttu-id="561e2-213">[Horizontális mintát](https://msdn.microsoft.com/library/dn589797.aspx).</span><span class="sxs-lookup"><span data-stu-id="561e2-213">[Sharding pattern](https://msdn.microsoft.com/library/dn589797.aspx).</span></span> <span data-ttu-id="561e2-214">Az Index táblázat mintát gyakran együtt használatos szilánkok használ adatokkal.</span><span class="sxs-lookup"><span data-stu-id="561e2-214">The Index Table pattern is frequently used in conjunction with data partitioned by using shards.</span></span> <span data-ttu-id="561e2-215">A horizontális mintát adattárat felosztani szilánkok készlete módjáról nyújt részletesebb információt.</span><span class="sxs-lookup"><span data-stu-id="561e2-215">The Sharding pattern provides more information on how to divide a data store into a set of shards.</span></span>
- <span data-ttu-id="561e2-216">[Materializált nézet mintát](materialized-view.md).</span><span class="sxs-lookup"><span data-stu-id="561e2-216">[Materialized View pattern](materialized-view.md).</span></span> <span data-ttu-id="561e2-217">Helyett az indexelési adatok támogatja az adatokat, akkor célszerű több adat materializált nézet létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="561e2-217">Instead of indexing data to support queries that summarize data, it might be more appropriate to create a materialized view of the data.</span></span> <span data-ttu-id="561e2-218">Ismerteti, hogyan támogatja az hatékony összefoglaló adatok előfeltöltött nézetek létrehozásával.</span><span class="sxs-lookup"><span data-stu-id="561e2-218">Describes how to support efficient summary queries by generating prepopulated views over data.</span></span>
