---
title: Versengő felhasználók mintája
titleSuffix: Cloud Design Patterns
description: Lehetővé teheti több párhuzamos felhasználó számára, hogy feldolgozzák az ugyanazon az üzenetkezelési csatornán fogadott üzeneteket.
keywords: tervezési minta
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: ea3f48971a78f59ad6575b055278aab449fa26a1
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 03/20/2019
ms.locfileid: "58299014"
---
# <a name="competing-consumers-pattern"></a><span data-ttu-id="45139-104">Versengő felhasználók mintája</span><span class="sxs-lookup"><span data-stu-id="45139-104">Competing Consumers pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="45139-105">Lehetővé teheti több párhuzamos felhasználó számára, hogy feldolgozzák az ugyanazon az üzenetkezelési csatornán fogadott üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="45139-105">Enable multiple concurrent consumers to process messages received on the same messaging channel.</span></span> <span data-ttu-id="45139-106">Ez lehetővé teszi, hogy a rendszer több üzenetet dolgozzon fel párhuzamosan a teljesítmény optimalizálása, a skálázhatóság és rendelkezésre állás javítása és a terhelés elosztása érdekében.</span><span class="sxs-lookup"><span data-stu-id="45139-106">This enables a system to process multiple messages concurrently to optimize throughput, to improve scalability and availability, and to balance the workload.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="45139-107">Kontextus és probléma</span><span class="sxs-lookup"><span data-stu-id="45139-107">Context and problem</span></span>

<span data-ttu-id="45139-108">Egy felhőben futó alkalmazásnak várhatóan sok kérelmet kell majd kezelnie.</span><span class="sxs-lookup"><span data-stu-id="45139-108">An application running in the cloud is expected to handle a large number of requests.</span></span> <span data-ttu-id="45139-109">Az egyes kérelmek szinkron módon történő feldolgozása helyett az általános módszer az, hogy az alkalmazás egy üzenetkezelési rendszeren keresztül egy másik szolgáltatásba (feldolgozói szolgáltatásba) küldi őket, ahol a feldolgozásuk aszinkron módon történik.</span><span class="sxs-lookup"><span data-stu-id="45139-109">Rather than process each request synchronously, a common technique is for the application to pass them through a messaging system to another service (a consumer service) that handles them asynchronously.</span></span> <span data-ttu-id="45139-110">Ez a stratégia segít biztosítani, hogy az alkalmazáshoz kapcsolódó üzleti logikát ne akadályozza semmi, miközben a kérelmek feldolgozása zajlik.</span><span class="sxs-lookup"><span data-stu-id="45139-110">This strategy helps to ensure that the business logic in the application isn't blocked while the requests are being processed.</span></span>

<span data-ttu-id="45139-111">Kérelmek száma idővel nagymértékben változhat, és ennek számos oka lehet.</span><span class="sxs-lookup"><span data-stu-id="45139-111">The number of requests can vary significantly over time for many reasons.</span></span> <span data-ttu-id="45139-112">A felhasználói aktivitás hirtelen növekedése vagy az egyszerre több bérlőtől érkező összesített kérelmek kiszámíthatatlan mennyiségű számítási feladatot eredményezhetnek.</span><span class="sxs-lookup"><span data-stu-id="45139-112">A sudden increase in user activity or aggregated requests coming from multiple tenants can cause an unpredictable workload.</span></span> <span data-ttu-id="45139-113">Csúcsidőszakban előfordulhat, hogy a rendszernek másodpercenként több száz kérelmet kell feldolgoznia, míg más esetben ez a szám igen alacsony is lehet.</span><span class="sxs-lookup"><span data-stu-id="45139-113">At peak hours a system might need to process many hundreds of requests per second, while at other times the number could be very small.</span></span> <span data-ttu-id="45139-114">Ezenkívül a kérelmek kezelése terén végzett munka jellege is igen változó lehet.</span><span class="sxs-lookup"><span data-stu-id="45139-114">Additionally, the nature of the work performed to handle these requests might be highly variable.</span></span> <span data-ttu-id="45139-115">Egyetlen feldolgozói szolgáltatás alkalmazása azt eredményezheti, hogy az adott példányt elárasztják a kérelmek, vagy az alkalmazás részéről érkező üzenetáradat túlterheli a levelezőrendszert.</span><span class="sxs-lookup"><span data-stu-id="45139-115">Using a single instance of the consumer service can cause that instance to become flooded with requests, or the messaging system might be overloaded by an influx of messages coming from the application.</span></span> <span data-ttu-id="45139-116">A változó mennyiségű számítási feladatok kezelése érdekében a rendszer a feldolgozói szolgáltatás több példányát is képes futtatni.</span><span class="sxs-lookup"><span data-stu-id="45139-116">To handle this fluctuating workload, the system can run multiple instances of the consumer service.</span></span> <span data-ttu-id="45139-117">Ezeket a feldolgozókat azonban össze kell hangolni annak érdekében, hogy egy üzenetet csak egyetlen feldolgozóhoz kézbesítsen a rendszer.</span><span class="sxs-lookup"><span data-stu-id="45139-117">However, these consumers must be coordinated to ensure that each message is only delivered to a single consumer.</span></span> <span data-ttu-id="45139-118">A számítási feladatok jelentette terhelést is el kell osztani a feldolgozók között, nehogy egy példány szűk keresztmetszetté váljon.</span><span class="sxs-lookup"><span data-stu-id="45139-118">The workload also needs to be load balanced across consumers to prevent an instance from becoming a bottleneck.</span></span>

## <a name="solution"></a><span data-ttu-id="45139-119">Megoldás</span><span class="sxs-lookup"><span data-stu-id="45139-119">Solution</span></span>

<span data-ttu-id="45139-120">Az üzenetsor segítségével megteremtheti a kommunikációs csatornát az alkalmazás és a feldolgozói szolgáltatás példányai között.</span><span class="sxs-lookup"><span data-stu-id="45139-120">Use a message queue to implement the communication channel between the application and the instances of the consumer service.</span></span> <span data-ttu-id="45139-121">Az alkalmazás üzenetek formájában tesz közzé kérelmeket az üzenetsorban, a feldolgozói szolgáltatáspéldányok pedig fogadják és feldolgozzák ezeket az üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="45139-121">The application posts requests in the form of messages to the queue, and the consumer service instances receive messages from the queue and process them.</span></span> <span data-ttu-id="45139-122">Ez a megközelítés lehetővé teszi, hogy ugyanaz a feldolgozói szolgáltatáspéldány-készlet képes legyen kezelni az alkalmazás bármely példányától érkező üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="45139-122">This approach enables the same pool of consumer service instances to handle messages from any instance of the application.</span></span> <span data-ttu-id="45139-123">Az ábra bemutatja, hogyan lehet az üzenetsor használatával elosztani a munkát a szolgáltatás példányai között.</span><span class="sxs-lookup"><span data-stu-id="45139-123">The figure illustrates using a message queue to distribute work to instances of a service.</span></span>

![A munka szétosztása egy szolgáltatás példányai között üzenetsor használatával](./_images/competing-consumers-diagram.png)

<span data-ttu-id="45139-125">Ez a megoldás a következő előnyökkel jár:</span><span class="sxs-lookup"><span data-stu-id="45139-125">This solution has the following benefits:</span></span>

- <span data-ttu-id="45139-126">Kiegyenlített terhelésű rendszert biztosít, amely jelentősen eltérő mennyiségben is képes kezelni az alkalmazáspéldányok által küldött kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="45139-126">It provides a load-leveled system that can handle wide variations in the volume of requests sent by application instances.</span></span> <span data-ttu-id="45139-127">Az üzenetsor pufferként viselkedik az alkalmazáspéldányok és a feldolgozói szolgáltatás példányai között.</span><span class="sxs-lookup"><span data-stu-id="45139-127">The queue acts as a buffer between the application instances and the consumer service instances.</span></span> <span data-ttu-id="45139-128">Ez segít minimalizálni a rendelkezésre állásra és a válaszképességre gyakorolt hatást mind az alkalmazás, mind a szolgáltatáspéldány esetében, az [Üzenetsor-alapú terheléskiegyenlítési minta](./queue-based-load-leveling.md) ismertetőjében foglaltak szerint.</span><span class="sxs-lookup"><span data-stu-id="45139-128">This can help to minimize the impact on availability and responsiveness for both the application and the service instances, as described by the [Queue-based Load Leveling pattern](./queue-based-load-leveling.md).</span></span> <span data-ttu-id="45139-129">A hosszabb ideig tartó feldolgozást igénylő üzenetek nem akadályozzák a feldolgozói szolgáltatás más példányait a többi üzenet párhuzamos kezelésében.</span><span class="sxs-lookup"><span data-stu-id="45139-129">Handling a message that requires some long-running processing doesn't prevent other messages from being handled concurrently by other instances of the consumer service.</span></span>

- <span data-ttu-id="45139-130">Ez növeli a megbízhatóságot.</span><span class="sxs-lookup"><span data-stu-id="45139-130">It improves reliability.</span></span> <span data-ttu-id="45139-131">Ha az előállító ennek a mintának a használata helyett közvetlenül kommunikál a feldolgozóval, de nem monitorozza azt, akkor nagy valószínűséggel el fognak veszni üzenetek, vagy a feldolgozásuk sikertelen lesz, ha a feldolgozó meghibásodik.</span><span class="sxs-lookup"><span data-stu-id="45139-131">If a producer communicates directly with a consumer instead of using this pattern, but doesn't monitor the consumer, there's a high probability that messages could be lost or fail to be processed if the consumer fails.</span></span> <span data-ttu-id="45139-132">Ebben a mintában a rendszer nem egy adott szolgáltatáspéldányra küldi az üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="45139-132">In this pattern, messages aren't sent to a specific service instance.</span></span> <span data-ttu-id="45139-133">A sikertelen szolgáltatáspéldány nem blokkolja az előállítót, az üzenetek feldolgozását pedig bármely működő szolgáltatáspéldány elvégezheti.</span><span class="sxs-lookup"><span data-stu-id="45139-133">A failed service instance won't block a producer, and messages can be processed by any working service instance.</span></span>

- <span data-ttu-id="45139-134">Nincs szükség összetett koordinációra a feldolgozók, illetve az előállítói és a feldolgozói példányok között.</span><span class="sxs-lookup"><span data-stu-id="45139-134">It doesn't require complex coordination between the consumers, or between the producer and the consumer instances.</span></span> <span data-ttu-id="45139-135">Az üzenetsor biztosítja, hogy a rendszer minden üzenetet legalább egyszer elküldjön.</span><span class="sxs-lookup"><span data-stu-id="45139-135">The message queue ensures that each message is delivered at least once.</span></span>

- <span data-ttu-id="45139-136">Skálázható.</span><span class="sxs-lookup"><span data-stu-id="45139-136">It's scalable.</span></span> <span data-ttu-id="45139-137">A rendszer dinamikusan növelheti vagy csökkentheti a feldolgozó szolgáltatás példányainak számát az üzenetek mennyiségbeli változásainak megfelelően.</span><span class="sxs-lookup"><span data-stu-id="45139-137">The system can dynamically increase or decrease the number of instances of the consumer service as the volume of messages fluctuates.</span></span>

- <span data-ttu-id="45139-138">Fokozható a rugalmasság, ha az üzenetsor tranzakciós olvasási műveleteket biztosít.</span><span class="sxs-lookup"><span data-stu-id="45139-138">It can improve resiliency if the message queue provides transactional read operations.</span></span> <span data-ttu-id="45139-139">Ha a feldolgozói szolgáltatáspéldány egy tranzakciós művelet részeként olvassa be és dolgozza fel az üzenetet, és a feldolgozói szolgáltatáspéldány meghibásodik, ez a minta gondoskodik arról, hogy az üzenet visszajusson az üzenetsorba, ahol a feldolgozói szolgáltatás egy másik példánya kezelheti.</span><span class="sxs-lookup"><span data-stu-id="45139-139">If a consumer service instance reads and processes the message as part of a transactional operation, and the consumer service instance fails, this pattern can ensure that the message will be returned to the queue to be picked up and handled by another instance of the consumer service.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="45139-140">Problémák és megfontolandó szempontok</span><span class="sxs-lookup"><span data-stu-id="45139-140">Issues and considerations</span></span>

<span data-ttu-id="45139-141">A minta megvalósítása során az alábbi pontokat vegye figyelembe:</span><span class="sxs-lookup"><span data-stu-id="45139-141">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="45139-142">**Üzenetrendezés**.</span><span class="sxs-lookup"><span data-stu-id="45139-142">**Message ordering**.</span></span> <span data-ttu-id="45139-143">A sorrend, amelyben a fogyasztói szolgáltatáspéldány az üzeneteket fogadja, nem garantált, és nem feltétlenül tükrözi az üzenetek létrehozásának sorrendjét.</span><span class="sxs-lookup"><span data-stu-id="45139-143">The order in which consumer service instances receive messages isn't guaranteed, and doesn't necessarily reflect the order in which the messages were created.</span></span> <span data-ttu-id="45139-144">Érdemes úgy megtervezni rendszert, hogy biztosítsa az üzenetek idempotens feldolgozását, mert ez segít kiküszöbölni minden olyan függőséget, amely az üzenetek kezelési sorrendjéhez kapcsolódik.</span><span class="sxs-lookup"><span data-stu-id="45139-144">Design the system to ensure that message processing is idempotent because this will help to eliminate any dependency on the order in which messages are handled.</span></span> <span data-ttu-id="45139-145">További információkért lásd: [Idempotens minták](https://blog.jonathanoliver.com/idempotency-patterns/) (Jonathan Oliver blogjában).</span><span class="sxs-lookup"><span data-stu-id="45139-145">For more information, see [Idempotency Patterns](https://blog.jonathanoliver.com/idempotency-patterns/) on Jonathon Oliver’s blog.</span></span>

    > <span data-ttu-id="45139-146">A Microsoft Azure Service Bus-üzenetsorok üzenet-munkamenetek alkalmazásával képesek garantálni az üzenetek elsőnek-be, elsőnek-ki típusú kezelését.</span><span class="sxs-lookup"><span data-stu-id="45139-146">Microsoft Azure Service Bus Queues can implement guaranteed first-in-first-out ordering of messages by using message sessions.</span></span> <span data-ttu-id="45139-147">További információkért lásd: [Üzenetkezelési minták munkamenetek használatával](https://msdn.microsoft.com/magazine/jj863132.aspx).</span><span class="sxs-lookup"><span data-stu-id="45139-147">For more information, see [Messaging Patterns Using Sessions](https://msdn.microsoft.com/magazine/jj863132.aspx).</span></span>

- <span data-ttu-id="45139-148">**Rugalmasságot biztosító szolgáltatások tervezése**.</span><span class="sxs-lookup"><span data-stu-id="45139-148">**Designing services for resiliency**.</span></span> <span data-ttu-id="45139-149">Ha a rendszert úgy tervezték, hogy észlelje és újraindítsa a sikertelen szolgáltatáspéldányokat, szükség lehet a szolgáltatáspéldányok által végrehajtott feldolgozás idempotens műveletekként történő alkalmazására, hogy egy adott üzenet többszöri lekéréséből és feldolgozásából eredő hatások minimalizálhatók legyenek.</span><span class="sxs-lookup"><span data-stu-id="45139-149">If the system is designed to detect and restart failed service instances, it might be necessary to implement the processing performed by the service instances as idempotent operations to minimize the effects of a single message being retrieved and processed more than once.</span></span>

- <span data-ttu-id="45139-150">**Az ártalmas üzenetek észlelése**.</span><span class="sxs-lookup"><span data-stu-id="45139-150">**Detecting poison messages**.</span></span> <span data-ttu-id="45139-151">Ha egy helytelenül formázott üzenet vagy feladat olyan erőforrásokhoz igényel hozzáférést, amelyek nem érhetők el, az a szolgáltatáspéldány sikertelen működéséhez vezethet.</span><span class="sxs-lookup"><span data-stu-id="45139-151">A malformed message, or a task that requires access to resources that aren't available, can cause a service instance to fail.</span></span> <span data-ttu-id="45139-152">A rendszernek meg kell akadályoznia, hogy ezek az üzenetek visszajussanak az üzenetsorba. Ehelyett valahol máshol kell tárolnia ezeknek az üzeneteknek az adatait, hogy szükség esetén elemezni lehessen azokat.</span><span class="sxs-lookup"><span data-stu-id="45139-152">The system should prevent such messages being returned to the queue, and instead capture and store the details of these messages elsewhere so that they can be analyzed if necessary.</span></span>

- <span data-ttu-id="45139-153">**Eredmények kezelése**.</span><span class="sxs-lookup"><span data-stu-id="45139-153">**Handling results**.</span></span> <span data-ttu-id="45139-154">Az üzenetet kezelő szolgáltatáspéldányt a rendszer teljes mértékben leválasztja az üzenetet létrehozó alkalmazáslogikáról, így ezek valószínűleg nem tudnak közvetlenül kommunikálni egymással.</span><span class="sxs-lookup"><span data-stu-id="45139-154">The service instance handling a message is fully decoupled from the application logic that generates the message, and they might not be able to communicate directly.</span></span> <span data-ttu-id="45139-155">Ha a szolgáltatáspéldány olyan eredményeket hoz létre, amelyeket vissza kell küldeni az alkalmazáslogikának, ezeket az információkat mindkét fél számára elérhető helyen kell tárolni.</span><span class="sxs-lookup"><span data-stu-id="45139-155">If the service instance generates results that must be passed back to the application logic, this information must be stored in a location that's accessible to both.</span></span> <span data-ttu-id="45139-156">Annak érdekében, hogy az alkalmazáslogika ne hívhasson le hiányos adatokat, a rendszernek jeleznie kell, ha az adatok feldolgozása befejeződött.</span><span class="sxs-lookup"><span data-stu-id="45139-156">In order to prevent the application logic from retrieving incomplete data the system must indicate when processing is complete.</span></span>

     > <span data-ttu-id="45139-157">Az Azure használata esetén egy feldolgozófolyamat vissza tudja küldeni az eredményeket az alkalmazáslogikának egy dedikált válaszadási üzenetsor használatával.</span><span class="sxs-lookup"><span data-stu-id="45139-157">If you're using Azure, a worker process can pass results back to the application logic by using a dedicated message reply queue.</span></span> <span data-ttu-id="45139-158">Az alkalmazáslogikának össze kell kötnie ezeket az eredményeket az eredeti üzenettel.</span><span class="sxs-lookup"><span data-stu-id="45139-158">The application logic must be able to correlate these results with the original message.</span></span> <span data-ttu-id="45139-159">Ennek a forgatókönyvnek a részletes leírása [az aszinkron üzenetkezelés ismertetését](https://msdn.microsoft.com/library/dn589781.aspx) tartalmazó témakörben található.</span><span class="sxs-lookup"><span data-stu-id="45139-159">This scenario is described in more detail in the [Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx).</span></span>

- <span data-ttu-id="45139-160">**Az üzenetkezelő rendszer skálázása**.</span><span class="sxs-lookup"><span data-stu-id="45139-160">**Scaling the messaging system**.</span></span> <span data-ttu-id="45139-161">Egy nagyméretű megoldás esetében egyetlen üzenetsort túlterhelhetnek az üzenetek, és így szűk keresztmetszetként jelenhet meg a rendszerben.</span><span class="sxs-lookup"><span data-stu-id="45139-161">In a large-scale solution, a single message queue could be overwhelmed by the number of messages and become a bottleneck in the system.</span></span> <span data-ttu-id="45139-162">Ebben a helyzetben érdemes megfontolni az üzenetkezelési rendszer particionálását, hogy az adott előállítók a meghatározott üzenetsorra küldjék az üzeneteket. Használhat terheléselosztást is, hogy több üzenetsor között oszthassa szét az üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="45139-162">In this situation, consider partitioning the messaging system to send messages from specific producers to a particular queue, or use load balancing to distribute messages across multiple message queues.</span></span>

- <span data-ttu-id="45139-163">**Az üzenetkezelési rendszer megbízhatóságának biztosítása**.</span><span class="sxs-lookup"><span data-stu-id="45139-163">**Ensuring reliability of the messaging system**.</span></span> <span data-ttu-id="45139-164">Egy megbízható üzenetkezelési rendszerre van szükség annak érdekében, hogy az alkalmazás által sorba helyezett üzenet biztosan ne vesszen el.</span><span class="sxs-lookup"><span data-stu-id="45139-164">A reliable messaging system is needed to guarantee that after the application enqueues a message it won't be lost.</span></span> <span data-ttu-id="45139-165">Ez elengedhetetlen ahhoz, hogy a rendszer minden üzenetet legalább egyszer kézbesítsen.</span><span class="sxs-lookup"><span data-stu-id="45139-165">This is essential for ensuring that all messages are delivered at least once.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="45139-166">Mikor érdemes ezt a mintát használni?</span><span class="sxs-lookup"><span data-stu-id="45139-166">When to use this pattern</span></span>

<span data-ttu-id="45139-167">Használja ezt a mintát, ha:</span><span class="sxs-lookup"><span data-stu-id="45139-167">Use this pattern when:</span></span>

- <span data-ttu-id="45139-168">Az alkalmazás számítási feladatai aszinkron módon futtatható feladatokra vannak osztva.</span><span class="sxs-lookup"><span data-stu-id="45139-168">The workload for an application is divided into tasks that can run asynchronously.</span></span>
- <span data-ttu-id="45139-169">A feladatok egymástól függetlenek, és párhuzamosan futtathatók.</span><span class="sxs-lookup"><span data-stu-id="45139-169">Tasks are independent and can run in parallel.</span></span>
- <span data-ttu-id="45139-170">A munka mennyisége nagymértékben változó, ami skálázható megoldást kíván.</span><span class="sxs-lookup"><span data-stu-id="45139-170">The volume of work is highly variable, requiring a scalable solution.</span></span>
- <span data-ttu-id="45139-171">A megoldásnak magas rendelkezésre állást kell biztosítania, továbbá rugalmasan kell kezelnie egy feladat feldolgozásának meghiúsulását.</span><span class="sxs-lookup"><span data-stu-id="45139-171">The solution must provide high availability, and must be resilient if the processing for a task fails.</span></span>

<span data-ttu-id="45139-172">Nem érdemes ezt a mintát használni, ha:</span><span class="sxs-lookup"><span data-stu-id="45139-172">This pattern might not be useful when:</span></span>

- <span data-ttu-id="45139-173">Az alkalmazás számítási feladatait nem könnyű különálló feladatokká szétválasztani, vagy a feladatok között nagyfokú függőség áll fenn.</span><span class="sxs-lookup"><span data-stu-id="45139-173">It's not easy to separate the application workload into discrete tasks, or there's a high degree of dependence between tasks.</span></span>
- <span data-ttu-id="45139-174">A feladatokat szinkron módon kell végrehajtani, és az alkalmazáslogikának meg kell várnia a feladat befejeződését a továbblépés előtt.</span><span class="sxs-lookup"><span data-stu-id="45139-174">Tasks must be performed synchronously, and the application logic must wait for a task to complete before continuing.</span></span>
- <span data-ttu-id="45139-175">A feladatok meghatározott sorrendben kell végrehajtani.</span><span class="sxs-lookup"><span data-stu-id="45139-175">Tasks must be performed in a specific sequence.</span></span>

> <span data-ttu-id="45139-176">Néhány üzenetküldő rendszer olyan munkameneteket támogat, amelyek lehetővé teszik az előállító számára az üzenetek csoportosítását, illetve annak biztosítását, hogy mindet ugyanaz a feldolgozó kezelje.</span><span class="sxs-lookup"><span data-stu-id="45139-176">Some messaging systems support sessions that enable a producer to group messages together and ensure that they're all handled by the same consumer.</span></span> <span data-ttu-id="45139-177">Ez a mechanizmus rangsorolt üzenetek esetében alkalmazható (ha azok támogatottak) egy olyan üzenetrendezés megvalósításához, amely sorrendben továbbítja az üzeneteket az előállítótól egyetlen fogyasztónak.</span><span class="sxs-lookup"><span data-stu-id="45139-177">This mechanism can be used with prioritized messages (if they are supported) to implement a form of message ordering that delivers messages in sequence from a producer to a single consumer.</span></span>

## <a name="example"></a><span data-ttu-id="45139-178">Példa</span><span class="sxs-lookup"><span data-stu-id="45139-178">Example</span></span>

<span data-ttu-id="45139-179">Az Azure olyan tárolási üzenetsorokat és Service Bus-üzenetsorokat biztosít, amelyek a minta alkalmazásának mechanizmusaként működhetnek.</span><span class="sxs-lookup"><span data-stu-id="45139-179">Azure provides storage queues and Service Bus queues that can act as a mechanism for implementing this pattern.</span></span> <span data-ttu-id="45139-180">Az alkalmazáslogika üzeneteket küldhet az üzenetsorba, a feladatokként, egy vagy több szerepkörben megvalósított feldolgozók pedig beolvashatják az üzeneteket ebből az üzenetsorból, és feldolgozhatják azokat.</span><span class="sxs-lookup"><span data-stu-id="45139-180">The application logic can post messages to a queue, and consumers implemented as tasks in one or more roles can retrieve messages from this queue and process them.</span></span> <span data-ttu-id="45139-181">A rugalmasság érdekében a Service Bus-üzenetsor lehetővé teszi, hogy a fogyasztó a `PeekLock` módot használja, amikor üzenetet kér le az üzenetsorból.</span><span class="sxs-lookup"><span data-stu-id="45139-181">For resiliency, a Service Bus queue enables a consumer to use `PeekLock` mode when it retrieves a message from the queue.</span></span> <span data-ttu-id="45139-182">Ez a mód ténylegesen nem távolítja el az üzenetet, hanem egyszerűen elrejti azt más feldolgozók elől.</span><span class="sxs-lookup"><span data-stu-id="45139-182">This mode doesn't actually remove the message, but simply hides it from other consumers.</span></span> <span data-ttu-id="45139-183">Az eredeti feldolgozó törölheti az üzenetet, amikor már végzett a feldolgozásával.</span><span class="sxs-lookup"><span data-stu-id="45139-183">The original consumer can delete the message when it's finished processing it.</span></span> <span data-ttu-id="45139-184">Ha a feldolgozó nem jár sikerrel, a betekintési zárolás időtúllépést okoz, és az üzenet újra láthatóvá válik, így egy másik feldolgozó is lekérheti azt.</span><span class="sxs-lookup"><span data-stu-id="45139-184">If the consumer fails, the peek lock will time out and the message will become visible again, allowing another consumer to retrieve it.</span></span>

<span data-ttu-id="45139-185">Az Azure Service Bus-üzenetsorok használatával kapcsolatos részletes információkért lásd: [Service Bus-üzenetsorok, témakörök és előfizetések](https://msdn.microsoft.com/library/windowsazure/hh367516.aspx).</span><span class="sxs-lookup"><span data-stu-id="45139-185">For detailed information on using Azure Service Bus queues, see [Service Bus queues, topics, and subscriptions](https://msdn.microsoft.com/library/windowsazure/hh367516.aspx).</span></span>

<span data-ttu-id="45139-186">Az Azure tárolási üzenetsorok használatával kapcsolatos információkért lásd: [Az Azure Queue Storage használatának első lépései a .NET-keretrendszerrel](/azure/storage/queues/storage-dotnet-how-to-use-queues).</span><span class="sxs-lookup"><span data-stu-id="45139-186">For information on using Azure storage queues, see [Get started with Azure Queue storage using .NET](/azure/storage/queues/storage-dotnet-how-to-use-queues).</span></span>

<span data-ttu-id="45139-187">A [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers)-on elérhető CompetingConsumers megoldás `QueueManager` osztályából származó alábbi kód bemutatja, hogyan hozható létre egy `QueueClient`-példány a `Start` eseménykezelővel egy webes vagy feldolgozói szerepkörben.</span><span class="sxs-lookup"><span data-stu-id="45139-187">The following code from the `QueueManager` class in CompetingConsumers solution available on [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers) shows how you can create a queue by using a `QueueClient` instance in the `Start` event handler in a web or worker role.</span></span>

```csharp
private string queueName = ...;
private string connectionString = ...;
...

public async Task Start()
{
  // Check if the queue already exists.
  var manager = NamespaceManager.CreateFromConnectionString(this.connectionString);
  if (!manager.QueueExists(this.queueName))
  {
    var queueDescription = new QueueDescription(this.queueName);

    // Set the maximum delivery count for messages in the queue. A message
    // is automatically dead-lettered after this number of deliveries. The
    // default value for dead letter count is 10.
    queueDescription.MaxDeliveryCount = 3;

    await manager.CreateQueueAsync(queueDescription);
  }
  ...

  // Create the queue client. By default the PeekLock method is used.
  this.client = QueueClient.CreateFromConnectionString(
    this.connectionString, this.queueName);
}
```

<span data-ttu-id="45139-188">A következő kódrészletet bemutatja, hogy egy alkalmazás hogyan hozhat létre és küldhet el egy üzenetköteget az üzenetsorba.</span><span class="sxs-lookup"><span data-stu-id="45139-188">The next code snippet shows how an application can create and send a batch of messages to the queue.</span></span>

```csharp
public async Task SendMessagesAsync()
{
  // Simulate sending a batch of messages to the queue.
  var messages = new List<BrokeredMessage>();

  for (int i = 0; i < 10; i++)
  {
    var message = new BrokeredMessage() { MessageId = Guid.NewGuid().ToString() };
    messages.Add(message);
  }
  await this.client.SendBatchAsync(messages);
}
```

<span data-ttu-id="45139-189">A következő kód bemutatja, hogy egy feldolgozói szolgáltatáspéldány hogyan fogadhat üzeneteket az üzenetsorból egy eseményvezérelt módszert követve.</span><span class="sxs-lookup"><span data-stu-id="45139-189">The following code shows how a consumer service instance can receive messages from the queue by following an event-driven approach.</span></span> <span data-ttu-id="45139-190">A `ReceiveMessages` metódus `processMessageTask` paramétere egy meghatalmazott, amely a futtatandó kódra hivatkozik egy üzenet beérkezésekor.</span><span class="sxs-lookup"><span data-stu-id="45139-190">The `processMessageTask` parameter to the `ReceiveMessages` method is a delegate that references the code to run when a message is received.</span></span> <span data-ttu-id="45139-191">Ez a kód aszinkron módon fut.</span><span class="sxs-lookup"><span data-stu-id="45139-191">This code is run asynchronously.</span></span>

```csharp
private ManualResetEvent pauseProcessingEvent;
...

public void ReceiveMessages(Func<BrokeredMessage, Task> processMessageTask)
{
  // Set up the options for the message pump.
  var options = new OnMessageOptions();

  // When AutoComplete is disabled it's necessary to manually
  // complete or abandon the messages and handle any errors.
  options.AutoComplete = false;
  options.MaxConcurrentCalls = 10;
  options.ExceptionReceived += this.OptionsOnExceptionReceived;

  // Use of the Service Bus OnMessage message pump.
  // The OnMessage method must be called once, otherwise an exception will occur.
  this.client.OnMessageAsync(
    async (msg) =>
    {
      // Will block the current thread if Stop is called.
      this.pauseProcessingEvent.WaitOne();

      // Execute processing task here.
      await processMessageTask(msg);
    },
    options);
}
...

private void OptionsOnExceptionReceived(object sender,
  ExceptionReceivedEventArgs exceptionReceivedEventArgs)
{
  ...
}
```

<span data-ttu-id="45139-192">Érdemes megjegyezni, hogy az automatikus skálázási funkciók – például azok, amelyek az Azure-ban is elérhetők – a szerepkörpéldányok indításához és leállításához is használhatók, ahogy az üzenetsor hossza ingadozik.</span><span class="sxs-lookup"><span data-stu-id="45139-192">Note that autoscaling features, such as those available in Azure, can be used to start and stop role instances as the queue length fluctuates.</span></span> <span data-ttu-id="45139-193">További információért lásd az [automatikus skálázás útmutatóját](https://msdn.microsoft.com/library/dn589774.aspx).</span><span class="sxs-lookup"><span data-stu-id="45139-193">For more information, see [Autoscaling Guidance](https://msdn.microsoft.com/library/dn589774.aspx).</span></span> <span data-ttu-id="45139-194">Emellett nincs szükség a szerepkörpéldányok és a munkavégző folyamatok közötti egy az egyhez típusú egyezés fenntartására &mdash; egyetlen szerepkörpéldány több munkavégző folyamatot is megvalósíthat.</span><span class="sxs-lookup"><span data-stu-id="45139-194">Also, it's not necessary to maintain a one-to-one correspondence between role instances and worker processes&mdash;a single role instance can implement multiple worker processes.</span></span> <span data-ttu-id="45139-195">További információkért lásd a [számításierőforrás-konszolidálási mintát](./compute-resource-consolidation.md).</span><span class="sxs-lookup"><span data-stu-id="45139-195">For more information, see [Compute Resource Consolidation pattern](./compute-resource-consolidation.md).</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="45139-196">Kapcsolódó minták és útmutatók</span><span class="sxs-lookup"><span data-stu-id="45139-196">Related patterns and guidance</span></span>

<span data-ttu-id="45139-197">Az alábbi minták és útmutatók hasznosak lehetnek a minta megvalósításakor:</span><span class="sxs-lookup"><span data-stu-id="45139-197">The following patterns and guidance might be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="45139-198">[Az aszinkron üzenetkezelés ismertetése](https://msdn.microsoft.com/library/dn589781.aspx).</span><span class="sxs-lookup"><span data-stu-id="45139-198">[Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx).</span></span> <span data-ttu-id="45139-199">Az üzenetsorok aszinkron típusú kommunikációs mechanizmusok.</span><span class="sxs-lookup"><span data-stu-id="45139-199">Message queues are an asynchronous communications mechanism.</span></span> <span data-ttu-id="45139-200">Ha a feldolgozói szolgáltatásnak választ kell küldenie egy alkalmazásnak, szükség lehet valamilyen válaszüzenet-küldés alkalmazására.</span><span class="sxs-lookup"><span data-stu-id="45139-200">If a consumer service needs to send a reply to an application, it might be necessary to implement some form of response messaging.</span></span> <span data-ttu-id="45139-201">Az aszinkron üzenetkezelés ismertetése információkat nyújt a kérelem/válasz típusú üzenetküldés üzenetsorok használatával történő megvalósításával kapcsolatban.</span><span class="sxs-lookup"><span data-stu-id="45139-201">The Asynchronous Messaging Primer provides information on how to implement request/reply messaging using message queues.</span></span>

- <span data-ttu-id="45139-202">[Útmutató az automatikus skálázáshoz](https://msdn.microsoft.com/library/dn589774.aspx).</span><span class="sxs-lookup"><span data-stu-id="45139-202">[Autoscaling Guidance](https://msdn.microsoft.com/library/dn589774.aspx).</span></span> <span data-ttu-id="45139-203">Egy feldolgozói szolgáltatás példányait el lehet indítani és le lehet állítani, mivel azon üzenetsorok hossza, amelyekre az alkalmazások üzeneteket küldenek, változó.</span><span class="sxs-lookup"><span data-stu-id="45139-203">It might be possible to start and stop instances of a consumer service since the length of the queue applications post messages on varies.</span></span> <span data-ttu-id="45139-204">Az automatikus skálázás segítségével az átviteli sebesség szinten tartható a feldolgozási csúcsidőszakban.</span><span class="sxs-lookup"><span data-stu-id="45139-204">Autoscaling can help to maintain throughput during times of peak processing.</span></span>

- <span data-ttu-id="45139-205">[Számításierőforrás-konszolidálási minta](./compute-resource-consolidation.md).</span><span class="sxs-lookup"><span data-stu-id="45139-205">[Compute Resource Consolidation pattern](./compute-resource-consolidation.md).</span></span> <span data-ttu-id="45139-206">Egy feldolgozói szolgáltatás több példánya egyetlen folyamatba vonhatók össze a költségek és a felügyeleti terhek csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="45139-206">It might be possible to consolidate multiple instances of a consumer service into a single process to reduce costs and management overhead.</span></span> <span data-ttu-id="45139-207">A számításierőforrás-konszolidálási minta ismerteti ennek a módszernek az előnyeit és a hátrányait.</span><span class="sxs-lookup"><span data-stu-id="45139-207">The Compute Resource Consolidation pattern describes the benefits and tradeoffs of following this approach.</span></span>

- <span data-ttu-id="45139-208">[Üzenetsor-alapú terheléskiegyenlítési minta](./queue-based-load-leveling.md).</span><span class="sxs-lookup"><span data-stu-id="45139-208">[Queue-based Load Leveling pattern](./queue-based-load-leveling.md).</span></span> <span data-ttu-id="45139-209">Az üzenetsor bevezetése rugalmassá teheti a rendszert, lehetővé téve, hogy a szolgáltatáspéldányok kezelni tudják alkalmazáspéldányoktól érkező, váltakozó mennyiségű kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="45139-209">Introducing a message queue can add resiliency to the system, enabling service instances to handle widely varying volumes of requests from application instances.</span></span> <span data-ttu-id="45139-210">Az üzenetsor pufferként viselkedik, ami kiegyenlíti a terhelést.</span><span class="sxs-lookup"><span data-stu-id="45139-210">The message queue acts as a buffer, which levels the load.</span></span> <span data-ttu-id="45139-211">Az üzenetsor-alapú terheléskiegyenlítési minta részletesebben is ismerteti ezt a forgatókönyvet.</span><span class="sxs-lookup"><span data-stu-id="45139-211">The Queue-based Load Leveling pattern describes this scenario in more detail.</span></span>

- <span data-ttu-id="45139-212">Ehhez a mintához egy [mintaalkalmazás](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers) is tartozik.</span><span class="sxs-lookup"><span data-stu-id="45139-212">This pattern has a [sample application](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers) associated with it.</span></span>
