---
title: "Versengő fogyasztó számára"
description: "Engedélyezze a több egyidejű fogyasztók ugyanazt a üzenetkezelési csatornát a Beérkezett üzenetek feldolgozásához."
keywords: "Kialakítási mintája"
author: dragon119
ms.date: 06/23/2017
pnp.series.title: Cloud Design Patterns
pnp.pattern.categories: messaging
ms.openlocfilehash: d72a09ef7613bebe3701634e4eac0716400e471d
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 11/14/2017
---
# <a name="competing-consumers-pattern"></a><span data-ttu-id="3b697-104">Versengő fogyasztók minta</span><span class="sxs-lookup"><span data-stu-id="3b697-104">Competing Consumers pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="3b697-105">Engedélyezze a több egyidejű fogyasztók ugyanazt a üzenetkezelési csatornát a Beérkezett üzenetek feldolgozásához.</span><span class="sxs-lookup"><span data-stu-id="3b697-105">Enable multiple concurrent consumers to process messages received on the same messaging channel.</span></span> <span data-ttu-id="3b697-106">Ez lehetővé teszi, hogy a rendszer több üzenetek egyidejűleg a teljesítmény, méretezhetőség és a rendelkezésre állás javítása érdekében, és a terhelés elosztása érdekében optimalizálása érdekében.</span><span class="sxs-lookup"><span data-stu-id="3b697-106">This enables a system to process multiple messages concurrently to optimize throughput, to improve scalability and availability, and to balance the workload.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="3b697-107">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="3b697-107">Context and problem</span></span>

<span data-ttu-id="3b697-108">A felhőben futó alkalmazáshoz várhatóan sok kérelmek kezeléséhez.</span><span class="sxs-lookup"><span data-stu-id="3b697-108">An application running in the cloud is expected to handle a large number of requests.</span></span> <span data-ttu-id="3b697-109">Helyett az egyes kérelmek szinkron módon feldolgozni, egy általános módszer van, az alkalmazás egy üzenetkezelési rendszerek őket átadása egy másik (egy fogyasztó) szolgáltatást, amely aszinkron módon kezeli őket.</span><span class="sxs-lookup"><span data-stu-id="3b697-109">Rather than process each request synchronously, a common technique is for the application to pass them through a messaging system to another service (a consumer service) that handles them asynchronously.</span></span> <span data-ttu-id="3b697-110">Ez a stratégia segít annak érdekében, hogy az üzleti logika, az alkalmazás nem blokkolja-e a kérelem feldolgozása során.</span><span class="sxs-lookup"><span data-stu-id="3b697-110">This strategy helps to ensure that the business logic in the application isn't blocked while the requests are being processed.</span></span>

<span data-ttu-id="3b697-111">Kérelmek száma az idők során számos oka nagymértékben változhat.</span><span class="sxs-lookup"><span data-stu-id="3b697-111">The number of requests can vary significantly over time for many reasons.</span></span> <span data-ttu-id="3b697-112">Váratlan növekedését riasztásviharnak felhasználói tevékenység vagy több bérlő érkező összesített kérelmek egy előre nem látható munkaterhelés okozhat.</span><span class="sxs-lookup"><span data-stu-id="3b697-112">A sudden increase in user activity or aggregated requests coming from multiple tenants can cause an unpredictable workload.</span></span> <span data-ttu-id="3b697-113">Csúcsidőszakon, a rendszer módosítania kell feldolgozni a több száz kérelmek / másodperc, amíg a többi időszakban a szám nagyon kis lehet.</span><span class="sxs-lookup"><span data-stu-id="3b697-113">At peak hours a system might need to process many hundreds of requests per second, while at other times the number could be very small.</span></span> <span data-ttu-id="3b697-114">Ezenkívül ezek a kérelmek kezelésére végzett munka jellege magas változó lehet.</span><span class="sxs-lookup"><span data-stu-id="3b697-114">Additionally, the nature of the work performed to handle these requests might be highly variable.</span></span> <span data-ttu-id="3b697-115">A fogyasztó szolgáltatás egyetlen példányát használja okozhat azt válnak árasztott kérések a példányt, vagy a levelezőrendszerrel túlterheltek egy beérkezése az alkalmazáshoz érkező üzenetek által.</span><span class="sxs-lookup"><span data-stu-id="3b697-115">Using a single instance of the consumer service can cause that instance to become flooded with requests, or the messaging system might be overloaded by an influx of messages coming from the application.</span></span> <span data-ttu-id="3b697-116">Változó munkaterhelés kezeléséhez, a rendszer több példánya is futtatható a fogyasztói szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="3b697-116">To handle this fluctuating workload, the system can run multiple instances of the consumer service.</span></span> <span data-ttu-id="3b697-117">A fogyasztók számára, össze kell hangolni győződjön meg arról, hogy minden üzenetet csak a rendszer egy-egy fogyasztó számára.</span><span class="sxs-lookup"><span data-stu-id="3b697-117">However, these consumers must be coordinated to ensure that each message is only delivered to a single consumer.</span></span> <span data-ttu-id="3b697-118">A munkaterhelés kell szerepelnie terhelésű megakadályozhatja, hogy a példány a szűk keresztmetszetek váljon a felhasználók között.</span><span class="sxs-lookup"><span data-stu-id="3b697-118">The workload also needs to be load balanced across consumers to prevent an instance from becoming a bottleneck.</span></span>

## <a name="solution"></a><span data-ttu-id="3b697-119">Megoldás</span><span class="sxs-lookup"><span data-stu-id="3b697-119">Solution</span></span>

<span data-ttu-id="3b697-120">Az üzenet-várólista segítségével valósítja meg az alkalmazás és a fogyasztói szolgáltatás példányainak közötti kommunikációs csatornát.</span><span class="sxs-lookup"><span data-stu-id="3b697-120">Use a message queue to implement the communication channel between the application and the instances of the consumer service.</span></span> <span data-ttu-id="3b697-121">Az alkalmazás által a várólista-üzenetek formájában kéréseket, és a fogyasztói szolgáltatáspéldány üzenetek fogadása az üzenetsorból, és dolgozza fel őket.</span><span class="sxs-lookup"><span data-stu-id="3b697-121">The application posts requests in the form of messages to the queue, and the consumer service instances receive messages from the queue and process them.</span></span> <span data-ttu-id="3b697-122">Ez a megközelítés lehetővé teszi, hogy a fogyasztói szolgáltatáspéldány kezelni az alkalmazás összes példányát üzeneteit azonos erőforráskészletben.</span><span class="sxs-lookup"><span data-stu-id="3b697-122">This approach enables the same pool of consumer service instances to handle messages from any instance of the application.</span></span> <span data-ttu-id="3b697-123">Az ábra azt mutatja be, egy üzenet-várólista segítségével kiosztani a munkát egy szolgáltatás példányának.</span><span class="sxs-lookup"><span data-stu-id="3b697-123">The figure illustrates using a message queue to distribute work to instances of a service.</span></span>

![Üzenet-várólista használata egy szolgáltatás példányának munkát terjesztése](./_images/competing-consumers-diagram.png)

<span data-ttu-id="3b697-125">Ez a megoldás rendelkezik a következő előnyöket biztosítja:</span><span class="sxs-lookup"><span data-stu-id="3b697-125">This solution has the following benefits:</span></span>

- <span data-ttu-id="3b697-126">A betöltési simítva rendszer, amelyet kezelni tud a nagy mennyiségű kérést alkalmazáspéldányok által küldött szórás biztosít.</span><span class="sxs-lookup"><span data-stu-id="3b697-126">It provides a load-leveled system that can handle wide variations in the volume of requests sent by application instances.</span></span> <span data-ttu-id="3b697-127">A várólista pufferként a az alkalmazáspéldányok és a fogyasztói szolgáltatáspéldányok között.</span><span class="sxs-lookup"><span data-stu-id="3b697-127">The queue acts as a buffer between the application instances and the consumer service instances.</span></span> <span data-ttu-id="3b697-128">Ez segít a rendelkezésre állási és az alkalmazás és a szolgáltatáspéldány reakcióidőt gyakorolt hatás minimalizálása érdekében, szerint a [terhelés simítás várólista alapú mintát](queue-based-load-leveling.md).</span><span class="sxs-lookup"><span data-stu-id="3b697-128">This can help to minimize the impact on availability and responsiveness for both the application and the service instances, as described by the [Queue-based Load Leveling pattern](queue-based-load-leveling.md).</span></span> <span data-ttu-id="3b697-129">Egy üzenet egyes hosszan futó feldolgozási nem akadályozza más üzenetek egyidejűleg más esetekben a fogyasztói szolgáltatás által kezelt igénylő kezelése.</span><span class="sxs-lookup"><span data-stu-id="3b697-129">Handling a message that requires some long-running processing doesn't prevent other messages from being handled concurrently by other instances of the consumer service.</span></span>

- <span data-ttu-id="3b697-130">Ez növeli a megbízhatóságot.</span><span class="sxs-lookup"><span data-stu-id="3b697-130">It improves reliability.</span></span> <span data-ttu-id="3b697-131">Ha termelő közvetlenül kommunikál a fogyasztó helyett ezt a mintát használja, de nem figyelheti a fogyasztónak, akkor nagy valószínűséggel, hogy a üzenetek veszni sikerült-e vagy nem dolgozható fel, ha a fogyasztó nem sikerült.</span><span class="sxs-lookup"><span data-stu-id="3b697-131">If a producer communicates directly with a consumer instead of using this pattern, but doesn't monitor the consumer, there's a high probability that messages could be lost or fail to be processed if the consumer fails.</span></span> <span data-ttu-id="3b697-132">Ebben a mintában üzeneteket a megadott példánya nem küldeni.</span><span class="sxs-lookup"><span data-stu-id="3b697-132">In this pattern, messages aren't sent to a specific service instance.</span></span> <span data-ttu-id="3b697-133">A sikertelen példánya nem blokkolja a gyártó, és bármely működő szolgáltatáspéldány feldolgozható üzenetek.</span><span class="sxs-lookup"><span data-stu-id="3b697-133">A failed service instance won't block a producer, and messages can be processed by any working service instance.</span></span>

- <span data-ttu-id="3b697-134">Összetett koordinációs felhasználói között, vagy a gyártót és a felhasználói példányok nem igényel.</span><span class="sxs-lookup"><span data-stu-id="3b697-134">It doesn't require complex coordination between the consumers, or between the producer and the consumer instances.</span></span> <span data-ttu-id="3b697-135">Az üzenet-várólista biztosítja, hogy minden üzenet legalább egyszer kerül.</span><span class="sxs-lookup"><span data-stu-id="3b697-135">The message queue ensures that each message is delivered at least once.</span></span>

- <span data-ttu-id="3b697-136">Is méretezhető.</span><span class="sxs-lookup"><span data-stu-id="3b697-136">It's scalable.</span></span> <span data-ttu-id="3b697-137">A rendszer dinamikusan növelheti vagy csökkentheti a fogyasztói szolgáltatás példányainak száma, az üzenetek a kötet ingadozik.</span><span class="sxs-lookup"><span data-stu-id="3b697-137">The system can dynamically increase or decrease the number of instances of the consumer service as the volume of messages fluctuates.</span></span>

- <span data-ttu-id="3b697-138">Rugalmasság azt javítható, ha az üzenet-várólista tranzakciós olvasási műveletek biztosít.</span><span class="sxs-lookup"><span data-stu-id="3b697-138">It can improve resiliency if the message queue provides transactional read operations.</span></span> <span data-ttu-id="3b697-139">Ha a fogyasztó példánya olvas, és feldolgozza az üzenetet egy tranzakciós művelet részeként, és a fogyasztói szolgáltatáspéldány meghibásodik, ebben a mintában bizonyosodjon meg arról, hogy az üzenet vissza a várólistában, felvenni, és egy másik példánya kezeli a ügyfélszolgálat.</span><span class="sxs-lookup"><span data-stu-id="3b697-139">If a consumer service instance reads and processes the message as part of a transactional operation, and the consumer service instance fails, this pattern can ensure that the message will be returned to the queue to be picked up and handled by another instance of the consumer service.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="3b697-140">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="3b697-140">Issues and considerations</span></span>

<span data-ttu-id="3b697-141">Ebben a mintában megvalósításához meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="3b697-141">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="3b697-142">**Üzenet rendelési**.</span><span class="sxs-lookup"><span data-stu-id="3b697-142">**Message ordering**.</span></span> <span data-ttu-id="3b697-143">A sorrendet, amelyben a fogyasztó szolgáltatáspéldány üzeneteket fogadni, nem garantált, és nem tükrözi a sorrendben, ahol az üzenetek hozta létre.</span><span class="sxs-lookup"><span data-stu-id="3b697-143">The order in which consumer service instances receive messages isn't guaranteed, and doesn't necessarily reflect the order in which the messages were created.</span></span> <span data-ttu-id="3b697-144">Tervezze meg a rendszer annak érdekében, hogy az üzenet feldolgozása-e az idempotent, mert ez hozzájárul a sorrendet, amelyben üzenetek kezelésének bármely függőség megszüntetéséhez.</span><span class="sxs-lookup"><span data-stu-id="3b697-144">Design the system to ensure that message processing is idempotent because this will help to eliminate any dependency on the order in which messages are handled.</span></span> <span data-ttu-id="3b697-145">További információkért lásd: [idempotencia minták](http://blog.jonathanoliver.com/idempotency-patterns/) Jonathon Oliver blogjában.</span><span class="sxs-lookup"><span data-stu-id="3b697-145">For more information, see [Idempotency Patterns](http://blog.jonathanoliver.com/idempotency-patterns/) on Jonathon Oliver’s blog.</span></span>

    > <span data-ttu-id="3b697-146">A Microsoft Azure Service Bus-üzenetsorok garantált első-first out rendelési üzenetek üzenet munkamenetek használatával is létrehozható.</span><span class="sxs-lookup"><span data-stu-id="3b697-146">Microsoft Azure Service Bus Queues can implement guaranteed first-in-first-out ordering of messages by using message sessions.</span></span> <span data-ttu-id="3b697-147">További információkért lásd: [minták használatával munkamenetek üzenetküldési](https://msdn.microsoft.com/magazine/jj863132.aspx).</span><span class="sxs-lookup"><span data-stu-id="3b697-147">For more information, see [Messaging Patterns Using Sessions](https://msdn.microsoft.com/magazine/jj863132.aspx).</span></span>

- <span data-ttu-id="3b697-148">**A rugalmasságot szolgáltatások tervezése**.</span><span class="sxs-lookup"><span data-stu-id="3b697-148">**Designing services for resiliency**.</span></span> <span data-ttu-id="3b697-149">Ha a rendszer célja, hogy észleli, és indítsa újra a sikertelen szolgáltatáspéldány, lehet, végre kell hajtani a szolgáltatáspéldány végzi el az idempotent műveletként, ha csökkenteni szeretné a lekérését és feldolgozott több különálló üzenet feldolgozása egynél többször.</span><span class="sxs-lookup"><span data-stu-id="3b697-149">If the system is designed to detect and restart failed service instances, it might be necessary to implement the processing performed by the service instances as idempotent operations to minimize the effects of a single message being retrieved and processed more than once.</span></span>

- <span data-ttu-id="3b697-150">**Az elhalt üzenetek észlelésére**.</span><span class="sxs-lookup"><span data-stu-id="3b697-150">**Detecting poison messages**.</span></span> <span data-ttu-id="3b697-151">Egy helytelenül formázott üzenetet, vagy erőforrásokat, amelyek nem érhetők el, a hozzáférést igénylő okozhat a szolgáltatáspéldány sikertelen lesz.</span><span class="sxs-lookup"><span data-stu-id="3b697-151">A malformed message, or a task that requires access to resources that aren't available, can cause a service instance to fail.</span></span> <span data-ttu-id="3b697-152">A rendszer kell megakadályozza az ilyen üzeneteket ad vissza a várólistára, és helyette, majd tárolhatja ezeket az üzeneteket részleteit máshol, hogy az elemzett szükség esetén.</span><span class="sxs-lookup"><span data-stu-id="3b697-152">The system should prevent such messages being returned to the queue, and instead capture and store the details of these messages elsewhere so that they can be analyzed if necessary.</span></span>

- <span data-ttu-id="3b697-153">**Eredmények kezelése**.</span><span class="sxs-lookup"><span data-stu-id="3b697-153">**Handling results**.</span></span> <span data-ttu-id="3b697-154">A szolgáltatáspéldány, egy üzenet kezelése teljes mértékben a rendszer leválasztja az alkalmazáslogikát, amely létrehozza az üzenetet, és előfordulhat, hogy nem tudnak közvetlenül kommunikálnak.</span><span class="sxs-lookup"><span data-stu-id="3b697-154">The service instance handling a message is fully decoupled from the application logic that generates the message, and they might not be able to communicate directly.</span></span> <span data-ttu-id="3b697-155">A szolgáltatáspéldány eredmények, amelyek kell átadni vissza az alkalmazáslogikát állít elő, ha ezeket az információkat egyaránt elérhető helyen kell tárolni.</span><span class="sxs-lookup"><span data-stu-id="3b697-155">If the service instance generates results that must be passed back to the application logic, this information must be stored in a location that's accessible to both.</span></span> <span data-ttu-id="3b697-156">Leállítja, nehogy a úgy az alkalmazáslogikát lekérése során a rendszer tartalmaznia kell feldolgozásakor nem teljes adatokat befejeződött.</span><span class="sxs-lookup"><span data-stu-id="3b697-156">In order to prevent the application logic from retrieving incomplete data the system must indicate when processing is complete.</span></span>

     > <span data-ttu-id="3b697-157">Azure használata, ha egy munkavégző folyamat képes továbbadni eredmények vissza az alkalmazáslogikát egy dedikált üzenet válasz várólista használatával.</span><span class="sxs-lookup"><span data-stu-id="3b697-157">If you're using Azure, a worker process can pass results back to the application logic by using a dedicated message reply queue.</span></span> <span data-ttu-id="3b697-158">Az alkalmazás logikáját ezekkel az eredményekkel összefüggéseket az eredeti üzenet képesnek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="3b697-158">The application logic must be able to correlate these results with the original message.</span></span> <span data-ttu-id="3b697-159">Ebben a forgatókönyvben a további részletes leírását lásd a [aszinkron üzenetkezelési ismertetése](https://msdn.microsoft.com/library/dn589781.aspx).</span><span class="sxs-lookup"><span data-stu-id="3b697-159">This scenario is described in more detail in the [Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx).</span></span>

- <span data-ttu-id="3b697-160">**Az üzenetkezelési rendszeréhez skálázás**.</span><span class="sxs-lookup"><span data-stu-id="3b697-160">**Scaling the messaging system**.</span></span> <span data-ttu-id="3b697-161">A felügyeleti teendők központjaként megoldás egyetlen üzenet-várólista sikerült kell túlterhelik, az üzenetek száma és keresztmetszetet jelenthet a rendszerben.</span><span class="sxs-lookup"><span data-stu-id="3b697-161">In a large-scale solution, a single message queue could be overwhelmed by the number of messages and become a bottleneck in the system.</span></span> <span data-ttu-id="3b697-162">Ebben a helyzetben vegye figyelembe, az üzenetkezelési rendszeréhez adott gyártók üzeneteket küldeni egy adott várólistában particionálás, vagy a terheléselosztás segítségével több üzenetsorok üzenetek szét.</span><span class="sxs-lookup"><span data-stu-id="3b697-162">In this situation, consider partitioning the messaging system to send messages from specific producers to a particular queue, or use load balancing to distribute messages across multiple message queues.</span></span>

- <span data-ttu-id="3b697-163">**Az üzenetkezelési rendszeréhez megbízhatóságának biztosítása**.</span><span class="sxs-lookup"><span data-stu-id="3b697-163">**Ensuring reliability of the messaging system**.</span></span> <span data-ttu-id="3b697-164">Egy megbízható üzenetkezelési rendszeréhez, hogy az alkalmazás enqueues után egy üzenetet, nem lesz elveszett biztosításához van szükség.</span><span class="sxs-lookup"><span data-stu-id="3b697-164">A reliable messaging system is needed to guarantee that after the application enqueues a message it won't be lost.</span></span> <span data-ttu-id="3b697-165">Ez elengedhetetlen ahhoz, hogy minden üzenet legalább egyszer érkeznek.</span><span class="sxs-lookup"><span data-stu-id="3b697-165">This is essential for ensuring that all messages are delivered at least once.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="3b697-166">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="3b697-166">When to use this pattern</span></span>

<span data-ttu-id="3b697-167">Ez mintát, mikor használja:</span><span class="sxs-lookup"><span data-stu-id="3b697-167">Use this pattern when:</span></span>

- <span data-ttu-id="3b697-168">Az alkalmazás a munkaterhelés aszinkron módon futtatható tevékenységek van osztva.</span><span class="sxs-lookup"><span data-stu-id="3b697-168">The workload for an application is divided into tasks that can run asynchronously.</span></span>
- <span data-ttu-id="3b697-169">Feladatok független, és párhuzamosan futtatható.</span><span class="sxs-lookup"><span data-stu-id="3b697-169">Tasks are independent and can run in parallel.</span></span>
- <span data-ttu-id="3b697-170">A munka mennyiségét magas változó, méretezhető megoldást igénylő.</span><span class="sxs-lookup"><span data-stu-id="3b697-170">The volume of work is highly variable, requiring a scalable solution.</span></span>
- <span data-ttu-id="3b697-171">A megoldás magas rendelkezésre állást biztosítani kell, és rugalmas, ha egy tevékenység feldolgozása sikertelen lehet.</span><span class="sxs-lookup"><span data-stu-id="3b697-171">The solution must provide high availability, and must be resilient if the processing for a task fails.</span></span>

<span data-ttu-id="3b697-172">Ebben a mintában előfordulhat, hogy nem lehet hasznos:</span><span class="sxs-lookup"><span data-stu-id="3b697-172">This pattern might not be useful when:</span></span>

- <span data-ttu-id="3b697-173">Nincs könnyen az alkalmazás munkaterhelést diszkrét feladatok külön, vagy nincs a tevékenységek közötti függőség magas fokú.</span><span class="sxs-lookup"><span data-stu-id="3b697-173">It's not easy to separate the application workload into discrete tasks, or there's a high degree of dependence between tasks.</span></span>
- <span data-ttu-id="3b697-174">Feladatok szinkron módon hajtható végre, és az alkalmazás logikáját kell várnia, hogy a feladat befejeződését.</span><span class="sxs-lookup"><span data-stu-id="3b697-174">Tasks must be performed synchronously, and the application logic must wait for a task to complete before continuing.</span></span>
- <span data-ttu-id="3b697-175">Feladatok meghatározott sorrendben kell végrehajtani.</span><span class="sxs-lookup"><span data-stu-id="3b697-175">Tasks must be performed in a specific sequence.</span></span>

> <span data-ttu-id="3b697-176">Néhány üzenetküldő rendszereket használnak a termelő üzenetek engedélyezése együtt, és győződjön meg arról, hogy azok még lehet kezelni az azonos ügyfél munkameneteket támogatják.</span><span class="sxs-lookup"><span data-stu-id="3b697-176">Some messaging systems support sessions that enable a producer to group messages together and ensure that they're all handled by the same consumer.</span></span> <span data-ttu-id="3b697-177">A mechanizmus segítségével rangsorolt üzeneteket (ha azok támogatottak) üzenet, amely továbbítja üzenetek sorozatban a gyártó egy-egy fogyasztó rendelési űrlap megvalósítása.</span><span class="sxs-lookup"><span data-stu-id="3b697-177">This mechanism can be used with prioritized messages (if they are supported) to implement a form of message ordering that delivers messages in sequence from a producer to a single consumer.</span></span>

## <a name="example"></a><span data-ttu-id="3b697-178">Példa</span><span class="sxs-lookup"><span data-stu-id="3b697-178">Example</span></span>

<span data-ttu-id="3b697-179">Azure storage várólisták és működhet-ben Ez a kialakítás megvalósítása a Service Bus-üzenetsorok biztosít.</span><span class="sxs-lookup"><span data-stu-id="3b697-179">Azure provides storage queues and Service Bus queues that can act as a mechanism for implementing this pattern.</span></span> <span data-ttu-id="3b697-180">Az alkalmazás logikáját beküldheti üzenetsorokba, és egy vagy több szerepkört a tevékenységként megvalósított fogyasztók üzeneteket beolvasni ebből a várólistából, és dolgozza fel őket.</span><span class="sxs-lookup"><span data-stu-id="3b697-180">The application logic can post messages to a queue, and consumers implemented as tasks in one or more roles can retrieve messages from this queue and process them.</span></span> <span data-ttu-id="3b697-181">Rugalmasság, a Service Bus-üzenetsorba lehetővé teszi, hogy egy felhasználó számára `PeekLock` módra, amikor lekérdezi a üzenetet az üzenetsorból.</span><span class="sxs-lookup"><span data-stu-id="3b697-181">For resiliency, a Service Bus queue enables a consumer to use `PeekLock` mode when it retrieves a message from the queue.</span></span> <span data-ttu-id="3b697-182">Ebben a módban ténylegesen nem távolítja az üzenetet, de egyszerűen elrejti a más fogyasztók.</span><span class="sxs-lookup"><span data-stu-id="3b697-182">This mode doesn't actually remove the message, but simply hides it from other consumers.</span></span> <span data-ttu-id="3b697-183">Az eredeti felhasználó törölheti az üzenet feldolgozása után.</span><span class="sxs-lookup"><span data-stu-id="3b697-183">The original consumer can delete the message when it's finished processing it.</span></span> <span data-ttu-id="3b697-184">Ha a fogyasztó nem sikerül, a betekintés zárolási időtúllépést okoz, és az üzenet újra láthatóvá válnak, így egy másik fogyasztó ennek lekéréséhez.</span><span class="sxs-lookup"><span data-stu-id="3b697-184">If the consumer fails, the peek lock will time out and the message will become visible again, allowing another consumer to retrieve it.</span></span>

> <span data-ttu-id="3b697-185">Azure Service Bus-üzenetsorok használatával kapcsolatos részletes információkért lásd: [Service Bus-üzenetsorok, témakörök és előfizetések](https://msdn.microsoft.com/library/windowsazure/hh367516.aspx).</span><span class="sxs-lookup"><span data-stu-id="3b697-185">For detailed information on using Azure Service Bus queues, see [Service Bus queues, topics, and subscriptions](https://msdn.microsoft.com/library/windowsazure/hh367516.aspx).</span></span>
<span data-ttu-id="3b697-186">Azure tárolási sorok használatával kapcsolatos információkért lásd: [Ismerkedés az Azure Queue storage használatának .NET](https://azure.microsoft.com/documentation/articles/storage-dotnet-how-to-use-queues/).</span><span class="sxs-lookup"><span data-stu-id="3b697-186">For information on using Azure storage queues, see [Get started with Azure Queue storage using .NET](https://azure.microsoft.com/documentation/articles/storage-dotnet-how-to-use-queues/).</span></span>

<span data-ttu-id="3b697-187">A következő kódot a a `QueueManager` osztály CompetingConsumers megoldás elérhető a [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers) bemutatja, hogyan hozhat létre egy üzenetsort használatával egy `QueueClient` a példányt a `Start` eseménykezelő egy webes vagy feldolgozói szerepkörben.</span><span class="sxs-lookup"><span data-stu-id="3b697-187">The following code from the `QueueManager` class in CompetingConsumers solution available on [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers) shows how you can create a queue by using a `QueueClient` instance in the `Start` event handler in a web or worker role.</span></span>

```csharp
private string queueName = ...;
private string connectionString = ...;
...

public async Task Start()
{
  // Check if the queue already exists.
  var manager = NamespaceManager.CreateFromConnectionString(this.connectionString);
  if (!manager.QueueExists(this.queueName))
  {
    var queueDescription = new QueueDescription(this.queueName);

    // Set the maximum delivery count for messages in the queue. A message
    // is automatically dead-lettered after this number of deliveries. The
    // default value for dead letter count is 10.
    queueDescription.MaxDeliveryCount = 3;

    await manager.CreateQueueAsync(queueDescription);
  }
  ...

  // Create the queue client. By default the PeekLock method is used.
  this.client = QueueClient.CreateFromConnectionString(
    this.connectionString, this.queueName);
}
```

<span data-ttu-id="3b697-188">A következő kódrészletet bemutatja, hogyan az alkalmazások létrehozása és az üzenetkötegek küldése az üzenetsorba.</span><span class="sxs-lookup"><span data-stu-id="3b697-188">The next code snippet shows how an application can create and send a batch of messages to the queue.</span></span>

```csharp
public async Task SendMessagesAsync()
{
  // Simulate sending a batch of messages to the queue.
  var messages = new List<BrokeredMessage>();

  for (int i = 0; i < 10; i++)
  {
    var message = new BrokeredMessage() { MessageId = Guid.NewGuid().ToString() };
    messages.Add(message);
  }
  await this.client.SendBatchAsync(messages);
}
```

<span data-ttu-id="3b697-189">A következő kód bemutatja, hogyan egy fogyasztói szolgáltatáspéldány is üzenetek fogadása az üzenetsorból egy eseményvezérelt módszert követve.</span><span class="sxs-lookup"><span data-stu-id="3b697-189">The following code shows how a consumer service instance can receive messages from the queue by following an event-driven approach.</span></span> <span data-ttu-id="3b697-190">A `processMessageTask` paramétert a `ReceiveMessages` metódust egy delegált fut egy üzenet jelenik meg, amikor a kód hivatkozó.</span><span class="sxs-lookup"><span data-stu-id="3b697-190">The `processMessageTask` parameter to the `ReceiveMessages` method is a delegate that references the code to run when a message is received.</span></span> <span data-ttu-id="3b697-191">Ez a kód aszinkron fut.</span><span class="sxs-lookup"><span data-stu-id="3b697-191">This code is run asynchronously.</span></span>

```csharp
private ManualResetEvent pauseProcessingEvent;
...

public void ReceiveMessages(Func<BrokeredMessage, Task> processMessageTask)
{
  // Set up the options for the message pump.
  var options = new OnMessageOptions();

  // When AutoComplete is disabled it's necessary to manually
  // complete or abandon the messages and handle any errors.
  options.AutoComplete = false;
  options.MaxConcurrentCalls = 10;
  options.ExceptionReceived += this.OptionsOnExceptionReceived;

  // Use of the Service Bus OnMessage message pump.
  // The OnMessage method must be called once, otherwise an exception will occur.
  this.client.OnMessageAsync(
    async (msg) =>
    {
      // Will block the current thread if Stop is called.
      this.pauseProcessingEvent.WaitOne();

      // Execute processing task here.
      await processMessageTask(msg);
    },
    options);
}
...

private void OptionsOnExceptionReceived(object sender,
  ExceptionReceivedEventArgs exceptionReceivedEventArgs)
{
  ...
}
```

<span data-ttu-id="3b697-192">Vegye figyelembe, hogy használható-e automatikus skálázás funkciók, például az Azure-ban elérhető indítása és leállítása szerepkörpéldányt beállítani, mert a várólista hossza ingadozik.</span><span class="sxs-lookup"><span data-stu-id="3b697-192">Note that autoscaling features, such as those available in Azure, can be used to start and stop role instances as the queue length fluctuates.</span></span> <span data-ttu-id="3b697-193">További információkért lásd: [automatikus skálázás útmutatást](https://msdn.microsoft.com/library/dn589774.aspx).</span><span class="sxs-lookup"><span data-stu-id="3b697-193">For more information, see [Autoscaling Guidance](https://msdn.microsoft.com/library/dn589774.aspx).</span></span> <span data-ttu-id="3b697-194">Emellett nincs szükség a szerepkörpéldányok és a munkavégző folyamatok közötti egy az egyhez típusú egyezés karbantartása&mdash;egyetlen szerepkörpéldányt megvalósítható a több munkavégző folyamatot.</span><span class="sxs-lookup"><span data-stu-id="3b697-194">Also, it's not necessary to maintain a one-to-one correspondence between role instances and worker processes&mdash;a single role instance can implement multiple worker processes.</span></span> <span data-ttu-id="3b697-195">További információkért lásd: [számítási erőforrás-összevonási mintát](compute-resource-consolidation.md).</span><span class="sxs-lookup"><span data-stu-id="3b697-195">For more information, see [Compute Resource Consolidation pattern](compute-resource-consolidation.md).</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="3b697-196">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="3b697-196">Related patterns and guidance</span></span>

<span data-ttu-id="3b697-197">A következő mintákat és útmutatókat előfordulhat, hogy használható legyen ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="3b697-197">The following patterns and guidance might be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="3b697-198">[Aszinkron üzenetkezelési ismertetése](https://msdn.microsoft.com/library/dn589781.aspx).</span><span class="sxs-lookup"><span data-stu-id="3b697-198">[Asynchronous Messaging Primer](https://msdn.microsoft.com/library/dn589781.aspx).</span></span> <span data-ttu-id="3b697-199">Üzenet-várólistákból egy aszinkron kommunikációs mechanizmus.</span><span class="sxs-lookup"><span data-stu-id="3b697-199">Message queues are an asynchronous communications mechanism.</span></span> <span data-ttu-id="3b697-200">Ha a fogyasztó szolgáltatásnak kell egy alkalmazás válaszol, valamilyen válasz üzenetküldési végrehajtásához szükség lehet.</span><span class="sxs-lookup"><span data-stu-id="3b697-200">If a consumer service needs to send a reply to an application, it might be necessary to implement some form of response messaging.</span></span> <span data-ttu-id="3b697-201">Az aszinkron üzenetkezelési ismertetése információkat nyújt a kérelem/válasz üzenetküldési használatával megvalósításához üzenet-várólistákat.</span><span class="sxs-lookup"><span data-stu-id="3b697-201">The Asynchronous Messaging Primer provides information on how to implement request/reply messaging using message queues.</span></span>

- <span data-ttu-id="3b697-202">[Automatikus skálázás útmutatást](https://msdn.microsoft.com/library/dn589774.aspx).</span><span class="sxs-lookup"><span data-stu-id="3b697-202">[Autoscaling Guidance](https://msdn.microsoft.com/library/dn589774.aspx).</span></span> <span data-ttu-id="3b697-203">Esetleg indítása és leállítása egy fogyasztói szolgáltatás példányának óta a feladás egy vagy több üzeneteket változik várólista alkalmazások hosszát.</span><span class="sxs-lookup"><span data-stu-id="3b697-203">It might be possible to start and stop instances of a consumer service since the length of the queue applications post messages on varies.</span></span> <span data-ttu-id="3b697-204">Automatikus skálázás segíthet átviteli karbantartása csúcs feldolgozás esetén.</span><span class="sxs-lookup"><span data-stu-id="3b697-204">Autoscaling can help to maintain throughput during times of peak processing.</span></span>

- <span data-ttu-id="3b697-205">[Számítási erőforrás-összevonási mintát](compute-resource-consolidation.md).</span><span class="sxs-lookup"><span data-stu-id="3b697-205">[Compute Resource Consolidation Pattern](compute-resource-consolidation.md).</span></span> <span data-ttu-id="3b697-206">Esetleg vonják össze a költségek és kezelési terhelés mellett csökkentése során egyetlen fogyasztói szolgáltatás több példánya.</span><span class="sxs-lookup"><span data-stu-id="3b697-206">It might be possible to consolidate multiple instances of a consumer service into a single process to reduce costs and management overhead.</span></span> <span data-ttu-id="3b697-207">A számítási erőforrás-összevonási mintát előnyei és az ezt a módszert használja a következő mellékhatásokkal ismerteti.</span><span class="sxs-lookup"><span data-stu-id="3b697-207">The Compute Resource Consolidation pattern describes the benefits and tradeoffs of following this approach.</span></span>

- <span data-ttu-id="3b697-208">[Minta simítás várólista alapú terhelés](queue-based-load-leveling.md).</span><span class="sxs-lookup"><span data-stu-id="3b697-208">[Queue-based Load Leveling Pattern](queue-based-load-leveling.md).</span></span> <span data-ttu-id="3b697-209">Üzenet-várólista bevezetéséről adhat hozzá rugalmasság a rendszer, szolgáltatáspéldány, széles körben változó mennyiségű alkalmazáspéldányok kérelmeinek kezeléséhez.</span><span class="sxs-lookup"><span data-stu-id="3b697-209">Introducing a message queue can add resiliency to the system, enabling service instances to handle widely varying volumes of requests from application instances.</span></span> <span data-ttu-id="3b697-210">Az üzenet-várólista pufferként a, amely a terhelési szintek.</span><span class="sxs-lookup"><span data-stu-id="3b697-210">The message queue acts as a buffer, which levels the load.</span></span> <span data-ttu-id="3b697-211">A várólista-alapú terhelés simítás mintát ebben a forgatókönyvben részletesebben ismerteti.</span><span class="sxs-lookup"><span data-stu-id="3b697-211">The Queue-based Load Leveling pattern describes this scenario in more detail.</span></span>

- <span data-ttu-id="3b697-212">Ez a minta van egy [mintaalkalmazás](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers) társítva.</span><span class="sxs-lookup"><span data-stu-id="3b697-212">This pattern has a [sample application](https://github.com/mspnp/cloud-design-patterns/tree/master/competing-consumers) associated with it.</span></span>
