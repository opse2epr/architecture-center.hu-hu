---
title: Horizontális skálázási minta
titleSuffix: Cloud Design Patterns
description: Egy adattárat horizontális partíció- vagy szilánkkészletté oszthat fel.
keywords: tervezési minta
author: dragon119
ms.date: 06/23/2017
ms.topic: design-pattern
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 62c8f5be8975a5c05a9118dccadcebf8717bf0ff
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 01/23/2019
ms.locfileid: "54488511"
---
# <a name="sharding-pattern"></a><span data-ttu-id="f46b1-104">Horizontális skálázási minta</span><span class="sxs-lookup"><span data-stu-id="f46b1-104">Sharding pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="f46b1-105">Egy adattárat horizontális partíció- vagy szilánkkészletté oszthat fel.</span><span class="sxs-lookup"><span data-stu-id="f46b1-105">Divide a data store into a set of horizontal partitions or shards.</span></span> <span data-ttu-id="f46b1-106">Ezzel javíthatja a skálázhatóságot nagy adatmennyiségek tárolásakor és elérésekor.</span><span class="sxs-lookup"><span data-stu-id="f46b1-106">This can improve scalability when storing and accessing large volumes of data.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="f46b1-107">Kontextus és probléma</span><span class="sxs-lookup"><span data-stu-id="f46b1-107">Context and problem</span></span>

<span data-ttu-id="f46b1-108">Az egyetlen kiszolgáló által futtatott adattárolókra az alábbi korlátozások vonatkozhatnak:</span><span class="sxs-lookup"><span data-stu-id="f46b1-108">A data store hosted by a single server might be subject to the following limitations:</span></span>

- <span data-ttu-id="f46b1-109">**Tárolóhely**.</span><span class="sxs-lookup"><span data-stu-id="f46b1-109">**Storage space**.</span></span> <span data-ttu-id="f46b1-110">A nagyméretű felhőalkalmazások adattára várhatóan hatalmas mennyiségű adatokat fog tartalmazni, és adatok mennyisége idővel jelentősen megnőhet.</span><span class="sxs-lookup"><span data-stu-id="f46b1-110">A data store for a large-scale cloud application is expected to contain a huge volume of data that could increase significantly over time.</span></span> <span data-ttu-id="f46b1-111">Egy kiszolgáló jellemzően korlátozott méretű lemezterületet biztosít, a meglévő lemezeket azonban kicserélheti nagyobbakra, vagy további lemezekkel bővítheti a gépet az adatmennyiség növekedésével.</span><span class="sxs-lookup"><span data-stu-id="f46b1-111">A server typically provides only a finite amount of disk storage, but you can replace existing disks with larger ones, or add further disks to a machine as data volumes grow.</span></span> <span data-ttu-id="f46b1-112">A rendszer viszont végül el fog érni egy korlátot, amikor már nem lehet könnyen növelni a kiszolgáló tárolókapacitását.</span><span class="sxs-lookup"><span data-stu-id="f46b1-112">However, the system will eventually reach a limit where it isn't possible to easily increase the storage capacity on a given server.</span></span>

- <span data-ttu-id="f46b1-113">**Számítási erőforrások**.</span><span class="sxs-lookup"><span data-stu-id="f46b1-113">**Computing resources**.</span></span> <span data-ttu-id="f46b1-114">A felhőalkalmazásoknak nagyszámú egyidejű felhasználót kell támogatniuk, akik mindegyike az adattárban lévő információkat lekérő lekérdezéseket futtat.</span><span class="sxs-lookup"><span data-stu-id="f46b1-114">A cloud application is required to support a large number of concurrent users, each of which run queries that retrieve information from the data store.</span></span> <span data-ttu-id="f46b1-115">Előfordulhat, hogy az adattárat futtató egyetlen kiszolgáló nem tudja biztosítani a terhelést támogató szükséges számítási teljesítményt, ami a felhasználók számára hosszú válaszidőt és gyakori hibákat eredményez, amikor az adatok tárolását és lekérését megkísérlő alkalmazások túllépik az időkorlátot. Megoldás lehet a memória bővítése vagy a processzorok nagyobb teljesítményűre cserélése, a rendszer azonban el fog érni egy korlátot, amikor a számítási erőforrások már nem növelhetők tovább.</span><span class="sxs-lookup"><span data-stu-id="f46b1-115">A single server hosting the data store might not be able to provide the necessary computing power to support this load, resulting in extended response times for users and frequent failures as applications attempting to store and retrieve data time out. It might be possible to add memory or upgrade processors, but the system will reach a limit when it isn't possible to increase the compute resources any further.</span></span>

- <span data-ttu-id="f46b1-116">**Hálózati sávszélesség**.</span><span class="sxs-lookup"><span data-stu-id="f46b1-116">**Network bandwidth**.</span></span> <span data-ttu-id="f46b1-117">Az egyetlen kiszolgálón futó adattárak teljesítményét végső soron az a sebesség határozza meg, amellyel a kiszolgáló képes a kérések fogadására és a válaszok elküldésére.</span><span class="sxs-lookup"><span data-stu-id="f46b1-117">Ultimately, the performance of a data store running on a single server is governed by the rate the server can receive requests and send replies.</span></span> <span data-ttu-id="f46b1-118">Előfordulhat, hogy a hálózati forgalom mennyisége meghaladja a kiszolgálóhoz való csatlakozáshoz használt hálózat kapacitását, ami sikertelen kéréseket eredményez.</span><span class="sxs-lookup"><span data-stu-id="f46b1-118">It's possible that the volume of network traffic might exceed the capacity of the network used to connect to the server, resulting in failed requests.</span></span>

- <span data-ttu-id="f46b1-119">**Földrajzi hely**.</span><span class="sxs-lookup"><span data-stu-id="f46b1-119">**Geography**.</span></span> <span data-ttu-id="f46b1-120">Jogi, megfelelőségi vagy teljesítménnyel kapcsolatos okokból, vagy pedig az adatelérés késésének csökkentése érdekében szükséges lehet az adott felhasználók által létrehozott adatokat a felhasználó régiójában tárolni.</span><span class="sxs-lookup"><span data-stu-id="f46b1-120">It might be necessary to store data generated by specific users in the same region as those users for legal, compliance, or performance reasons, or to reduce latency of data access.</span></span> <span data-ttu-id="f46b1-121">Ha a felhasználók különböző országokban vagy régiókban vannak, előfordulhat, hogy nem lehet egyetlen adattárolóban tárolni az alkalmazás összes adatát.</span><span class="sxs-lookup"><span data-stu-id="f46b1-121">If the users are dispersed across different countries or regions, it might not be possible to store the entire data for the application in a single data store.</span></span>

<span data-ttu-id="f46b1-122">A nagyobb lemezkapacitás, feldolgozási teljesítmény, több memória és hálózati kapcsolat hozzáadásával történő függőlegesen skálázás késleltetheti néhány ilyen korlátozás hatását, valószínűleg azonban csak ideiglenes megoldást jelent.</span><span class="sxs-lookup"><span data-stu-id="f46b1-122">Scaling vertically by adding more disk capacity, processing power, memory, and network connections can postpone the effects of some of these limitations, but it's likely to only be a temporary solution.</span></span> <span data-ttu-id="f46b1-123">A nagyszámú felhasználót és nagy mennyiségű adatot támogató kereskedelmi felhőalkalmazásoknak szinte végtelen skálázásra kell képesnek lenniük, így a függőleges skálázás nem feltétlenül a legjobb megoldás.</span><span class="sxs-lookup"><span data-stu-id="f46b1-123">A commercial cloud application capable of supporting large numbers of users and high volumes of data must be able to scale almost indefinitely, so vertical scaling isn't necessarily the best solution.</span></span>

## <a name="solution"></a><span data-ttu-id="f46b1-124">Megoldás</span><span class="sxs-lookup"><span data-stu-id="f46b1-124">Solution</span></span>

<span data-ttu-id="f46b1-125">Ossza fel az adattárat horizontális partíciókra vagy szegmensekre.</span><span class="sxs-lookup"><span data-stu-id="f46b1-125">Divide the data store into horizontal partitions or shards.</span></span> <span data-ttu-id="f46b1-126">Mindegyik szegmens ugyanazzal a sémával rendelkezik, azonban az adatok saját különálló részhalmazát tartalmazzák.</span><span class="sxs-lookup"><span data-stu-id="f46b1-126">Each shard has the same schema, but holds its own distinct subset of the data.</span></span> <span data-ttu-id="f46b1-127">A szegmensek adattárnak számítanak (sok különböző típusú entitás adatait tartalmazhatják), amelyek a tárolócsomópontként működő kiszolgálón futnak.</span><span class="sxs-lookup"><span data-stu-id="f46b1-127">A shard is a data store in its own right (it can contain the data for many entities of different types), running on a server acting as a storage node.</span></span>

<span data-ttu-id="f46b1-128">Ez a minta az alábbi előnyökkel jár:</span><span class="sxs-lookup"><span data-stu-id="f46b1-128">This pattern has the following benefits:</span></span>

- <span data-ttu-id="f46b1-129">A rendszer horizontális skálázásához további tárolócsomópontokon futó további szegmenseket adhat hozzá.</span><span class="sxs-lookup"><span data-stu-id="f46b1-129">You can scale the system out by adding further shards running on additional storage nodes.</span></span>

- <span data-ttu-id="f46b1-130">A rendszer azonnali használatra kész hardvert használhat az egyes tárolócsomópontokhoz szükséges speciális és költséges számítógépek helyett.</span><span class="sxs-lookup"><span data-stu-id="f46b1-130">A system can use off-the-shelf hardware rather than specialized and expensive computers for each storage node.</span></span>

- <span data-ttu-id="f46b1-131">A számítási feladatoknak a szegmensek közötti elosztásával csökkentheti a versengést és növelheti teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="f46b1-131">You can reduce contention and improve performance by balancing the workload across shards.</span></span>

- <span data-ttu-id="f46b1-132">A felhőben a szegmensek fizikailag közel helyezhetők el az adatokat elérő felhasználókhoz.</span><span class="sxs-lookup"><span data-stu-id="f46b1-132">In the cloud, shards can be located physically close to the users that'll access the data.</span></span>

<span data-ttu-id="f46b1-133">Amikor az adatárat szegmensekre osztja, döntse el, mely adatok kerüljenek az egyes szegmensekbe.</span><span class="sxs-lookup"><span data-stu-id="f46b1-133">When dividing a data store up into shards, decide which data should be placed in each shard.</span></span> <span data-ttu-id="f46b1-134">A szegmensek általában olyan elemeket tartalmaznak, amelyek az adatok egy vagy több attribútuma által meghatározott tartományba esnek.</span><span class="sxs-lookup"><span data-stu-id="f46b1-134">A shard typically contains items that fall within a specified range determined by one or more attributes of the data.</span></span> <span data-ttu-id="f46b1-135">Ezek az attribútumok alkotják a szegmenskulcsot (amelyet néha partíciókulcsnak is neveznek).</span><span class="sxs-lookup"><span data-stu-id="f46b1-135">These attributes form the shard key (sometimes referred to as the partition key).</span></span> <span data-ttu-id="f46b1-136">A szegmenskulcsnak statikusnak kell lennie.</span><span class="sxs-lookup"><span data-stu-id="f46b1-136">The shard key should be static.</span></span> <span data-ttu-id="f46b1-137">Nem alapulhat olyan adatokon, amelyek változhatnak.</span><span class="sxs-lookup"><span data-stu-id="f46b1-137">It shouldn't be based on data that might change.</span></span>

<span data-ttu-id="f46b1-138">A horizontális skálázás fizikailag rendezi az adatokat.</span><span class="sxs-lookup"><span data-stu-id="f46b1-138">Sharding physically organizes the data.</span></span> <span data-ttu-id="f46b1-139">Ha egy alkalmazás adatokat tárol és kér le, a horizontális skálázási logika az alkalmazást a megfelelő szegmenshez irányítja.</span><span class="sxs-lookup"><span data-stu-id="f46b1-139">When an application stores and retrieves data, the sharding logic directs the application to the appropriate shard.</span></span> <span data-ttu-id="f46b1-140">A horizontális skálázási logika megvalósítható az alkalmazás adatelérési kódjának részeként, vagy pedig az adattároló rendszer valósíthatja meg, ha transzparens módon támogatja a horizontális skálázást.</span><span class="sxs-lookup"><span data-stu-id="f46b1-140">This sharding logic can be implemented as part of the data access code in the application, or it could be implemented by the data storage system if it transparently supports sharding.</span></span>

<span data-ttu-id="f46b1-141">Az adatok fizikai helyének a horizontális skálázási logikában való meghatározásával magas szinten szabályozható, hogy az egyes szegmensek mely adatokat tartalmazzák.</span><span class="sxs-lookup"><span data-stu-id="f46b1-141">Abstracting the physical location of the data in the sharding logic provides a high level of control over which shards contain which data.</span></span> <span data-ttu-id="f46b1-142">Emellett lehetővé teszi azt is, hogy az adatok az alkalmazás üzleti logikájának átdolgozása lehessen migrálhatók, ha a szegmensekben lévő adatokat később újra el kellene osztani (például akkor, ha a szegmensek kiegyensúlyozatlanná válnak).</span><span class="sxs-lookup"><span data-stu-id="f46b1-142">It also enables data to migrate between shards without reworking the business logic of an application if the data in the shards need to be redistributed later (for example, if the shards become unbalanced).</span></span> <span data-ttu-id="f46b1-143">Ennek ára a további adatelérési terhelés, amelyre az adatok helyének meghatározásához van szükség az adatok lekérésekor.</span><span class="sxs-lookup"><span data-stu-id="f46b1-143">The tradeoff is the additional data access overhead required in determining the location of each data item as it's retrieved.</span></span>

<span data-ttu-id="f46b1-144">Az optimális teljesítmény és skálázhatóság biztosítása érdekében olyan módon kell felosztani az adatokat, amely megfelel az alkalmazás által végrehajtott lekérdezések típusának.</span><span class="sxs-lookup"><span data-stu-id="f46b1-144">To ensure optimal performance and scalability, it's important to split the data in a way that's appropriate for the types of queries that the application performs.</span></span> <span data-ttu-id="f46b1-145">Sok esetben nem valószínű, hogy a horizontális skálázási séma pontosan megfelel minden lekérdezés követelményeinek.</span><span class="sxs-lookup"><span data-stu-id="f46b1-145">In many cases, it's unlikely that the sharding scheme will exactly match the requirements of every query.</span></span> <span data-ttu-id="f46b1-146">Egy több-bérlős rendszerben például lehet, hogy egy alkalmazásnak a bérlőazonosítóval kell lekérnie bérlőadatokat, de előfordulhat, hogy ezeket az adatokat más attribútum, például a bérlő neve vagy helye alapján kell megkeresnie.</span><span class="sxs-lookup"><span data-stu-id="f46b1-146">For example, in a multi-tenant system an application might need to retrieve tenant data using the tenant ID, but it might also need to look up this data based on some other attribute such as the tenant’s name or location.</span></span> <span data-ttu-id="f46b1-147">Az ilyen helyzetek kezelése érdekében a leggyakrabban végrehajtott lekérdezéseket támogató szegmenskulccsal rendelkező horizontális skálázási stratégiát valósítson meg.</span><span class="sxs-lookup"><span data-stu-id="f46b1-147">To handle these situations, implement a sharding strategy with a shard key that supports the most commonly performed queries.</span></span>

<span data-ttu-id="f46b1-148">Ha a lekérdezések rendszeresen kérnek le adatokat az attribútumértékek kombinációjával, valószínűleg meghatározhat egy összetett szegmenskulcsot az attribútumok összekapcsolásával.</span><span class="sxs-lookup"><span data-stu-id="f46b1-148">If queries regularly retrieve data using a combination of attribute values, you can likely define a composite shard key by linking attributes together.</span></span> <span data-ttu-id="f46b1-149">Másik megoldásként egy mintával, például az [indextábla](./index-table.md) használatával teheti lehetővé az adatok gyors keresését olyan attribútumok alapján, amelyekre a szegmenskulcs nem terjed ki.</span><span class="sxs-lookup"><span data-stu-id="f46b1-149">Alternatively, use a pattern such as [Index Table](./index-table.md) to provide fast lookup to data based on attributes that aren't covered by the shard key.</span></span>

## <a name="sharding-strategies"></a><span data-ttu-id="f46b1-150">Horizontális skálázási stratégiák</span><span class="sxs-lookup"><span data-stu-id="f46b1-150">Sharding strategies</span></span>

<span data-ttu-id="f46b1-151">A szegmenskulcs kiválasztása és az adatok szegmensek közötti elosztási módjának meghatározása három gyakori stratégia használatával történik.</span><span class="sxs-lookup"><span data-stu-id="f46b1-151">Three strategies are commonly used when selecting the shard key and deciding how to distribute data across shards.</span></span> <span data-ttu-id="f46b1-152">Vegye figyelembe, hogy nem kell egy az egyhez típusú egyezésnek lennie a szegmensek és az azokat futtató kiszolgálók között – egyetlen kiszolgáló több szegmenst is futtathat.</span><span class="sxs-lookup"><span data-stu-id="f46b1-152">Note that there doesn't have to be a one-to-one correspondence between shards and the servers that host them&mdash;a single server can host multiple shards.</span></span> <span data-ttu-id="f46b1-153">A stratégiák az alábbiak:</span><span class="sxs-lookup"><span data-stu-id="f46b1-153">The strategies are:</span></span>

<span data-ttu-id="f46b1-154">**A keresési stratégia**.</span><span class="sxs-lookup"><span data-stu-id="f46b1-154">**The Lookup strategy**.</span></span> <span data-ttu-id="f46b1-155">Ebben a stratégiában a horizontális skálázási logika olyan összerendelést valósít meg, amely az adatkéréseket az adatokat tartalmazó szegmenshez irányítja a szegmenskulccsal.</span><span class="sxs-lookup"><span data-stu-id="f46b1-155">In this strategy the sharding logic implements a map that routes a request for data to the shard that contains that data using the shard key.</span></span> <span data-ttu-id="f46b1-156">A több-bérlős alkalmazásokban előfordulhat, hogy egy bérlő összes adatát egy szegmens tárolja a bérlő azonosítóját használva szegmenskulcsként.</span><span class="sxs-lookup"><span data-stu-id="f46b1-156">In a multi-tenant application all the data for a tenant might be stored together in a shard using the tenant ID as the shard key.</span></span> <span data-ttu-id="f46b1-157">Ugyanazon a szegmensen osztozhat több, azonban egy adott bérlő adatai nem oszlanak meg több szegmens között.</span><span class="sxs-lookup"><span data-stu-id="f46b1-157">Multiple tenants might share the same shard, but the data for a single tenant won't be spread across multiple shards.</span></span> <span data-ttu-id="f46b1-158">Az ábra a bérlőadatok bérlőazonosítókon alapuló horizontális skálázását mutatja be.</span><span class="sxs-lookup"><span data-stu-id="f46b1-158">The figure illustrates sharding tenant data based on tenant IDs.</span></span>

   ![1. ábra – Bérlőadatok horizontális skálázása a bérlőazonosítók alapján](./_images/sharding-tenant.png)

<span data-ttu-id="f46b1-160">A szegmenskulcs és a fizikai tároló közötti összerendelés alapulhat fizikai szegmenseken, mely esetben minden szegmenskulcs egy fizikai partíciónak felel meg.</span><span class="sxs-lookup"><span data-stu-id="f46b1-160">The mapping between the shard key and the physical storage can be based on physical shards where each shard key maps to a physical partition.</span></span> <span data-ttu-id="f46b1-161">A szegmensek újraegyensúlyozásának egy rugalmasabb technikája a virtuális particionálás, mely során a szegmenskulcsok ugyanannyi virtuális szegmensre vannak leképezve, amelyek viszont így kevesebb fizikai partíciónak felelnek meg.</span><span class="sxs-lookup"><span data-stu-id="f46b1-161">Alternatively, a more flexible technique for rebalancing shards is virtual partitioning, where shard keys map to the same number of virtual shards, which in turn map to fewer physical partitions.</span></span> <span data-ttu-id="f46b1-162">Ezen megközelítés esetén az alkalmazás egy virtuális szegmensre hivatkozó szegmenskulccsal keresi meg az adatokat, és a rendszer transzparens módon képezi le a virtuális szegmenseket fizikai partíciókra.</span><span class="sxs-lookup"><span data-stu-id="f46b1-162">In this approach, an application locates data using a shard key that refers to a virtual shard, and the system transparently maps virtual shards to physical partitions.</span></span> <span data-ttu-id="f46b1-163">A virtuális szegmensek és fizikai partíciók közötti összerendelés anélkül változhat, hogy az alkalmazáskódot más szegmenskulcsok használatára kellene módosítani.</span><span class="sxs-lookup"><span data-stu-id="f46b1-163">The mapping between a virtual shard and a physical partition can change without requiring the application code be modified to use a different set of shard keys.</span></span>

<span data-ttu-id="f46b1-164">**A tartományalapú stratégia**.</span><span class="sxs-lookup"><span data-stu-id="f46b1-164">**The Range strategy**.</span></span> <span data-ttu-id="f46b1-165">Ez a stratégia ugyanabban a szegmensben csoportosítja a kapcsolódó elemeket, és szegmenskulcs szerint rendezi azokat – a szegmenskulcsok sorrendben követik egymást.</span><span class="sxs-lookup"><span data-stu-id="f46b1-165">This strategy groups related items together in the same shard, and orders them by shard key&mdash;the shard keys are sequential.</span></span> <span data-ttu-id="f46b1-166">Ez olyan alkalmazások esetén hasznos, amelyek gyakran kérnek le elemeket tartománylekérdezésekkel (olyan lekérdezésekkel, amelyek adott tartományba eső szegmenskulcsok adatelemeit adják vissza).</span><span class="sxs-lookup"><span data-stu-id="f46b1-166">It's useful for applications that frequently retrieve sets of items using range queries (queries that return a set of data items for a shard key that falls within a given range).</span></span> <span data-ttu-id="f46b1-167">Ha például egy alkalmazásnak rendszeresen meg kell keresnie egy adott hónap összes megrendelését, akkor ezek az adatok gyorsabban lekérhetők, ha egy hónap összes megrendelésének a tárolása dátum és idő szerint rendezve történik ugyanabban a szegmensben.</span><span class="sxs-lookup"><span data-stu-id="f46b1-167">For example, if an application regularly needs to find all orders placed in a given month, this data can be retrieved more quickly if all orders for a month are stored in date and time order in the same shard.</span></span> <span data-ttu-id="f46b1-168">Ha az egyes megrendeléseket eltérő szegmensben tárolná, egyenként kellene lekérni azokat nagyszámú pontlekérdezés (egyetlen adatelemet visszaadó lekérdezés) végrehajtásával.</span><span class="sxs-lookup"><span data-stu-id="f46b1-168">If each order was stored in a different shard, they'd have to be fetched individually by performing a large number of point queries (queries that return a single data item).</span></span> <span data-ttu-id="f46b1-169">A következő ábra az adatok egymást követő halmazának (tartományának) szegmensben való tárolását mutatja be.</span><span class="sxs-lookup"><span data-stu-id="f46b1-169">The next figure illustrates storing sequential sets (ranges) of data in shard.</span></span>

   ![2. ábra – Adatok egymást követő halmazának (tartományának) tárolása szegmenseken](./_images/sharding-sequential-sets.png)

<span data-ttu-id="f46b1-171">Ebben a példában a szegmenskulcs egy összetett kulcs, amelynek a legjelentősebb eleme a megrendelés hónapja, amelyet a megrendelés napja és ideje követ.</span><span class="sxs-lookup"><span data-stu-id="f46b1-171">In this example, the shard key is a composite key containing the order month as the most significant element, followed by the order day and the time.</span></span> <span data-ttu-id="f46b1-172">A megrendelések adatainak rendezése értelemszerűen történik új megrendelések létrehozásakor és a szegmenshez való hozzáadásukkor.</span><span class="sxs-lookup"><span data-stu-id="f46b1-172">The data for orders is naturally sorted when new orders are created and added to a shard.</span></span> <span data-ttu-id="f46b1-173">Néhány adattár támogatja a két részből álló szegmenskulcsokat, amelyek a szegmenset azonosító partíciókulcs-elemet és a szegmensben lévő elemet egyedi módon azonosító sorkulcsot tartalmaznak.</span><span class="sxs-lookup"><span data-stu-id="f46b1-173">Some data stores support two-part shard keys containing a partition key element that identifies the shard and a row key that uniquely identifies an item in the shard.</span></span> <span data-ttu-id="f46b1-174">A szegmens általában a sorkulcs sorrendjének megfelelően tárolja az adatokat.</span><span class="sxs-lookup"><span data-stu-id="f46b1-174">Data is usually held in row key order in the shard.</span></span> <span data-ttu-id="f46b1-175">A tartománylekérdezésekkel lekérhető és az együtt csoportosítandó elemek olyan szegmenskulcsot használhatnak, amelynek partíciókulcsa a szegmenskulccsal egyező értékű, sorkulcsa azonban egyedi értékkel rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="f46b1-175">Items that are subject to range queries and need to be grouped together can use a shard key that has the same value for the partition key but a unique value for the row key.</span></span>

<span data-ttu-id="f46b1-176">**A kivonatolási stratégia**.</span><span class="sxs-lookup"><span data-stu-id="f46b1-176">**The Hash strategy**.</span></span> <span data-ttu-id="f46b1-177">Ennek a stratégiának az a célja, hogy csökkentse a kritikus pontok esélyét (olyan szegmensek, amelyek aránytalanul nagy mennyiségű terhelést kapnak).</span><span class="sxs-lookup"><span data-stu-id="f46b1-177">The purpose of this strategy is to reduce the chance of hotspots (shards that receive a disproportionate amount of load).</span></span> <span data-ttu-id="f46b1-178">A stratégia olyan módon osztja el az adatokat a szegmensek között, amely egyensúlyt teremt az egyes szegmensek mérete és a szegmensekre háruló átlagos terhelés között.</span><span class="sxs-lookup"><span data-stu-id="f46b1-178">It distributes the data across the shards in a way that achieves a balance between the size of each shard and the average load that each shard will encounter.</span></span> <span data-ttu-id="f46b1-179">A horizontális skálázási logika az elemet tároló szegmenst az adatok egy vagy több attribútumának kivonata alapján számítja ki.</span><span class="sxs-lookup"><span data-stu-id="f46b1-179">The sharding logic computes the shard to store an item in based on a hash of one or more attributes of the data.</span></span> <span data-ttu-id="f46b1-180">A kiválasztott kivonatolási függvénynek egyenletesen kell elosztania az adatokat a szegmensek között, lehetőleg valamilyen véletlenszerű elem bevezetésével a számításba.</span><span class="sxs-lookup"><span data-stu-id="f46b1-180">The chosen hashing function should distribute data evenly across the shards, possibly by introducing some random element into the computation.</span></span> <span data-ttu-id="f46b1-181">A következő ábra a bérlőadatoknak a bérlőazonosítók kivonata alapján történő horizontális skálázását mutatja be.</span><span class="sxs-lookup"><span data-stu-id="f46b1-181">The next figure illustrates sharding tenant data based on a hash of tenant IDs.</span></span>

   ![3. ábra – Bérlőadatok horizontális skálázása a bérlőazonosítók kivonata alapján](./_images/sharding-data-hash.png)

<span data-ttu-id="f46b1-183">A kivonatolási stratégia más horizontális skálázási stratégiákkal szembeni előnyének megértéséhez gondolja végig, hogy az új bérlőket egymás után regisztráló több-bérlős alkalmazás, hogyan rendelné a bérlőket az adattárban található szegmensekhez.</span><span class="sxs-lookup"><span data-stu-id="f46b1-183">To understand the advantage of the Hash strategy over other sharding strategies, consider how a multi-tenant application that enrolls new tenants sequentially might assign the tenants to shards in the data store.</span></span> <span data-ttu-id="f46b1-184">A tartományalapú stratégia használatakor az 1–n bérlők adatainak mindegyikét az A szegmens tárolná, az n+1–m bérlők adatainak mindegyikét a B szegmens tárolná, és így tovább.</span><span class="sxs-lookup"><span data-stu-id="f46b1-184">When using the Range strategy, the data for tenants 1 to n will all be stored in shard A, the data for tenants n+1 to m will all be stored in shard B, and so on.</span></span> <span data-ttu-id="f46b1-185">Ha a legutóbb regisztrált bérlők a legaktívabbak is, a legtöbb adattevékenység kevés szegmensben történik, ami kritikus pontokat okozhat.</span><span class="sxs-lookup"><span data-stu-id="f46b1-185">If the most recently registered tenants are also the most active, most data activity will occur in a small number of shards, which could cause hotspots.</span></span> <span data-ttu-id="f46b1-186">Ezzel szemben a kivonatolási stratégia a bérlőazonosítójuk kivonata alapján rendeli a bérlőket a szegmensekhez.</span><span class="sxs-lookup"><span data-stu-id="f46b1-186">In contrast, the Hash strategy allocates tenants to shards based on a hash of their tenant ID.</span></span> <span data-ttu-id="f46b1-187">Ez azt jelenti, hogy az egymást követő bérlők valószínűleg különböző szegmensekhez lesznek rendelve, ami elosztja a szegmensek közötti terhelést.</span><span class="sxs-lookup"><span data-stu-id="f46b1-187">This means that sequential tenants are most likely to be allocated to different shards, which will distribute the load across them.</span></span> <span data-ttu-id="f46b1-188">Az előző ábra ezt mutatja be az 55. és az 56. bérlőre vonatkozásában.</span><span class="sxs-lookup"><span data-stu-id="f46b1-188">The previous figure shows this for tenants 55 and 56.</span></span>

<span data-ttu-id="f46b1-189">A három horizontális skálázási stratégia az alábbi előnyökkel és megfontolandó szempontokkal jár:</span><span class="sxs-lookup"><span data-stu-id="f46b1-189">The three sharding strategies have the following advantages and considerations:</span></span>

- <span data-ttu-id="f46b1-190">**Keresési stratégia**.</span><span class="sxs-lookup"><span data-stu-id="f46b1-190">**Lookup**.</span></span> <span data-ttu-id="f46b1-191">Nagyobb mértékű vezérlést nyújt a szegmensek konfigurálásának és használatának módja felett.</span><span class="sxs-lookup"><span data-stu-id="f46b1-191">This offers more control over the way that shards are configured and used.</span></span> <span data-ttu-id="f46b1-192">A virtuális szegmensek használata csökkenti az adatok újraegyensúlyozásakor fellépő terhelést, mert új fizikai partíciók adhatók hozzá a számítási feladatok kiegyenlítése érdekében.</span><span class="sxs-lookup"><span data-stu-id="f46b1-192">Using virtual shards reduces the impact when rebalancing data because new physical partitions can be added to even out the workload.</span></span> <span data-ttu-id="f46b1-193">A virtuális szegmens és a szegmenst megvalósító fizikai partíciók közötti összerendelés anélkül módosítható, hogy az hatással lenne az adatok tárolására és lekérésére szolgáló szegmenskulcsot használó alkalmazáskódra.</span><span class="sxs-lookup"><span data-stu-id="f46b1-193">The mapping between a virtual shard and the physical partitions that implement the shard can be modified without affecting application code that uses a shard key to store and retrieve data.</span></span> <span data-ttu-id="f46b1-194">A szegmenshelyek keresése további többletterhelést jelenthet.</span><span class="sxs-lookup"><span data-stu-id="f46b1-194">Looking up shard locations can impose an additional overhead.</span></span>

- <span data-ttu-id="f46b1-195">**Tartományalapú stratégia**.</span><span class="sxs-lookup"><span data-stu-id="f46b1-195">**Range**.</span></span> <span data-ttu-id="f46b1-196">Könnyen megvalósítható, és jól működik a tartománylekérdezésekkel, mert azok gyakran több adatelemet kérhetnek le egyetlen szegmensből egyetlen művelet során.</span><span class="sxs-lookup"><span data-stu-id="f46b1-196">This is easy to implement and works well with range queries because they can often fetch multiple data items from a single shard in a single operation.</span></span> <span data-ttu-id="f46b1-197">Ez a stratégia egyszerűbb adatkezelést kínál.</span><span class="sxs-lookup"><span data-stu-id="f46b1-197">This strategy offers easier data management.</span></span> <span data-ttu-id="f46b1-198">Ha például egy adott régió felhasználói ugyanabban a szegmensben találhatók, a frissítések a helyi terhelés és az igényminta alapján ütemezhetők az egyes időzónákban.</span><span class="sxs-lookup"><span data-stu-id="f46b1-198">For example, if users in the same region are in the same shard, updates can be scheduled in each time zone based on the local load and demand pattern.</span></span> <span data-ttu-id="f46b1-199">Ez a stratégia azonban nem biztosít optimális terheléselosztást a szegmensek között.</span><span class="sxs-lookup"><span data-stu-id="f46b1-199">However, this strategy doesn't provide optimal balancing between shards.</span></span> <span data-ttu-id="f46b1-200">A szegmensek újraegyensúlyozása nehéz feladat, és előfordulhat, hogy akkor sem oldja meg az egyenetlen terhelés problémáját, ha a tevékenységek többsége szomszédos szegmenskulcsokhoz kapcsolódik.</span><span class="sxs-lookup"><span data-stu-id="f46b1-200">Rebalancing shards is difficult and might not resolve the problem of uneven load if the majority of activity is for adjacent shard keys.</span></span>

- <span data-ttu-id="f46b1-201">**Kivonatolási stratégia**.</span><span class="sxs-lookup"><span data-stu-id="f46b1-201">**Hash**.</span></span> <span data-ttu-id="f46b1-202">Ez a stratégia nagyobb eséllyel teszi lehetővé az egyenletesebb adat- és terheléselosztást.</span><span class="sxs-lookup"><span data-stu-id="f46b1-202">This strategy offers a better chance of more even data and load distribution.</span></span> <span data-ttu-id="f46b1-203">A kérések továbbítása közvetlenül végezhető a kivonatolási függvény használatával.</span><span class="sxs-lookup"><span data-stu-id="f46b1-203">Request routing can be accomplished directly by using the hash function.</span></span> <span data-ttu-id="f46b1-204">Nem kell leképezést fenntartani.</span><span class="sxs-lookup"><span data-stu-id="f46b1-204">There's no need to maintain a map.</span></span> <span data-ttu-id="f46b1-205">Vegye figyelembe, hogy a kivonat kiszámítása többletterhelést okozhat.</span><span class="sxs-lookup"><span data-stu-id="f46b1-205">Note that computing the hash might impose an additional overhead.</span></span> <span data-ttu-id="f46b1-206">Emellett nehéz a szegmensek újraegyensúlyozása.</span><span class="sxs-lookup"><span data-stu-id="f46b1-206">Also, rebalancing shards is difficult.</span></span>

<span data-ttu-id="f46b1-207">A leggyakoribb horizontális skálázási rendszerek a fent leírt megközelítések egyikét valósítják meg, figyelembe kell vennie azonban az alkalmazások üzleti követelményeit és az alkalmazások adathasználatának mintáit is.</span><span class="sxs-lookup"><span data-stu-id="f46b1-207">Most common sharding systems implement one of the approaches described above, but you should also consider the business requirements of your applications and their patterns of data usage.</span></span> <span data-ttu-id="f46b1-208">Egy több-bérlős alkalmazásban például:</span><span class="sxs-lookup"><span data-stu-id="f46b1-208">For example, in a multi-tenant application:</span></span>

- <span data-ttu-id="f46b1-209">Az adatok horizontális skálázását végezheti számítási feladatok alapján.</span><span class="sxs-lookup"><span data-stu-id="f46b1-209">You can shard data based on workload.</span></span> <span data-ttu-id="f46b1-210">A kevéssé permanens bérlők adatait különálló szegmensekbe különítheti el.</span><span class="sxs-lookup"><span data-stu-id="f46b1-210">You could segregate the data for highly volatile tenants in separate shards.</span></span> <span data-ttu-id="f46b1-211">Ennek eredményeként növekedhet a többi bérlő adatelérésének sebessége.</span><span class="sxs-lookup"><span data-stu-id="f46b1-211">The speed of data access for other tenants might be improved as a result.</span></span>

- <span data-ttu-id="f46b1-212">Az adatok horizontális skálázását végezheti a bérlők helye alapján.</span><span class="sxs-lookup"><span data-stu-id="f46b1-212">You can shard data based on the location of tenants.</span></span> <span data-ttu-id="f46b1-213">Egy adott földrajzi régióban található bérlők adatait biztonsági mentés és karbantartás céljából offline állapotba helyezheti az alacsony forgalmú időszakban, míg a többi régióban lévő bérlők adatai online és elérhetők maradnak a bérlők munkaidejében.</span><span class="sxs-lookup"><span data-stu-id="f46b1-213">You can take the data for tenants in a specific geographic region offline for backup and maintenance during off-peak hours in that region, while the data for tenants in other regions remains online and accessible during their business hours.</span></span>

- <span data-ttu-id="f46b1-214">Az értékes bérlők személyes, nagy teljesítményű, alacsony terhelésű szegmensekhez rendelhetők, ugyanakkor előfordulhat, hogy a kevésbé értékes bérlőknek kissé sűrűbb, forgalmas szegmenseken kell osztozniuk.</span><span class="sxs-lookup"><span data-stu-id="f46b1-214">High-value tenants could be assigned their own private, high performing, lightly loaded shards, whereas lower-value tenants might be expected to share more densely-packed, busy shards.</span></span>

- <span data-ttu-id="f46b1-215">A nagyfokú adatelkülönítést és adatvédelmet igénylő bérlők adatai teljesen különálló kiszolgálón tárolhatók.</span><span class="sxs-lookup"><span data-stu-id="f46b1-215">The data for tenants that need a high degree of data isolation and privacy can be stored on a completely separate server.</span></span>

## <a name="scaling-and-data-movement-operations"></a><span data-ttu-id="f46b1-216">Skálázási és adatáthelyezési műveletek</span><span class="sxs-lookup"><span data-stu-id="f46b1-216">Scaling and data movement operations</span></span>

<span data-ttu-id="f46b1-217">Minden horizontális skálázási stratégia a horizontális leskálázás, a horizontális felskálázás, az adatáthelyezés és az állapotfenntartás kezelésének különböző képességeivel és összetettségi szintjével jár.</span><span class="sxs-lookup"><span data-stu-id="f46b1-217">Each of the sharding strategies implies different capabilities and levels of complexity for managing scale in, scale out, data movement, and maintaining state.</span></span>

<span data-ttu-id="f46b1-218">A keresési stratégia a skálázási és adatáthelyezési műveletek online vagy offline, felhasználói szinten való végrehajtását teszi lehetővé.</span><span class="sxs-lookup"><span data-stu-id="f46b1-218">The Lookup strategy permits scaling and data movement operations to be carried out at the user level, either online or offline.</span></span> <span data-ttu-id="f46b1-219">A módszer felfüggeszt néhány vagy minden felhasználói tevékenységet (esetleg a csúcsidőn kívüli időszakokban), az adatokat az új virtuális partícióra vagy fizikai szegmensre helyezi át, módosítja a leképezéseket, érvényteleníti vagy frissíti az ezen adatokat tároló gyorsítótárakat, majd engedélyezi a felhasználói tevékenység folytatását.</span><span class="sxs-lookup"><span data-stu-id="f46b1-219">The technique is to suspend some or all user activity (perhaps during off-peak periods), move the data to the new virtual partition or physical shard, change the mappings, invalidate or refresh any caches that hold this data, and then allow user activity to resume.</span></span> <span data-ttu-id="f46b1-220">Az ilyen típusú működés gyakran központilag kezelhető.</span><span class="sxs-lookup"><span data-stu-id="f46b1-220">Often this type of operation can be centrally managed.</span></span> <span data-ttu-id="f46b1-221">A keresési stratégia megköveteli, hogy az állapot rendkívül jól gyorsítótárazható és replikabarát legyen.</span><span class="sxs-lookup"><span data-stu-id="f46b1-221">The Lookup strategy requires state to be highly cacheable and replica friendly.</span></span>

<span data-ttu-id="f46b1-222">A tartományalapú stratégia némileg korlátozza a skálázási és adatáthelyezési műveleteket, amelyeket általában akkor kell végrehajtani, amikor az adattár egy része vagy egésze offline állapotban van, mert az adatokat fel kell osztani és egyesíteni kell a szegmensek között.</span><span class="sxs-lookup"><span data-stu-id="f46b1-222">The Range strategy imposes some limitations on scaling and data movement operations, which must typically be carried out when a part or all of the data store is offline because the data must be split and merged across the shards.</span></span> <span data-ttu-id="f46b1-223">Előfordulhat, hogy a szegmensek újraegyensúlyozása céljából végrehajtott adatáthelyezés nem oldja meg az egyenetlen terhelés problémáját, ha a tevékenységek többsége szomszédos szegmenskulcsokhoz vagy az ugyanabban a tartományban lévő adatazonosítókhoz kapcsolódik.</span><span class="sxs-lookup"><span data-stu-id="f46b1-223">Moving the data to rebalance shards might not resolve the problem of uneven load if the majority of activity is for adjacent shard keys or data identifiers that are within the same range.</span></span> <span data-ttu-id="f46b1-224">A tartományalapú stratégiához bizonyos állapot fenntartására is szükség lehet a tartományok fizikai partíciókra való leképezéséhez.</span><span class="sxs-lookup"><span data-stu-id="f46b1-224">The Range strategy might also require some state to be maintained in order to map ranges to the physical partitions.</span></span>

<span data-ttu-id="f46b1-225">A kivonatolási stratégia összetettebbé teszi a skálázási és adatáthelyezési műveleteket, mivel a partíciókulcsok a szegmenskulcsok vagy adatazonosítók kivonatai.</span><span class="sxs-lookup"><span data-stu-id="f46b1-225">The Hash strategy makes scaling and data movement operations more complex because the partition keys are hashes of the shard keys or data identifiers.</span></span> <span data-ttu-id="f46b1-226">A kivonatolási függvényből vagy a megfelelő leképezések biztosítása érdekében módosított függvényből kell meghatározni az egyes szegmensek új helyét.</span><span class="sxs-lookup"><span data-stu-id="f46b1-226">The new location of each shard must be determined from the hash function, or the function modified to provide the correct mappings.</span></span> <span data-ttu-id="f46b1-227">A kivonatolási stratégiához azonban nincs szükség állapot fenntartására.</span><span class="sxs-lookup"><span data-stu-id="f46b1-227">However, the Hash strategy doesn't require maintenance of state.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="f46b1-228">Problémák és megfontolandó szempontok</span><span class="sxs-lookup"><span data-stu-id="f46b1-228">Issues and considerations</span></span>

<span data-ttu-id="f46b1-229">A minta megvalósítása során az alábbi pontokat vegye figyelembe:</span><span class="sxs-lookup"><span data-stu-id="f46b1-229">Consider the following points when deciding how to implement this pattern:</span></span>

- <span data-ttu-id="f46b1-230">A horizontális skálázás kiegészíti a particionálás többi formáját, például a függőleges particionálást és a funkcionális particionálást.</span><span class="sxs-lookup"><span data-stu-id="f46b1-230">Sharding is complementary to other forms of partitioning, such as vertical partitioning and functional partitioning.</span></span> <span data-ttu-id="f46b1-231">Egy szegmens például tartalmazhat függőlegesen particionált entitásokat, egy funkcionális partíció pedig megvalósítható több szegmensként.</span><span class="sxs-lookup"><span data-stu-id="f46b1-231">For example, a single shard can contain entities that have been partitioned vertically, and a functional partition can be implemented as multiple shards.</span></span> <span data-ttu-id="f46b1-232">További információ a particionálással kapcsolatban: [Adatparticionálási útmutató](https://msdn.microsoft.com/library/dn589795.aspx).</span><span class="sxs-lookup"><span data-stu-id="f46b1-232">For more information about partitioning, see the [Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span>

- <span data-ttu-id="f46b1-233">Tartsa fenn az egyensúlyt a szegmensek között, hogy mindegyik hasonló mértékű I/O-forgalmat kezeljen.</span><span class="sxs-lookup"><span data-stu-id="f46b1-233">Keep shards balanced so they all handle a similar volume of I/O.</span></span> <span data-ttu-id="f46b1-234">Adatok beszúrásakor és törlésekor rendszeresen újra kell egyensúlyozni a szegmenseket az egyenletes eloszlás biztosítása és a kritikus pontok esélyének csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="f46b1-234">As data is inserted and deleted, it's necessary to periodically rebalance the shards to guarantee an even distribution and to reduce the chance of hotspots.</span></span> <span data-ttu-id="f46b1-235">Az újraegyensúlyozás drága művelet lehet.</span><span class="sxs-lookup"><span data-stu-id="f46b1-235">Rebalancing can be an expensive operation.</span></span> <span data-ttu-id="f46b1-236">Az újraegyensúlyozás szükségességének csökkentése érdekében a növekedést szem előtt tartva tervezzen: győződjön meg arról, hogy mindegyik szegmens elegendő szabad hellyel rendelkezik-e a várt mennyiségű módosítás kezeléséhez.</span><span class="sxs-lookup"><span data-stu-id="f46b1-236">To reduce the necessity of rebalancing, plan for growth by ensuring that each shard contains sufficient free space to handle the expected volume of changes.</span></span> <span data-ttu-id="f46b1-237">Stratégiákat és szkripteket is ki kell fejlesztenie a szegmensek gyors újraegyensúlyozására, ha az szükségessé válik.</span><span class="sxs-lookup"><span data-stu-id="f46b1-237">You should also develop strategies and scripts you can use to quickly rebalance shards if this becomes necessary.</span></span>

- <span data-ttu-id="f46b1-238">Stabil adatokat használjon a szegmenskulcshoz.</span><span class="sxs-lookup"><span data-stu-id="f46b1-238">Use stable data for the shard key.</span></span> <span data-ttu-id="f46b1-239">Ha a szegmenskulcs megváltozik, előfordulhat, hogy a kulcsnak megfelelő adatelemnek mozognia kell a szegmensek között, így növekszik a frissítési műveletek által végzett munka mennyisége.</span><span class="sxs-lookup"><span data-stu-id="f46b1-239">If the shard key changes, the corresponding data item might have to move between shards, increasing the amount of work performed by update operations.</span></span> <span data-ttu-id="f46b1-240">Ezért ne alapozza a szegmenskulcsot olyan információkra, amelyek változhatnak.</span><span class="sxs-lookup"><span data-stu-id="f46b1-240">For this reason, avoid basing the shard key on potentially volatile information.</span></span> <span data-ttu-id="f46b1-241">Ehelyett nem változó vagy jellegükből adódóan kulcsot formáló attribútumokat keressen.</span><span class="sxs-lookup"><span data-stu-id="f46b1-241">Instead, look for attributes that are invariant or that naturally form a key.</span></span>

- <span data-ttu-id="f46b1-242">Gondoskodjon arról, hogy a szegmenskulcsok egyediek legyenek.</span><span class="sxs-lookup"><span data-stu-id="f46b1-242">Ensure that shard keys are unique.</span></span> <span data-ttu-id="f46b1-243">Kerülje például az automatikusan növekvő mezők szegmenskulcsként való használatát.</span><span class="sxs-lookup"><span data-stu-id="f46b1-243">For example, avoid using autoincrementing fields as the shard key.</span></span> <span data-ttu-id="f46b1-244">Néhány rendszerben az automatikusan növekvő mezők nem koordinálhatók a szegmensek között, ami miatt a különböző szegmenseken lévő elemek ugyanazzal a szegmenskulccsal rendelkezhetnek.</span><span class="sxs-lookup"><span data-stu-id="f46b1-244">Is some systems, autoincremented fields can't be coordinated across shards, possibly resulting in items in different shards having the same shard key.</span></span>

    >  <span data-ttu-id="f46b1-245">Problémákat okozhatnak az egyéb olyan mezők automatikusan növekvő értékei is, amelyek nem szegmenskulcsok.</span><span class="sxs-lookup"><span data-stu-id="f46b1-245">Autoincremented values in other fields that are not shard keys can also cause problems.</span></span> <span data-ttu-id="f46b1-246">Ha például automatikusan növekvő mezőkkel hoz létre egyedi azonosítókat, akkor két különböző szegmensben lévő két különböző elemhez ugyanaz az azonosító lehet hozzárendelve.</span><span class="sxs-lookup"><span data-stu-id="f46b1-246">For example, if you use autoincremented fields to generate unique IDs, then two different items located in different shards might be assigned the same ID.</span></span>

- <span data-ttu-id="f46b1-247">Előfordulhat, hogy nem lehet olyan szegmenskulcsot tervezni, amely megfelel az adatokra irányuló minden lehetséges lekérdezés követelményeinek.</span><span class="sxs-lookup"><span data-stu-id="f46b1-247">It might not be possible to design a shard key that matches the requirements of every possible query against the data.</span></span> <span data-ttu-id="f46b1-248">Az adatok horizontális skálázásával támogassa a leggyakrabban végrehajtott lekérdezéseket, és szükség esetén hozzon létre másodlagos indextáblákat azon lekérdezések támogatásához, amelyek a szegmenskulcs részét nem képező attribútumokon alapuló feltételek használatával kérdezik le az adatokat.</span><span class="sxs-lookup"><span data-stu-id="f46b1-248">Shard the data to support the most frequently performed queries, and if necessary create secondary index tables to support queries that retrieve data using criteria based on attributes that aren't part of the shard key.</span></span> <span data-ttu-id="f46b1-249">További információ: [indextábla minta](./index-table.md).</span><span class="sxs-lookup"><span data-stu-id="f46b1-249">For more information, see the [Index Table pattern](./index-table.md).</span></span>

- <span data-ttu-id="f46b1-250">A csak egy szegmenst elérő lekérdezések hatékonyabbak, mint az adatokat több szegmensből lekérő lekérdezések, ezért ne valósítson meg olyan horizontális skálázási rendszert, amely azt eredményezi, hogy az alkalmazások a különböző szegmensekben tárolt adatokat egyesítő nagyszámú lekérdezést hajtanak végre.</span><span class="sxs-lookup"><span data-stu-id="f46b1-250">Queries that access only a single shard are more efficient than those that retrieve data from multiple shards, so avoid implementing a sharding system that results in applications performing large numbers of queries that join data held in different shards.</span></span> <span data-ttu-id="f46b1-251">Ne feledje, hogy egyetlen szegmens több entitástípus adatait is tartalmazhatja.</span><span class="sxs-lookup"><span data-stu-id="f46b1-251">Remember that a single shard can contain the data for multiple types of entities.</span></span> <span data-ttu-id="f46b1-252">Érdemes lehet denormalizálni az adatokat, hogy a gyakran együtt lekérdezett kapcsolódó entitások (például az ügyfelek és az általuk kezdeményezett megrendelések adatai) ugyanazon a szegmensben legyenek az alkalmazások által végrehajtott különálló olvasások számának a csökkentéséhez.</span><span class="sxs-lookup"><span data-stu-id="f46b1-252">Consider denormalizing your data to keep related entities that are commonly queried together (such as the details of customers and the orders that they have placed) in the same shard to reduce the number of separate reads that an application performs.</span></span>

    >  <span data-ttu-id="f46b1-253">Ha az egyik szegmensben lévő entitás egy másik szegmensben tárolt entitásra hivatkozik, az első entitás sémájának részeként adja meg a második entitás szegmenskulcsát.</span><span class="sxs-lookup"><span data-stu-id="f46b1-253">If an entity in one shard references an entity stored in another shard, include the shard key for the second entity as part of the schema for the first entity.</span></span> <span data-ttu-id="f46b1-254">Ez hozzájárulhat a szegmenseken található kapcsolódó adatokra hivatkozó lekérdezések teljesítményének a javításához.</span><span class="sxs-lookup"><span data-stu-id="f46b1-254">This can help to improve the performance of queries that reference related data across shards.</span></span>

- <span data-ttu-id="f46b1-255">Ha egy alkalmazásnak az adatokat több szegmensből lekérő lekérdezéseket kell végrehajtania, lehet, hogy az adatok lekérhetők párhuzamos tevékenységek használatával.</span><span class="sxs-lookup"><span data-stu-id="f46b1-255">If an application must perform queries that retrieve data from multiple shards, it might be possible to fetch this data by using parallel tasks.</span></span> <span data-ttu-id="f46b1-256">Erre példa az elosztott lekérdezés, ahol a rendszer több szegmens adatait kéri le párhuzamosan, majd egyetlen eredményben összesíti azokat.</span><span class="sxs-lookup"><span data-stu-id="f46b1-256">Examples include fan-out queries, where data from multiple shards is retrieved in parallel and then aggregated into a single result.</span></span> <span data-ttu-id="f46b1-257">Ez a megközelítés azonban elkerülhetetlenül összetetté teszi a megoldások adatelérési logikáját.</span><span class="sxs-lookup"><span data-stu-id="f46b1-257">However, this approach inevitably adds some complexity to the data access logic of a solution.</span></span>

- <span data-ttu-id="f46b1-258">Sok alkalmazás esetén hatékonyabb lehet több kisméretű szegmens létrehozása, mint kevés nagyméretű használata, mert ez több lehetőséget kínál a terheléselosztáshoz.</span><span class="sxs-lookup"><span data-stu-id="f46b1-258">For many applications, creating a larger number of small shards can be more efficient than having a small number of large shards because they can offer increased opportunities for load balancing.</span></span> <span data-ttu-id="f46b1-259">Ez akkor is hasznos lehet, ha várhatóan az egyik fizikai helyről egy másikra kell szegmenseket migrálnia.</span><span class="sxs-lookup"><span data-stu-id="f46b1-259">This can also be useful if you anticipate the need to migrate shards from one physical location to another.</span></span> <span data-ttu-id="f46b1-260">A kis szegmensek gyorsabban áthelyezhetők, mint a nagyok.</span><span class="sxs-lookup"><span data-stu-id="f46b1-260">Moving a small shard is quicker than moving a large one.</span></span>

- <span data-ttu-id="f46b1-261">Gondoskodjon róla, hogy az egyes szegmenstároló csomópontok erőforrásai elegendőek legyenek a skálázhatósági követelmények kezelésére az adatméret és a feldolgozási sebesség tekintetében.</span><span class="sxs-lookup"><span data-stu-id="f46b1-261">Make sure the resources available to each shard storage node are sufficient to handle the scalability requirements in terms of data size and throughput.</span></span> <span data-ttu-id="f46b1-262">További információért tekintse meg az [Adatparticionálási útmutató](https://msdn.microsoft.com/library/dn589795.aspx) „Partíciók tervezése skálázhatóságra” című szakaszát.</span><span class="sxs-lookup"><span data-stu-id="f46b1-262">For more information, see the section “Designing Partitions for Scalability” in the [Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span>

- <span data-ttu-id="f46b1-263">Vegye fontolóra a referenciaadatok replikálását minden szegmensre.</span><span class="sxs-lookup"><span data-stu-id="f46b1-263">Consider replicating reference data to all shards.</span></span> <span data-ttu-id="f46b1-264">Ha egy szegmensből adatokat lekérő művelet statikus vagy lassan mozgó adatokra is hivatkozik ugyanazon lekérdezés részeként, adja hozzá ezeket az adatokat a szegmenshez.</span><span class="sxs-lookup"><span data-stu-id="f46b1-264">If an operation that retrieves data from a shard also references static or slow-moving data as part of the same query, add this data to the shard.</span></span> <span data-ttu-id="f46b1-265">Az alkalmazás ezután könnyedén le tudja kérni a lekérdezés összes adatát anélkül, hogy további adatváltást kellene végrehajtania egy különálló adattárral.</span><span class="sxs-lookup"><span data-stu-id="f46b1-265">The application can then fetch all of the data for the query easily, without having to make an additional round trip to a separate data store.</span></span>

    >  <span data-ttu-id="f46b1-266">Ha a több szegmensben tárolt referenciaadatok megváltoznak, a rendszernek szinkronizálnia kell ezeket a változásokat minden szegmensben.</span><span class="sxs-lookup"><span data-stu-id="f46b1-266">If reference data held in multiple shards changes, the system must synchronize these changes across all shards.</span></span> <span data-ttu-id="f46b1-267">A rendszer valamilyen fokú inkonzisztenciát tapasztalhat az ilyen szinkronizálás során.</span><span class="sxs-lookup"><span data-stu-id="f46b1-267">The system can experience a degree of inconsistency while this synchronization occurs.</span></span> <span data-ttu-id="f46b1-268">Ez esetben úgy kell megterveznie az alkalmazásokat, hogy képesek legyenek ennek kezelésére.</span><span class="sxs-lookup"><span data-stu-id="f46b1-268">If you do this, you should design your applications to be able to handle it.</span></span>

- <span data-ttu-id="f46b1-269">Nehéznek bizonyulhat a hivatkozások integritásának és a szegmensek közötti konzisztenciának a fenntartása, ezért minimálisra kell csökkentenie a több szegmensben lévő adatokra hatással lévő műveletek számát.</span><span class="sxs-lookup"><span data-stu-id="f46b1-269">It can be difficult to maintain referential integrity and consistency between shards, so you should minimize operations that affect data in multiple shards.</span></span> <span data-ttu-id="f46b1-270">Ha egy alkalmazásnak több szegmensben található adatokat kell módosítania, mérje fel, hogy valóban szükség van-e az adatok teljes konzisztenciájára.</span><span class="sxs-lookup"><span data-stu-id="f46b1-270">If an application must modify data across shards, evaluate whether complete data consistency is actually required.</span></span> <span data-ttu-id="f46b1-271">Ehelyett egy, a felhőben gyakran alkalmazott megközelítés a végső konzisztencia megvalósítása.</span><span class="sxs-lookup"><span data-stu-id="f46b1-271">Instead, a common approach in the cloud is to implement eventual consistency.</span></span> <span data-ttu-id="f46b1-272">Az egyes partíciók adatainak frissítése külön történik, és az alkalmazáslogikának felelősséget kell vállalnia a frissítések mindegyikének sikeres befejezéséért, valamint egy végül konzisztensnek bizonyuló művelet futása során az adatok lekérdezéséből fakadó inkonzisztencia kezeléséért.</span><span class="sxs-lookup"><span data-stu-id="f46b1-272">The data in each partition is updated separately, and the application logic must take responsibility for ensuring that the updates all complete successfully, as well as handling the inconsistencies that can arise from querying data while an eventually consistent operation is running.</span></span> <span data-ttu-id="f46b1-273">A végül bekövetkező konzisztenciával kapcsolatos további információkat az [adatkonzisztenciát ismertető](https://msdn.microsoft.com/library/dn589800.aspx) szakaszban találja.</span><span class="sxs-lookup"><span data-stu-id="f46b1-273">For more information about implementing eventual consistency, see the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

- <span data-ttu-id="f46b1-274">Sok szegmens konfigurálása és kezelése kihívást jelenthet.</span><span class="sxs-lookup"><span data-stu-id="f46b1-274">Configuring and managing a large number of shards can be a challenge.</span></span> <span data-ttu-id="f46b1-275">Az olyan feladatokat, mint a monitorozás, biztonsági mentés, konzisztencia-ellenőrzés és naplózás, különálló, lehetőség szerint több helyen található szegmenseken és kiszolgálókon kell végezni.</span><span class="sxs-lookup"><span data-stu-id="f46b1-275">Tasks such as monitoring, backing up, checking for consistency, and logging or auditing must be accomplished on multiple shards and servers, possibly held in multiple locations.</span></span> <span data-ttu-id="f46b1-276">Ezek a feladatok valószínűleg megvalósíthatók szkriptekkel vagy más automatizálási megoldásokkal, azonban lehet, hogy ezek nem küszöbölik ki teljesen a további felügyeleti követelményeket.</span><span class="sxs-lookup"><span data-stu-id="f46b1-276">These tasks are likely to be implemented using scripts or other automation solutions, but that might not completely eliminate the additional administrative requirements.</span></span>

- <span data-ttu-id="f46b1-277">A szegmensek földrajzi helyhez köthetők, hogy az általuk tárolt adatok közel legyenek az adatokat használó alkalmazások példányaihoz.</span><span class="sxs-lookup"><span data-stu-id="f46b1-277">Shards can be geolocated so that the data that they contain is close to the instances of an application that use it.</span></span> <span data-ttu-id="f46b1-278">Ez a módszer jelentősen javíthatja a teljesítményt, azonban további szempontokat kell figyelembe venni olyan feladatok esetén, amelyeknek több, különböző helyeken található szegmenst kell elérniük.</span><span class="sxs-lookup"><span data-stu-id="f46b1-278">This approach can considerably improve performance, but requires additional consideration for tasks that must access multiple shards in different locations.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="f46b1-279">Mikor érdemes ezt a mintát használni?</span><span class="sxs-lookup"><span data-stu-id="f46b1-279">When to use this pattern</span></span>

<span data-ttu-id="f46b1-280">Akkor használja ezt a mintát, ha egy adattárat valószínűleg egy adott tárolócsomópont számára elérhető erőforrásokon túl kell skálázni, vagy amikor javítani szeretné a teljesítményt egy adattárban tapasztalható versengés csökkentésével.</span><span class="sxs-lookup"><span data-stu-id="f46b1-280">Use this pattern when a data store is likely to need to scale beyond the resources available to a single storage node, or to improve performance by reducing contention in a data store.</span></span>

> [!NOTE]
<span data-ttu-id="f46b1-281">A horizontális skálázás elsődleges célja a rendszerek teljesítményének és a skálázhatóságnak a javítása, mellékhatásként azonban a rendelkezésre állást is növelheti attól függően, hogy az adatok hogyan lettek külön partíciókra osztva.</span><span class="sxs-lookup"><span data-stu-id="f46b1-281">The primary focus of sharding is to improve the performance and scalability of a system, but as a by-product it can also improve availability due to how the data is divided into separate partitions.</span></span> <span data-ttu-id="f46b1-282">Egy partíción bekövetkező hiba nem akadályozza meg feltétlenül, hogy egy alkalmazás elérje a többi partíción tárolt adatokat, és egy operátor egy vagy több helyen végezhet karbantartást vagy helyreállítást anélkül, hogy egy alkalmazás összes adata elérhetetlenné váljon.</span><span class="sxs-lookup"><span data-stu-id="f46b1-282">A failure in one partition doesn't necessarily prevent an application from accessing data held in other partitions, and an operator can perform maintenance or recovery of one or more partitions without making the entire data for an application inaccessible.</span></span> <span data-ttu-id="f46b1-283">További információ: [Adatparticionálási útmutató](https://msdn.microsoft.com/library/dn589795.aspx).</span><span class="sxs-lookup"><span data-stu-id="f46b1-283">For more information, see the [Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span>

## <a name="example"></a><span data-ttu-id="f46b1-284">Példa</span><span class="sxs-lookup"><span data-stu-id="f46b1-284">Example</span></span>

<span data-ttu-id="f46b1-285">Az alábbi, C# nyelven írt példa SQL Server-adatbázisokat használ szegmensekként.</span><span class="sxs-lookup"><span data-stu-id="f46b1-285">The following example in C# uses a set of SQL Server databases acting as shards.</span></span> <span data-ttu-id="f46b1-286">Az egyes adatbázisok az alkalmazás által használt adatok egy részét tartalmazzák.</span><span class="sxs-lookup"><span data-stu-id="f46b1-286">Each database holds a subset of the data used by an application.</span></span> <span data-ttu-id="f46b1-287">Az alkalmazás a saját horizontális skálázási logikájával kéri le a szegmensek között elosztott adatokat (ez egy példa az elosztott lekérdezésre).</span><span class="sxs-lookup"><span data-stu-id="f46b1-287">The application retrieves data that's distributed across the shards using its own sharding logic (this is an example of a fan-out query).</span></span> <span data-ttu-id="f46b1-288">Az egyes szegmensekben található adatok részleteit a `GetShards` nevű metódus adja vissza.</span><span class="sxs-lookup"><span data-stu-id="f46b1-288">The details of the data that's located in each shard is returned by a method called `GetShards`.</span></span> <span data-ttu-id="f46b1-289">Ez a metódus a `ShardInformation` objektumok enumerálható listáját adja vissza, amelyen a `ShardInformation` típus tartalmazza az egyes szegmensek azonosítóját és azon SQL Server kapcsolati sztringet, amellyel az alkalmazásnak a szegmenshez kell kapcsolódnia (a kapcsolati sztringek nem láthatók a kódpéldában).</span><span class="sxs-lookup"><span data-stu-id="f46b1-289">This method returns an enumerable list of `ShardInformation` objects, where the `ShardInformation` type contains an identifier for each shard and the SQL Server connection string that an application should use to connect to the shard (the connection strings aren't shown in the code example).</span></span>

```csharp
private IEnumerable<ShardInformation> GetShards()
{
  // This retrieves the connection information from a shard store
  // (commonly a root database).
  return new[]
  {
    new ShardInformation
    {
      Id = 1,
      ConnectionString = ...
    },
    new ShardInformation
    {
      Id = 2,
      ConnectionString = ...
    }
  };
}
```

<span data-ttu-id="f46b1-290">Az alábbi kód bemutatja, hogyan használja az alkalmazás a `ShardInformation` objektumok listáját olyan lekérdezés végrehajtásához, amely mindegyik szegmensből párhuzamosan kéri le adatokat.</span><span class="sxs-lookup"><span data-stu-id="f46b1-290">The code below shows how the application uses the list of `ShardInformation` objects to perform a query that fetches data from each shard in parallel.</span></span> <span data-ttu-id="f46b1-291">A lekérdezés részletei nem láthatók, a példában a lekért adatok azonban egy sztringet tartalmaznak, amely információkat tartalmazhat, például egy ügyfél nevét, ha a szegmensek tartalmazzák az ügyfelek adatait.</span><span class="sxs-lookup"><span data-stu-id="f46b1-291">The details of the query aren't shown, but in this example the data that's retrieved contains a string that could hold information such as the name of a customer if the shards contain the details of customers.</span></span> <span data-ttu-id="f46b1-292">Az eredményeket egy `ConcurrentBag` gyűjteményben összesíti a rendszer az alkalmazás általi feldolgozáshoz.</span><span class="sxs-lookup"><span data-stu-id="f46b1-292">The results are aggregated into a `ConcurrentBag` collection for processing by the application.</span></span>

```csharp
// Retrieve the shards as a ShardInformation[] instance.
var shards = GetShards();

var results = new ConcurrentBag<string>();

// Execute the query against each shard in the shard list.
// This list would typically be retrieved from configuration
// or from a root/master shard store.
Parallel.ForEach(shards, shard =>
{
  // NOTE: Transient fault handling isn't included,
  // but should be incorporated when used in a real world application.
  using (var con = new SqlConnection(shard.ConnectionString))
  {
    con.Open();
    var cmd = new SqlCommand("SELECT ... FROM ...", con);

    Trace.TraceInformation("Executing command against shard: {0}", shard.Id);

    var reader = cmd.ExecuteReader();
    // Read the results in to a thread-safe data structure.
    while (reader.Read())
    {
      results.Add(reader.GetString(0));
    }
  }
});

Trace.TraceInformation("Fanout query complete - Record Count: {0}",
                        results.Count);
```

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="f46b1-293">Kapcsolódó minták és útmutatók</span><span class="sxs-lookup"><span data-stu-id="f46b1-293">Related patterns and guidance</span></span>

<span data-ttu-id="f46b1-294">Az alábbi minták és útmutatók szintén hasznosak lehetnek a minta megvalósításakor:</span><span class="sxs-lookup"><span data-stu-id="f46b1-294">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="f46b1-295">[Adatkonzisztencia – Ismertető](https://msdn.microsoft.com/library/dn589800.aspx).</span><span class="sxs-lookup"><span data-stu-id="f46b1-295">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span> <span data-ttu-id="f46b1-296">A különböző szegmensek között elosztott adatok konzisztenciájának megőrzéséhez lehet szükséges.</span><span class="sxs-lookup"><span data-stu-id="f46b1-296">It might be necessary to maintain consistency for data distributed across different shards.</span></span> <span data-ttu-id="f46b1-297">A cikk összefoglalja az elosztott adatok konzisztenciájának megőrzésével kapcsolatos problémákat, és bemutatja a különböző konzisztenciamodellek előnyeit és hátrányait.</span><span class="sxs-lookup"><span data-stu-id="f46b1-297">Summarizes the issues surrounding maintaining consistency over distributed data, and describes the benefits and tradeoffs of different consistency models.</span></span>
- <span data-ttu-id="f46b1-298">[Adatparticionálási útmutató](https://msdn.microsoft.com/library/dn589795.aspx).</span><span class="sxs-lookup"><span data-stu-id="f46b1-298">[Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span> <span data-ttu-id="f46b1-299">Az adattárak horizontális skálázása további problémákat vethet fel.</span><span class="sxs-lookup"><span data-stu-id="f46b1-299">Sharding a data store can introduce a range of additional issues.</span></span> <span data-ttu-id="f46b1-300">Ez az útmutató az adattáraknak a skálázhatóság növelése, a versengés csökkentése és a teljesítmény optimalizálása érdekében a felhőben történő particionálásával kapcsolatos problémákat ismerteti.</span><span class="sxs-lookup"><span data-stu-id="f46b1-300">Describes these issues in relation to partitioning data stores in the cloud to improve scalability, reduce contention, and optimize performance.</span></span>
- <span data-ttu-id="f46b1-301">[Index Table minta](./index-table.md).</span><span class="sxs-lookup"><span data-stu-id="f46b1-301">[Index Table pattern](./index-table.md).</span></span> <span data-ttu-id="f46b1-302">A lekérdezések néha nem támogathatók teljes mértékben pusztán a szegmenskulcs kialakításának segítségével.</span><span class="sxs-lookup"><span data-stu-id="f46b1-302">Sometimes it isn't possible to completely support queries just through the design of the shard key.</span></span> <span data-ttu-id="f46b1-303">Lehetővé teszi, hogy az alkalmazások gyorsan kérjenek le adatokat egy nagy adattárból a szegmenskulcstól eltérő kulcs megadásával.</span><span class="sxs-lookup"><span data-stu-id="f46b1-303">Enables an application to quickly retrieve data from a large data store by specifying a key other than the shard key.</span></span>
- <span data-ttu-id="f46b1-304">[Tényleges táblán alapuló nézet minta](./materialized-view.md).</span><span class="sxs-lookup"><span data-stu-id="f46b1-304">[Materialized View pattern](./materialized-view.md).</span></span> <span data-ttu-id="f46b1-305">Bizonyos lekérdezési műveletek teljesítményének fenntartása érdekében célszerű materializált nézeteket létrehozni, amelyek egyesítik és összegzik az adatokat, különösen akkor, ha ezek az összegzett adatok a szegmensek között elosztott információkon alapulnak.</span><span class="sxs-lookup"><span data-stu-id="f46b1-305">To maintain the performance of some query operations, it's useful to create materialized views that aggregate and summarize data, especially if this summary data is based on information that's distributed across shards.</span></span> <span data-ttu-id="f46b1-306">Ismerteti, hogyan hozhatja létre és töltheti fel adatokkal ezeket a nézeteket.</span><span class="sxs-lookup"><span data-stu-id="f46b1-306">Describes how to generate and populate these views.</span></span>
