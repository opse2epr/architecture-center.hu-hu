---
title: Event Sourcing
description: "Használhat egy csak hozzáfűzéssel bővíthető tárat az egy tartomány adatain elvégzett műveleteket leíró események teljes sorozatának rögzítésére."
keywords: "tervezési minta"
author: dragon119
ms.date: 06/23/2017
pnp.series.title: Cloud Design Patterns
pnp.pattern.categories:
- data-management
- performance-scalability
ms.openlocfilehash: 9a0bf170c9b54c3b2ee9cc91d6dcb5c55a13b96a
ms.sourcegitcommit: ea7108f71dab09175ff69322874d1bcba800a37a
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 03/17/2018
---
# <a name="event-sourcing-pattern"></a><span data-ttu-id="710f4-104">Események forráskezelése minta</span><span class="sxs-lookup"><span data-stu-id="710f4-104">Event Sourcing pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="710f4-105">Ahelyett, hogy a tartomány adatainak csak az aktuális állapotát tárolná, egy csak hozzáfűzéssel bővíthető tár használatával rögzítheti az adatokon végzett műveletek teljes sorozatát is.</span><span class="sxs-lookup"><span data-stu-id="710f4-105">Instead of storing just the current state of the data in a domain, use an append-only store to record the full series of actions taken on that data.</span></span>
<span data-ttu-id="710f4-106">A tároló rekordrendszerként működik, és a használatával tényleges táblává alakíthatóak tartományi objektumok.</span><span class="sxs-lookup"><span data-stu-id="710f4-106">The store acts as the system of record and can be used to materialize the domain objects.</span></span> <span data-ttu-id="710f4-107">Ez egyszerűsítheti a feladatokat az összetett tartományokban, mivel nem szükséges szinkronizálni az adatmodellt és a vállalati tartományt, miközben nő a teljesítmény, a skálázhatóság és a válaszképesség.</span><span class="sxs-lookup"><span data-stu-id="710f4-107">This can simplify tasks in complex domains, by avoiding the need to synchronize the data model and the business domain, while improving performance, scalability, and responsiveness.</span></span> <span data-ttu-id="710f4-108">Emellett konzisztenciát kölcsönöz a tranzakciós adatoknak, és teljeskörű naplókat és előzményeket tárol, ami lehetővé teszi a kompenzáló műveletek végrehajtását.</span><span class="sxs-lookup"><span data-stu-id="710f4-108">It can also provide consistency for transactional data, and maintain full audit trails and history that can enable compensating actions.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="710f4-109">Kontextus és probléma</span><span class="sxs-lookup"><span data-stu-id="710f4-109">Context and problem</span></span>

<span data-ttu-id="710f4-110">A legtöbb alkalmazás adatokkal dolgozik, és a szokásos megközelítés szerint az alkalmazás az adatok aktuális állapotát tárolja, és folyamatosan frissíti, ahogy a felhasználók használják azokat.</span><span class="sxs-lookup"><span data-stu-id="710f4-110">Most applications work with data, and the typical approach is for the application to maintain the current state of the data by updating it as users work with it.</span></span> <span data-ttu-id="710f4-111">Például a hagyományos CRUD (create – létrehozás, read – olvasás, update – frissítés, delete – törlés) modellben a tipikus adatfolyamat szerint az alkalmazás beolvassa az adatokat a tárolóból, bizonyos módosításokat végez azokon, majd frissíti az adatok aktuális állapotát az új értékekkel,&mdash;gyakran olyan tranzakciók használatával, amelyek zárolják az adatokat.</span><span class="sxs-lookup"><span data-stu-id="710f4-111">For example, in the traditional create, read, update, and delete (CRUD) model a typical data process is to read data from the store, make some modifications to it, and update the current state of the data with the new values&mdash;often by using transactions that lock the data.</span></span>

<span data-ttu-id="710f4-112">A CRUD megközelítésnek vannak bizonyos korlátai:</span><span class="sxs-lookup"><span data-stu-id="710f4-112">The CRUD approach has some limitations:</span></span>

- <span data-ttu-id="710f4-113">A CRUD rendszerek a frissítési műveleteket közvetlenül az adattárolóban hajtják végre, ami ronthatja a teljesítményt és a válaszképességet, valamint a szükséges feldolgozási többletterhelés miatt korlátozhatja a skálázhatóságot.</span><span class="sxs-lookup"><span data-stu-id="710f4-113">CRUD systems perform update operations directly against a data store, which can slow down performance and responsiveness, and limit scalability, due to the processing overhead it requires.</span></span>

- <span data-ttu-id="710f4-114">A nagyszámú egyidejű felhasználót tartalmazó együttműködési tartományokban az adatfrissítés konfliktusok valószínűbbek, mivel a frissítési műveletek egyetlen adatelemen vannak végrehajtva.</span><span class="sxs-lookup"><span data-stu-id="710f4-114">In a collaborative domain with many concurrent users, data update conflicts are more likely because the update operations take place on a single item of data.</span></span>

- <span data-ttu-id="710f4-115">Hacsak nincs valamilyen további naplózási mechanizmus kiépítve, amely az egyes műveletek részleteit egy külön naplóban rögzíti, az előzmények elvesznek.</span><span class="sxs-lookup"><span data-stu-id="710f4-115">Unless there's an additional auditing mechanism that records the details of each operation in a separate log, history is lost.</span></span>

> <span data-ttu-id="710f4-116">A CRUD megközelítés korlátairól részletesebben a [CRUD – csak akkor, ha megengedheti](https://blogs.msdn.microsoft.com/maarten_mullender/2004/07/23/crud-only-when-you-can-afford-it-revisited/) című cikkben olvashat.</span><span class="sxs-lookup"><span data-stu-id="710f4-116">For a deeper understanding of the limits of the CRUD approach see [CRUD, Only When You Can Afford It](https://blogs.msdn.microsoft.com/maarten_mullender/2004/07/23/crud-only-when-you-can-afford-it-revisited/).</span></span>

## <a name="solution"></a><span data-ttu-id="710f4-117">Megoldás</span><span class="sxs-lookup"><span data-stu-id="710f4-117">Solution</span></span>

<span data-ttu-id="710f4-118">Az Események forráskezelése minta az adatokon végrehajtott műveletek kezelésére eseménysorozat-alapú megközelítést definiál, amelyben az események egy csak hozzáfűzéssel bővíthető tárban vannak rögzítve.</span><span class="sxs-lookup"><span data-stu-id="710f4-118">The Event Sourcing pattern defines an approach to handling operations on data that's driven by a sequence of events, each of which is recorded in an append-only store.</span></span> <span data-ttu-id="710f4-119">Az alkalmazáskód ez egyes adatműveleteket imperatív módon leíró események sorát küldi a tárolóba, ahol azok megőrződnek.</span><span class="sxs-lookup"><span data-stu-id="710f4-119">Application code sends a series of events that imperatively describe each action that has occurred on the data to the event store, where they're persisted.</span></span> <span data-ttu-id="710f4-120">Mindegyik esemény az adatok módosításainak egy halmazát (például `AddedItemToOrder`) jelöli.</span><span class="sxs-lookup"><span data-stu-id="710f4-120">Each event represents a set of changes to the data (such as `AddedItemToOrder`).</span></span>

<span data-ttu-id="710f4-121">Az eseményeket egy eseménytár őrzi, amely az adatok aktuális állapotát rögzítő rekordrendszerként (mérvadó adatforrásként) működik.</span><span class="sxs-lookup"><span data-stu-id="710f4-121">The events are persisted in an event store that acts as the system of record (the authoritative data source) about the current state of the data.</span></span> <span data-ttu-id="710f4-122">Az eseménytár általában közzéteszi ezeket az eseményeket, hogy a felhasználók értesüljenek róluk, és szükség szerint kezelhessék azokat.</span><span class="sxs-lookup"><span data-stu-id="710f4-122">The event store typically publishes these events so that consumers can be notified and can handle them if needed.</span></span> <span data-ttu-id="710f4-123">A fogyasztók például inicializálhatnak olyan feladatokat, amelyek az eseményekben lévő műveleteket más rendszerekre alkalmazzák, vagy egyéb kapcsolódó műveleteket hajtanak végre, amelyek a működéshez szükségesek.</span><span class="sxs-lookup"><span data-stu-id="710f4-123">Consumers could, for example, initiate tasks that apply the operations in the events to other systems, or perform any other associated action that's required to complete the operation.</span></span> <span data-ttu-id="710f4-124">Vegyük észre, hogy az eseményeket létrehozó alkalmazáskód elválik az eseményekre feliratkozó rendszerektől.</span><span class="sxs-lookup"><span data-stu-id="710f4-124">Notice that the application code that generates the events is decoupled from the systems that subscribe to the events.</span></span>

<span data-ttu-id="710f4-125">Az eseménytár által közzétett események tipikus felhasználása az entitások tényleges táblán alapuló nézeteinek karbantartása, ahogy az alkalmazás műveletei módosítják azokat, valamint a külső rendszerekkel való integráció biztosítása.</span><span class="sxs-lookup"><span data-stu-id="710f4-125">Typical uses of the events published by the event store are to maintain materialized views of entities as actions in the application change them, and for integration with external systems.</span></span> <span data-ttu-id="710f4-126">Például a rendszer megtarthatja az összes olyan ügyfélmegrendelés tényleges táblán alapuló nézetét, amelyek a felhasználói felület részein megjelentek.</span><span class="sxs-lookup"><span data-stu-id="710f4-126">For example, a system can maintain a materialized view of all customer orders that's used to populate parts of the UI.</span></span> <span data-ttu-id="710f4-127">Ahogy az alkalmazás új megrendeléseket ad hozzá, tételeket ad hozzá vagy távolít el a megrendelésekben, szállítási információkat ad hozzá, az ezeket a módosításokat leíró események kezelhetőek, és a használatukkal frissíthetőek a [tényleges táblán alapuló nézetek](materialized-view.md).</span><span class="sxs-lookup"><span data-stu-id="710f4-127">As the application adds new orders, adds or removes items on the order, and adds shipping information, the events that describe these changes can be handled and used to update the [materialized view](materialized-view.md).</span></span>

<span data-ttu-id="710f4-128">Emellett az alkalmazásoknak bármikor lehetősége van olvasni az eseményelőzményeket, és azok használatával tényleges táblává alakítani az entitások aktuális állapotát az adott eseményhez tartozó összes esemény visszajátszásával és feldolgozásával.</span><span class="sxs-lookup"><span data-stu-id="710f4-128">In addition, at any point it's possible for applications to read the history of events, and use it to materialize the current state of an entity by playing back and consuming all the events related to that entity.</span></span> <span data-ttu-id="710f4-129">Ez történhet igény szerint a tartományobjektumok tényleges táblává alakításával a kérések feldolgozása során, vagy pedig ütemezett feladatokon keresztül, hogy az entitás állapota tényleges táblán alapuló nézetként tárolható legyen a megjelenítési réteg kiszolgálására.</span><span class="sxs-lookup"><span data-stu-id="710f4-129">This can occur on demand to materialize a domain object when handling a request, or through a scheduled task so that the state of the entity can be stored as a materialized view to support the presentation layer.</span></span>

<span data-ttu-id="710f4-130">Az ábrán a minta áttekintése látható, beleértve az eseménystream használata kínálta egyes lehetőségeket, például a tényleges táblán alapuló nézetek létrehozását, az események külső alkalmazásokkal és rendszerekkel való integrálását, valamint az események visszajátszását az adott entitások aktuális állapotai leképezéseinek létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="710f4-130">The figure shows an overview of the pattern, including some of the options for using the event stream such as creating a materialized view, integrating events with external applications and systems, and replaying events to create projections of the current state of specific entities.</span></span>

![Az Események forráskezelése minta áttekintése és példája](./_images/event-sourcing-overview.png)


<span data-ttu-id="710f4-132">Az Események forráskezelése minta az alábbi előnyöket biztosítja:</span><span class="sxs-lookup"><span data-stu-id="710f4-132">The Event Sourcing pattern provides the following advantages:</span></span>

- <span data-ttu-id="710f4-133">Az események nem módosíthatók, és egy csak hozzáfűzési művelettel tárolhatók.</span><span class="sxs-lookup"><span data-stu-id="710f4-133">Events are immutable and can be stored using an append-only operation.</span></span> <span data-ttu-id="710f4-134">Az eseményt inicializáló felhasználói felület, munkafolyamat vagy folyamat folytatódhat, és az eseményeket kezelő feladatok a háttérben futhatnak.</span><span class="sxs-lookup"><span data-stu-id="710f4-134">The user interface, workflow, or process that initiated an event can continue, and tasks that handle the events can run in the background.</span></span> <span data-ttu-id="710f4-135">Kombinálva azzal a ténnyel, hogy a tranzakciók a feldolgozás során nem versengenek, ez rendkívüli mértékben javíthatja az alkalmazások teljesítményét és skálázhatóságét, különösen a megjelenítési szint vagy a felhasználói felület vonatkozásában.</span><span class="sxs-lookup"><span data-stu-id="710f4-135">This, combined with the fact that there's no contention during the processing of transactions, can vastly improve performance and scalability for applications, especially for the presentation level or user interface.</span></span>

- <span data-ttu-id="710f4-136">Az események olyan egyszerű objektumok, amelyek valamely megtörtént műveletet írnak le, az esemény által jelölt művelet leírásához szükséges társított adatokkal együtt.</span><span class="sxs-lookup"><span data-stu-id="710f4-136">Events are simple objects that describe some action that occurred, together with any associated data required to describe the action represented by the event.</span></span> <span data-ttu-id="710f4-137">Az események közvetlenül nem frissítik az adattárakat.</span><span class="sxs-lookup"><span data-stu-id="710f4-137">Events don't directly update a data store.</span></span> <span data-ttu-id="710f4-138">Egyszerűen csak rögzítve vannak, hogy a megfelelő időben kezelhetőek legyenek.</span><span class="sxs-lookup"><span data-stu-id="710f4-138">They're simply recorded for handling at the appropriate time.</span></span> <span data-ttu-id="710f4-139">Ez egyszerűbbé teheti az implementálást és a felügyeletet.</span><span class="sxs-lookup"><span data-stu-id="710f4-139">This can simplify implementation and management.</span></span>

- <span data-ttu-id="710f4-140">Az események általában jelentéssel bírnak a tartományszakértők számára, miközben az [objektumrelációs impedanciaeltérés](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch) miatt az összetett adatbázistáblák nehezen érthetőek lehetnek.</span><span class="sxs-lookup"><span data-stu-id="710f4-140">Events typically have meaning for a domain expert, whereas [object-relational impedance mismatch](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch) can make complex database tables hard to understand.</span></span> <span data-ttu-id="710f4-141">A táblák olyan mesterséges szerkezetek, amelyek a rendszer aktuális állapotát és nem a bekövetkezett eseményeket mutatják.</span><span class="sxs-lookup"><span data-stu-id="710f4-141">Tables are artificial constructs that represent the current state of the system, not the events that occurred.</span></span>

- <span data-ttu-id="710f4-142">Az Események forráskezelése segítségével megelőzhető, hogy a párhuzamos frissítések ütközést okozzanak, mivel nem szükséges az objektumokat közvetlenül az adattárban frissíteni.</span><span class="sxs-lookup"><span data-stu-id="710f4-142">Event sourcing can help prevent concurrent updates from causing conflicts because it avoids the requirement to directly update objects in the data store.</span></span> <span data-ttu-id="710f4-143">Azonban a tartománymodellt továbbra is úgy kell kialakítani, hogy védje magát az olyan kérések ellen, amelyek inkonzisztens állapotot okozhatnak.</span><span class="sxs-lookup"><span data-stu-id="710f4-143">However, the domain model must still be designed to protect itself from requests that might result in an inconsistent state.</span></span>

- <span data-ttu-id="710f4-144">Az események csak hozzáfűzéssel bővíthető tárolása biztosítja, hogy a naplózás használatával monitorozhatóak az adattáron végrehajtott műveletek, az aktuális állapot a tényleges táblán alapuló nézetekként vagy leképezésekként újra létrehozható az események bármely pillanatban való visszajátszásával, valamint támogatja a tesztelést és a hibakeresést is.</span><span class="sxs-lookup"><span data-stu-id="710f4-144">The append-only storage of events provides an audit trail that can be used to monitor actions taken against a data store, regenerate the current state as materialized views or projections by replaying the events at any time, and assist in testing and debugging the system.</span></span> <span data-ttu-id="710f4-145">Emellett azzal, hogy a változásokat kompenzáló eseményekkel kell visszavonni, a visszavont módosítások is szerepelnek az előzményekben, ami nem így lenne, ha a modell egyszerűen csak az aktuális állapotot tárolná.</span><span class="sxs-lookup"><span data-stu-id="710f4-145">In addition, the requirement to use compensating events to cancel changes provides a history of changes that were reversed, which wouldn't be the case if the model simply stored the current state.</span></span> <span data-ttu-id="710f4-146">Az események listájának használatával emellett elemezhető az alkalmazás teljesítménye, és észlelhetőek a felhasználók viselkedési trendjei, valamint egyéb, üzleti szempontból hasznos információk is kinyerhetőek.</span><span class="sxs-lookup"><span data-stu-id="710f4-146">The list of events can also be used to analyze application performance and detect user behavior trends, or to obtain other useful business information.</span></span>

- <span data-ttu-id="710f4-147">Az eseménytár eseményeket indít, és a feladatok ezekre válaszképp hajtanak végre műveleteket.</span><span class="sxs-lookup"><span data-stu-id="710f4-147">The event store raises events, and tasks perform operations in response to those events.</span></span> <span data-ttu-id="710f4-148">A feladatok ily módú leválasztása az eseményekről biztosítja a rugalmasságot és a bővíthetőséget.</span><span class="sxs-lookup"><span data-stu-id="710f4-148">This decoupling of the tasks from the events provides flexibility and extensibility.</span></span> <span data-ttu-id="710f4-149">A feladatok ismerik az események típusát és adatait, az eseményeket kiváltó műveleteket azonban nem.</span><span class="sxs-lookup"><span data-stu-id="710f4-149">Tasks know about the type of event and the event data, but not about the operation that triggered the event.</span></span> <span data-ttu-id="710f4-150">További előny, hogy egyszerre több feladat is kezelheti az egyes eseményeket.</span><span class="sxs-lookup"><span data-stu-id="710f4-150">In addition, multiple tasks can handle each event.</span></span> <span data-ttu-id="710f4-151">Ez egyszerűsíti az integrációt az olyan szolgáltatásokkal és rendszerekkel, amelyek csak az eseménytár által kiváltott új eseményeket figyelik.</span><span class="sxs-lookup"><span data-stu-id="710f4-151">This enables easy integration with other services and systems that only listen for new events raised by the event store.</span></span> <span data-ttu-id="710f4-152">Azonban az Események forráskezelése események általában nagyon alacsony szintűek, így szükség lehet inkább adott integrációs események létrehozására.</span><span class="sxs-lookup"><span data-stu-id="710f4-152">However, the event sourcing events tend to be very low level, and it might be necessary to generate specific integration events instead.</span></span>

> <span data-ttu-id="710f4-153">Az Események forráskezelése mintát általában a CQRS mintával kombinálva alkalmazzák az adatkezelési feladatoknak az eseményekre való válaszként történő végrehajtásával és a tárolt eseményekből tényleges táblán alapuló nézeteket létrehozásával.</span><span class="sxs-lookup"><span data-stu-id="710f4-153">Event sourcing is commonly combined with the CQRS pattern by performing the data management tasks in response to the events, and by materializing views from the stored events.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="710f4-154">Problémák és megfontolandó szempontok</span><span class="sxs-lookup"><span data-stu-id="710f4-154">Issues and considerations</span></span>

<span data-ttu-id="710f4-155">A minta megvalósítása során az alábbi pontokat vegye figyelembe:</span><span class="sxs-lookup"><span data-stu-id="710f4-155">Consider the following points when deciding how to implement this pattern:</span></span>

<span data-ttu-id="710f4-156">A rendszer végül csak a tényleges táblán alapuló nézetek vagy adatleképezések a visszajátszott adatok alapján való létrehozásával válik konzisztenssé.</span><span class="sxs-lookup"><span data-stu-id="710f4-156">The system will only be eventually consistent when creating materialized views or generating projections of data by replaying events.</span></span> <span data-ttu-id="710f4-157">Bizonyos időbeli késedelem van az eseményeknek a kérések kezelése során az eseménytárba való felvétele, az események közzététele és az események a fogyasztók általi feldolgozása között.</span><span class="sxs-lookup"><span data-stu-id="710f4-157">There's some delay between an application adding events to the event store as the result of handling a request, the events being published, and consumers of the events handling them.</span></span> <span data-ttu-id="710f4-158">Ez alatt az idő alatt az entitások további módosításait leíró új események érkezhetnek az eseménytárba.</span><span class="sxs-lookup"><span data-stu-id="710f4-158">During this period, new events that describe further changes to entities might have arrived at the event store.</span></span>

> [!NOTE]
> <span data-ttu-id="710f4-159">A végleges konzisztenciával kapcsolatos információkért lásd: [Adatkonzisztencia – Ismertető](https://msdn.microsoft.com/library/dn589800.aspx).</span><span class="sxs-lookup"><span data-stu-id="710f4-159">See the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx) for information about eventual consistency.</span></span>

<span data-ttu-id="710f4-160">Az eseménytár szolgál az adatok állandó forrásaként, emiatt az eseményadatokat soha nem szabad frissíteni.</span><span class="sxs-lookup"><span data-stu-id="710f4-160">The event store is the permanent source of information, and so the event data should never be updated.</span></span> <span data-ttu-id="710f4-161">Az entitások frissítésének egyetlen módja a módosítások visszavonására, ha egy kompenzáló eseményt vesz fel az eseménytárba.</span><span class="sxs-lookup"><span data-stu-id="710f4-161">The only way to update an entity to undo a change is to add a compensating event to the event store.</span></span> <span data-ttu-id="710f4-162">Ha a megőrzött események formátumát (tehát nem magukat az adatokat) kell módosítani, például egy migrálás során, nehézkes lehet a tárolóban lévő meglévő eseményeket kombinálni az új verzióval.</span><span class="sxs-lookup"><span data-stu-id="710f4-162">If the format (rather than the data) of the persisted events needs to change, perhaps during a migration, it can be difficult to combine existing events in the store with the new version.</span></span> <span data-ttu-id="710f4-163">Esetleg szükséges lehet a módosításokat végrehajtó összes eseményt végigléptetni, hogy kompatibilisek legyenek az új formátummal, vagy az új formátumot használó új eseményeket hozzáadni.</span><span class="sxs-lookup"><span data-stu-id="710f4-163">It might be necessary to iterate through all the events making changes so they're compliant with the new format, or add new events that use the new format.</span></span> <span data-ttu-id="710f4-164">Érdemes lehet az eseményséma minden verzióját verzióbélyeggel ellátni a régi és az új eseményformátumok megtartásához.</span><span class="sxs-lookup"><span data-stu-id="710f4-164">Consider using a version stamp on each version of the event schema to maintain both the old and the new event formats.</span></span>

<span data-ttu-id="710f4-165">Az eseménytárban több szálon vagy példányban futó alkalmazások is tárolhatnak eseményeket.</span><span class="sxs-lookup"><span data-stu-id="710f4-165">Multi-threaded applications and multiple instances of applications might be storing events in the event store.</span></span> <span data-ttu-id="710f4-166">Az eseménytárban tárolt események konzisztenciája létfontosságú, csakúgy, mint az egyes entitásokra ható események sorrendje (az entitásokat érintő változások sorrendje befolyásolja azok aktuális állapotát).</span><span class="sxs-lookup"><span data-stu-id="710f4-166">The consistency of events in the event store is vital, as is the order of events that affect a specific entity (the order that changes occur to an entity affects its current state).</span></span> <span data-ttu-id="710f4-167">Segíthet elkerülni a problémákat, ha az egyes eseményeket időbélyeggel látja el.</span><span class="sxs-lookup"><span data-stu-id="710f4-167">Adding a timestamp to every event can help to avoid issues.</span></span> <span data-ttu-id="710f4-168">Egy másik gyakori eljárás, ha a kérésekből eredő minden eseményt egy növekményes azonosítóval jelöl.</span><span class="sxs-lookup"><span data-stu-id="710f4-168">Another common practice is to annotate each event resulting from a request with an incremental identifier.</span></span> <span data-ttu-id="710f4-169">Ha két művelet egyidőben próbál eseményeket hozzáadni ugyanahhoz az entitáshoz, az eseménytár elutasíthatja az olyan eseményeket, amelyek entitásazonosítója és eseményazonosítója megegyezik egy meglévőével.</span><span class="sxs-lookup"><span data-stu-id="710f4-169">If two actions attempt to add events for the same entity at the same time, the event store can reject an event that matches an existing entity identifier and event identifier.</span></span>

<span data-ttu-id="710f4-170">Nincs szabványos megközelítés vagy létező mechanizmus (mint például az SQL-lekérdezések) az események olvasására az adatok beszerzéséhez.</span><span class="sxs-lookup"><span data-stu-id="710f4-170">There's no standard approach, or existing mechanisms such as SQL queries, for reading the events to obtain information.</span></span> <span data-ttu-id="710f4-171">Adatként kizárólag eseménystreamek olvashatóak ki feltételként egy eseményazonosítót megadva.</span><span class="sxs-lookup"><span data-stu-id="710f4-171">The only data that can be extracted is a stream of events using an event identifier as the criteria.</span></span> <span data-ttu-id="710f4-172">Az eseményazonosító tipikusan egyedi entitásokra képezhető le.</span><span class="sxs-lookup"><span data-stu-id="710f4-172">The event ID typically maps to individual entities.</span></span> <span data-ttu-id="710f4-173">Egy entitás aktuális állapota csak úgy határozható meg, ha visszajátssza az összes hozzá kapcsolódó eseményt az entitás eredeti állapotából kiindulva.</span><span class="sxs-lookup"><span data-stu-id="710f4-173">The current state of an entity can be determined only by replaying all of the events that relate to it against the original state of that entity.</span></span>

<span data-ttu-id="710f4-174">Az egyes eseménystreamek hossza kihat a rendszer kezelésére és frissítésére.</span><span class="sxs-lookup"><span data-stu-id="710f4-174">The length of each event stream affects managing and updating the system.</span></span> <span data-ttu-id="710f4-175">Nagyobb streamek esetén érdemes lehet adott időközönként, például adott számú eseményenként pillanatképeket létrehozni.</span><span class="sxs-lookup"><span data-stu-id="710f4-175">If the streams are large, consider creating snapshots at specific intervals such as a specified number of events.</span></span> <span data-ttu-id="710f4-176">Az entitás aktuális állapota a pillanatképből kiindulva és az annak időpontját követően bekövetkezett eseményeket visszajátszva kérhető le.</span><span class="sxs-lookup"><span data-stu-id="710f4-176">The current state of the entity can be obtained from the snapshot and by replaying any events that occurred after that point in time.</span></span> <span data-ttu-id="710f4-177">Az adatpillanatképek létrehozásával kapcsolatos további információkért lásd: [Pillanatkép Martin Fowler Enterprise Application Architecture webhelyén](http://martinfowler.com/eaaDev/Snapshot.html) és [Mester-alárendelt pillanatkép-replikálás](https://msdn.microsoft.com/library/ff650012.aspx).</span><span class="sxs-lookup"><span data-stu-id="710f4-177">For more information about creating snapshots of data, see [Snapshot on Martin Fowler’s Enterprise Application Architecture website](http://martinfowler.com/eaaDev/Snapshot.html) and [Master-Subordinate Snapshot Replication](https://msdn.microsoft.com/library/ff650012.aspx).</span></span>

<span data-ttu-id="710f4-178">Bár az Események forráskezelése minimalizálja az adatok ütköző frissítésének esélyét, az alkalmazásnak így is képesnek kell lennie kezelni a végleges konzisztenciából és a tranzakciók hiányából eredő inkonzisztenciát.</span><span class="sxs-lookup"><span data-stu-id="710f4-178">Even though event sourcing minimizes the chance of conflicting updates to the data, the application must still be able to deal with inconsistencies that result from eventual consistency and the lack of transactions.</span></span> <span data-ttu-id="710f4-179">Például egy, a leltárkészlet csökkenését jelző esemény érkezhet az adattárba, miközben éppen egy, az adott tételre vonatkozó megrendelés érkezik, ami azt eredményezi, hogy a két művelet egyeztetni kell, és vagy az ügyfelet tájékoztatni kell, vagy egy teljesítetlen rendelést létrehozni.</span><span class="sxs-lookup"><span data-stu-id="710f4-179">For example, an event that indicates a reduction in stock inventory might arrive in the data store while an order for that item is being placed, resulting in a requirement to reconcile the two operations either by advising the customer or creating a back order.</span></span>

<span data-ttu-id="710f4-180">Az esemény-közzététel lehet „legalább egyszer” beállítású, amely esetben az események fogyasztóinak idempotensnek kell lenniük.</span><span class="sxs-lookup"><span data-stu-id="710f4-180">Event publication might be “at least once,” and so consumers of the events must be idempotent.</span></span> <span data-ttu-id="710f4-181">Az eseményekben leírt frissítéseket nem szabad ismételten alkalmazniuk, ha az esemény többször is kezelve lett.</span><span class="sxs-lookup"><span data-stu-id="710f4-181">They must not reapply the update described in an event if the event is handled more than once.</span></span> <span data-ttu-id="710f4-182">Például ha egy fogyasztó több példánya is karbantartja egy entitás valamely tulajdonságának összesítését, például a leadott megrendelések teljes számát, csak az egyiknek szabad sikeresen növelnie az összesítést a megrendelésleadás esemény bekövetkezésekor.</span><span class="sxs-lookup"><span data-stu-id="710f4-182">For example, if multiple instances of a consumer maintain an aggregate an entity's property, such as the total number of orders placed, only one must succeed in incrementing the aggregate when an order placed event occurs.</span></span> <span data-ttu-id="710f4-183">Bár nem kulcsfontosságú jellemzője az Események forráskezelése mintának, ez az általános implementációs döntés.</span><span class="sxs-lookup"><span data-stu-id="710f4-183">While this isn't a key characteristic of event sourcing, it's the usual implementation decision.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="710f4-184">Mikor érdemes ezt a mintát használni?</span><span class="sxs-lookup"><span data-stu-id="710f4-184">When to use this pattern</span></span>

<span data-ttu-id="710f4-185">Az alábbi esetekben alkalmazza ezt a mintát:</span><span class="sxs-lookup"><span data-stu-id="710f4-185">Use this pattern in the following scenarios:</span></span>

- <span data-ttu-id="710f4-186">Ha rögzíteni szeretné a szándékokat, a célokat vagy az okokat az adatokban.</span><span class="sxs-lookup"><span data-stu-id="710f4-186">When you want to capture intent, purpose, or reason in the data.</span></span> <span data-ttu-id="710f4-187">Például egy ügyfélentitás módosításai rögzíthetők adott eseménytípusok sorozataként, például _Hazaköltözött_, _Lezárt számla_ vagy _Elhalálozott_.</span><span class="sxs-lookup"><span data-stu-id="710f4-187">For example, changes to a customer entity can be captured as a series of specific event types such as _Moved home_, _Closed account_, or _Deceased_.</span></span>

- <span data-ttu-id="710f4-188">Ha elengedhetetlen az ütköző adatfrissítések előfordulásának minimalizálása vagy teljes megszüntetése.</span><span class="sxs-lookup"><span data-stu-id="710f4-188">When it's vital to minimize or completely avoid the occurrence of conflicting updates to data.</span></span>

- <span data-ttu-id="710f4-189">Ha szeretné a bekövetkező eseményeket rögzíteni, majd azok visszajátszásával visszaállítani a rendszer állapotát, visszafordítani a változásokat, vagy megőrizni az előzményeket és naplózni az eseményeket.</span><span class="sxs-lookup"><span data-stu-id="710f4-189">When you want to record events that occur, and be able to replay them to restore the state of a system, roll back changes, or keep a history and audit log.</span></span> <span data-ttu-id="710f4-190">Például ha egy feladat több lépésből áll, esetleg szükség lehet olyan műveletek végrehajtására, amelyek visszavonják a frissítéseket, majd egyes lépések visszajátszásával visszaállítják az adatokat egy konzisztens állapotba.</span><span class="sxs-lookup"><span data-stu-id="710f4-190">For example, when a task involves multiple steps you might need to execute actions to revert updates and then replay some steps to bring the data back into a consistent state.</span></span>

- <span data-ttu-id="710f4-191">Ha az események használata az alkalmazás működésének természetes funkciója, és további fejlesztést vagy implementálási ráfordítást igényel.</span><span class="sxs-lookup"><span data-stu-id="710f4-191">When using events is a natural feature of the operation of the application, and requires little additional development or implementation effort.</span></span>

- <span data-ttu-id="710f4-192">Ha le szeretné választani az adatok bevitelének vagy frissítésének folyamatát az adott műveletek alkalmazásához szükséges feladatokról.</span><span class="sxs-lookup"><span data-stu-id="710f4-192">When you need to decouple the process of inputting or updating data from the tasks required to apply these actions.</span></span> <span data-ttu-id="710f4-193">Ez történhet a felhasználói felület teljesítményének javítása vagy az események olyan figyelőkre való terjesztésének érdekében, amelyek az események bekövetkezésekor végeznek műveleteket.</span><span class="sxs-lookup"><span data-stu-id="710f4-193">This might be to improve UI performance, or to distribute events to other listeners that take action when the events occur.</span></span> <span data-ttu-id="710f4-194">Például egy bérlistarendszer integrálása egy költségbeküldési webhellyel azzal a céllal, hogy az eseménytár által a webhelyen megvalósított adatfrissítésekre válaszként indított eseményeket a webhely és a bérlistarendszer egyaránt feldolgozza.</span><span class="sxs-lookup"><span data-stu-id="710f4-194">For example, integrating a payroll system with an expense submission website so that events raised by the event store in response to data updates made in the website are consumed by both the website and the payroll system.</span></span>

- <span data-ttu-id="710f4-195">Ha szeretné tudni rugalmasan módosítani a tényleges táblává alakított modellek és entitásadatok formátumát a követelmények változásakor, vagy&mdash;a CQRS-sel való együttes használatkor&mdash;igazítania kell valamely olvasási modellt vagy az adatokat feltáró nézeteket.</span><span class="sxs-lookup"><span data-stu-id="710f4-195">When you want flexibility to be able to change the format of materialized models and entity data if requirements change, or&mdash;when used in conjunction with CQRS&mdash;you need to adapt a read model or the views that expose the data.</span></span>

- <span data-ttu-id="710f4-196">A CQRS-sel való együttes használatkor, és ha a végleges konzisztencia az olvasási modellek frissítése közben elfogadható, vagy az eseménystreamekből származó entitások és adatok rehidratálása eredményezte teljesítményváltozás elfogadható.</span><span class="sxs-lookup"><span data-stu-id="710f4-196">When used in conjunction with CQRS, and eventual consistency is acceptable while a read model is updated, or the performance impact of rehydrating entities and data from an event stream is acceptable.</span></span>

<span data-ttu-id="710f4-197">Nem érdemes ezt a mintát használni a következő helyzetekben:</span><span class="sxs-lookup"><span data-stu-id="710f4-197">This pattern might not be useful in the following situations:</span></span>

- <span data-ttu-id="710f4-198">Kis vagy egyszerű tartományok, rendszerek, kis vagy semmilyen üzleti logikával nem rendelkező rendszerek, valamint a hagyományos CRUD adatkezelési mechanizmusokkal eleve jól együttműködő nem tartományi rendszerek esetén.</span><span class="sxs-lookup"><span data-stu-id="710f4-198">Small or simple domains, systems that have little or no business logic, or nondomain systems that naturally work well with traditional CRUD data management mechanisms.</span></span>

- <span data-ttu-id="710f4-199">Olyan rendszerek esetén, ahol a konzisztencia és az adatnézetek valós idejű frissítése szükséges.</span><span class="sxs-lookup"><span data-stu-id="710f4-199">Systems where consistency and real-time updates to the views of the data are required.</span></span>

- <span data-ttu-id="710f4-200">Olyan rendszerek esetén, ahol a naplózásra, az előzmények megőrzésére, a visszaállítási képességekre és a műveletek visszajátszására nincs szükség.</span><span class="sxs-lookup"><span data-stu-id="710f4-200">Systems where audit trails, history, and capabilities to roll back and replay actions are not required.</span></span>

- <span data-ttu-id="710f4-201">Olyan rendszerek esetén, ahol a mögöttes adatok ütköző frissítései rendkívül kis eséllyel fordulnak elő.</span><span class="sxs-lookup"><span data-stu-id="710f4-201">Systems where there's only a very low occurrence of conflicting updates to the underlying data.</span></span> <span data-ttu-id="710f4-202">Például olyan rendszerek esetén, amelyek túlnyomórészt hozzáadnak, nem pedig frissítenek adatokat.</span><span class="sxs-lookup"><span data-stu-id="710f4-202">For example, systems that predominantly add data rather than updating it.</span></span>

## <a name="example"></a><span data-ttu-id="710f4-203">Példa</span><span class="sxs-lookup"><span data-stu-id="710f4-203">Example</span></span>

<span data-ttu-id="710f4-204">Egy konferenciakezelő rendszerben nyomon kell követni a kész foglalások számát, hogy lehessen tudni, van-e még szabad hely egy adott konferencián, ha egy érdeklődő foglalni szeretne.</span><span class="sxs-lookup"><span data-stu-id="710f4-204">A conference management system needs to track the number of completed bookings for a conference so that it can check whether there are seats still available when a potential attendee tries to make a booking.</span></span> <span data-ttu-id="710f4-205">A rendszer az egyes konferenciákra érkezett foglalások számát legalább kétféleképpen tárolhatja:</span><span class="sxs-lookup"><span data-stu-id="710f4-205">The system could store the total number of bookings for a conference in at least two ways:</span></span>

- <span data-ttu-id="710f4-206">A rendszer az egyes konferenciákra érkezett foglalások számára vonatkozó adatokat tárolhatja külön entitásként a foglalási adatokat tartalmazó adatbázisban.</span><span class="sxs-lookup"><span data-stu-id="710f4-206">The system could store the information about the total number of bookings as a separate entity in a database that holds booking information.</span></span> <span data-ttu-id="710f4-207">A foglalások vagy a lemondások alkalmával a rendszer megfelelően növelheti vagy csökkentheti ezt a számot.</span><span class="sxs-lookup"><span data-stu-id="710f4-207">As bookings are made or canceled, the system could increment or decrement this number as appropriate.</span></span> <span data-ttu-id="710f4-208">Ez a megközelítés elméletben egyszerű, azonban skálázhatósági problémákat okozhat, ha rövid időn belül nagy számú résztvevő próbál foglalni.</span><span class="sxs-lookup"><span data-stu-id="710f4-208">This approach is simple in theory, but can cause scalability issues if a large number of attendees are attempting to book seats during a short period of time.</span></span> <span data-ttu-id="710f4-209">Például egy foglalási időszak utolsó vagy utolsó néhány napján.</span><span class="sxs-lookup"><span data-stu-id="710f4-209">For example, in the last day or so prior to the booking period closing.</span></span>

- <span data-ttu-id="710f4-210">A rendszer a foglalásokkal és lemondásokkal kapcsolatos adatokat tárolhatja eseményekként egy eseménytárban.</span><span class="sxs-lookup"><span data-stu-id="710f4-210">The system could store information about bookings and cancellations as events held in an event store.</span></span> <span data-ttu-id="710f4-211">Ezután a szabad helyek számát ezeknek az eseményeknek a visszajátszásával számíthatja ki.</span><span class="sxs-lookup"><span data-stu-id="710f4-211">It could then calculate the number of seats available by replaying these events.</span></span> <span data-ttu-id="710f4-212">Ez a megközelítés az események változtathatatlansága miatt jobban skálázható lehet.</span><span class="sxs-lookup"><span data-stu-id="710f4-212">This approach can be more scalable due to the immutability of events.</span></span> <span data-ttu-id="710f4-213">A rendszernek csak az eseménytárból kell tudnia adatokat olvasni, vagy adatokat hozzáfűzni ugyanitt.</span><span class="sxs-lookup"><span data-stu-id="710f4-213">The system only needs to be able to read data from the event store, or append data to the event store.</span></span> <span data-ttu-id="710f4-214">A foglalások és a lemondások eseményadatai soha nem módosulnak.</span><span class="sxs-lookup"><span data-stu-id="710f4-214">Event information about bookings and cancellations is never modified.</span></span>

<span data-ttu-id="710f4-215">A következő ábra azt mutatja be, hogy a konferenciakezelő rendszer helyfoglaló alrendszere hogyan implementálható az Események forráskezelése használatával.</span><span class="sxs-lookup"><span data-stu-id="710f4-215">The following diagram illustrates how the seat reservation subsystem of the conference management system might be implemented using event sourcing.</span></span>

![Helyfoglalási adatok rögzítése az Események forráskezelése használatával egy konferenciakezelő rendszerben](./_images/event-sourcing-bounded-context.png)


<span data-ttu-id="710f4-217">Két hely foglalása esetén a műveletek sorrendje a következő:</span><span class="sxs-lookup"><span data-stu-id="710f4-217">The sequence of actions for reserving two seats is as follows:</span></span>

1. <span data-ttu-id="710f4-218">A felhasználói felület kiad egy parancsot két hely foglalására két résztvevő számára.</span><span class="sxs-lookup"><span data-stu-id="710f4-218">The user interface issues a command to reserve seats for two attendees.</span></span> <span data-ttu-id="710f4-219">A parancsot egy külön parancskezelő dolgozza fel.</span><span class="sxs-lookup"><span data-stu-id="710f4-219">The command is handled by a separate command handler.</span></span> <span data-ttu-id="710f4-220">Egy, a felhasználói felületről leválasztott és a parancsként közzétett kérések kezeléséért felelős logikai rész.</span><span class="sxs-lookup"><span data-stu-id="710f4-220">A piece of logic that is decoupled from the user interface and is responsible for handling requests posted as commands.</span></span>

2. <span data-ttu-id="710f4-221">A konferencia összes foglalásával kapcsolatos adatokat tartalmazó összesítés a foglalásokat és a lemondásokat leíró események lekérdezésével állatható össze.</span><span class="sxs-lookup"><span data-stu-id="710f4-221">An aggregate containing information about all reservations for the conference is constructed by querying the events that describe bookings and cancellations.</span></span> <span data-ttu-id="710f4-222">Az összesítés neve `SeatAvailability`, és egy olyan tartományi modell tartalmazza, amely az összesítésben foglalt adatok lekérdezésére és módosítására szolgáló metódusokat tárja fel.</span><span class="sxs-lookup"><span data-stu-id="710f4-222">This aggregate is called `SeatAvailability`, and is contained within a domain model that exposes methods for querying and modifying the data in the aggregate.</span></span>

    > <span data-ttu-id="710f4-223">A fontolóra vehető optimalizálási lehetőségek a pillanatképek használata (így az összesítés aktuális állapotának bekéréséhez nem szükséges a teljes eseménylistát lekérdezni és visszajátszani), valamint az összesítés gyorsítótárazott másolatának tárolása a memóriában.</span><span class="sxs-lookup"><span data-stu-id="710f4-223">Some optimizations to consider are using snapshots (so that you don’t need to query and replay the full list of events to obtain the current state of the aggregate), and maintaining a cached copy of the aggregate in memory.</span></span>

3. <span data-ttu-id="710f4-224">A parancskezelő egy, a tartományi modellben feltárt metódust hív meg a foglalások intézésére.</span><span class="sxs-lookup"><span data-stu-id="710f4-224">The command handler invokes a method exposed by the domain model to make the reservations.</span></span>

4. <span data-ttu-id="710f4-225">A `SeatAvailability` összesítés rögzíti a lefoglalt helyek számát tartalmazó eseményt.</span><span class="sxs-lookup"><span data-stu-id="710f4-225">The `SeatAvailability` aggregate records an event containing the number of seats that were reserved.</span></span> <span data-ttu-id="710f4-226">A következő alkalommal, amikor az összesítés valamilyen eseményt alkalmaz, a szabad helyek számát a rendszer az összes foglalás használatával számítja ki.</span><span class="sxs-lookup"><span data-stu-id="710f4-226">The next time the aggregate applies events, all the reservations will be used to compute how many seats remain.</span></span>

5. <span data-ttu-id="710f4-227">A rendszer hozzáfűzi az új eseményt az események sorához az eseménytárban.</span><span class="sxs-lookup"><span data-stu-id="710f4-227">The system appends the new event to the list of events in the event store.</span></span>

<span data-ttu-id="710f4-228">Ha egy felhasználó lemond egy helyet, a rendszer ugyanezt a folyamatot követi, azzal a különbséggel, hogy a parancskezelő egy helylemondási eseményt létrehozó parancsot ad ki és fűz hozzá az eseménytárhoz.</span><span class="sxs-lookup"><span data-stu-id="710f4-228">If a user cancels a seat, the system follows a similar process except the command handler issues a command that generates a seat cancellation event and appends it to the event store.</span></span>

<span data-ttu-id="710f4-229">Amellett, hogy több lehetőséget kínál a skálázásra, az eseménytár teljes körű előzményeket – vagy naplózást – is biztosít a konferencia foglalásaival és lemondásaival kapcsolatban.</span><span class="sxs-lookup"><span data-stu-id="710f4-229">As well as providing more scope for scalability, using an event store also provides a complete history, or audit trail, of the bookings and cancellations for a conference.</span></span> <span data-ttu-id="710f4-230">Az eseménytárban szereplő események szolgálnak pontos rekordként.</span><span class="sxs-lookup"><span data-stu-id="710f4-230">The events in the event store are the accurate record.</span></span> <span data-ttu-id="710f4-231">Az összesítéseket nem szükséges egyéb módon megőrizni, mivel a rendszer könnyedén visszajátszhatja az eseményeket, és visszaállíthatja az állapotot bármely időpontra.</span><span class="sxs-lookup"><span data-stu-id="710f4-231">There is no need to persist aggregates in any other way because the system can easily replay the events and restore the state to any point in time.</span></span>

> <span data-ttu-id="710f4-232">Ezzel a példával kapcsolatban további információkat [az Események forráskezelése bemutatásában](https://msdn.microsoft.com/library/jj591559.aspx) talál.</span><span class="sxs-lookup"><span data-stu-id="710f4-232">You can find more information about this example in [Introducing Event Sourcing](https://msdn.microsoft.com/library/jj591559.aspx).</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="710f4-233">Kapcsolódó minták és útmutatók</span><span class="sxs-lookup"><span data-stu-id="710f4-233">Related patterns and guidance</span></span>

<span data-ttu-id="710f4-234">Az alábbi minták és útmutatók szintén hasznosak lehetnek a minta megvalósításakor:</span><span class="sxs-lookup"><span data-stu-id="710f4-234">The following patterns and guidance might also be relevant when implementing this pattern:</span></span>

- <span data-ttu-id="710f4-235">[Parancskiadási és lekérdezési felelősségek elkülönítése (CQRS) minta](cqrs.md).</span><span class="sxs-lookup"><span data-stu-id="710f4-235">[Command and Query Responsibility Segregation (CQRS) Pattern](cqrs.md).</span></span> <span data-ttu-id="710f4-236">A CQRS implementálások állandó adatforrását biztosító írási tároló alapjául gyakran az Események forráskezelése minta egy implementálása szolgál.</span><span class="sxs-lookup"><span data-stu-id="710f4-236">The write store that provides the permanent source of information for a CQRS implementation is often based on an implementation of the Event Sourcing pattern.</span></span> <span data-ttu-id="710f4-237">A szakasz azt ismerteti, hogyan lehet különböző felületek használatával elkülöníteni az alkalmazások adatolvasó műveleteit az adatfrissítő műveletektől.</span><span class="sxs-lookup"><span data-stu-id="710f4-237">Describes how to segregate the operations that read data in an application from the operations that update data by using separate interfaces.</span></span>

- <span data-ttu-id="710f4-238">[A Materialized View minta](materialized-view.md).</span><span class="sxs-lookup"><span data-stu-id="710f4-238">[Materialized View Pattern](materialized-view.md).</span></span> <span data-ttu-id="710f4-239">Az Események forráskezelése mintán alapuló rendszerekben használt adattárak tipikusan nem nagyon alkalmasak a hatékony lekérdezésre.</span><span class="sxs-lookup"><span data-stu-id="710f4-239">The data store used in a system based on event sourcing is typically not well suited to efficient querying.</span></span> <span data-ttu-id="710f4-240">Ehelyett az általános megközelítés szerint rendszeres időközönként vagy az adatok változásakor szokás előfeltöltött nézeteket létrehozni az adatokról.</span><span class="sxs-lookup"><span data-stu-id="710f4-240">Instead, a common approach is to generate prepopulated views of the data at regular intervals, or when the data changes.</span></span> <span data-ttu-id="710f4-241">Ez a szakasz ennek a menetét mutatja be.</span><span class="sxs-lookup"><span data-stu-id="710f4-241">Shows how this can be done.</span></span>

- <span data-ttu-id="710f4-242">[Kompenzáló tranzakció mintája](compensating-transaction.md).</span><span class="sxs-lookup"><span data-stu-id="710f4-242">[Compensating Transaction Pattern](compensating-transaction.md).</span></span> <span data-ttu-id="710f4-243">Az Események forráskezelése tárban található meglévő adatok nem frissülnek, hanem új bejegyzések lesznek hozzáadva, amelyek átváltják az entitások állapotát az új értékekre.</span><span class="sxs-lookup"><span data-stu-id="710f4-243">The existing data in an event sourcing store is not updated, instead new entries are added that transition the state of entities to the new values.</span></span> <span data-ttu-id="710f4-244">A módosítások visszavonásához kompenzáló bejegyzéseket kell alkalmazni, mivel a megelőző módosításokat nem lehet egyszerűen visszavonni.</span><span class="sxs-lookup"><span data-stu-id="710f4-244">To reverse a change, compensating entries are used because it isn't possible to simply reverse the previous change.</span></span> <span data-ttu-id="710f4-245">A szakasz azt ismerteti, hogyan lehet visszavonni a korábbi műveletek által végrehajtott módosításokat.</span><span class="sxs-lookup"><span data-stu-id="710f4-245">Describes how to undo the work that was performed by a previous operation.</span></span>

- <span data-ttu-id="710f4-246">[Adatkonzisztencia – Ismertető](https://msdn.microsoft.com/library/dn589800.aspx).</span><span class="sxs-lookup"><span data-stu-id="710f4-246">[Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span> <span data-ttu-id="710f4-247">Ha az Események forráskezelése mintát egy külön olvasási tárral vagy tényleges táblán alapuló nézetekkel alkalmazza, a beolvasott adatok nem azonnal, hanem csak végül lesznek konzisztensek.</span><span class="sxs-lookup"><span data-stu-id="710f4-247">When using event sourcing with a separate read store or materialized views, the read data won't be immediately consistent, instead it'll be only eventually consistent.</span></span> <span data-ttu-id="710f4-248">A szakasz az elosztott adatok konzisztenciájának megőrzésével kapcsolatos problémákat foglalja össze.</span><span class="sxs-lookup"><span data-stu-id="710f4-248">Summarizes the issues surrounding maintaining consistency over distributed data.</span></span>

- <span data-ttu-id="710f4-249">[Adatparticionálási útmutató](https://msdn.microsoft.com/library/dn589795.aspx).</span><span class="sxs-lookup"><span data-stu-id="710f4-249">[Data Partitioning Guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span> <span data-ttu-id="710f4-250">Az Események forráskezelése minta alkalmazása esetén az adatokat gyakorta szokás particionálni a skálázhatóság javítása, a versengés csökkentése és a teljesítmény optimalizálása érdekében.</span><span class="sxs-lookup"><span data-stu-id="710f4-250">Data is often partitioned when using event sourcing to improve scalability, reduce contention, and optimize performance.</span></span> <span data-ttu-id="710f4-251">A szakasz az adatok diszkrét partíciókra való felosztását és az esetlegesen felmerülő problémákat ismerteti.</span><span class="sxs-lookup"><span data-stu-id="710f4-251">Describes how to divide data into discrete partitions, and the issues that can arise.</span></span>

- <span data-ttu-id="710f4-252">Greg Young bejegyzése: [Miért érdemes az Események forráskezelése mintát alkalmazni?](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/).</span><span class="sxs-lookup"><span data-stu-id="710f4-252">Greg Young’s post [Why use Event Sourcing?](http://codebetter.com/gregyoung/2010/02/20/why-use-event-sourcing/).</span></span>
