---
title: Leader Election
description: Koordinálhat egy elosztott alkalmazásban az együttműködő feladatpéldányokból álló gyűjtemény által végrehajtott műveleteket, ha vezetőnek választ meg egy példányt, amely vállalja a többi példány kezelésével járó felelősséget.
keywords: tervezési minta
author: dragon119
ms.date: 06/23/2017
pnp.series.title: Cloud Design Patterns
pnp.pattern.categories:
- design-implementation
- resiliency
ms.openlocfilehash: 3e7d47f70f660f2507f0619e1c41bf9a32a25be4
ms.sourcegitcommit: e67b751f230792bba917754d67789a20810dc76b
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 04/06/2018
---
# <a name="leader-election-pattern"></a><span data-ttu-id="0b52b-104">Vezetőválasztási minta</span><span class="sxs-lookup"><span data-stu-id="0b52b-104">Leader Election pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="0b52b-105">Az elosztott alkalmazásokban az együttműködő példányok gyűjteményei által végrehajtott műveletek koordinálhatók, ha megválaszt egy példányt vezetőnek, amely így felelős lesz a többi példány kezeléséért.</span><span class="sxs-lookup"><span data-stu-id="0b52b-105">Coordinate the actions performed by a collection of collaborating instances in a distributed application by electing one instance as the leader that assumes responsibility for managing the others.</span></span> <span data-ttu-id="0b52b-106">Ez segít annak biztosításában, hogy a példányok nem ütköznek egymással, nem versengenek a megosztott erőforrásokért, és véletlenül sem zavarják meg a többi példány működését.</span><span class="sxs-lookup"><span data-stu-id="0b52b-106">This can help to ensure that instances don't conflict with each other, cause contention for shared resources, or inadvertently interfere with the work that other instances are performing.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="0b52b-107">Kontextus és probléma</span><span class="sxs-lookup"><span data-stu-id="0b52b-107">Context and problem</span></span>

<span data-ttu-id="0b52b-108">Egy tipikus felhőalkalmazásban több, koordinált módon működő feladat található.</span><span class="sxs-lookup"><span data-stu-id="0b52b-108">A typical cloud application has many tasks acting in a coordinated manner.</span></span> <span data-ttu-id="0b52b-109">Ezek a feladatok lehetnek ugyanazt a kódot futtató és ugyanahhoz az erőforráshoz hozzáférést igénylő példányok, vagy előfordulhat, hogy egy összetett számítás egyes részeit végzik párhuzamosan.</span><span class="sxs-lookup"><span data-stu-id="0b52b-109">These tasks could all be instances running the same code and requiring access to the same resources, or they might be working together in parallel to perform the individual parts of a complex calculation.</span></span>

<span data-ttu-id="0b52b-110">A feladatpéldányok az idő legnagyobb részében külön futhatnak, de szükség lehet az egyes példányok műveleteinek koordinálására, hogy a példányok ne ütközzenek, ne versengjenek a megosztott erőforrásokért, és véletlenül se zavarják meg a többi példány működését.</span><span class="sxs-lookup"><span data-stu-id="0b52b-110">The task instances might run separately for much of the time, but it might also be necessary to coordinate the actions of each instance to ensure that they don’t conflict, cause contention for shared resources, or accidentally interfere with the work that other task instances are performing.</span></span>

<span data-ttu-id="0b52b-111">Példa:</span><span class="sxs-lookup"><span data-stu-id="0b52b-111">For example:</span></span>

- <span data-ttu-id="0b52b-112">A horizontális skálázást alkalmazó felhőalapú rendszerekben egy feladat több példánya is futhat egyszerre úgy, hogy mindegyik példány egy különböző felhasználót szolgál ki.</span><span class="sxs-lookup"><span data-stu-id="0b52b-112">In a cloud-based system that implements horizontal scaling, multiple instances of the same task could be running at the same time with each instance serving a different user.</span></span> <span data-ttu-id="0b52b-113">Ha ezek a példányok egy megosztott erőforrásba írnak, össze kell hangolni a műveleteiket, nehogy az egyik példány felülírja egy másik példány által elvégzett módosításokat.</span><span class="sxs-lookup"><span data-stu-id="0b52b-113">If these instances write to a shared resource, it's necessary to coordinate their actions to prevent each instance from overwriting the changes made by the others.</span></span>
- <span data-ttu-id="0b52b-114">Ha a feladatok egy összetett számítás egyes elemeit párhuzamosan végzik, a feladatok befejezése után összesíteni kell az eredményeket.</span><span class="sxs-lookup"><span data-stu-id="0b52b-114">If the tasks are performing individual elements of a complex calculation in parallel, the results need to be aggregated when they all complete.</span></span>

<span data-ttu-id="0b52b-115">A feladatpéldányok társviszonyban állnak, ezért nincs koordinátorként vagy összesítőként működő, vezető példány.</span><span class="sxs-lookup"><span data-stu-id="0b52b-115">The task instances are all peers, so there isn't a natural leader that can act as the coordinator or aggregator.</span></span>

## <a name="solution"></a><span data-ttu-id="0b52b-116">Megoldás</span><span class="sxs-lookup"><span data-stu-id="0b52b-116">Solution</span></span>

<span data-ttu-id="0b52b-117">Ki kell választani egy feladatpéldányt, amely vezetőként működik, és ez a példány fogja koordinálni a többi, alárendelt feladatpéldány műveleteit.</span><span class="sxs-lookup"><span data-stu-id="0b52b-117">A single task instance should be elected to act as the leader, and this instance should coordinate the actions of the other subordinate task instances.</span></span> <span data-ttu-id="0b52b-118">Ha az összes feladatpéldány ugyanazt a kódot futtatja, akkor bármelyik működhet vezetőként.</span><span class="sxs-lookup"><span data-stu-id="0b52b-118">If all of the task instances are running the same code, they are each capable of acting as the leader.</span></span> <span data-ttu-id="0b52b-119">Ezért a választás során ügyelnie kell arra, nehogy két vagy több példány egyszerre vegye át a vezetői szerepkört.</span><span class="sxs-lookup"><span data-stu-id="0b52b-119">Therefore, the election process must be managed carefully to prevent two or more instances taking over the leader role at the same time.</span></span>

<span data-ttu-id="0b52b-120">A rendszernek robusztus mechanizmust kell biztosítania a vezető kiválasztásához.</span><span class="sxs-lookup"><span data-stu-id="0b52b-120">The system must provide a robust mechanism for selecting the leader.</span></span> <span data-ttu-id="0b52b-121">Ennek a módszernek tudnia kell kezelni az olyan eseményeket, mint például a hálózati kimaradások vagy a folyamathibák.</span><span class="sxs-lookup"><span data-stu-id="0b52b-121">This method has to cope with events such as network outages or process failures.</span></span> <span data-ttu-id="0b52b-122">Számos megoldásban az alárendelt folyamatpéldányok valamilyen szívveréses módszerrel vagy lekérdezéssel monitorozzák a vezetőt.</span><span class="sxs-lookup"><span data-stu-id="0b52b-122">In many solutions, the subordinate task instances monitor the leader through some type of heartbeat method, or by polling.</span></span> <span data-ttu-id="0b52b-123">Ha a kijelölt vezető váratlanul leáll, vagy az alárendelt feladatpéldányok hálózatkimaradás miatt nem tudják elérni, új vezetőt kell választani nekik.</span><span class="sxs-lookup"><span data-stu-id="0b52b-123">If the designated leader terminates unexpectedly, or a network failure makes the leader unavailable to the subordinate task instances, it's necessary for them to elect a new leader.</span></span>

<span data-ttu-id="0b52b-124">Többféle módon is kiválasztható egy vezető egy elosztott környezet feladatainak készletéből, például:</span><span class="sxs-lookup"><span data-stu-id="0b52b-124">There are several strategies for electing a leader among a set of tasks in a distributed environment, including:</span></span>
- <span data-ttu-id="0b52b-125">A legalacsonyabb besorolású példány- vagy folyamatazonosítóval rendelkező feladatpéldány kiválasztása.</span><span class="sxs-lookup"><span data-stu-id="0b52b-125">Selecting the task instance with the lowest-ranked instance or process ID.</span></span>
- <span data-ttu-id="0b52b-126">Verseny a közös, elosztott mutex beszerzéséért.</span><span class="sxs-lookup"><span data-stu-id="0b52b-126">Racing to acquire a shared, distributed mutex.</span></span> <span data-ttu-id="0b52b-127">Az a feladatpéldány lesz a vezető, amelyik elsőként szerzi be a mutexet.</span><span class="sxs-lookup"><span data-stu-id="0b52b-127">The first task instance that acquires the mutex is the leader.</span></span> <span data-ttu-id="0b52b-128">Azonban a rendszernek biztosítania kell a mutex felszabadítását, ha a vezető leáll vagy megszakad a kapcsolata a rendszer többi részével, hogy egy másik feladatpéldány vehesse át a vezető szerepet.</span><span class="sxs-lookup"><span data-stu-id="0b52b-128">However, the system must ensure that, if the leader terminates or becomes disconnected from the rest of the system, the mutex is released to allow another task instance to become the leader.</span></span>
- <span data-ttu-id="0b52b-129">Egyik széles körben használt vezetőválasztási algoritmus (például a [Bully algoritmus](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/BullyExample.html) vagy a [Ring algoritmus](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/RingElectExample.html)) megvalósítása.</span><span class="sxs-lookup"><span data-stu-id="0b52b-129">Implementing one of the common leader election algorithms such as the [Bully Algorithm](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/BullyExample.html) or the [Ring Algorithm](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/RingElectExample.html).</span></span> <span data-ttu-id="0b52b-130">Ezek az algoritmusok azt feltételezik, hogy a választásban részt vevő minden jelölt egyedi azonosítóval rendelkezik, és megbízhatóan kommunikál a többi jelölttel.</span><span class="sxs-lookup"><span data-stu-id="0b52b-130">These algorithms assume that each candidate in the election has a unique ID, and that it can communicate with the other candidates reliably.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="0b52b-131">Problémák és megfontolandó szempontok</span><span class="sxs-lookup"><span data-stu-id="0b52b-131">Issues and considerations</span></span>

<span data-ttu-id="0b52b-132">A minta megvalósítása során az alábbi pontokat vegye figyelembe:</span><span class="sxs-lookup"><span data-stu-id="0b52b-132">Consider the following points when deciding how to implement this pattern:</span></span>
- <span data-ttu-id="0b52b-133">A vezetőválasztási folyamatnak ellenállónak kell lennie az átmeneti és állandó hibákkal szemben.</span><span class="sxs-lookup"><span data-stu-id="0b52b-133">The process of electing a leader should be resilient to transient and persistent failures.</span></span>
- <span data-ttu-id="0b52b-134">Észlelnie kell, ha a vezető leáll vagy bármely más okból elérhetetlenné válik (például egy kommunikációs hiba miatt).</span><span class="sxs-lookup"><span data-stu-id="0b52b-134">It must be possible to detect when the leader has failed or has become otherwise unavailable (such as due to a communications failure).</span></span> <span data-ttu-id="0b52b-135">Az észlelés szükséges sebessége a rendszertől függ.</span><span class="sxs-lookup"><span data-stu-id="0b52b-135">How quickly detection is needed is system dependent.</span></span> <span data-ttu-id="0b52b-136">Egyes rendszerek rövid ideig vezető nélkül is működőképesek lehetnek, és ez alatt az idő alatt az átmeneti hiba kijavítható.</span><span class="sxs-lookup"><span data-stu-id="0b52b-136">Some systems might be able to function for a short time without a leader, during which a transient fault might be fixed.</span></span> <span data-ttu-id="0b52b-137">Más esetekben előfordulhat, hogy azonnal észlelni kell a vezető leállását, és új választást kell indítani.</span><span class="sxs-lookup"><span data-stu-id="0b52b-137">In other cases, it might be necessary to detect leader failure immediately and trigger a new election.</span></span>
- <span data-ttu-id="0b52b-138">Az automatikus horizontális skálázást megvalósító rendszereknél a vezető eltávolítható, ha a rendszer leskálázza a számítási erőforrásokat, vagy néhányat leállít közülük.</span><span class="sxs-lookup"><span data-stu-id="0b52b-138">In a system that implements horizontal autoscaling, the leader could be terminated if the system scales back and shuts down some of the computing resources.</span></span>
- <span data-ttu-id="0b52b-139">Közös, elosztott mutex használata esetén függőségi kapcsolat áll fenn a mutexet biztosító külső szolgáltatással.</span><span class="sxs-lookup"><span data-stu-id="0b52b-139">Using a shared, distributed mutex introduces a dependency on the external service that provides the mutex.</span></span> <span data-ttu-id="0b52b-140">Ez a szolgáltatás kritikus hibapont lehet.</span><span class="sxs-lookup"><span data-stu-id="0b52b-140">The service constitutes a single point of failure.</span></span> <span data-ttu-id="0b52b-141">Ha ez bármilyen okból elérhetetlenné válik, a rendszer nem fog tudni vezetőt választani.</span><span class="sxs-lookup"><span data-stu-id="0b52b-141">If it becomes unavailable for any reason, the system won't be able to elect a leader.</span></span>
- <span data-ttu-id="0b52b-142">Egyetlen dedikált folyamat egyszerűen használható vezetőként.</span><span class="sxs-lookup"><span data-stu-id="0b52b-142">Using a single dedicated process as the leader is a straightforward approach.</span></span> <span data-ttu-id="0b52b-143">Ha azonban a folyamat leáll, jelentős késés léphet fel az újraindulásáig.</span><span class="sxs-lookup"><span data-stu-id="0b52b-143">However, if the process fails there could be a significant delay while it's restarted.</span></span> <span data-ttu-id="0b52b-144">Ez a késés hatással lehet a többi folyamat teljesítményére és válaszidejére, ha arra várnak, hogy a vezető koordináljon egy műveletet.</span><span class="sxs-lookup"><span data-stu-id="0b52b-144">The resulting latency can affect the performance and response times of other processes if they're waiting for the leader to coordinate an operation.</span></span>
- <span data-ttu-id="0b52b-145">Az egyik vezetőválasztási algoritmus manuális megvalósítása biztosítja a legnagyobb rugalmasságot a kód finomhangolásához és optimalizáláshoz.</span><span class="sxs-lookup"><span data-stu-id="0b52b-145">Implementing one of the leader election algorithms manually provides the greatest flexibility for tuning and optimizing the code.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="0b52b-146">Mikor érdemes ezt a mintát használni?</span><span class="sxs-lookup"><span data-stu-id="0b52b-146">When to use this pattern</span></span>

<span data-ttu-id="0b52b-147">Akkor használja ezt a mintát, ha egy elosztott alkalmazásban található feladathoz (például egy felhőben üzemeltetett megoldáshoz) gondos koordináció szükséges, és nincs természetes vezető.</span><span class="sxs-lookup"><span data-stu-id="0b52b-147">Use this pattern when the tasks in a distributed application, such as a cloud-hosted solution, need careful coordination and there's no natural leader.</span></span>

>  <span data-ttu-id="0b52b-148">Kerülje el, hogy a vezető szűk keresztmetszet legyen a rendszerben.</span><span class="sxs-lookup"><span data-stu-id="0b52b-148">Avoid making the leader a bottleneck in the system.</span></span> <span data-ttu-id="0b52b-149">A vezető célja az alárendelt feladatok munkájának összehangolása. Magának a vezetőnek nem feltétlenül kell részt vennie a munkában, de képesnek kell lennie rá, mert előfordulhat, hogy nem ezt a feladatot választják meg vezetőnek.</span><span class="sxs-lookup"><span data-stu-id="0b52b-149">The purpose of the leader is to coordinate the work of the subordinate tasks, and it doesn't necessarily have to participate in this work itself&mdash;although it should be able to do so if the task isn't elected as the leader.</span></span>

<span data-ttu-id="0b52b-150">Nem érdemes ezt a mintát használni, ha:</span><span class="sxs-lookup"><span data-stu-id="0b52b-150">This pattern might not be useful if:</span></span>
- <span data-ttu-id="0b52b-151">Van természetes vezető vagy dedikált folyamat, amely mindig vezetőként működhet.</span><span class="sxs-lookup"><span data-stu-id="0b52b-151">There's a natural leader or dedicated process that can always act as the leader.</span></span> <span data-ttu-id="0b52b-152">Például lehetséges, hogy meg lehet valósítani egyetlen olyan folyamatot, amely a feladatpéldányokat koordinálja.</span><span class="sxs-lookup"><span data-stu-id="0b52b-152">For example, it might be possible to implement a singleton process that coordinates the task instances.</span></span> <span data-ttu-id="0b52b-153">Ha ez a folyamat meghibásodik, a rendszer le tudja állítani, és újra tudja indítani.</span><span class="sxs-lookup"><span data-stu-id="0b52b-153">If this process fails or becomes unhealthy, the system can shut it down and restart it.</span></span>
- <span data-ttu-id="0b52b-154">A feladatok egy kisebb terhelést jelentő módszerrel is összehangolhatók.</span><span class="sxs-lookup"><span data-stu-id="0b52b-154">The coordination between tasks can be achieved using a more lightweight method.</span></span> <span data-ttu-id="0b52b-155">Ha például egyszerűen több feladatpéldánynak kell koordinált hozzáférést biztosítani egy közös erőforráshoz, akkor célszerűbb optimista vagy pesszimista zárolással vezérelni a hozzáférést.</span><span class="sxs-lookup"><span data-stu-id="0b52b-155">For example, if several task instances simply need coordinated access to a shared resource, a better solution is to use optimistic or pessimistic locking to control access.</span></span>
- <span data-ttu-id="0b52b-156">Egy külső megoldás megfelelőbb.</span><span class="sxs-lookup"><span data-stu-id="0b52b-156">A third-party solution is more appropriate.</span></span> <span data-ttu-id="0b52b-157">Például az Apache Hadoopon alapuló Microsoft Azure HDInsight szolgáltatás az Apache Zookeeper szolgáltatásaival koordinálja a leképezési és csökkentési feladatokat, amelyek begyűjtik és összefoglalják az adatokat.</span><span class="sxs-lookup"><span data-stu-id="0b52b-157">For example, the Microsoft Azure HDInsight service (based on Apache Hadoop) uses the services provided by Apache Zookeeper to coordinate the map and reduce tasks that collect and summarize data.</span></span>

## <a name="example"></a><span data-ttu-id="0b52b-158">Példa</span><span class="sxs-lookup"><span data-stu-id="0b52b-158">Example</span></span>

<span data-ttu-id="0b52b-159">A LeaderElection megoldás DistributedMutex projektje (a mintát bemutató mintakód elérhető a [GitHubon](https://github.com/mspnp/cloud-design-patterns/tree/master/leader-election)) bemutatja, hogyan használható egy Azure Storage-blobbérlet egy közös, elosztott mutex megvalósításához szükséges mechanizmus biztosítására.</span><span class="sxs-lookup"><span data-stu-id="0b52b-159">The DistributedMutex project in the LeaderElection solution (a sample that demonstrates this pattern is available on [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/leader-election)) shows how to use a lease on an Azure Storage blob to provide a mechanism for implementing a shared, distributed mutex.</span></span> <span data-ttu-id="0b52b-160">Ezzel a mutexszel kiválasztható a vezető egy Azure-felhőszolgáltatásban lévő szerepkörpéldányok csoportjából.</span><span class="sxs-lookup"><span data-stu-id="0b52b-160">This mutex can be used to elect a leader among a group of role instances in an Azure cloud service.</span></span> <span data-ttu-id="0b52b-161">A bérletet elsőként megszerző szerepkörpéldány lesz megválasztva vezetőnek, és addig az is marad, amíg fel nem szabadítja a bérletet, vagy nem tudja megújítani.</span><span class="sxs-lookup"><span data-stu-id="0b52b-161">The first role instance to acquire the lease is elected the leader, and remains the leader until it releases the lease or isn't able to renew the lease.</span></span> <span data-ttu-id="0b52b-162">A többi szerepkörpéldány folytathatja a blobbérlet monitorozását, ha a vezető nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="0b52b-162">Other role instances can continue to monitor the blob lease in case the leader is no longer available.</span></span>

>  <span data-ttu-id="0b52b-163">A blobbérlet egy blob exkluzív írási zárolása.</span><span class="sxs-lookup"><span data-stu-id="0b52b-163">A blob lease is an exclusive write lock over a blob.</span></span> <span data-ttu-id="0b52b-164">Egy blob mindig csak egy bérlet tárgya lehet.</span><span class="sxs-lookup"><span data-stu-id="0b52b-164">A single blob can be the subject of only one lease at any point in time.</span></span> <span data-ttu-id="0b52b-165">Egy szerepkörpéldány kérelmezheti egy adott blob bérletét, és meg is kapja, ha egyetlen másik szerepkörpéldány sem rendelkezik ugyanennek a blobnak a bérletével.</span><span class="sxs-lookup"><span data-stu-id="0b52b-165">A role instance can request a lease over a specified blob, and it'll be granted the lease if no other role instance holds a lease over the same blob.</span></span> <span data-ttu-id="0b52b-166">Egyéb esetben a kérelem kivételt ad vissza.</span><span class="sxs-lookup"><span data-stu-id="0b52b-166">Otherwise the request will throw an exception.</span></span>
> 
> <span data-ttu-id="0b52b-167">Ha el szeretné kerülni, hogy a hibás szerepkörpéldány határozatlan időre szerezze be a bérletet, adja meg a bérlet élettartamát.</span><span class="sxs-lookup"><span data-stu-id="0b52b-167">To avoid a faulted role instance retaining the lease indefinitely, specify a lifetime for the lease.</span></span> <span data-ttu-id="0b52b-168">Amikor ez lejár, a bérlet elérhetővé válik.</span><span class="sxs-lookup"><span data-stu-id="0b52b-168">When this expires, the lease becomes available.</span></span> <span data-ttu-id="0b52b-169">Azonban amíg egy szerepkörpéldány rendelkezik a bérlettel, kérelmezheti a megújítását, és hosszabb időre megkaphatja a bérletet.</span><span class="sxs-lookup"><span data-stu-id="0b52b-169">However, while a role instance holds the lease it can request that the lease is renewed, and it'll be granted the lease for a further period of time.</span></span> <span data-ttu-id="0b52b-170">A szerepkörpéldány rendszeresen megismételheti ezt a folyamatot, ha meg kívánja őrizni a bérletet.</span><span class="sxs-lookup"><span data-stu-id="0b52b-170">The role instance can continually repeat this process if it wants to retain the lease.</span></span>
> <span data-ttu-id="0b52b-171">További információ a blobbérletekről: [Blobbérlet (REST API)](https://msdn.microsoft.com/library/azure/ee691972.aspx).</span><span class="sxs-lookup"><span data-stu-id="0b52b-171">For more information on how to lease a blob, see [Lease Blob (REST API)](https://msdn.microsoft.com/library/azure/ee691972.aspx).</span></span>

<span data-ttu-id="0b52b-172">Az alábbi C#-példában látható `BlobDistributedMutex` osztály tartalmazza a `RunTaskWhenMutexAquired` metódust, amely lehetővé teszi egy szerepkörpéldány számára, hogy megpróbálja beszerezni egy adott blob bérletét.</span><span class="sxs-lookup"><span data-stu-id="0b52b-172">The `BlobDistributedMutex` class in the C# example below contains the `RunTaskWhenMutexAquired` method that enables a role instance to attempt to acquire a lease over a specified blob.</span></span> <span data-ttu-id="0b52b-173">A rendszer egy `BlobSettings` objektumban adja át a blob adatait (név, tároló és tárfiók) a konstruktornak a `BlobDistributedMutex` objektum létrehozásakor (ez az objektum egy egyszerű struktúra, amelyet a mintakód is tartalmaz).</span><span class="sxs-lookup"><span data-stu-id="0b52b-173">The details of the blob (the name, container, and storage account) are passed to the constructor in a `BlobSettings` object when the `BlobDistributedMutex` object is created (this object is a simple struct that is included in the sample code).</span></span> <span data-ttu-id="0b52b-174">A konstruktor egy `Task` elemet is fogad, amely arra a kódra hivatkozik, amelyet a szerepkörpéldánynak futtatnia kell, ha sikeresen beszerzi a blobbérletet, és megválasztják vezetőnek.</span><span class="sxs-lookup"><span data-stu-id="0b52b-174">The constructor also accepts a `Task` that references the code that the role instance should run if it successfully acquires the lease over the blob and is elected the leader.</span></span> <span data-ttu-id="0b52b-175">Vegye figyelembe, hogy a bérlet beszerzésének kevésbé fontos részleteit kezelő kód egy különálló, `BlobLeaseManager` nevű segítőosztályban szerepel.</span><span class="sxs-lookup"><span data-stu-id="0b52b-175">Note that the code that handles the low-level details of acquiring the lease is implemented in a separate helper class named `BlobLeaseManager`.</span></span>

```csharp
public class BlobDistributedMutex
{
  ...
  private readonly BlobSettings blobSettings;
  private readonly Func<CancellationToken, Task> taskToRunWhenLeaseAcquired;
  ...

  public BlobDistributedMutex(BlobSettings blobSettings,
           Func<CancellationToken, Task> taskToRunWhenLeaseAquired)
  {
    this.blobSettings = blobSettings;
    this.taskToRunWhenLeaseAquired = taskToRunWhenLeaseAquired;
  }

  public async Task RunTaskWhenMutexAcquired(CancellationToken token)
  {
    var leaseManager = new BlobLeaseManager(blobSettings);
    await this.RunTaskWhenBlobLeaseAcquired(leaseManager, token);
  }
  ...
```

<span data-ttu-id="0b52b-176">A fenti kódmintában szereplő `RunTaskWhenMutexAquired` metódus meghívja a következő kódmintában látható `RunTaskWhenBlobLeaseAcquired` metódust a bérlet beszerzéséhez.</span><span class="sxs-lookup"><span data-stu-id="0b52b-176">The `RunTaskWhenMutexAquired` method in the code sample above invokes the `RunTaskWhenBlobLeaseAcquired` method shown in the following code sample to actually acquire the lease.</span></span> <span data-ttu-id="0b52b-177">A `RunTaskWhenBlobLeaseAcquired` metódus aszinkron módon fut.</span><span class="sxs-lookup"><span data-stu-id="0b52b-177">The `RunTaskWhenBlobLeaseAcquired` method runs asynchronously.</span></span> <span data-ttu-id="0b52b-178">Ha sikeresen beszerezte a bérletet, a szerepkörpéldány lesz megválasztva vezetőnek.</span><span class="sxs-lookup"><span data-stu-id="0b52b-178">If the lease is successfully acquired, the role instance has been elected the leader.</span></span> <span data-ttu-id="0b52b-179">A `taskToRunWhenLeaseAcquired` delegált feladata a többi szerepkörpéldányt koordináló munka elvégzése.</span><span class="sxs-lookup"><span data-stu-id="0b52b-179">The purpose of the `taskToRunWhenLeaseAcquired` delegate is to perform the work that coordinates the other role instances.</span></span> <span data-ttu-id="0b52b-180">Ha nem sikerül beszereznie a bérletet, egy másik szerepkörpéldány lesz megválasztva vezetőnek, és az aktuális szerepkörpéldány alárendelt marad.</span><span class="sxs-lookup"><span data-stu-id="0b52b-180">If the lease isn't acquired, another role instance has been elected as the leader and the current role instance remains a subordinate.</span></span> <span data-ttu-id="0b52b-181">Vegye figyelembe, hogy a `TryAcquireLeaseOrWait` metódus egy olyan segédmetódus, amely a `BlobLeaseManager` objektumot használja a bérlet beszerzéséhez.</span><span class="sxs-lookup"><span data-stu-id="0b52b-181">Note that the `TryAcquireLeaseOrWait` method is a helper method that uses the `BlobLeaseManager` object to acquire the lease.</span></span>

```csharp
  private async Task RunTaskWhenBlobLeaseAcquired(
    BlobLeaseManager leaseManager, CancellationToken token)
  {
    while (!token.IsCancellationRequested)
    {
      // Try to acquire the blob lease.
      // Otherwise wait for a short time before trying again.
      string leaseId = await this.TryAquireLeaseOrWait(leaseManager, token);

      if (!string.IsNullOrEmpty(leaseId))
      {
        // Create a new linked cancellation token source so that if either the
        // original token is canceled or the lease can't be renewed, the
        // leader task can be canceled.
        using (var leaseCts =
          CancellationTokenSource.CreateLinkedTokenSource(new[] { token }))
        {
          // Run the leader task.
          var leaderTask = this.taskToRunWhenLeaseAquired.Invoke(leaseCts.Token);
          ...
        }
      }
    }
    ...
  }
```

<span data-ttu-id="0b52b-182">A vezető által elindított feladat szintén aszinkron módon fut.</span><span class="sxs-lookup"><span data-stu-id="0b52b-182">The task started by the leader also runs asynchronously.</span></span> <span data-ttu-id="0b52b-183">Amíg ez a feladat fut, az alábbi kódmintában látható `RunTaskWhenBlobLeaseAquired` metódus időnként megkísérli a bérlet megújítását.</span><span class="sxs-lookup"><span data-stu-id="0b52b-183">While this task is running, the `RunTaskWhenBlobLeaseAquired` method shown in the following code sample periodically attempts to renew the lease.</span></span> <span data-ttu-id="0b52b-184">Ezzel biztosítható, hogy ez a szerepkörpéldány marad a vezető.</span><span class="sxs-lookup"><span data-stu-id="0b52b-184">This helps to ensure that the role instance remains the leader.</span></span> <span data-ttu-id="0b52b-185">A mintamegoldásban a megújítási kérelmek közötti késés kevesebb, mint a bérlethez beállított időtartam, hogy ne lehessen egy másik szerepkörpéldányt megválasztani vezetőnek.</span><span class="sxs-lookup"><span data-stu-id="0b52b-185">In the sample solution, the delay between renewal requests is less than the time specified for the duration of the lease in order to prevent another role instance from being elected the leader.</span></span> <span data-ttu-id="0b52b-186">Ha a megújítás bármilyen okból nem sikerül, a feladat megszakad.</span><span class="sxs-lookup"><span data-stu-id="0b52b-186">If the renewal fails for any reason, the task is canceled.</span></span>

<span data-ttu-id="0b52b-187">Ha a bérlet megújítása nem sikerül vagy a feladat megszakad (például a szerepkörpéldány leállása miatt), felszabadul a bérlet.</span><span class="sxs-lookup"><span data-stu-id="0b52b-187">If the lease fails to be renewed or the task is canceled (possibly as a result of the role instance shutting down), the lease is released.</span></span> <span data-ttu-id="0b52b-188">Ekkor ez vagy egy másik szerepkörpéldány is megválasztható vezetőként.</span><span class="sxs-lookup"><span data-stu-id="0b52b-188">At this point, this or another role instance might be elected as the leader.</span></span> <span data-ttu-id="0b52b-189">Az alábbi kódkivonat a folyamat ezen részét mutatja.</span><span class="sxs-lookup"><span data-stu-id="0b52b-189">The code extract below shows this part of the process.</span></span>

```csharp
  private async Task RunTaskWhenBlobLeaseAcquired(
    BlobLeaseManager leaseManager, CancellationToken token)
  {
    while (...)
    {
      ...
      if (...)
      {
        ...
        using (var leaseCts = ...)
        {
          ...
          // Keep renewing the lease in regular intervals.
          // If the lease can't be renewed, then the task completes.
          var renewLeaseTask =
            this.KeepRenewingLease(leaseManager, leaseId, leaseCts.Token);

          // When any task completes (either the leader task itself or when it
          // couldn't renew the lease) then cancel the other task.
          await CancelAllWhenAnyCompletes(leaderTask, renewLeaseTask, leaseCts);
        }
      }
    }
  }
  ...
}
```

<span data-ttu-id="0b52b-190">A `KeepRenewingLease` metódus egy másik olyan segédmetódus, amely a `BlobLeaseManager` objektumot használja a bérlet megújításához.</span><span class="sxs-lookup"><span data-stu-id="0b52b-190">The `KeepRenewingLease` method is another helper method that uses the `BlobLeaseManager` object to renew the lease.</span></span> <span data-ttu-id="0b52b-191">A `CancelAllWhenAnyCompletes` metódus megszakítja az első két paraméterként megadott feladatokat.</span><span class="sxs-lookup"><span data-stu-id="0b52b-191">The `CancelAllWhenAnyCompletes` method cancels the tasks specified as the first two parameters.</span></span> <span data-ttu-id="0b52b-192">A következő diagram azt mutatja be, hogyan választható egy vezető és futtatható egy műveleteket koordináló feladat a `BlobDistributedMutex` osztály használatával.</span><span class="sxs-lookup"><span data-stu-id="0b52b-192">The following diagram illustrates using the `BlobDistributedMutex` class to elect a leader and run a task that coordinates operations.</span></span>

![Az 1. ábra a BlobDistributedMutex osztály funkcióit szemlélteti](./_images/leader-election-diagram.png)


<span data-ttu-id="0b52b-194">Az alábbi példakód bemutatja, hogyan használható a `BlobDistributedMutex` osztály feldolgozói szerepkörben.</span><span class="sxs-lookup"><span data-stu-id="0b52b-194">The following code example shows how to use the `BlobDistributedMutex` class in a worker role.</span></span> <span data-ttu-id="0b52b-195">Ez a kód beszerzi a fejlesztési tárterület bérlettárolójában lévő `MyLeaderCoordinatorTask` blob bérletét, és megadja, hogy a `MyLeaderCoordinatorTask` metódusban meghatározott kódnak akkor kell futnia, ha a szerepkörpéldányt megválasztják vezetőnek.</span><span class="sxs-lookup"><span data-stu-id="0b52b-195">This code acquires a lease over a blob named `MyLeaderCoordinatorTask` in the lease's container in development storage, and specifies that the code defined in the `MyLeaderCoordinatorTask` method should run if the role instance is elected the leader.</span></span>

```csharp
var settings = new BlobSettings(CloudStorageAccount.DevelopmentStorageAccount,
  "leases", "MyLeaderCoordinatorTask");
var cts = new CancellationTokenSource();
var mutex = new BlobDistributedMutex(settings, MyLeaderCoordinatorTask);
mutex.RunTaskWhenMutexAcquired(this.cts.Token);
...

// Method that runs if the role instance is elected the leader
private static async Task MyLeaderCoordinatorTask(CancellationToken token)
{
  ...
}
```

<span data-ttu-id="0b52b-196">Vegye figyelembe a következő szempontokat a mintaként szolgáló megoldásról:</span><span class="sxs-lookup"><span data-stu-id="0b52b-196">Note the following points about the sample solution:</span></span>
- <span data-ttu-id="0b52b-197">A blob egy potenciálisan hibaérzékeny pont.</span><span class="sxs-lookup"><span data-stu-id="0b52b-197">The blob is a potential single point of failure.</span></span> <span data-ttu-id="0b52b-198">Ha a blobszolgáltatás nem áll rendelkezésre vagy nem érhető el, a vezető nem tudja megújítani a bérletet, és a többi szerepkörpéldány sem fogja tudni beszerezni a bérletet.</span><span class="sxs-lookup"><span data-stu-id="0b52b-198">If the blob service becomes unavailable, or is inaccessible, the leader won't be able to renew the lease and no other role instance will be able to acquire the lease.</span></span> <span data-ttu-id="0b52b-199">Ebben az esetben egyik szerepkörpéldány sem tud vezetőként működni.</span><span class="sxs-lookup"><span data-stu-id="0b52b-199">In this case, no role instance will be able to act as the leader.</span></span> <span data-ttu-id="0b52b-200">Azonban a blobszolgáltatást úgy tervezték, hogy rugalmas legyen, ezért a blobszolgáltatás teljes leállása nagyon valószínűtlen.</span><span class="sxs-lookup"><span data-stu-id="0b52b-200">However, the blob service is designed to be resilient, so complete failure of the blob service is considered to be extremely unlikely.</span></span>
- <span data-ttu-id="0b52b-201">Ha a vezető által elvégzett feladat megáll, a vezető folytathatja a bérlet megújítását, így a többi szerepkörpéldány nem tudja beszerezni a bérletet és átvenni a vezetői szerepkört a feladatok koordinálása érdekében.</span><span class="sxs-lookup"><span data-stu-id="0b52b-201">If the task being performed by the leader stalls, the leader might continue to renew the lease, preventing any other role instance from acquiring the lease and taking over the leader role in order to coordinate tasks.</span></span> <span data-ttu-id="0b52b-202">A való világban a vezető állapotát gyakori időközönként ellenőrizni kell.</span><span class="sxs-lookup"><span data-stu-id="0b52b-202">In the real world, the health of the leader should be checked at frequent intervals.</span></span>
- <span data-ttu-id="0b52b-203">A választási folyamat nem determinált.</span><span class="sxs-lookup"><span data-stu-id="0b52b-203">The election process is nondeterministic.</span></span> <span data-ttu-id="0b52b-204">Nem jósolható meg, hogy melyik szerepkörpéldány fogja beszerezni a blobbérletet és válik ezáltal vezetővé.</span><span class="sxs-lookup"><span data-stu-id="0b52b-204">You can't make any assumptions about which role instance will acquire the blob lease and become the leader.</span></span>
- <span data-ttu-id="0b52b-205">A blobbérlet céljaként használt blobot ne használja más célra.</span><span class="sxs-lookup"><span data-stu-id="0b52b-205">The blob used as the target of the blob lease shouldn't be used for any other purpose.</span></span> <span data-ttu-id="0b52b-206">Ha egy szerepkörpéldány megpróbál adatokat tárolni ebben a blobban, ezek az adatok csak akkor lesznek elérhetők, ha a szerepkörpéldány a vezető, és rendelkezik a blobbérlettel.</span><span class="sxs-lookup"><span data-stu-id="0b52b-206">If a role instance attempts to store data in this blob, this data won't be accessible unless the role instance is the leader and holds the blob lease.</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="0b52b-207">Kapcsolódó minták és útmutatók</span><span class="sxs-lookup"><span data-stu-id="0b52b-207">Related patterns and guidance</span></span>

<span data-ttu-id="0b52b-208">Az alábbi útmutatók segíthetnek a minta megvalósításakor:</span><span class="sxs-lookup"><span data-stu-id="0b52b-208">The following guidance might also be relevant when implementing this pattern:</span></span>
- <span data-ttu-id="0b52b-209">Ez a minta egy letölthető [mintaalkalmazást](https://github.com/mspnp/cloud-design-patterns/tree/master/leader-election) tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="0b52b-209">This pattern has a downloadable [sample application](https://github.com/mspnp/cloud-design-patterns/tree/master/leader-election).</span></span>
- <span data-ttu-id="0b52b-210">[Útmutató az automatikus skálázáshoz](https://msdn.microsoft.com/library/dn589774.aspx).</span><span class="sxs-lookup"><span data-stu-id="0b52b-210">[Autoscaling Guidance](https://msdn.microsoft.com/library/dn589774.aspx).</span></span> <span data-ttu-id="0b52b-211">A feladatot futtató gazdagépek példányai az alkalmazások terhelésének változásainak megfelelően elindíthatók vagy leállíthatók.</span><span class="sxs-lookup"><span data-stu-id="0b52b-211">It's possible to start and stop instances of the task hosts as the load on the application varies.</span></span> <span data-ttu-id="0b52b-212">Az automatikus skálázás segítségével a teljesítmény és az átviteli sebesség szinten tartható a feldolgozási csúcsidőszakban.</span><span class="sxs-lookup"><span data-stu-id="0b52b-212">Autoscaling can help to maintain throughput and performance during times of peak processing.</span></span>
- <span data-ttu-id="0b52b-213">[Compute-particionálási útmutató](https://msdn.microsoft.com/library/dn589773.aspx)</span><span class="sxs-lookup"><span data-stu-id="0b52b-213">[Compute Partitioning Guidance](https://msdn.microsoft.com/library/dn589773.aspx).</span></span> <span data-ttu-id="0b52b-214">Ez az útmutató ismerteti, hogyan rendelhet feladatokat a gazdagépekhez egy felhőszolgáltatásban olyan módon, hogy az segítsen minimalizálni a futtatási költségeket a szolgáltatás skálázhatóságának, teljesítményének, rendelkezésre állásának és biztonságának megőrzése mellett.</span><span class="sxs-lookup"><span data-stu-id="0b52b-214">This guidance describes how to allocate tasks to hosts in a cloud service in a way that helps to minimize running costs while maintaining the scalability, performance, availability, and security of the service.</span></span>
- <span data-ttu-id="0b52b-215">[Feladatalapú aszinkron minta](https://msdn.microsoft.com/library/hh873175.aspx).</span><span class="sxs-lookup"><span data-stu-id="0b52b-215">The [Task-based Asynchronous Pattern](https://msdn.microsoft.com/library/hh873175.aspx).</span></span>
- <span data-ttu-id="0b52b-216">A [Bully algoritmust](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/BullyExample.html) ábrázoló példa.</span><span class="sxs-lookup"><span data-stu-id="0b52b-216">An example illustrating the [Bully Algorithm](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/BullyExample.html).</span></span>
- <span data-ttu-id="0b52b-217">A [Ring algoritmust](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/RingElectExample.html) ábrázoló példa.</span><span class="sxs-lookup"><span data-stu-id="0b52b-217">An example illustrating the [Ring Algorithm](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/RingElectExample.html).</span></span>
- <span data-ttu-id="0b52b-218">Az [Apache Zookeeper Microsoft Azure-ban való használatát](https://msopentech.com/opentech-projects/apache-zookeeper-on-windows-azure-2/) ismertető cikk a Microsoft Open Technologies webhelyén.</span><span class="sxs-lookup"><span data-stu-id="0b52b-218">The article [Apache Zookeeper on Microsoft Azure](https://msopentech.com/opentech-projects/apache-zookeeper-on-windows-azure-2/) on the Microsoft Open Technologies website.</span></span>
- <span data-ttu-id="0b52b-219">Az [Apache Curator](http://curator.apache.org/), amely az Apache ZooKeeper ügyfélkódtára.</span><span class="sxs-lookup"><span data-stu-id="0b52b-219">[Apache Curator](http://curator.apache.org/) a client library for Apache ZooKeeper.</span></span>
- <span data-ttu-id="0b52b-220">Az MSDN [blobbérleteket (REST API)](https://msdn.microsoft.com/library/azure/ee691972.aspx) ismertető cikke.</span><span class="sxs-lookup"><span data-stu-id="0b52b-220">The article [Lease Blob (REST API)](https://msdn.microsoft.com/library/azure/ee691972.aspx) on MSDN.</span></span>
