---
title: "Vezető választás"
description: "Koordinálja az elosztott alkalmazásban lévő együttműködés task példányokat gyűjteménye egy példánya, amely azt feltételezi, hogy a többi példány felelős a vezetőjeként megválasztását által végrehajtott műveletekről."
keywords: "Kialakítási mintája"
author: dragon119
ms.date: 06/23/2017
pnp.series.title: Cloud Design Patterns
pnp.pattern.categories:
- design-implementation
- resiliency
ms.openlocfilehash: ddb61097ed3229ed0ed517b94c280d3ef892c999
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 11/14/2017
---
# <a name="leader-election-pattern"></a><span data-ttu-id="b7827-104">Vezető választás minta</span><span class="sxs-lookup"><span data-stu-id="b7827-104">Leader Election pattern</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="b7827-105">Koordinálja megválasztását egy példánya, amely a többi kezelése felelősséget a vezetőjeként a gyűjtemény egy elosztottalkalmazás-együttműködés példánya által végrehajtott műveletekről.</span><span class="sxs-lookup"><span data-stu-id="b7827-105">Coordinate the actions performed by a collection of collaborating instances in a distributed application by electing one instance as the leader that assumes responsibility for managing the others.</span></span> <span data-ttu-id="b7827-106">Ez segít annak érdekében, hogy példányok nem ütköznek egymással, a versengés a megosztott erőforrások miatt, vagy véletlenül zavarja a munkát, amely a többi példány hajtja végre.</span><span class="sxs-lookup"><span data-stu-id="b7827-106">This can help to ensure that instances don't conflict with each other, cause contention for shared resources, or inadvertently interfere with the work that other instances are performing.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="b7827-107">A környezetben, és probléma</span><span class="sxs-lookup"><span data-stu-id="b7827-107">Context and problem</span></span>

<span data-ttu-id="b7827-108">Egy tipikus felhő alkalmazásnak összehangolt módon viselkedő számos feladatot.</span><span class="sxs-lookup"><span data-stu-id="b7827-108">A typical cloud application has many tasks acting in a coordinated manner.</span></span> <span data-ttu-id="b7827-109">Ezeket a feladatokat az összes lehet kódot futtató és az erőforrásokhoz hozzáférést igénylő példányok, vagy azok működik együtt egy bonyolult számításhoz egyes részeire végre párhuzamosan.</span><span class="sxs-lookup"><span data-stu-id="b7827-109">These tasks could all be instances running the same code and requiring access to the same resources, or they might be working together in parallel to perform the individual parts of a complex calculation.</span></span>

<span data-ttu-id="b7827-110">A task példányokat lehet, hogy külön futtatja az az idő nagy, de is szükség lehet a műveleteket, győződjön meg arról, hogy nem ütköznek, a versengés a megosztott erőforrások miatt, vagy véletlenül zavarja a munkát, hogy a feladat minden egyes példányának koordinálására példányok hajt végre.</span><span class="sxs-lookup"><span data-stu-id="b7827-110">The task instances might run separately for much of the time, but it might also be necessary to coordinate the actions of each instance to ensure that they don’t conflict, cause contention for shared resources, or accidentally interfere with the work that other task instances are performing.</span></span>

<span data-ttu-id="b7827-111">Példa:</span><span class="sxs-lookup"><span data-stu-id="b7827-111">For example:</span></span>

- <span data-ttu-id="b7827-112">Egy felhőalapú rendszer, amely megvalósítja a horizontális skálázás ugyanezt a feladatot több példánya sikerült fut egyszerre, ha minden példánya egy másik felhasználót szolgál.</span><span class="sxs-lookup"><span data-stu-id="b7827-112">In a cloud-based system that implements horizontal scaling, multiple instances of the same task could be running at the same time with each instance serving a different user.</span></span> <span data-ttu-id="b7827-113">Ha ezek a példányok írni egy megosztott erőforráson, fontos együttműködéséből feltünteti a mások által végrehajtott módosítások felülírják megelőzése érdekében.</span><span class="sxs-lookup"><span data-stu-id="b7827-113">If these instances write to a shared resource, it's necessary to coordinate their actions to prevent each instance from overwriting the changes made by the others.</span></span>
- <span data-ttu-id="b7827-114">A feladatok egyes elemeit, egy bonyolult számításhoz párhuzamosan hajtja végre, ha az eredmények kell lennie összesítését, amikor az összes művelet befejeződik.</span><span class="sxs-lookup"><span data-stu-id="b7827-114">If the tasks are performing individual elements of a complex calculation in parallel, the results need to be aggregated when they all complete.</span></span>

<span data-ttu-id="b7827-115">A task példányokat összes társak, így egy természetes vezető, amely működhet, és a koordinátor vagy a gyűjtő nem áll rendelkezésre.</span><span class="sxs-lookup"><span data-stu-id="b7827-115">The task instances are all peers, so there isn't a natural leader that can act as the coordinator or aggregator.</span></span>

## <a name="solution"></a><span data-ttu-id="b7827-116">Megoldás</span><span class="sxs-lookup"><span data-stu-id="b7827-116">Solution</span></span>

<span data-ttu-id="b7827-117">Egy adott feladat példány választják vezetője nevében járhasson el, és ezt a példányt kell koordinálja a többi alárendelt task példányokat a műveleteket.</span><span class="sxs-lookup"><span data-stu-id="b7827-117">A single task instance should be elected to act as the leader, and this instance should coordinate the actions of the other subordinate task instances.</span></span> <span data-ttu-id="b7827-118">Minden a task példányokat futtassa ugyanazt a kódot, ha egyes képes a vezetőjeként működő.</span><span class="sxs-lookup"><span data-stu-id="b7827-118">If all of the task instances are running the same code, they are each capable of acting as the leader.</span></span> <span data-ttu-id="b7827-119">Ezért a választási folyamat felügyelni gondosan két vagy több példány egyszerre a vezető szerepkör tart megelőzése érdekében.</span><span class="sxs-lookup"><span data-stu-id="b7827-119">Therefore, the election process must be managed carefully to prevent two or more instances taking over the leader role at the same time.</span></span>

<span data-ttu-id="b7827-120">A rendszer meg kell adnia egy robusztus mechanizmus vezetője kijelöléséhez.</span><span class="sxs-lookup"><span data-stu-id="b7827-120">The system must provide a robust mechanism for selecting the leader.</span></span> <span data-ttu-id="b7827-121">Ez a módszer a folyamatosan esemény, például a hálózati kimaradások vagy folyamathibák rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="b7827-121">This method has to cope with events such as network outages or process failures.</span></span> <span data-ttu-id="b7827-122">A sok megoldások az alsóbb szintű task példányokat figyelése valamilyen szívverés metódus, vagy lekérdezési keresztül vezetője.</span><span class="sxs-lookup"><span data-stu-id="b7827-122">In many solutions, the subordinate task instances monitor the leader through some type of heartbeat method, or by polling.</span></span> <span data-ttu-id="b7827-123">Ha a kijelölt vezető leáll váratlanul, vagy egy hálózati hiba miatt elérhetetlenné vezetője az alárendelt tevékenység példányokhoz, fontos egy új vezető dönthetnek úgy, hogy.</span><span class="sxs-lookup"><span data-stu-id="b7827-123">If the designated leader terminates unexpectedly, or a network failure makes the leader unavailable to the subordinate task instances, it's necessary for them to elect a new leader.</span></span>

<span data-ttu-id="b7827-124">Nincsenek több stratégiák megválasztását között elosztott környezetben feladatokat egy vezető például:</span><span class="sxs-lookup"><span data-stu-id="b7827-124">There are several strategies for electing a leader among a set of tasks in a distributed environment, including:</span></span>
- <span data-ttu-id="b7827-125">A feladat példány kiválasztja a legalacsonyabb rangsorolva példányt, vagy a folyamat azonosítója.</span><span class="sxs-lookup"><span data-stu-id="b7827-125">Selecting the task instance with the lowest-ranked instance or process ID.</span></span>
- <span data-ttu-id="b7827-126">Racing megosztott, elosztott mutex megszerzésére.</span><span class="sxs-lookup"><span data-stu-id="b7827-126">Racing to acquire a shared, distributed mutex.</span></span> <span data-ttu-id="b7827-127">Az első feladat, amely szerez be a mutex példány vezetője.</span><span class="sxs-lookup"><span data-stu-id="b7827-127">The first task instance that acquires the mutex is the leader.</span></span> <span data-ttu-id="b7827-128">A rendszer azonban biztosítja, hogy a vezető megszakítja, vagy megszakítja a kapcsolatot a rendszer a többi, ha a mutex átadott lehetővé válik a vezető egy másik feladat példány.</span><span class="sxs-lookup"><span data-stu-id="b7827-128">However, the system must ensure that, if the leader terminates or becomes disconnected from the rest of the system, the mutex is released to allow another task instance to become the leader.</span></span>
- <span data-ttu-id="b7827-129">Például a végrehajtási egyik közös vezető választás algoritmus a [Bully algoritmus](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/BullyExample.html) vagy a [Ring algoritmus](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/RingElectExample.html).</span><span class="sxs-lookup"><span data-stu-id="b7827-129">Implementing one of the common leader election algorithms such as the [Bully Algorithm](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/BullyExample.html) or the [Ring Algorithm](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/RingElectExample.html).</span></span> <span data-ttu-id="b7827-130">Ezek az algoritmusok azt feltételezik, hogy minden jelölt a választás egy egyedi Azonosítóval rendelkezik-e, és, hogy képes legyen kommunikálni az egyéb jelöltek megbízhatóan.</span><span class="sxs-lookup"><span data-stu-id="b7827-130">These algorithms assume that each candidate in the election has a unique ID, and that it can communicate with the other candidates reliably.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="b7827-131">Problémákat és szempontok</span><span class="sxs-lookup"><span data-stu-id="b7827-131">Issues and considerations</span></span>

<span data-ttu-id="b7827-132">Ebben a mintában megvalósításához meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="b7827-132">Consider the following points when deciding how to implement this pattern:</span></span>
- <span data-ttu-id="b7827-133">Egy vezető megválasztását folyamata rugalmas ideiglenes és állandó hibák kell lennie.</span><span class="sxs-lookup"><span data-stu-id="b7827-133">The process of electing a leader should be resilient to transient and persistent failures.</span></span>
- <span data-ttu-id="b7827-134">Észlelés, ha a sikertelen vagy más módon elérhetetlenné vált elemezhetőnek kell lennie (például egy kommunikációs hiba miatt).</span><span class="sxs-lookup"><span data-stu-id="b7827-134">It must be possible to detect when the leader has failed or has become otherwise unavailable (such as due to a communications failure).</span></span> <span data-ttu-id="b7827-135">Milyen gyorsan észlelési van szükség a rendszer függő.</span><span class="sxs-lookup"><span data-stu-id="b7827-135">How quickly detection is needed is system dependent.</span></span> <span data-ttu-id="b7827-136">Egyes rendszerek lehet egy vezető, amely során egy átmeneti hiba előfordulhat, hogy rögzített nélkül rövid ideig működik.</span><span class="sxs-lookup"><span data-stu-id="b7827-136">Some systems might be able to function for a short time without a leader, during which a transient fault might be fixed.</span></span> <span data-ttu-id="b7827-137">Más esetekben szükség lehet vezető hiba azonnali észlelésére, és indul el, egy új választás.</span><span class="sxs-lookup"><span data-stu-id="b7827-137">In other cases, it might be necessary to detect leader failure immediately and trigger a new election.</span></span>
- <span data-ttu-id="b7827-138">A vízszintes automatikus skálázás megvalósító rendszer vezetője sikerült megszakítása, ha a rendszer méretezi vissza, és leállítja a számítási erőforrások.</span><span class="sxs-lookup"><span data-stu-id="b7827-138">In a system that implements horizontal autoscaling, the leader could be terminated if the system scales back and shuts down some of the computing resources.</span></span>
- <span data-ttu-id="b7827-139">A külső szolgáltatás, amely a mutex függ a megosztott, elosztott mutex használatával vezet be.</span><span class="sxs-lookup"><span data-stu-id="b7827-139">Using a shared, distributed mutex introduces a dependency on the external service that provides the mutex.</span></span> <span data-ttu-id="b7827-140">A szolgáltatás jelent a hibaérzékeny pontok kialakulását.</span><span class="sxs-lookup"><span data-stu-id="b7827-140">The service constitutes a single point of failure.</span></span> <span data-ttu-id="b7827-141">Ha az elérhetetlenné válik a bármilyen okból, a rendszer nem lehet egy vezető kiválasztják.</span><span class="sxs-lookup"><span data-stu-id="b7827-141">If it becomes unavailable for any reason, the system won't be able to elect a leader.</span></span>
- <span data-ttu-id="b7827-142">Egyetlen dedikált folyamat a vezetőjeként használata egyszerű megközelítése.</span><span class="sxs-lookup"><span data-stu-id="b7827-142">Using a single dedicated process as the leader is a straightforward approach.</span></span> <span data-ttu-id="b7827-143">Azonban ha a sikertelen lehetnek jelentős késés az újraindítás közben.</span><span class="sxs-lookup"><span data-stu-id="b7827-143">However, if the process fails there could be a significant delay while it's restarted.</span></span> <span data-ttu-id="b7827-144">Az eredményül kapott késés hatással lehet a teljesítmény és a válasz időpont más folyamatok, ha azok egy művelet. koordinálására vezetője eredménykészletre várakozik.</span><span class="sxs-lookup"><span data-stu-id="b7827-144">The resulting latency can affect the performance and response times of other processes if they're waiting for the leader to coordinate an operation.</span></span>
- <span data-ttu-id="b7827-145">Manuálisan végrehajtási egyik vezető választás algoritmus beállítás, és optimalizálja a kódot a legnagyobb rugalmasságot biztosít.</span><span class="sxs-lookup"><span data-stu-id="b7827-145">Implementing one of the leader election algorithms manually provides the greatest flexibility for tuning and optimizing the code.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="b7827-146">Mikor érdemes használni ezt a mintát</span><span class="sxs-lookup"><span data-stu-id="b7827-146">When to use this pattern</span></span>

<span data-ttu-id="b7827-147">Ezt a mintát használja, ha az elosztott alkalmazásokban, például a felhőben üzemeltetett megoldás, a feladatok óvatos koordinációs kell, és nem természetes vezető.</span><span class="sxs-lookup"><span data-stu-id="b7827-147">Use this pattern when the tasks in a distributed application, such as a cloud-hosted solution, need careful coordination and there's no natural leader.</span></span>

>  <span data-ttu-id="b7827-148">Elkerüli a vezető szűk keresztmetszet a rendszerben.</span><span class="sxs-lookup"><span data-stu-id="b7827-148">Avoid making the leader a bottleneck in the system.</span></span> <span data-ttu-id="b7827-149">A vezetője célja, hogy összehangolják a munkát az alsóbb szintű feladatokat, és nem feltétlenül kell részt vesz a munkát saját magát a&mdash;bár erre, ha a feladat nem döntött a vezetőjeként képesnek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="b7827-149">The purpose of the leader is to coordinate the work of the subordinate tasks, and it doesn't necessarily have to participate in this work itself&mdash;although it should be able to do so if the task isn't elected as the leader.</span></span>

<span data-ttu-id="b7827-150">Ez a minta nem lehet hasznos, ha:</span><span class="sxs-lookup"><span data-stu-id="b7827-150">This pattern might not be useful if:</span></span>
- <span data-ttu-id="b7827-151">Legyen egy természetes vezető vagy dedikált folyamat, amely mindig működhet-e a vezetőjeként.</span><span class="sxs-lookup"><span data-stu-id="b7827-151">There's a natural leader or dedicated process that can always act as the leader.</span></span> <span data-ttu-id="b7827-152">Például előfordulhat, hogy legyen egy egypéldányos folyamat, amely koordinálja a task példányokat valósíthat meg.</span><span class="sxs-lookup"><span data-stu-id="b7827-152">For example, it might be possible to implement a singleton process that coordinates the task instances.</span></span> <span data-ttu-id="b7827-153">Ez a folyamat sikertelen lesz, vagy akkor kerül sérült állapotba, ha a rendszer leállítják a webhelyet, és indítsa újra.</span><span class="sxs-lookup"><span data-stu-id="b7827-153">If this process fails or becomes unhealthy, the system can shut it down and restart it.</span></span>
- <span data-ttu-id="b7827-154">A feladatok összehangolását több egyszerűsített módszerrel lehet elérni.</span><span class="sxs-lookup"><span data-stu-id="b7827-154">The coordination between tasks can be achieved using a more lightweight method.</span></span> <span data-ttu-id="b7827-155">Például ha több task példányokat egyszerűen egy megosztott erőforráson koordinált hozzáférésre van szükségük, jobb megoldás, hogy használja a optimista vagy pesszimista zárolás való hozzáférés.</span><span class="sxs-lookup"><span data-stu-id="b7827-155">For example, if several task instances simply need coordinated access to a shared resource, a better solution is to use optimistic or pessimistic locking to control access.</span></span>
- <span data-ttu-id="b7827-156">Egy harmadik féltől származó megoldás több alkalmas.</span><span class="sxs-lookup"><span data-stu-id="b7827-156">A third-party solution is more appropriate.</span></span> <span data-ttu-id="b7827-157">Például a Microsoft Azure HDInsight szolgáltatáson (Apache Hadoop) Apache Zookeeper által nyújtott szolgáltatások koordinálja a térkép és feladatokat, melyek begyűjtik és adatainak összefoglalója használja.</span><span class="sxs-lookup"><span data-stu-id="b7827-157">For example, the Microsoft Azure HDInsight service (based on Apache Hadoop) uses the services provided by Apache Zookeeper to coordinate the map and reduce tasks that collect and summarize data.</span></span>

## <a name="example"></a><span data-ttu-id="b7827-158">Példa</span><span class="sxs-lookup"><span data-stu-id="b7827-158">Example</span></span>

<span data-ttu-id="b7827-159">A LeaderElection DistributedMutex projektje (minta bemutatja, ebben a mintában érhető el a [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/leader-election)) bemutatja, hogyan lehet egy Azure Storage-blob a címbérlet segítségével végrehajtási egy megosztott egy olyan mechanizmus biztosítása elosztott mutex.</span><span class="sxs-lookup"><span data-stu-id="b7827-159">The DistributedMutex project in the LeaderElection solution (a sample that demonstrates this pattern is available on [GitHub](https://github.com/mspnp/cloud-design-patterns/tree/master/leader-election)) shows how to use a lease on an Azure Storage blob to provide a mechanism for implementing a shared, distributed mutex.</span></span> <span data-ttu-id="b7827-160">A mutex segítségével választ egy vezető Azure-felhőszolgáltatás szerepkörpéldányt csoportja között.</span><span class="sxs-lookup"><span data-stu-id="b7827-160">This mutex can be used to elect a leader among a group of role instances in an Azure cloud service.</span></span> <span data-ttu-id="b7827-161">A bérleti jogot szerezni az első szerepkörpéldányt vezetője kijelölt, és a vezető marad, amíg kiadja a címbérlet, vagy nem tudja a címbérlet megújítása.</span><span class="sxs-lookup"><span data-stu-id="b7827-161">The first role instance to acquire the lease is elected the leader, and remains the leader until it releases the lease or isn't able to renew the lease.</span></span> <span data-ttu-id="b7827-162">Többi szerepkörpéldányon továbbra is figyelheti a blob bérleti abban az esetben, ha a vezető már nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="b7827-162">Other role instances can continue to monitor the blob lease in case the leader is no longer available.</span></span>

>  <span data-ttu-id="b7827-163">A blob címbérlet egy kizárólagos írási zárolás blob felett.</span><span class="sxs-lookup"><span data-stu-id="b7827-163">A blob lease is an exclusive write lock over a blob.</span></span> <span data-ttu-id="b7827-164">Egy blob idő lehet bármely pontján csak egy címbérlet tárgyát.</span><span class="sxs-lookup"><span data-stu-id="b7827-164">A single blob can be the subject of only one lease at any point in time.</span></span> <span data-ttu-id="b7827-165">A szerepkör példánya a címbérlet kérheti a megadott blob keresztül, és azt fogja adható a címbérlet Ha nincs más szerepkörpéldányt tárolja a címbérlet azonos blob keresztül.</span><span class="sxs-lookup"><span data-stu-id="b7827-165">A role instance can request a lease over a specified blob, and it'll be granted the lease if no other role instance holds a lease over the same blob.</span></span> <span data-ttu-id="b7827-166">A kérelem egyébként kivételt jelez.</span><span class="sxs-lookup"><span data-stu-id="b7827-166">Otherwise the request will throw an exception.</span></span>

> <span data-ttu-id="b7827-167">A hibás szerepkör példánya határozatlan ideig megtartja a címbérlet elkerülése érdekében adja meg a címbérlet-élettartamot.</span><span class="sxs-lookup"><span data-stu-id="b7827-167">To avoid a faulted role instance retaining the lease indefinitely, specify a lifetime for the lease.</span></span> <span data-ttu-id="b7827-168">Amikor lejár, a címbérlet elérhetővé válik.</span><span class="sxs-lookup"><span data-stu-id="b7827-168">When this expires, the lease becomes available.</span></span> <span data-ttu-id="b7827-169">Azonban amíg egy szerepkörpéldányt, amely tárolja a címbérlet kérheti, hogy a címbérlet megújulásakor, és azt fogja nyújtani a címbérlet további időn belül.</span><span class="sxs-lookup"><span data-stu-id="b7827-169">However, while a role instance holds the lease it can request that the lease is renewed, and it'll be granted the lease for a further period of time.</span></span> <span data-ttu-id="b7827-170">A szerepkör példánya is folyamatosan ismételje ezt az eljárást, ha azt szeretné megőrizni a címbérlet.</span><span class="sxs-lookup"><span data-stu-id="b7827-170">The role instance can continually repeat this process if it wants to retain the lease.</span></span>
<span data-ttu-id="b7827-171">Blob címbérlet kapcsolatos további információkért lásd: [bérleti Blob (REST API-t)](https://msdn.microsoft.com/library/azure/ee691972.aspx).</span><span class="sxs-lookup"><span data-stu-id="b7827-171">For more information on how to lease a blob, see [Lease Blob (REST API)](https://msdn.microsoft.com/library/azure/ee691972.aspx).</span></span>

<span data-ttu-id="b7827-172">A `BlobDistributedMutex` osztály a C# az alábbi példa tartalmazza a `RunTaskWhenMutexAquired` módszer, amely lehetővé teszi, hogy egy sikertelen bejelentkezési kísérletet bérletet szerezni a megadott blob keresztül szerepkörpéldányt.</span><span class="sxs-lookup"><span data-stu-id="b7827-172">The `BlobDistributedMutex` class in the C# example below contains the `RunTaskWhenMutexAquired` method that enables a role instance to attempt to acquire a lease over a specified blob.</span></span> <span data-ttu-id="b7827-173">A konstruktornak átadott a blobot (a neve, a tároló és a tárolási fiók) részleteit egy `BlobSettings` objektum amikor a `BlobDistributedMutex` objektum létrehozása (Ez az objektum, amely megtalálható a mintakódot egyszerű struktúra).</span><span class="sxs-lookup"><span data-stu-id="b7827-173">The details of the blob (the name, container, and storage account) are passed to the constructor in a `BlobSettings` object when the `BlobDistributedMutex` object is created (this object is a simple struct that is included in the sample code).</span></span> <span data-ttu-id="b7827-174">A konstruktornak is fogad el egy `Task` , amely a kódot, amely a szerepkör példánya futhat, ha sikeresen szerez be a címbérlet a blob keresztül, és kijelölt vezetője hivatkozik.</span><span class="sxs-lookup"><span data-stu-id="b7827-174">The constructor also accepts a `Task` that references the code that the role instance should run if it successfully acquires the lease over the blob and is elected the leader.</span></span> <span data-ttu-id="b7827-175">Vegye figyelembe, hogy a kódot, amely kezeli a kevésbé fontos részletek az beszerzése a címbérlet vezettek be egy külön segítőosztály nevű `BlobLeaseManager`.</span><span class="sxs-lookup"><span data-stu-id="b7827-175">Note that the code that handles the low-level details of acquiring the lease is implemented in a separate helper class named `BlobLeaseManager`.</span></span>

```csharp
public class BlobDistributedMutex
{
  ...
  private readonly BlobSettings blobSettings;
  private readonly Func<CancellationToken, Task> taskToRunWhenLeaseAcquired;
  ...

  public BlobDistributedMutex(BlobSettings blobSettings,
           Func<CancellationToken, Task> taskToRunWhenLeaseAquired)
  {
    this.blobSettings = blobSettings;
    this.taskToRunWhenLeaseAquired = taskToRunWhenLeaseAquired;
  }

  public async Task RunTaskWhenMutexAcquired(CancellationToken token)
  {
    var leaseManager = new BlobLeaseManager(blobSettings);
    await this.RunTaskWhenBlobLeaseAcquired(leaseManager, token);
  }
  ...
```

<span data-ttu-id="b7827-176">A `RunTaskWhenMutexAquired` a fenti kódminta metódus meghívja a `RunTaskWhenBlobLeaseAcquired` mintában látható módon a következő kód ténylegesen bérleti jogot szerezni a metódust.</span><span class="sxs-lookup"><span data-stu-id="b7827-176">The `RunTaskWhenMutexAquired` method in the code sample above invokes the `RunTaskWhenBlobLeaseAcquired` method shown in the following code sample to actually acquire the lease.</span></span> <span data-ttu-id="b7827-177">A `RunTaskWhenBlobLeaseAcquired` metódus aszinkron módon futtatja.</span><span class="sxs-lookup"><span data-stu-id="b7827-177">The `RunTaskWhenBlobLeaseAcquired` method runs asynchronously.</span></span> <span data-ttu-id="b7827-178">A bérlet sikeresen szerezte be, ha a szerepkör példánya úgy lett döntött, hogy a vezető.</span><span class="sxs-lookup"><span data-stu-id="b7827-178">If the lease is successfully acquired, the role instance has been elected the leader.</span></span> <span data-ttu-id="b7827-179">A célja a `taskToRunWhenLeaseAcquired` delegált, amely a többi szerepkörpéldányon koordinálja a munkájuk elvégzéséhez.</span><span class="sxs-lookup"><span data-stu-id="b7827-179">The purpose of the `taskToRunWhenLeaseAcquired` delegate is to perform the work that coordinates the other role instances.</span></span> <span data-ttu-id="b7827-180">A bérlet nem szerezte be, ha egy másik szerepkör példánya lett döntött a vezetőjeként, és az aktuális példányon beosztottja marad.</span><span class="sxs-lookup"><span data-stu-id="b7827-180">If the lease isn't acquired, another role instance has been elected as the leader and the current role instance remains a subordinate.</span></span> <span data-ttu-id="b7827-181">Vegye figyelembe, hogy a `TryAcquireLeaseOrWait` metódus által használt egy segédmetódust a `BlobLeaseManager` objektum a bérleti jogot szerezni.</span><span class="sxs-lookup"><span data-stu-id="b7827-181">Note that the `TryAcquireLeaseOrWait` method is a helper method that uses the `BlobLeaseManager` object to acquire the lease.</span></span>

```csharp
  private async Task RunTaskWhenBlobLeaseAcquired(
    BlobLeaseManager leaseManager, CancellationToken token)
  {
    while (!token.IsCancellationRequested)
    {
      // Try to acquire the blob lease.
      // Otherwise wait for a short time before trying again.
      string leaseId = await this.TryAquireLeaseOrWait(leaseManager, token);

      if (!string.IsNullOrEmpty(leaseId))
      {
        // Create a new linked cancellation token source so that if either the
        // original token is canceled or the lease can't be renewed, the
        // leader task can be canceled.
        using (var leaseCts =
          CancellationTokenSource.CreateLinkedTokenSource(new[] { token }))
        {
          // Run the leader task.
          var leaderTask = this.taskToRunWhenLeaseAquired.Invoke(leaseCts.Token);
          ...
        }
      }
    }
    ...
  }
```

<span data-ttu-id="b7827-182">A feladat elindult vezetője is aszinkron módon futtatja.</span><span class="sxs-lookup"><span data-stu-id="b7827-182">The task started by the leader also runs asynchronously.</span></span> <span data-ttu-id="b7827-183">Ez a feladat futása közben a `RunTaskWhenBlobLeaseAquired` metódus mintában látható módon a következő kód rendszeres időközönként megpróbálja a címbérlet megújítása.</span><span class="sxs-lookup"><span data-stu-id="b7827-183">While this task is running, the `RunTaskWhenBlobLeaseAquired` method shown in the following code sample periodically attempts to renew the lease.</span></span> <span data-ttu-id="b7827-184">Ezzel biztosíthatja, hogy a szerepkör példánya továbbra is a vezető.</span><span class="sxs-lookup"><span data-stu-id="b7827-184">This helps to ensure that the role instance remains the leader.</span></span> <span data-ttu-id="b7827-185">A minta a megoldásban a közötti megújítási kérelmeket késleltetési idő legyen kisebb, mint a címbérlet időtartama leállítja, nehogy egy másik szerepkör példánya választanak vezetője megadott idő.</span><span class="sxs-lookup"><span data-stu-id="b7827-185">In the sample solution, the delay between renewal requests is less than the time specified for the duration of the lease in order to prevent another role instance from being elected the leader.</span></span> <span data-ttu-id="b7827-186">A megújítás bármilyen okból nem sikerül, ha a feladat megszakadt.</span><span class="sxs-lookup"><span data-stu-id="b7827-186">If the renewal fails for any reason, the task is canceled.</span></span>

<span data-ttu-id="b7827-187">Ha a címbérlet megújítását sikertelen, vagy megszakadt a feladat (valószínűleg miatt a szerepkörpéldányt leállítása), a címbérlet szabadul fel.</span><span class="sxs-lookup"><span data-stu-id="b7827-187">If the lease fails to be renewed or the task is canceled (possibly as a result of the role instance shutting down), the lease is released.</span></span> <span data-ttu-id="b7827-188">Ez vagy egy másik szerepkör példánya ezen a ponton a vezetőjeként kell választani.</span><span class="sxs-lookup"><span data-stu-id="b7827-188">At this point, this or another role instance might be elected as the leader.</span></span> <span data-ttu-id="b7827-189">A kód alatt mutat ez a folyamat során.</span><span class="sxs-lookup"><span data-stu-id="b7827-189">The code extract below shows this part of the process.</span></span>

```csharp
  private async Task RunTaskWhenBlobLeaseAcquired(
    BlobLeaseManager leaseManager, CancellationToken token)
  {
    while (...)
    {
      ...
      if (...)
      {
        ...
        using (var leaseCts = ...)
        {
          ...
          // Keep renewing the lease in regular intervals.
          // If the lease can't be renewed, then the task completes.
          var renewLeaseTask =
            this.KeepRenewingLease(leaseManager, leaseId, leaseCts.Token);

          // When any task completes (either the leader task itself or when it
          // couldn't renew the lease) then cancel the other task.
          await CancelAllWhenAnyCompletes(leaderTask, renewLeaseTask, leaseCts);
        }
      }
    }
  }
  ...
}
```

<span data-ttu-id="b7827-190">A `KeepRenewingLease` metódus egy másik segítő módszerrel, amely a `BlobLeaseManager` a címbérlet megújítása objektum.</span><span class="sxs-lookup"><span data-stu-id="b7827-190">The `KeepRenewingLease` method is another helper method that uses the `BlobLeaseManager` object to renew the lease.</span></span> <span data-ttu-id="b7827-191">A `CancelAllWhenAnyCompletes` metódus visszavonja a feladatokat az első két paraméterként megadva.</span><span class="sxs-lookup"><span data-stu-id="b7827-191">The `CancelAllWhenAnyCompletes` method cancels the tasks specified as the first two parameters.</span></span> <span data-ttu-id="b7827-192">A következő diagram azt ábrázolja, használja a `BlobDistributedMutex` osztályt választ egy vezető műveleteket koordináló feladat futtatása.</span><span class="sxs-lookup"><span data-stu-id="b7827-192">The following diagram illustrates using the `BlobDistributedMutex` class to elect a leader and run a task that coordinates operations.</span></span>

![1. ábra szemlélteti a funkciók BlobDistributedMutex osztály](./_images/leader-election-diagram.png)


<span data-ttu-id="b7827-194">Az alábbi példakód bemutatja, hogyan használható a `BlobDistributedMutex` osztály a feldolgozói szerepkörök.</span><span class="sxs-lookup"><span data-stu-id="b7827-194">The following code example shows how to use the `BlobDistributedMutex` class in a worker role.</span></span> <span data-ttu-id="b7827-195">Ez a kód címbérletet keresztül nevű blob `MyLeaderCoordinatorTask` a címbérlet tárolóban fejlesztési tárolóban, és megadja, hogy a kód definiálva a `MyLeaderCoordinatorTask` metódus kell futtatni, ha a szerepkör példánya kijelölt vezetője.</span><span class="sxs-lookup"><span data-stu-id="b7827-195">This code acquires a lease over a blob named `MyLeaderCoordinatorTask` in the lease's container in development storage, and specifies that the code defined in the `MyLeaderCoordinatorTask` method should run if the role instance is elected the leader.</span></span>

```csharp
var settings = new BlobSettings(CloudStorageAccount.DevelopmentStorageAccount,
  "leases", "MyLeaderCoordinatorTask");
var cts = new CancellationTokenSource();
var mutex = new BlobDistributedMutex(settings, MyLeaderCoordinatorTask);
mutex.RunTaskWhenMutexAcquired(this.cts.Token);
...

// Method that runs if the role instance is elected the leader
private static async Task MyLeaderCoordinatorTask(CancellationToken token)
{
  ...
}
```

<span data-ttu-id="b7827-196">Megjegyzés: a minta-megoldás a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="b7827-196">Note the following points about the sample solution:</span></span>
- <span data-ttu-id="b7827-197">A blob nem lehetséges hibaérzékeny pontok kialakulását.</span><span class="sxs-lookup"><span data-stu-id="b7827-197">The blob is a potential single point of failure.</span></span> <span data-ttu-id="b7827-198">A blob szolgáltatás nem érhető el, vagy nem érhető el, ha a kitöltés nem fog tudni a címbérlet megújítása, és nincs más szerepkörpéldányt tudják a bérleti jogot szerezni.</span><span class="sxs-lookup"><span data-stu-id="b7827-198">If the blob service becomes unavailable, or is inaccessible, the leader won't be able to renew the lease and no other role instance will be able to acquire the lease.</span></span> <span data-ttu-id="b7827-199">Ebben az esetben nem szerepkörpéldányt tudnak vezetője nevében járhasson el.</span><span class="sxs-lookup"><span data-stu-id="b7827-199">In this case, no role instance will be able to act as the leader.</span></span> <span data-ttu-id="b7827-200">Azonban a blob szolgáltatás tervezték rugalmas, így teljesen meghibásodik, a blob szolgáltatás nagyon valószínű tekinthető.</span><span class="sxs-lookup"><span data-stu-id="b7827-200">However, the blob service is designed to be resilient, so complete failure of the blob service is considered to be extremely unlikely.</span></span>
- <span data-ttu-id="b7827-201">A feladat vezetője által végzett lefagy, ha a vezető előfordulhat, hogy továbbra is a címbérlet megújítása akadályozza meg, hogy más szerepkör példánya a címbérlet beszerzése és a vezető szerepkör feladatok koordinálására tovább tart.</span><span class="sxs-lookup"><span data-stu-id="b7827-201">If the task being performed by the leader stalls, the leader might continue to renew the lease, preventing any other role instance from acquiring the lease and taking over the leader role in order to coordinate tasks.</span></span> <span data-ttu-id="b7827-202">A valós életben vezetője állapotát ellenőrizni kell, rendszeres időközönként.</span><span class="sxs-lookup"><span data-stu-id="b7827-202">In the real world, the health of the leader should be checked at frequent intervals.</span></span>
- <span data-ttu-id="b7827-203">A választási folyamat nem determinált.</span><span class="sxs-lookup"><span data-stu-id="b7827-203">The election process is nondeterministic.</span></span> <span data-ttu-id="b7827-204">Nem hajtható végre semmilyen feltételezéseket szerepkörtől példányt fog szerezni a blob-címbérlet és vezetője válnak.</span><span class="sxs-lookup"><span data-stu-id="b7827-204">You can't make any assumptions about which role instance will acquire the blob lease and become the leader.</span></span>
- <span data-ttu-id="b7827-205">A blob bérleti céljaként használt blob semmilyen más célra nem használható.</span><span class="sxs-lookup"><span data-stu-id="b7827-205">The blob used as the target of the blob lease shouldn't be used for any other purpose.</span></span> <span data-ttu-id="b7827-206">Ha a szerepkör példánya megkísérli az adatok tárolása a blob, ezek az adatok nem érhető el kivéve, ha a szerepkör példánya vezetője, valamint a blob bérleti.</span><span class="sxs-lookup"><span data-stu-id="b7827-206">If a role instance attempts to store data in this blob, this data won't be accessible unless the role instance is the leader and holds the blob lease.</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="b7827-207">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="b7827-207">Related patterns and guidance</span></span>

<span data-ttu-id="b7827-208">A következő útmutatást is lehet megfelelő, ebben a mintában végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="b7827-208">The following guidance might also be relevant when implementing this pattern:</span></span>
- <span data-ttu-id="b7827-209">Ez a minta van egy letölthető [mintaalkalmazás](https://github.com/mspnp/cloud-design-patterns/tree/master/leader-election).</span><span class="sxs-lookup"><span data-stu-id="b7827-209">This pattern has a downloadable [sample application](https://github.com/mspnp/cloud-design-patterns/tree/master/leader-election).</span></span>
- <span data-ttu-id="b7827-210">[Automatikus skálázás útmutatást](https://msdn.microsoft.com/library/dn589774.aspx).</span><span class="sxs-lookup"><span data-stu-id="b7827-210">[Autoscaling Guidance](https://msdn.microsoft.com/library/dn589774.aspx).</span></span> <span data-ttu-id="b7827-211">Akkor lehet indítása és leállítása a feladat gazdagépek példányai, mivel változik a terhelés, az alkalmazás.</span><span class="sxs-lookup"><span data-stu-id="b7827-211">It's possible to start and stop instances of the task hosts as the load on the application varies.</span></span> <span data-ttu-id="b7827-212">Automatikus skálázás segítségével átviteli sebesség és a maximális feldolgozási idők során.</span><span class="sxs-lookup"><span data-stu-id="b7827-212">Autoscaling can help to maintain throughput and performance during times of peak processing.</span></span>
- <span data-ttu-id="b7827-213">[Útmutatás particionálás számítási](https://msdn.microsoft.com/library/dn589773.aspx).</span><span class="sxs-lookup"><span data-stu-id="b7827-213">[Compute Partitioning Guidance](https://msdn.microsoft.com/library/dn589773.aspx).</span></span> <span data-ttu-id="b7827-214">Ez az útmutató ismerteti a feladatok lefoglalása egy felhőalapú szolgáltatás, ezáltal segít a méretezhetőséget, teljesítményt, rendelkezésre állási és a szolgáltatás biztonsági megőrzésével futó költségek minimalizálása érdekében a gazdagépek számára.</span><span class="sxs-lookup"><span data-stu-id="b7827-214">This guidance describes how to allocate tasks to hosts in a cloud service in a way that helps to minimize running costs while maintaining the scalability, performance, availability, and security of the service.</span></span>
- <span data-ttu-id="b7827-215">A [feladatalapú aszinkron mintát](https://msdn.microsoft.com/library/hh873175.aspx).</span><span class="sxs-lookup"><span data-stu-id="b7827-215">The [Task-based Asynchronous Pattern](https://msdn.microsoft.com/library/hh873175.aspx).</span></span>
- <span data-ttu-id="b7827-216">Egy példa ábrázoló a [Bully algoritmus](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/BullyExample.html).</span><span class="sxs-lookup"><span data-stu-id="b7827-216">An example illustrating the [Bully Algorithm](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/BullyExample.html).</span></span>
- <span data-ttu-id="b7827-217">Egy példa ábrázoló a [Ring algoritmus](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/RingElectExample.html).</span><span class="sxs-lookup"><span data-stu-id="b7827-217">An example illustrating the [Ring Algorithm](http://www.cs.colostate.edu/~cs551/CourseNotes/Synchronization/RingElectExample.html).</span></span>
- <span data-ttu-id="b7827-218">A cikk [Apache Zookeeper a Microsoft Azure](https://msopentech.com/opentech-projects/apache-zookeeper-on-windows-azure-2/) a Microsoft Open Technologies webhelyen.</span><span class="sxs-lookup"><span data-stu-id="b7827-218">The article [Apache Zookeeper on Microsoft Azure](https://msopentech.com/opentech-projects/apache-zookeeper-on-windows-azure-2/) on the Microsoft Open Technologies website.</span></span>
- <span data-ttu-id="b7827-219">[Apache gondnoka](http://curator.apache.org/) egy ügyfélkönyvtárat az Apache ZooKeeper.</span><span class="sxs-lookup"><span data-stu-id="b7827-219">[Apache Curator](http://curator.apache.org/) a client library for Apache ZooKeeper.</span></span>
- <span data-ttu-id="b7827-220">A cikk [bérleti Blob (REST API-t)](https://msdn.microsoft.com/library/azure/ee691972.aspx) az MSDN Webhelyén.</span><span class="sxs-lookup"><span data-stu-id="b7827-220">The article [Lease Blob (REST API)](https://msdn.microsoft.com/library/azure/ee691972.aspx) on MSDN.</span></span>
