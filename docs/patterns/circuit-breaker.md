---
title: Circuit Breaker
description: Ha távoli szolgáltatáshoz vagy erőforráshoz csatlakozik, kezelheti azokat a hibákat, amelyek javítása esetleg sok időt venne igénybe.
keywords: tervezési minta
author: dragon119
ms.date: 06/23/2017
pnp.series.title: Cloud Design Patterns
pnp.pattern.categories:
- resiliency
ms.openlocfilehash: 0f93c1ef664c8e7385895e3854835699f674ee0e
ms.sourcegitcommit: c441fd165e6bebbbbbc19854ec6f3676be9c3b25
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 03/30/2018
ms.locfileid: "30270472"
---
# <a name="circuit-breaker-pattern"></a><span data-ttu-id="b4523-104">Áramkör-megszakító minta</span><span class="sxs-lookup"><span data-stu-id="b4523-104">Circuit Breaker pattern</span></span>

<span data-ttu-id="b4523-105">Ha távoli szolgáltatáshoz vagy erőforráshoz csatlakozik, kezelheti azokat a hibákat, amelyek helyreállítása esetleg sok időt venne igénybe.</span><span class="sxs-lookup"><span data-stu-id="b4523-105">Handle faults that might take a variable amount of time to recover from, when connecting to a remote service or resource.</span></span> <span data-ttu-id="b4523-106">Ez javítja az alkalmazások stabilitását és rugalmasságát.</span><span class="sxs-lookup"><span data-stu-id="b4523-106">This can improve the stability and resiliency of an application.</span></span>

## <a name="context-and-problem"></a><span data-ttu-id="b4523-107">Kontextus és probléma</span><span class="sxs-lookup"><span data-stu-id="b4523-107">Context and problem</span></span>

<span data-ttu-id="b4523-108">Elosztott környezetben előfordulhat, hogy a távoli erőforrások és szolgáltatások meghívása átmeneti hibák miatt meghiúsul. Ilyen probléma lehet a lassú hálózati kapcsolat vagy időtúllépés, illetve ha az erőforrások nem fedezik az igényeket, vagy átmenetileg nem érhetők el.</span><span class="sxs-lookup"><span data-stu-id="b4523-108">In a distributed environment, calls to remote resources and services can fail due to transient faults, such as slow network connections, timeouts, or the resources being overcommitted or temporarily unavailable.</span></span> <span data-ttu-id="b4523-109">Ezek a hibák általában rövid idő alatt kijavítják magukat, és egy stabil felhőalapú alkalmazásnak fel kell készülnie az ilyesmi kezelésére, például egy [újrapróbálkozási mintához][retry-pattern] hasonló stratégiát alkalmazva.</span><span class="sxs-lookup"><span data-stu-id="b4523-109">These faults typically correct themselves after a short period of time, and a robust cloud application should be prepared to handle them by using a strategy such as the [Retry pattern][retry-pattern].</span></span>

<span data-ttu-id="b4523-110">Lehetnek azonban olyan helyzetek, amikor a hibákat nem várt események okozzák, amelyek helyrehozása tovább tarthat.</span><span class="sxs-lookup"><span data-stu-id="b4523-110">However, there can also be situations where faults are due to unanticipated events, and that might take much longer to fix.</span></span> <span data-ttu-id="b4523-111">Az ilyen hibák súlyossága a részleges kapcsolódási problémától a szolgáltatás teljes leállásáig terjedhet.</span><span class="sxs-lookup"><span data-stu-id="b4523-111">These faults can range in severity from a partial loss of connectivity to the complete failure of a service.</span></span> <span data-ttu-id="b4523-112">Az ilyen helyzetekben lehet, hogy nincs értelme az alkalmazásnak folyamatosan újrapróbálkozni a művelettel, mert nem valószínű, hogy sikerrel járna. Ehelyett inkább az a szerencsés, ha az alkalmazás gyorsan tudomásul veszi, hogy a művelet nem sikerült, és ennek megfelelően kezeli a hibát.</span><span class="sxs-lookup"><span data-stu-id="b4523-112">In these situations it might be pointless for an application to continually retry an operation that is unlikely to succeed, and instead the application should quickly accept that the operation has failed and handle this failure accordingly.</span></span>

<span data-ttu-id="b4523-113">Emellett, ha egy szolgáltatás nagyon elfoglalt, a rendszer egy részén előforduló hiba egész hibasorozatot indíthat be.</span><span class="sxs-lookup"><span data-stu-id="b4523-113">Additionally, if a service is very busy, failure in one part of the system might lead to cascading failures.</span></span> <span data-ttu-id="b4523-114">Egy szolgáltatást meghívó műveletet például lehet úgy konfigurálni, hogy megvalósítson egy időtúllépést, és hibaüzenettel válaszoljon, ha a szolgáltatás nem válaszol a megadott időkereten belül.</span><span class="sxs-lookup"><span data-stu-id="b4523-114">For example, an operation that invokes a service could be configured to implement a timeout, and reply with a failure message if the service fails to respond within this period.</span></span> <span data-ttu-id="b4523-115">Ez a stratégia azonban eredményezheti azt, hogy az ugyanehhez a művelethez küldött sok párhuzamos kérés is blokkolva lesz az időkorlát lejáratáig.</span><span class="sxs-lookup"><span data-stu-id="b4523-115">However, this strategy could cause many concurrent requests to the same operation to be blocked until the timeout period expires.</span></span> <span data-ttu-id="b4523-116">Ezek a blokkolt kérelmek olyan kritikus rendszererőforrásokat akadályozhatnak, mint a memória, szálak, adatbázis-kapcsolatok stb.</span><span class="sxs-lookup"><span data-stu-id="b4523-116">These blocked requests might hold critical system resources such as memory, threads, database connections, and so on.</span></span> <span data-ttu-id="b4523-117">Ebből következik, hogy ezek az erőforrások kimerülhetnek, ez pedig hibát okozhat a rendszer esetleg nem is kapcsolódó, de azonos erőforrásokat használó részeiben.</span><span class="sxs-lookup"><span data-stu-id="b4523-117">Consequently, these resources could become exhausted, causing failure of other possibly unrelated parts of the system that need to use the same resources.</span></span> <span data-ttu-id="b4523-118">Ezekben a helyzetekben az a jó, ha a művelet azonnal meghiúsul, és csak akkor érdemes újból meghívni a szolgáltatást, ha nagy esély van arra, hogy sikerül.</span><span class="sxs-lookup"><span data-stu-id="b4523-118">In these situations, it would be preferable for the operation to fail immediately, and only attempt to invoke the service if it's likely to succeed.</span></span> <span data-ttu-id="b4523-119">Vegye figyelembe, hogy rövidebb időkorlát beállításával megoldható ez a probléma, de az időkorlát ne legyen olyan rövid, hogy a művelet szinte mindig meghiúsuljon, még akkor is, ha végül a szolgáltatáskérés sikeres.</span><span class="sxs-lookup"><span data-stu-id="b4523-119">Note that setting a shorter timeout might help to resolve this problem, but the timeout shouldn't be so short that the operation fails most of the time, even if the request to the service would eventually succeed.</span></span>

## <a name="solution"></a><span data-ttu-id="b4523-120">Megoldás</span><span class="sxs-lookup"><span data-stu-id="b4523-120">Solution</span></span>

<span data-ttu-id="b4523-121">A Michael Nygard [Release it!](https://pragprog.com/book/mnee/release-it) című könyvében népszerűsített áramkör-megszakítási minta megakadályozhatja, hogy egy alkalmazás ismételten megpróbáljon végrehajtani egy nagy valószínűséggel meghiúsuló műveletet.</span><span class="sxs-lookup"><span data-stu-id="b4523-121">The Circuit Breaker pattern, popularized by Michael Nygard in his book, [Release It!](https://pragprog.com/book/mnee/release-it), can prevent an application from repeatedly trying to execute an operation that's likely to fail.</span></span> <span data-ttu-id="b4523-122">Így lehetővé teszi a folytatást, nem kell a hiba kijavítására várni, vagy CPU-ciklusokat pazarolni arra, hogy kiderüljön, hosszan tartó hibáról van szó.</span><span class="sxs-lookup"><span data-stu-id="b4523-122">Allowing it to continue without waiting for the fault to be fixed or wasting CPU cycles while it determines that the fault is long lasting.</span></span> <span data-ttu-id="b4523-123">Az áramkör-megszakítási minta azt is lehetővé teszi az alkalmazás számára, hogy észlelje, ha a hibát kijavították.</span><span class="sxs-lookup"><span data-stu-id="b4523-123">The Circuit Breaker pattern also enables an application to detect whether the fault has been resolved.</span></span> <span data-ttu-id="b4523-124">Ha úgy tűnik, hogy a hiba megoldódott, az alkalmazás megpróbálhatja meghívni a műveletet.</span><span class="sxs-lookup"><span data-stu-id="b4523-124">If the problem appears to have been fixed, the application can try to invoke the operation.</span></span>

> <span data-ttu-id="b4523-125">Az áramkör-megszakító minta nem azonos az újrapróbálkozási mintával.</span><span class="sxs-lookup"><span data-stu-id="b4523-125">The purpose of the Circuit Breaker pattern is different than the Retry pattern.</span></span> <span data-ttu-id="b4523-126">Az újrapróbálkozási minta lehetővé teszi az alkalmazás számára, hogy újból megpróbálkozzon egy művelettel, ha arra számít, hogy sikeres lesz.</span><span class="sxs-lookup"><span data-stu-id="b4523-126">The Retry pattern enables an application to retry an operation in the expectation that it'll succeed.</span></span> <span data-ttu-id="b4523-127">Az áramkör-megszakítási minta megakadályozza, hogy egy alkalmazás olyan műveletet próbáljon többször végrehajtani, amely nagy eséllyel lesz sikertelen.</span><span class="sxs-lookup"><span data-stu-id="b4523-127">The Circuit Breaker pattern prevents an application from performing an operation that is likely to fail.</span></span> <span data-ttu-id="b4523-128">Az alkalmazások kombinálhatják ezt a két mintát úgy, hogy az újrapróbálkozási mintát használják egy művelet áramkör-megszakítón keresztüli meghívására.</span><span class="sxs-lookup"><span data-stu-id="b4523-128">An application can combine these two patterns by using the Retry pattern to invoke an operation through a circuit breaker.</span></span> <span data-ttu-id="b4523-129">Az azonban fontos, hogy az újrapróbálkozási minta érzékeny legyen az áramkör-megszakító által visszaadott kivételekre, és abbahagyja az újrapróbálkozási kísérleteket, ha az áramkör-megszakító azt jelzi, hogy a hiba nem átmeneti.</span><span class="sxs-lookup"><span data-stu-id="b4523-129">However, the retry logic should be sensitive to any exceptions returned by the circuit breaker and abandon retry attempts if the circuit breaker indicates that a fault is not transient.</span></span>

<span data-ttu-id="b4523-130">Az áramkör-megszakító proxyként viselkedik az esetlegesen meghiúsuló műveleteknél.</span><span class="sxs-lookup"><span data-stu-id="b4523-130">A circuit breaker acts as a proxy for operations that might fail.</span></span> <span data-ttu-id="b4523-131">A proxynak monitoroznia kell a legutóbbi jelentkezett hibák számát, ez az információ segít eldönteni, hogy engedje-e a művelet továbbhaladását, vagy egyszerűen azonnal küldjön egy kivételt.</span><span class="sxs-lookup"><span data-stu-id="b4523-131">The proxy should monitor the number of recent failures that have occurred, and use this information to decide whether to allow the operation to proceed, or simply return an exception immediately.</span></span>

<span data-ttu-id="b4523-132">A proxy egy, az alábbi, egy elektromos áramkör-megszakító működését utánzó állapotokkal bíró állapotgépként valósítható meg:</span><span class="sxs-lookup"><span data-stu-id="b4523-132">The proxy can be implemented as a state machine with the following states that mimic the functionality of an electrical circuit breaker:</span></span>

- <span data-ttu-id="b4523-133">**Zárt**: Az alkalmazásból érkező kérelmet a rendszer a művelethez irányítja.</span><span class="sxs-lookup"><span data-stu-id="b4523-133">**Closed**: The request from the application is routed to the operation.</span></span> <span data-ttu-id="b4523-134">A proxy számlálóban követi a közelmúltbeli hibák számát, és ha a művelet meghívása nem sikeres, a proxy növeli a számláló értékét.</span><span class="sxs-lookup"><span data-stu-id="b4523-134">The proxy maintains a count of the number of recent failures, and if the call to the operation is unsuccessful the proxy increments this count.</span></span> <span data-ttu-id="b4523-135">Ha a közelmúltbeli hibák száma meghalad egy megadott küszöbértéket egy adott időtartamon belül, a proxy **Nyitott** állapotba kerül.</span><span class="sxs-lookup"><span data-stu-id="b4523-135">If the number of recent failures exceeds a specified threshold within a given time period, the proxy is placed into the **Open** state.</span></span> <span data-ttu-id="b4523-136">Ezen a ponton a proxy elindít egy időtúllépési időzítőt, és annak lejártakor a proxy **Félig nyitott** állapotba kerül.</span><span class="sxs-lookup"><span data-stu-id="b4523-136">At this point the proxy starts a timeout timer, and when this timer expires the proxy is placed into the **Half-Open** state.</span></span>

    > <span data-ttu-id="b4523-137">Az időtúllépési időzítő célja az, hogy időt adjon a rendszernek a hibát okozó probléma megoldására, mielőtt engedélyezné az alkalmazás számára, hogy újra megpróbálja elvégezni a műveletet.</span><span class="sxs-lookup"><span data-stu-id="b4523-137">The purpose of the timeout timer is to give the system time to fix the problem that caused the failure before allowing the application to try to perform the operation again.</span></span>

- <span data-ttu-id="b4523-138">**Nyitott**: Az alkalmazásból érkező kérelem azonnal meghiúsul, az alkalmazás kivételt kap vissza.</span><span class="sxs-lookup"><span data-stu-id="b4523-138">**Open**: The request from the application fails immediately and an exception is returned to the application.</span></span>

- <span data-ttu-id="b4523-139">**Félig nyitott**: Az alkalmazásból érkező kérelmek korlátozott számban átjuthatnak, és meghívhatják a műveletet.</span><span class="sxs-lookup"><span data-stu-id="b4523-139">**Half-Open**: A limited number of requests from the application are allowed to pass through and invoke the operation.</span></span> <span data-ttu-id="b4523-140">Ha ezek a kérelmek sikeresek, feltételezhető, hogy a korábban meghibásodást okozó hiba megszűnt, és az áramkör-megszakító átvált **Zárt** állapotra (a hibaszámláló alaphelyzetbe áll).</span><span class="sxs-lookup"><span data-stu-id="b4523-140">If these requests are successful, it's assumed that the fault that was previously causing the failure has been fixed and the circuit breaker switches to the **Closed** state (the failure counter is reset).</span></span> <span data-ttu-id="b4523-141">Ha a kérelem meghiúsul, az áramkör-megszakító feltételezi, hogy a hiba továbbra is fennáll, ezért visszaáll **Nyitott** állapotba, és újraindítja az időtúllépési időzítőt, hogy további időt biztosítson a rendszernek a meghibásodásból való helyreállásra.</span><span class="sxs-lookup"><span data-stu-id="b4523-141">If any request fails, the circuit breaker assumes that the fault is still present so it reverts back to the **Open** state and restarts the timeout timer to give the system a further period of time to recover from the failure.</span></span>

    > <span data-ttu-id="b4523-142">A **Félig nyitott** állapot azért hasznos, mert megakadályozza, hogy a helyreálló szolgáltatást hirtelen elárasszák a kérelmek.</span><span class="sxs-lookup"><span data-stu-id="b4523-142">The **Half-Open** state is useful to prevent a recovering service from suddenly being flooded with requests.</span></span> <span data-ttu-id="b4523-143">Előfordul, hogy miközben zajlik a helyreállítás, a szolgáltatás már képes korlátozott számban kiszolgálni kéréseket a teljes helyreállásig, de amíg folyamatban van a helyreállítás, a nagy mennyiségű feladattól időtúllépés fordulhat elő, vagy esetleg újra meghibásodik a szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="b4523-143">As a service recovers, it might be able to support a limited volume of requests until the recovery is complete, but while recovery is in progress a flood of work can cause the service to time out or fail again.</span></span>

![Az áramkör-megszakító állapotai](./_images/circuit-breaker-diagram.png)

<span data-ttu-id="b4523-145">Az ábrán a **Zárt** állapot által használt hibaszámláló időalapú.</span><span class="sxs-lookup"><span data-stu-id="b4523-145">In the figure, the failure counter used by the **Closed** state is time based.</span></span> <span data-ttu-id="b4523-146">Rendszeres időközönként automatikusan alaphelyzetbe áll.</span><span class="sxs-lookup"><span data-stu-id="b4523-146">It's automatically reset at periodic intervals.</span></span> <span data-ttu-id="b4523-147">Ez segít megakadályozni, hogy az áramkör-megszakító belépjen a **Nyitott** állapotba, ha csak alkalmanként észlel hibát.</span><span class="sxs-lookup"><span data-stu-id="b4523-147">This helps to prevent the circuit breaker from entering the **Open** state if it experiences occasional failures.</span></span> <span data-ttu-id="b4523-148">Az áramkör-megszakítót **Nyitott** állapotba léptető küszöbérték csak akkor érhető el, hogy a megadott számú hiba megadott időtartam alatt következik be.</span><span class="sxs-lookup"><span data-stu-id="b4523-148">The failure threshold that trips the circuit breaker into the **Open** state is only reached when a specified number of failures have occurred during a specified interval.</span></span> <span data-ttu-id="b4523-149">A **Félig nyitott** állapot által használt számláló a művelet meghívására tett sikeres kísérletek számát rögzít.</span><span class="sxs-lookup"><span data-stu-id="b4523-149">The counter used by the **Half-Open** state records the number of successful attempts to invoke the operation.</span></span> <span data-ttu-id="b4523-150">Az áramkör-megszakító akkor tér vissza a **Zárt** állapotba, ha adott számú egymást követő műveletmeghívás sikeres volt.</span><span class="sxs-lookup"><span data-stu-id="b4523-150">The circuit breaker reverts to the **Closed** state after a specified number of consecutive operation invocations have been successful.</span></span> <span data-ttu-id="b4523-151">Ha bármely meghívás meghiúsul, az áramkör-megszakító azonnal belép a **Nyitott** állapotba, és a sikeres meghívások számlálója alaphelyzetbe áll, amikor a megszakító újra **Félig nyitott** állapotba lép.</span><span class="sxs-lookup"><span data-stu-id="b4523-151">If any invocation fails, the circuit breaker enters the **Open** state immediately and the success counter will be reset the next time it enters the **Half-Open** state.</span></span>

> <span data-ttu-id="b4523-152">A rendszer helyreállásának kezelése kívülről történik, esetleg egy meghibásodott összetevő visszaállításával vagy újraindításával, vagy a hálózati kapcsolat megjavításával.</span><span class="sxs-lookup"><span data-stu-id="b4523-152">How the system recovers is handled externally, possibly by restoring or restarting a failed component or repairing a network connection.</span></span>

<span data-ttu-id="b4523-153">Az áramkör-megszakító minta stabilitást biztosít arra az időszakra, amíg a rendszer helyreáll egy meghibásodás után, és minimálisra csökkenti a hiba teljesítményre gyakorolt hatását.</span><span class="sxs-lookup"><span data-stu-id="b4523-153">The Circuit Breaker pattern provides stability while the system recovers from a failure and minimizes the impact on performance.</span></span> <span data-ttu-id="b4523-154">A segítségével fenntartható a rendszer válaszideje, mert gyorsan visszautasítja a várhatóan sikertelen műveletekre irányuló kéréseket, nem várja meg a művelet időtúllépését, vagy azt, hogy egyáltalán ne küldjön választ.</span><span class="sxs-lookup"><span data-stu-id="b4523-154">It can help to maintain the response time of the system by quickly rejecting a request for an operation that's likely to fail, rather than waiting for the operation to time out, or never return.</span></span> <span data-ttu-id="b4523-155">Ha az áramkör-megszakító minden állapotváltáskor létrehoz egy eseményt, ez az információ segít monitorozni a rendszer áramkör-megszakító által védett részének állapotát, vagy riasztást küldeni egy rendszergazdának, ha az áramkör-megszakító **Nyitott** állapotba kerül.</span><span class="sxs-lookup"><span data-stu-id="b4523-155">If the circuit breaker raises an event each time it changes state, this information can be used to monitor the health of the part of the system protected by the circuit breaker, or to alert an administrator when a circuit breaker trips to the **Open** state.</span></span>

<span data-ttu-id="b4523-156">A minta testreszabható, és a lehetséges hiba típusának megfelelően alkalmazható.</span><span class="sxs-lookup"><span data-stu-id="b4523-156">The pattern is customizable and can be adapted according to the type of the possible failure.</span></span> <span data-ttu-id="b4523-157">Alkalmazhat például növekvő időtúllépési időzítőt egy áramkör-megszakítón.</span><span class="sxs-lookup"><span data-stu-id="b4523-157">For example, you can apply an increasing timeout timer to a circuit breaker.</span></span> <span data-ttu-id="b4523-158">Az áramkör-megszakítót először néhány másodpercre helyezheti **Nyitott** állapotba, majd, ha a hiba nem oldódott meg, növelheti az időkorlátot néhány percre, és így tovább.</span><span class="sxs-lookup"><span data-stu-id="b4523-158">You could place the circuit breaker in the **Open** state for a few seconds initially, and then if the failure hasn't been resolved increase the timeout to a few minutes, and so on.</span></span> <span data-ttu-id="b4523-159">Bizonyos esetekben hasznos lehet egy, az alkalmazás számára jelentéssel bíró alapértelmezett értéket visszaadni az alkalmazásnak ahelyett, hogy a **Nyitott** állapot hibát adna vissza, és kivételt hozna létre.</span><span class="sxs-lookup"><span data-stu-id="b4523-159">In some cases, rather than the **Open** state returning failure and raising an exception, it could be useful to return a default value that is meaningful to the application.</span></span>

## <a name="issues-and-considerations"></a><span data-ttu-id="b4523-160">Problémák és megfontolandó szempontok</span><span class="sxs-lookup"><span data-stu-id="b4523-160">Issues and considerations</span></span>

<span data-ttu-id="b4523-161">A minta megvalósítása során az alábbi pontokat vegye figyelembe:</span><span class="sxs-lookup"><span data-stu-id="b4523-161">You should consider the following points when deciding how to implement this pattern:</span></span>

<span data-ttu-id="b4523-162">**Kivételkezelés**.</span><span class="sxs-lookup"><span data-stu-id="b4523-162">**Exception Handling**.</span></span> <span data-ttu-id="b4523-163">A műveletet áramkör-megszakítón keresztüli meghívó alkalmazást fel kell készíteni azon kivételek kezelésére, amelyek akkor jönnek létre, amikor a művelet nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="b4523-163">An application invoking an operation through a circuit breaker must be prepared to handle the exceptions raised if the operation is unavailable.</span></span> <span data-ttu-id="b4523-164">A kivételek kezelése alkalmazásspecifikus lesz.</span><span class="sxs-lookup"><span data-stu-id="b4523-164">The way exceptions are handled will be application specific.</span></span> <span data-ttu-id="b4523-165">Az alkalmazás például átmenetileg csökkentheti a működési teljesítményét, meghívhat egy másik műveletet, hogy az megpróbálja végrehajtani ugyanazt a feladatot, vagy beszerezni ugyanazokat az adatokat, illetve jelentheti a kivételt a felhasználónak, és megkérheti, hogy próbálkozzon később újra.</span><span class="sxs-lookup"><span data-stu-id="b4523-165">For example, an application could temporarily degrade its functionality, invoke an alternative operation to try to perform the same task or obtain the same data, or report the exception to the user and ask them to try again later.</span></span>

<span data-ttu-id="b4523-166">**Kivételek típusai**.</span><span class="sxs-lookup"><span data-stu-id="b4523-166">**Types of Exceptions**.</span></span> <span data-ttu-id="b4523-167">Egy kérés sok okból meghiúsulhat, ezek némelyike komolyabb meghibásodást jelez, mint mások.</span><span class="sxs-lookup"><span data-stu-id="b4523-167">A request might fail for many reasons, some of which might indicate a more severe type of failure than others.</span></span> <span data-ttu-id="b4523-168">Egy kérelem meghiúsulhat például azért, mert egy távoli szolgáltatás összeomlott, és a helyreállása eltart pár percig, vagy meghiúsulhat időtúllépés miatt, ha a szolgáltatás átmenetileg túl lett terhelve.</span><span class="sxs-lookup"><span data-stu-id="b4523-168">For example, a request might fail because a remote service has crashed and will take several minutes to recover, or because of a timeout due to the service being temporarily overloaded.</span></span> <span data-ttu-id="b4523-169">Egy áramkör-megszakító képes lehet a felmerülő kivételek típusának vizsgálatára, és képes az adott kivételek természetéhez igazítani a stratégiáját.</span><span class="sxs-lookup"><span data-stu-id="b4523-169">A circuit breaker might be able to examine the types of exceptions that occur and adjust its strategy depending on the nature of these exceptions.</span></span> <span data-ttu-id="b4523-170">Előfordulhat például, hogy nagyobb számú időtúllépési kivételre lesz szüksége az áramkör-megszakító **Nyitott** állapotba váltásához ahhoz képest, mint amikor a szolgáltatás teljes leállása miatt jelentkeznek a hibák.</span><span class="sxs-lookup"><span data-stu-id="b4523-170">For example, it might require a larger number of timeout exceptions to trip the circuit breaker to the **Open** state compared to the number of failures due to the service being completely unavailable.</span></span>

<span data-ttu-id="b4523-171">**Naplózás**.</span><span class="sxs-lookup"><span data-stu-id="b4523-171">**Logging**.</span></span> <span data-ttu-id="b4523-172">Az áramkör-megszakítónak minden meghiúsult kérelmet naplóznia kell (és esetleg a sikereseket is), hogy a rendszergazda monitorozni tudja a művelet állapotát.</span><span class="sxs-lookup"><span data-stu-id="b4523-172">A circuit breaker should log all failed requests (and possibly successful requests) to enable an administrator to monitor the health of the operation.</span></span>

<span data-ttu-id="b4523-173">**Helyreállíthatóság**.</span><span class="sxs-lookup"><span data-stu-id="b4523-173">**Recoverability**.</span></span> <span data-ttu-id="b4523-174">Az áramkör-megszakítót úgy konfigurálja, hogy kövesse a védett művelet várható helyreállítási mintáját.</span><span class="sxs-lookup"><span data-stu-id="b4523-174">You should configure the circuit breaker to match the likely recovery pattern of the operation it's protecting.</span></span> <span data-ttu-id="b4523-175">Ha például az áramkör-megszakító hosszan **Nyitott** állapotban marad, akkor is létrehozhat kivételeket, ha a hiba oka már megszűnt.</span><span class="sxs-lookup"><span data-stu-id="b4523-175">For example, if the circuit breaker remains in the **Open** state for a long period, it could raise exceptions even if the reason for the failure has been resolved.</span></span> <span data-ttu-id="b4523-176">Ehhez hasonlóan az áramkör-megszakító ingadozhat és csökkentheti az alkalmazások válaszidejeit, ha túl gyorsan vált a **Nyitott** állapotból **Félig nyitott** állapotba.</span><span class="sxs-lookup"><span data-stu-id="b4523-176">Similarly, a circuit breaker could fluctuate and reduce the response times of applications if it switches from the **Open** state to the **Half-Open** state too quickly.</span></span>

<span data-ttu-id="b4523-177">**Sikertelen műveletek tesztelése**.</span><span class="sxs-lookup"><span data-stu-id="b4523-177">**Testing Failed Operations**.</span></span> <span data-ttu-id="b4523-178">A **Nyitott** állapotban lévő áramkör-megszakító ahelyett, hogy időzítővel határozná meg, mikor váltson **Félig nyitott** állapotba, rendszeres időközönként pingelheti a távoli szolgáltatást vagy erőforrást annak megállapításához, hogy az mikor válik újra elérhetővé.</span><span class="sxs-lookup"><span data-stu-id="b4523-178">In the **Open** state, rather than using a timer to determine when to switch to the **Half-Open** state, a circuit breaker can instead periodically ping the remote service or resource to determine whether it's become available again.</span></span> <span data-ttu-id="b4523-179">Ez a pingelés történhet egy korában meghiúsult művelet meghívásának formájában, vagy lehet a távoli szolgáltatás által kifejezetten a szolgáltatás állapotának tesztelésére biztosított speciális műveletet használni, mint például az [állapot végponti monitorozását végző minta](health-endpoint-monitoring.md).</span><span class="sxs-lookup"><span data-stu-id="b4523-179">This ping could take the form of an attempt to invoke an operation that had previously failed, or it could use a special operation provided by the remote service specifically for testing the health of the service, as described by the [Health Endpoint Monitoring pattern](health-endpoint-monitoring.md).</span></span>

<span data-ttu-id="b4523-180">**Kézi felülbírálás**.</span><span class="sxs-lookup"><span data-stu-id="b4523-180">**Manual Override**.</span></span> <span data-ttu-id="b4523-181">Olyan rendszerben, ahol a meghiúsuló művelet helyreállítási ideje kifejezetten változó, érdemes manuális visszaállítási lehetőséget biztosítani, hogy a rendszergazda zárhassa az áramkör-megszakítót (és alaphelyzetbe állíthassa a hibaszámlálót).</span><span class="sxs-lookup"><span data-stu-id="b4523-181">In a system where the recovery time for a failing operation is extremely variable, it's beneficial to provide a manual reset option that enables an administrator to close a circuit breaker (and reset the failure counter).</span></span> <span data-ttu-id="b4523-182">Ehhez hasonlóan a rendszergazda **Nyitott** állapotba kényszerítheti az áramkör-megszakítót (és alaphelyzetbe állíthatja az időtúllépési időzítőt), ha az áramkör-megszakító által védett művelet átmenetileg nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="b4523-182">Similarly, an administrator could force a circuit breaker into the **Open** state (and restart the timeout timer) if the operation protected by the circuit breaker is temporarily unavailable.</span></span>

<span data-ttu-id="b4523-183">**Egyidejűség**.</span><span class="sxs-lookup"><span data-stu-id="b4523-183">**Concurrency**.</span></span> <span data-ttu-id="b4523-184">Ugyanazt az áramkör-megszakítót számos párhuzamos alkalmazáspéldány is elérheti.</span><span class="sxs-lookup"><span data-stu-id="b4523-184">The same circuit breaker could be accessed by a large number of concurrent instances of an application.</span></span> <span data-ttu-id="b4523-185">Ez a megvalósítás valószínűleg nem blokkolja a párhuzamos kéréseket, és nem ad túlzott többletterhelést az egyes műveletmeghívásokhoz.</span><span class="sxs-lookup"><span data-stu-id="b4523-185">The implementation shouldn't block concurrent requests or add excessive overhead to each call to an operation.</span></span>

<span data-ttu-id="b4523-186">**Erőforrás-megkülönböztetés**.</span><span class="sxs-lookup"><span data-stu-id="b4523-186">**Resource Differentiation**.</span></span> <span data-ttu-id="b4523-187">Legyen óvatos, ha egy áramkör-megszakítót használ egy erőforrástípushoz, amennyiben több alapul szolgáló független szolgáltató is előfordulhat.</span><span class="sxs-lookup"><span data-stu-id="b4523-187">Be careful when using a single circuit breaker for one type of resource if there might be multiple underlying independent providers.</span></span> <span data-ttu-id="b4523-188">Egy több szilánkot tartalmazó adattárban előfordulhat, hogy az egyik szilánk teljesen hozzáférhető, de egy másiknál átmenetileg probléma jelentkezik.</span><span class="sxs-lookup"><span data-stu-id="b4523-188">For example, in a data store that contains multiple shards, one shard might be fully accessible while another is experiencing a temporary issue.</span></span> <span data-ttu-id="b4523-189">Ha ezekben a forgatókönyvekben egyesülnek a hibaválaszok, előfordulhat, hogy egy alkalmazás akkor is megpróbál hozzáférni egy szilánkhoz, amikor nagy valószínűséggel hiba jelentkezek, miközben más szilánkokat blokkol, noha valószínűleg sikeres lenne a művelet.</span><span class="sxs-lookup"><span data-stu-id="b4523-189">If the error responses in these scenarios are merged, an application might try to access some shards even when failure is highly likely, while access to other shards might be blocked even though it's likely to succeed.</span></span>

<span data-ttu-id="b4523-190">**Gyorsított áramkör-megszakítás**.</span><span class="sxs-lookup"><span data-stu-id="b4523-190">**Accelerated Circuit Breaking**.</span></span> <span data-ttu-id="b4523-191">Néha egy hibaválasz elég információt tartalmaz ahhoz, hogy az áramkör-megszakító azonnal váltson, és átváltva maradjon a lehető legrövidebb ideig.</span><span class="sxs-lookup"><span data-stu-id="b4523-191">Sometimes a failure response can contain enough information for the circuit breaker to trip immediately and stay tripped for a minimum amount of time.</span></span> <span data-ttu-id="b4523-192">Egy túlterhelt megosztott erőforrástól érkező hibaüzenet például jelezheti azt, hogy az azonnali újrapróbálkozás nem ajánlott, és érdemes inkább pár perccel később újrapróbálkoznia az alkalmazásnak.</span><span class="sxs-lookup"><span data-stu-id="b4523-192">For example, the error response from a shared resource that's overloaded could indicate that an immediate retry isn't recommended and that the application should instead try again in a few minutes.</span></span>

> [!NOTE]
> <span data-ttu-id="b4523-193">A szolgáltatás adhat vissza HTTP 429-es hibát (Túl sok kérés), ha szabályozza az ügyfelet, vagy HTTP 503-as hibát (A szolgáltatás nem érhető el), ha a szolgáltatás jelenleg nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="b4523-193">A service can return HTTP 429 (Too Many Requests) if it is throttling the client, or HTTP 503 (Service Unavailable) if the service is not currently available.</span></span> <span data-ttu-id="b4523-194">A válasz tartalmazhat további információkat is, például a késleltetés várható időtartamát.</span><span class="sxs-lookup"><span data-stu-id="b4523-194">The response can include additional information, such as the anticipated duration of the delay.</span></span>

<span data-ttu-id="b4523-195">**Sikertelen kérelmek visszajátszása**.</span><span class="sxs-lookup"><span data-stu-id="b4523-195">**Replaying Failed Requests**.</span></span> <span data-ttu-id="b4523-196">Egy **Nyitott** állapotú áramkör-megszakító az egyszerű és gyors meghiúsulás helyett rögzítheti az egyes kérések adatait egy naplóba, és beállítja a kérések megismétlését, ha a távoli erőforrás vagy szolgáltatás elérhetővé válik.</span><span class="sxs-lookup"><span data-stu-id="b4523-196">In the **Open** state, rather than simply failing quickly, a circuit breaker could also record the details of each request to a journal and arrange for these requests to be replayed when the remote resource or service becomes available.</span></span>

<span data-ttu-id="b4523-197">**Külső szolgáltatások nem megfelelő időtúllépései**.</span><span class="sxs-lookup"><span data-stu-id="b4523-197">**Inappropriate Timeouts on External Services**.</span></span> <span data-ttu-id="b4523-198">Előfordulhat, hogy egy áramkör-megszakító nem képes teljesen megvédeni az alkalmazásokat a hosszú időkorláttal konfigurált külső szolgáltatásokon meghiúsuló műveletektől.</span><span class="sxs-lookup"><span data-stu-id="b4523-198">A circuit breaker might not be able to fully protect applications from operations that fail in external services that are configured with a lengthy timeout period.</span></span> <span data-ttu-id="b4523-199">Ha az időkorlát túl hosszú, egy áramkör-megszakítót futtató szál blokkolása hosszú ideig is tarthat, mielőtt az áramkör-megszakító a művelet meghiúsulását jelezné.</span><span class="sxs-lookup"><span data-stu-id="b4523-199">If the timeout is too long, a thread running a circuit breaker might be blocked for an extended period before the circuit breaker indicates that the operation has failed.</span></span> <span data-ttu-id="b4523-200">Lehet, hogy ezen idő alatt sok más alkalmazáspéldány is megpróbálja meghívni a szolgáltatást az áramkör-megszakítón keresztül, és jelentős számú szálat lefoglalhatnak, mielőtt meghiúsulnak.</span><span class="sxs-lookup"><span data-stu-id="b4523-200">In this time, many other application instances might also try to invoke the service through the circuit breaker and tie up a significant number of threads before they all fail.</span></span>

## <a name="when-to-use-this-pattern"></a><span data-ttu-id="b4523-201">Mikor érdemes ezt a mintát használni?</span><span class="sxs-lookup"><span data-stu-id="b4523-201">When to use this pattern</span></span>

<span data-ttu-id="b4523-202">Használja a következő mintát a következő helyzetekben:</span><span class="sxs-lookup"><span data-stu-id="b4523-202">Use this pattern:</span></span>

- <span data-ttu-id="b4523-203">Ha meg kell akadályozni, hogy egy alkalmazás meghívjon egy távoli szolgáltatást vagy hozzáférjen egy megosztott erőforráshoz, mert a művelet nagy valószínűséggel meghiúsul.</span><span class="sxs-lookup"><span data-stu-id="b4523-203">To prevent an application from trying to invoke a remote service or access a shared resource if this operation is highly likely to fail.</span></span>

<span data-ttu-id="b4523-204">Ez a minta nem ajánlott a következő helyzetekben:</span><span class="sxs-lookup"><span data-stu-id="b4523-204">This pattern isn't recommended:</span></span>

- <span data-ttu-id="b4523-205">Ha helyi személyes erőforrások hozzáférését kell kezelnie egy alkalmazásban, például egy memórián belüli adatstruktúrát.</span><span class="sxs-lookup"><span data-stu-id="b4523-205">For handling access to local private resources in an application, such as in-memory data structure.</span></span> <span data-ttu-id="b4523-206">Ebben a környezetben az áramkör-megszakító csak többletterhelést jelentene a rendszer számára.</span><span class="sxs-lookup"><span data-stu-id="b4523-206">In this environment, using a circuit breaker would add overhead to your system.</span></span>
- <span data-ttu-id="b4523-207">Ha helyettesíteni szeretné a kivételkezelést az alkalmazásai üzleti logikájában.</span><span class="sxs-lookup"><span data-stu-id="b4523-207">As a substitute for handling exceptions in the business logic of your applications.</span></span>

## <a name="example"></a><span data-ttu-id="b4523-208">Példa</span><span class="sxs-lookup"><span data-stu-id="b4523-208">Example</span></span>

<span data-ttu-id="b4523-209">Egy webalkalmazásban számos oldal külső szolgáltatásból származó adatokkal van feltöltve.</span><span class="sxs-lookup"><span data-stu-id="b4523-209">In a web application, several of the pages are populated with data retrieved from an external service.</span></span> <span data-ttu-id="b4523-210">Ha a rendszer minimális gyorsítótárazást valósít meg, ezen oldalak legtöbb megkeresése a szolgáltatással való adatváltást eredményez.</span><span class="sxs-lookup"><span data-stu-id="b4523-210">If the system implements minimal caching, most hits to these pages will cause a round trip to the service.</span></span> <span data-ttu-id="b4523-211">A webalkalmazás és a szolgáltatás közötti kapcsolatokat lehet egy időkorláttal (általában 60 mp) konfigurálni, és ha a szolgáltatás nem válaszol ennyi idő alatt, az egyes weboldalak logikája feltételezi, hogy a szolgáltatás nem érhető el, ezért kivételt jelez.</span><span class="sxs-lookup"><span data-stu-id="b4523-211">Connections from the web application to the service could be configured with a timeout period (typically 60 seconds), and if the service doesn't respond in this time the logic in each web page will assume that the service is unavailable and throw an exception.</span></span>

<span data-ttu-id="b4523-212">Ha azonban a szolgáltatás meghiúsul, és a rendszer nagyon elfoglalt, a felhasználóknak akár 60 másodpercig is várakozniuk kell a kivétel létrejötte előtt.</span><span class="sxs-lookup"><span data-stu-id="b4523-212">However, if the service fails and the system is very busy, users could be forced to wait for up to 60 seconds before an exception occurs.</span></span> <span data-ttu-id="b4523-213">Végül a memória, a kapcsolatok, a szálak és a hasonló erőforrások kimerülhetnek, és megakadályozhatják, hogy más felhasználók csatlakozzanak a rendszerhez, még ha azok nem is a szolgáltatástól adatokat lekérő oldalakhoz akarnának hozzáférni.</span><span class="sxs-lookup"><span data-stu-id="b4523-213">Eventually resources such as memory, connections, and threads could be exhausted, preventing other users from connecting to the system, even if they aren't accessing pages that retrieve data from the service.</span></span>

<span data-ttu-id="b4523-214">A rendszer méretezése további webkiszolgálók hozzáadásával és terhelés-kiegyenlítés megvalósításával késleltetheti az erőforrások kimerülését, de nem fogja megoldani a problémát, mert a felhasználói kérelmek továbbra sem fognak válaszolni, és a végül az összes webkiszolgáló kifogyhat az erőforrásokból.</span><span class="sxs-lookup"><span data-stu-id="b4523-214">Scaling the system by adding further web servers and implementing load balancing might delay when resources become exhausted, but it won't resolve the issue because user requests will still be unresponsive and all web servers could still eventually run out of resources.</span></span>

<span data-ttu-id="b4523-215">Ha a szolgáltatáshoz kapcsolódó és az adatokat lekérő adatokat egy áramkör-megszakítóba burkoljuk, az segít megoldani ezt a problémát, és a szolgáltatás-meghibásodás kezelése elegánsabb lesz.</span><span class="sxs-lookup"><span data-stu-id="b4523-215">Wrapping the logic that connects to the service and retrieves the data in a circuit breaker could help to solve this problem and handle the service failure more elegantly.</span></span> <span data-ttu-id="b4523-216">A felhasználói kérések továbbra is meghiúsulnak, de gyorsabban, és az erőforrások nem lesznek blokkolva.</span><span class="sxs-lookup"><span data-stu-id="b4523-216">User requests will still fail, but they'll fail more quickly and the resources won't be blocked.</span></span>

<span data-ttu-id="b4523-217">A `CircuitBreaker` osztály az áramkör-megszakítók állapotinformációit egy olyan objektumban tartalmazza, amely megvalósítja az alábbi kódban látható `ICircuitBreakerStateStore` interfészt.</span><span class="sxs-lookup"><span data-stu-id="b4523-217">The `CircuitBreaker` class maintains state information about a circuit breaker in an object that implements the `ICircuitBreakerStateStore` interface shown in the following code.</span></span>

```csharp
interface ICircuitBreakerStateStore
{
  CircuitBreakerStateEnum State { get; }

  Exception LastException { get; }

  DateTime LastStateChangedDateUtc { get; }

  void Trip(Exception ex);

  void Reset();

  void HalfOpen();

  bool IsClosed { get; }
}
```

<span data-ttu-id="b4523-218">A `State` tulajdonság jelzi az áramkör-megszakító aktuális állapotát, és **Open** (Nyitott), **HalfOpen** (Félig nyitott) vagy **Closed** (Zárt) értéket vehet fel a `CircuitBreakerStateEnum` enumerálásban megadottak szerint.</span><span class="sxs-lookup"><span data-stu-id="b4523-218">The `State` property indicates the current state of the circuit breaker, and will be either **Open**, **HalfOpen**, or **Closed** as defined by the `CircuitBreakerStateEnum` enumeration.</span></span> <span data-ttu-id="b4523-219">Az `IsClosed` tulajdonság értéke akkor legyen true (igaz), ha az áramkör-megszakító le van zárva, és akkor false (hamis), ha a megszakító nyitva vagy félig nyitva van.</span><span class="sxs-lookup"><span data-stu-id="b4523-219">The `IsClosed` property should be true if the circuit breaker is closed, but false if it's open or half open.</span></span> <span data-ttu-id="b4523-220">A `Trip` metódus az áramköri megszakított nyitott állapotba váltja, valamint rögzíti az állapotban változást okozó kivételt a kivétel létrejöttének dátumával és időpontjával együtt.</span><span class="sxs-lookup"><span data-stu-id="b4523-220">The `Trip` method switches the state of the circuit breaker to the open state and records the exception that caused the change in state, together with the date and time that the exception occurred.</span></span> <span data-ttu-id="b4523-221">A `LastException` és a `LastStateChangedDateUtc` tulajdonságok adják vissza ezeket az információkat.</span><span class="sxs-lookup"><span data-stu-id="b4523-221">The `LastException` and the `LastStateChangedDateUtc` properties return this information.</span></span> <span data-ttu-id="b4523-222">A `Reset` metódus zárja az áramkör-megszakítót, a `HalfOpen` metódus pedig félig nyitott állapotba helyezi az áramkör-megszakítót.</span><span class="sxs-lookup"><span data-stu-id="b4523-222">The `Reset` method closes the circuit breaker, and the `HalfOpen` method sets the circuit breaker to half open.</span></span>

<span data-ttu-id="b4523-223">A példában szereplő `InMemoryCircuitBreakerStateStore` osztály tartalmazza az `ICircuitBreakerStateStore` interfész megvalósítását.</span><span class="sxs-lookup"><span data-stu-id="b4523-223">The `InMemoryCircuitBreakerStateStore` class in the example contains an implementation of the `ICircuitBreakerStateStore` interface.</span></span> <span data-ttu-id="b4523-224">A `CircuitBreaker` osztály létrehozza ennek az osztálynak egy példányát, hogy megőrizze az áramkör-megszakító állapotát.</span><span class="sxs-lookup"><span data-stu-id="b4523-224">The `CircuitBreaker` class creates an instance of this class to hold the state of the circuit breaker.</span></span>

<span data-ttu-id="b4523-225">A `CircuitBreaker` osztály `ExecuteAction` metódusa egy, az `Action` delegáltjaként megadott műveletet burkol be.</span><span class="sxs-lookup"><span data-stu-id="b4523-225">The `ExecuteAction` method in the `CircuitBreaker` class wraps an operation, specified as an `Action` delegate.</span></span> <span data-ttu-id="b4523-226">Ha az áramkör-megszakító zárt, az `ExecuteAction` meghívja az `Action` delegáltat.</span><span class="sxs-lookup"><span data-stu-id="b4523-226">If the circuit breaker is closed, `ExecuteAction` invokes the `Action` delegate.</span></span> <span data-ttu-id="b4523-227">Ha a művelet meghiúsul, egy kivételkezelő meghívja a `TrackException` metódust, amely az áramkör-megszakító állapotát nyitottra állítja.</span><span class="sxs-lookup"><span data-stu-id="b4523-227">If the operation fails, an exception handler calls `TrackException`, which sets the circuit breaker state to open.</span></span> <span data-ttu-id="b4523-228">A folyamatot az itt következő kód mutatja be.</span><span class="sxs-lookup"><span data-stu-id="b4523-228">The following code example highlights this flow.</span></span>

```csharp
public class CircuitBreaker
{
  private readonly ICircuitBreakerStateStore stateStore =
    CircuitBreakerStateStoreFactory.GetCircuitBreakerStateStore();

  private readonly object halfOpenSyncObject = new object ();
  ...
  public bool IsClosed { get { return stateStore.IsClosed; } }

  public bool IsOpen { get { return !IsClosed; } }

  public void ExecuteAction(Action action)
  {
    ...
    if (IsOpen)
    {
      // The circuit breaker is Open.
      ... (see code sample below for details)
    }

    // The circuit breaker is Closed, execute the action.
    try
    {
      action();
    }
    catch (Exception ex)
    {
      // If an exception still occurs here, simply
      // retrip the breaker immediately.
      this.TrackException(ex);

      // Throw the exception so that the caller can tell
      // the type of exception that was thrown.
      throw;
    }
  }

  private void TrackException(Exception ex)
  {
    // For simplicity in this example, open the circuit breaker on the first exception.
    // In reality this would be more complex. A certain type of exception, such as one
    // that indicates a service is offline, might trip the circuit breaker immediately.
    // Alternatively it might count exceptions locally or across multiple instances and
    // use this value over time, or the exception/success ratio based on the exception
    // types, to open the circuit breaker.
    this.stateStore.Trip(ex);
  }
}
```

<span data-ttu-id="b4523-229">A következő példa bemutatja azt az előző példából kihagyott kódrészt, amely akkor lesz végrehajtva, ha az áramkör-megszakító nincs zárva.</span><span class="sxs-lookup"><span data-stu-id="b4523-229">The following example shows the code (omitted from the previous example) that is executed if the circuit breaker isn't closed.</span></span> <span data-ttu-id="b4523-230">Először ellenőrzi, hogy az áramkör-megszakító hosszabb ideje van-e nyitva, mint ami a helyi `OpenToHalfOpenWaitTime` mezőben van megadva a `CircuitBreaker` osztályban.</span><span class="sxs-lookup"><span data-stu-id="b4523-230">It first checks if the circuit breaker has been open for a period longer than the time specified by the local `OpenToHalfOpenWaitTime` field in the `CircuitBreaker` class.</span></span> <span data-ttu-id="b4523-231">Ha ez a helyzet, az `ExecuteAction` metódus félig nyitott állapotba állítja az áramkör-megszakítót, majd megpróbálja végrehajtani az `Action` delegált által meghatározott műveletet.</span><span class="sxs-lookup"><span data-stu-id="b4523-231">If this is the case, the `ExecuteAction` method sets the circuit breaker to half open, then tries to perform the operation specified by the `Action` delegate.</span></span>

<span data-ttu-id="b4523-232">Ha a művelet sikeres, az áramkör-megszakító visszavált zárt állapotba.</span><span class="sxs-lookup"><span data-stu-id="b4523-232">If the operation is successful, the circuit breaker is reset to the closed state.</span></span> <span data-ttu-id="b4523-233">Ha a művelet meghiúsul, visszavált nyitott állapotba, és frissül a kivétel létrejöttének időpontja, így az áramkör-megszakító kivár egy újabb időtartamot, mielőtt újra megpróbálja végrehajtani a műveletet.</span><span class="sxs-lookup"><span data-stu-id="b4523-233">If the operation fails, it is tripped back to the open state and the time the exception occurred is updated so that the circuit breaker will wait for a further period before trying to perform the operation again.</span></span>

<span data-ttu-id="b4523-234">Ha az áramkör-megszakító csak egy rövid ideje van nyitva, az `OpenToHalfOpenWaitTime` értéknél nem régebben, az `ExecuteAction` metódus egyszerűen `CircuitBreakerOpenException` kivételt jelez, és visszaadja azt a hibát, amely miatt az áramkör-megszakító nyitott állapotba került.</span><span class="sxs-lookup"><span data-stu-id="b4523-234">If the circuit breaker has only been open for a short time, less than the `OpenToHalfOpenWaitTime` value, the `ExecuteAction` method simply throws a `CircuitBreakerOpenException` exception and returns the error that caused the circuit breaker to transition to the open state.</span></span>

<span data-ttu-id="b4523-235">Ezen felül egy zár segítségével akadályozza meg, hogy az áramkör-megszakító félig nyitott állapotban megpróbáljon párhuzamos hívásokat indítani a művelethez.</span><span class="sxs-lookup"><span data-stu-id="b4523-235">Additionally, it uses a lock to prevent the circuit breaker from trying to perform concurrent calls to the operation while it's half open.</span></span> <span data-ttu-id="b4523-236">A művelet meghívására indított egyidejű kísérleteket a rendszer úgy kezeli, mintha az áramkör-megszakító nyitott állapotban lenne, és a kísérlet meghiúsulna a később ismertetett kivétellel.</span><span class="sxs-lookup"><span data-stu-id="b4523-236">A concurrent attempt to invoke the operation will be handled as if the circuit breaker was open, and it'll fail with an exception as described later.</span></span>

```csharp
    ...
    if (IsOpen)
    {
      // The circuit breaker is Open. Check if the Open timeout has expired.
      // If it has, set the state to HalfOpen. Another approach might be to
      // check for the HalfOpen state that had be set by some other operation.
      if (stateStore.LastStateChangedDateUtc + OpenToHalfOpenWaitTime < DateTime.UtcNow)
      {
        // The Open timeout has expired. Allow one operation to execute. Note that, in
        // this example, the circuit breaker is set to HalfOpen after being
        // in the Open state for some period of time. An alternative would be to set
        // this using some other approach such as a timer, test method, manually, and
        // so on, and check the state here to determine how to handle execution
        // of the action.
        // Limit the number of threads to be executed when the breaker is HalfOpen.
        // An alternative would be to use a more complex approach to determine which
        // threads or how many are allowed to execute, or to execute a simple test
        // method instead.
        bool lockTaken = false;
        try
        {
          Monitor.TryEnter(halfOpenSyncObject, ref lockTaken);
          if (lockTaken)
          {
            // Set the circuit breaker state to HalfOpen.
            stateStore.HalfOpen();

            // Attempt the operation.
            action();

            // If this action succeeds, reset the state and allow other operations.
            // In reality, instead of immediately returning to the Closed state, a counter
            // here would record the number of successful operations and return the
            // circuit breaker to the Closed state only after a specified number succeed.
            this.stateStore.Reset();
            return;
          }
          catch (Exception ex)
          {
            // If there's still an exception, trip the breaker again immediately.
            this.stateStore.Trip(ex);

            // Throw the exception so that the caller knows which exception occurred.
            throw;
          }
          finally
          {
            if (lockTaken)
            {
              Monitor.Exit(halfOpenSyncObject);
            }
          }
        }
      }
      // The Open timeout hasn't yet expired. Throw a CircuitBreakerOpen exception to
      // inform the caller that the call was not actually attempted,
      // and return the most recent exception received.
      throw new CircuitBreakerOpenException(stateStore.LastException);
    }
    ...
```

<span data-ttu-id="b4523-237">Ha `CircuitBreaker` objektumot használ egy művelet védelmére, egy alkalmazás létrehoz egy példányt a `CircuitBreaker` osztályból, és meghívja az `ExecuteAction` metódust, amelynek paramétere a végrehajtani kívánt művelet.</span><span class="sxs-lookup"><span data-stu-id="b4523-237">To use a `CircuitBreaker` object to protect an operation, an application creates an instance of the `CircuitBreaker` class and invokes the `ExecuteAction` method, specifying the operation to be performed as the parameter.</span></span> <span data-ttu-id="b4523-238">Az alkalmazást elő kell készíteni a `CircuitBreakerOpenException` kivétel rögzítésére arra az esetre, ha a művelet az áramkör-megszakító nyitott állapota miatt meghiúsulna.</span><span class="sxs-lookup"><span data-stu-id="b4523-238">The application should be prepared to catch the `CircuitBreakerOpenException` exception if the operation fails because the circuit breaker is open.</span></span> <span data-ttu-id="b4523-239">Az alábbi kód példa erre:</span><span class="sxs-lookup"><span data-stu-id="b4523-239">The following code shows an example:</span></span>

```csharp
var breaker = new CircuitBreaker();

try
{
  breaker.ExecuteAction(() =>
  {
    // Operation protected by the circuit breaker.
    ...
  });
}
catch (CircuitBreakerOpenException ex)
{
  // Perform some different action when the breaker is open.
  // Last exception details are in the inner exception.
  ...
}
catch (Exception ex)
{
  ...
}
```

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="b4523-240">Kapcsolódó minták és útmutatók</span><span class="sxs-lookup"><span data-stu-id="b4523-240">Related patterns and guidance</span></span>

<span data-ttu-id="b4523-241">A következő minták is hasznosak lehetnek ennek a mintának a végrehajtása során:</span><span class="sxs-lookup"><span data-stu-id="b4523-241">The following patterns might also be useful when implementing this pattern:</span></span>

- <span data-ttu-id="b4523-242">[Újrapróbálkozási minta][retry-pattern].</span><span class="sxs-lookup"><span data-stu-id="b4523-242">[Retry Pattern][retry-pattern].</span></span> <span data-ttu-id="b4523-243">Ismerteti egy alkalmazás számára a szolgáltatásokhoz vagy hálózati erőforrásokhoz való csatlakozáskor jelentkező előre jelzett, átmeneti meghibásodások kezelését egy korábban meghiúsult művelet transzparens módon való ismételt megkísérlésével.</span><span class="sxs-lookup"><span data-stu-id="b4523-243">Describes how an application can handle anticipated temporary failures when it tries to connect to a service or network resource by transparently retrying an operation that has previously failed.</span></span>

- <span data-ttu-id="b4523-244">[Állapot végponti monitorozását végző minta](health-endpoint-monitoring.md).</span><span class="sxs-lookup"><span data-stu-id="b4523-244">[Health Endpoint Monitoring Pattern](health-endpoint-monitoring.md).</span></span> <span data-ttu-id="b4523-245">Egy áramkör-megszakító képes lehet egy szolgáltatás állapotának tesztelésére oly módon, hogy kérést küld egy, a szolgáltatás által közzétett végpontnak.</span><span class="sxs-lookup"><span data-stu-id="b4523-245">A circuit breaker might be able to test the health of a service by sending a request to an endpoint exposed by the service.</span></span> <span data-ttu-id="b4523-246">A szolgáltatásnak az állapotát jelző adatokat kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="b4523-246">The service should return information indicating its status.</span></span>


[retry-pattern]: ./retry.md
