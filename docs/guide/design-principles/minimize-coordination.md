---
title: "Koordinációs minimalizálása érdekében"
description: "Méretezhetőség eléréséhez alkalmazásszolgáltatások összehangolását minimalizálása érdekében"
author: MikeWasson
layout: LandingPage
ms.openlocfilehash: 1f8caa8b7cd85593c937f1d99d582492d4cf9a8b
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 11/14/2017
---
# <a name="minimize-coordination"></a><span data-ttu-id="92303-103">Koordinációs minimalizálása érdekében</span><span class="sxs-lookup"><span data-stu-id="92303-103">Minimize coordination</span></span> 

## <a name="minimize-coordination-between-application-services-to-achieve-scalability"></a><span data-ttu-id="92303-104">Méretezhetőség eléréséhez alkalmazásszolgáltatások összehangolását minimalizálása érdekében</span><span class="sxs-lookup"><span data-stu-id="92303-104">Minimize coordination between application services to achieve scalability</span></span>

<span data-ttu-id="92303-105">Felhőalapú alkalmazások többségéhez áll több alkalmazásszolgáltatások &mdash; webes előtér-webkiszolgálóinak, adatbázisok, üzleti folyamatok, jelentéskészítés és elemzés, és így tovább.</span><span class="sxs-lookup"><span data-stu-id="92303-105">Most cloud applications consist of multiple application services &mdash; web front ends, databases, business processes, reporting and analysis, and so on.</span></span> <span data-ttu-id="92303-106">Eléréséhez skálázhatóságát és megbízhatóságát, ezek a szolgáltatások szabad futnia több példánya.</span><span class="sxs-lookup"><span data-stu-id="92303-106">To achieve scalability and reliability, each of those services should run on multiple instances.</span></span> 

<span data-ttu-id="92303-107">Mi történik, amikor két példányt próbál egyidejű műveleteket, amelyek hatással vannak az egyes közös állapotot?</span><span class="sxs-lookup"><span data-stu-id="92303-107">What happens when two instances try to perform concurrent operations that affect some shared state?</span></span> <span data-ttu-id="92303-108">Bizonyos esetekben kell koordinációs ACID garanciák megőrzése érdekében például a csomópontok között.</span><span class="sxs-lookup"><span data-stu-id="92303-108">In some cases, there must be coordination across nodes, for example to preserve ACID guarantees.</span></span> <span data-ttu-id="92303-109">Ezen a diagramon `Node2` arra vár, hogy `Node1` egy adatbázis-zárolás feloldására:</span><span class="sxs-lookup"><span data-stu-id="92303-109">In this diagram, `Node2` is waiting for `Node1` to release a database lock:</span></span>

![](./images/database-lock.svg)

<span data-ttu-id="92303-110">Koordinációs korlátozza a horizontális skálázhatóságot előnyeit, és létrehozza a szűk keresztmetszeteket.</span><span class="sxs-lookup"><span data-stu-id="92303-110">Coordination limits the benefits of horizontal scale and creates bottlenecks.</span></span> <span data-ttu-id="92303-111">Ebben a példában az alkalmazás horizontális, és adja hozzá a további példányokat, látni fogja, nagyobb zárolási versenyt.</span><span class="sxs-lookup"><span data-stu-id="92303-111">In this example, as you scale out the application and add more instances, you'll see increased lock contention.</span></span> <span data-ttu-id="92303-112">A legrosszabb esetben az előtér-példányok legmagasabbak lesz a ideig vár a zárolás.</span><span class="sxs-lookup"><span data-stu-id="92303-112">In the worst case, the front-end instances will spend most of their time waiting on locks.</span></span>

<span data-ttu-id="92303-113">"Pontosan egyszeri" szemantikáját egy másik gyakori forrás az egyeztetés.</span><span class="sxs-lookup"><span data-stu-id="92303-113">"Exactly once" semantics are another frequent source of coordination.</span></span> <span data-ttu-id="92303-114">Például egy megrendelés pontosan egyszer kell feldolgozni.</span><span class="sxs-lookup"><span data-stu-id="92303-114">For example, an order must be processed exactly once.</span></span> <span data-ttu-id="92303-115">Két munkavállalók új rendelések figyelő.</span><span class="sxs-lookup"><span data-stu-id="92303-115">Two workers are listening for new orders.</span></span> <span data-ttu-id="92303-116">`Worker1`szerzi be egy feldolgozási sorrendet.</span><span class="sxs-lookup"><span data-stu-id="92303-116">`Worker1` picks up an order for processing.</span></span> <span data-ttu-id="92303-117">Az alkalmazás biztosítania kell, hogy `Worker2` nem ugyanezt a munkát, de még ha `Worker1` összeomlik, sorrendje nem dobva.</span><span class="sxs-lookup"><span data-stu-id="92303-117">The application must ensure that `Worker2` doesn't duplicate the work, but also if `Worker1` crashes, the order isn't dropped.</span></span>

![](./images/coordination.svg)

<span data-ttu-id="92303-118">Például használhatja mintaként [Feladatütemező ügynök felügyelő] [ sas-pattern] koordinálhatja a munkavállalók között, de ebben az esetben jobb megközelítés lehet, a munkahelyi particionálásához.</span><span class="sxs-lookup"><span data-stu-id="92303-118">You can use a pattern such as [Scheduler Agent Supervisor][sas-pattern] to coordinate between the workers, but in this case a better approach might be to partition the work.</span></span> <span data-ttu-id="92303-119">Minden egyes worker bizonyos számos rendelések (például, számlázási régiónként) van hozzárendelve.</span><span class="sxs-lookup"><span data-stu-id="92303-119">Each worker is assigned a certain range of orders (say, by billing region).</span></span> <span data-ttu-id="92303-120">Ha egy munkavégző összeomlik, egy új példány felveszi ahol abbahagyta az előző alkalmazáspéldányt, de több példánya nem vitában.</span><span class="sxs-lookup"><span data-stu-id="92303-120">If a worker crashes, a new instance picks up where the previous instance left off, but multiple instances aren't contending.</span></span>

## <a name="recommendations"></a><span data-ttu-id="92303-121">Javaslatok</span><span class="sxs-lookup"><span data-stu-id="92303-121">Recommendations</span></span>

<span data-ttu-id="92303-122">**Vezessék be a végleges konzisztencia**.</span><span class="sxs-lookup"><span data-stu-id="92303-122">**Embrace eventual consistency**.</span></span> <span data-ttu-id="92303-123">Amikor adatokat, az erős konzisztencia biztosítja kényszerítéséhez koordinációs vesz igénybe.</span><span class="sxs-lookup"><span data-stu-id="92303-123">When data is distributed, it takes coordination to enforce strong consistency guarantees.</span></span> <span data-ttu-id="92303-124">Tegyük fel például, egy művelet frissítések két adatbázis.</span><span class="sxs-lookup"><span data-stu-id="92303-124">For example, suppose an operation updates two databases.</span></span> <span data-ttu-id="92303-125">Helyett üzembe azt egy egyetlen tranzakció hatókörében, azt jobb, ha a rendszer lehetővé teszi végleges konzisztencia, lehet, hogy a a [Compensating tranzakció] [ compensating-transaction] mintát logikailag visszavonása esetén.</span><span class="sxs-lookup"><span data-stu-id="92303-125">Instead of putting it into a single transaction scope, it's better if the system can accommodate eventual consistency, perhaps by using the [Compensating Transaction][compensating-transaction] pattern to logically roll back after a failure.</span></span>

<span data-ttu-id="92303-126">**Tartomány eseményeknek a segítségével állapot szinkronizálása**.</span><span class="sxs-lookup"><span data-stu-id="92303-126">**Use domain events to synchronize state**.</span></span> <span data-ttu-id="92303-127">A [tartomány esemény] [ domain-event] egy eseményt, amely rögzíti, amikor esemény történik, amely jelentőséggel bír, a tartományon belül.</span><span class="sxs-lookup"><span data-stu-id="92303-127">A [domain event][domain-event] is an event that records when something happens that has significance within the domain.</span></span> <span data-ttu-id="92303-128">Érintett szolgáltatások az esemény, nem pedig egy globális tranzakcióba segítségével több szolgáltatásban koordinálja a figyelheti.</span><span class="sxs-lookup"><span data-stu-id="92303-128">Interested services can listen for the event, rather than using a global transaction to coordinate across multiple services.</span></span> <span data-ttu-id="92303-129">Ez a módszer használata esetén a rendszer a végleges konzisztencia kell működését (lásd az előző elem).</span><span class="sxs-lookup"><span data-stu-id="92303-129">If this approach is used, the system must tolerate eventual consistency (see previous item).</span></span> 

<span data-ttu-id="92303-130">**Vegye figyelembe például CQRS és az esemény forrás minták**.</span><span class="sxs-lookup"><span data-stu-id="92303-130">**Consider patterns such as CQRS and event sourcing**.</span></span> <span data-ttu-id="92303-131">Ezek két minták között olvasási munkaterhelések versengés csökkentéséhez és a munkaterhelések írási segítségével.</span><span class="sxs-lookup"><span data-stu-id="92303-131">These two patterns can help to reduce contention between read workloads and write workloads.</span></span> 

- <span data-ttu-id="92303-132">A [CQRS mintát] [ cqrs-pattern] elkülönítésére szolgál olvasási műveleteket az írási műveletek.</span><span class="sxs-lookup"><span data-stu-id="92303-132">The [CQRS pattern][cqrs-pattern] separates read operations from write operations.</span></span> <span data-ttu-id="92303-133">Az egyes megvalósítások a beolvasott adat fizikailag elkülönített az adatok írása az.</span><span class="sxs-lookup"><span data-stu-id="92303-133">In some implementations, the read data is physically separated from the write data.</span></span> 

- <span data-ttu-id="92303-134">Az a [esemény forrás mintát][event-sourcing], állapotváltozások csak append adattárolóihoz események sorozataként fájl rögzíti.</span><span class="sxs-lookup"><span data-stu-id="92303-134">In the [Event Sourcing pattern][event-sourcing], state changes are recorded as a series of events to an append-only data store.</span></span> <span data-ttu-id="92303-135">Egy esemény hozzáfűzi a stream egy atomi művelet, minimális zárolását igénylő.</span><span class="sxs-lookup"><span data-stu-id="92303-135">Appending an event to the stream is an atomic operation, requiring minimal locking.</span></span> 

<span data-ttu-id="92303-136">Ezek két minták egészítik ki egymást.</span><span class="sxs-lookup"><span data-stu-id="92303-136">These two patterns complement each other.</span></span> <span data-ttu-id="92303-137">Ha a csak írható tárban CQRS esemény forrás, a csak olvasható tároló figyelheti az azonos események olvasható pillanatképet az aktuális állapot, a lekérdezések optimalizálva.</span><span class="sxs-lookup"><span data-stu-id="92303-137">If the write-only store in CQRS uses event sourcing, the read-only store can listen for the same events to create a readable snapshot of the current state, optimized for queries.</span></span> <span data-ttu-id="92303-138">Mielőtt CQRS vagy forrás eseményt, azonban figyelembe ezt a módszert kihívásai.</span><span class="sxs-lookup"><span data-stu-id="92303-138">Before adopting CQRS or event sourcing, however, be aware of the challenges of this approach.</span></span> <span data-ttu-id="92303-139">További információkért lásd: [CQRS architektúra stílus][cqrs-style].</span><span class="sxs-lookup"><span data-stu-id="92303-139">For more information, see [CQRS architecture style][cqrs-style].</span></span>

<span data-ttu-id="92303-140">**Adatok particionálása**.</span><span class="sxs-lookup"><span data-stu-id="92303-140">**Partition data**.</span></span>  <span data-ttu-id="92303-141">Ne üzembe az összes adat, amelyet egy adatkulcsokat számos alkalmazás szolgáltatásban.</span><span class="sxs-lookup"><span data-stu-id="92303-141">Avoid putting all of your data into one data schema that is shared across many application services.</span></span> <span data-ttu-id="92303-142">Egy mikroszolgáltatások architektúra azáltal, hogy minden egyes szolgáltatás felelős a saját adattár érvénybe lépteti a elvet.</span><span class="sxs-lookup"><span data-stu-id="92303-142">A microservices architecture enforces this principle by making each service responsible for its own data store.</span></span> <span data-ttu-id="92303-143">Belül egy önálló adatbázis szilánkok be az adatok particionálása javíthatja a feldolgozási, mert egy shard írása szolgáltatás nincs hatással a szolgáltatás egy másik shard írásakor.</span><span class="sxs-lookup"><span data-stu-id="92303-143">Within a single database, partitioning the data into shards can improve concurrency, because a service writing to one shard does not affect a service writing to a different shard.</span></span>

<span data-ttu-id="92303-144">**Az idempotent műveleti terv**.</span><span class="sxs-lookup"><span data-stu-id="92303-144">**Design idempotent operations**.</span></span> <span data-ttu-id="92303-145">Ha lehetséges, műveletek idempotent tervezése.</span><span class="sxs-lookup"><span data-stu-id="92303-145">When possible, design operations to be idempotent.</span></span> <span data-ttu-id="92303-146">Így azok kezelhetők: legalább egyszeri szemantika használatával.</span><span class="sxs-lookup"><span data-stu-id="92303-146">That way, they can be handled using at-least-once semantics.</span></span> <span data-ttu-id="92303-147">Például a munkaelemek helyezheti várólistát.</span><span class="sxs-lookup"><span data-stu-id="92303-147">For example, you can put work items on a queue.</span></span> <span data-ttu-id="92303-148">Ha egy munkavégző összeomlik éppen olyan műveletet, egy másik feldolgozónak egyszerűen felveszi a munkaelemet.</span><span class="sxs-lookup"><span data-stu-id="92303-148">If a worker crashes in the middle of an operation, another worker simply picks up the work item.</span></span>

<span data-ttu-id="92303-149">**Használja az aszinkron párhuzamos feldolgozás**.</span><span class="sxs-lookup"><span data-stu-id="92303-149">**Use asynchronous parallel processing**.</span></span> <span data-ttu-id="92303-150">Ha egy művelet aszinkron módon történik (például távoli hívások) végrehajtott több lépést igényel, valószínűleg létre tudja azokat párhuzamosan, és majd az eredmények összesítése.</span><span class="sxs-lookup"><span data-stu-id="92303-150">If an operation requires multiple steps that are performed asynchronously (such as remote service calls), you might be able to call them in parallel, and then aggregate the results.</span></span> <span data-ttu-id="92303-151">Ezt a módszert használja azt feltételezi, hogy az egyes lépések nem függ az előző lépés.</span><span class="sxs-lookup"><span data-stu-id="92303-151">This approach assumes that each step does not depend on the results of the previous step.</span></span>   

<span data-ttu-id="92303-152">**Használja a hozzáférések optimista, amikor lehetséges**.</span><span class="sxs-lookup"><span data-stu-id="92303-152">**Use optimistic concurrency when possible**.</span></span> <span data-ttu-id="92303-153">Pesszimista feldolgozási használ adatbázis zárolások ütközések elkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="92303-153">Pessimistic concurrency control uses database locks to prevent conflicts.</span></span> <span data-ttu-id="92303-154">Ez teljesítményproblémákat okozhat, és csökkentheti a rendelkezésre állási.</span><span class="sxs-lookup"><span data-stu-id="92303-154">This can cause poor performance and reduce availability.</span></span> <span data-ttu-id="92303-155">Az egyidejű hozzáférések optimista vezérlését minden tranzakció módosítja, a másolási vagy az adatok pillanatképe.</span><span class="sxs-lookup"><span data-stu-id="92303-155">With optimistic concurrency control, each transaction modifies a copy or snapshot of the data.</span></span> <span data-ttu-id="92303-156">Ha a tranzakció véglegesítése, az adatbázismotor érvényesíti a tranzakció, és hatással lenne az adatbázis-konzisztencia tranzakciók elutasítja.</span><span class="sxs-lookup"><span data-stu-id="92303-156">When the transaction is committed, the database engine validates the transaction and rejects any transactions that would affect database consistency.</span></span> 

<span data-ttu-id="92303-157">Az Azure SQL Database és SQL Server támogatja az egyidejű hozzáférések optimista keresztül [pillanatkép-elkülönítés][sql-snapshot-isolation].</span><span class="sxs-lookup"><span data-stu-id="92303-157">Azure SQL Database and SQL Server support optimistic concurrency through [snapshot isolation][sql-snapshot-isolation].</span></span> <span data-ttu-id="92303-158">Bizonyos Azure storage szolgáltatások támogatja az egyidejű hozzáférések optimista révén ETag-EK, beleértve a [DocumentDB API] [ docdb-faq] és [Azure Storage] [ storage-concurrency].</span><span class="sxs-lookup"><span data-stu-id="92303-158">Some Azure storage services support optimistic concurrency through the use of Etags, including [DocumentDB API][docdb-faq] and [Azure Storage][storage-concurrency].</span></span>

<span data-ttu-id="92303-159">**Távolítsa el a MapReduce vagy más párhuzamos, elosztott algoritmusok**.</span><span class="sxs-lookup"><span data-stu-id="92303-159">**Consider MapReduce or other parallel, distributed algorithms**.</span></span> <span data-ttu-id="92303-160">Attól függően, hogy az adatok és végzett munka típusú előfordulhat független feladatokat, amelyek párhuzamosan több csomópontok végzi el a munkahelyi leíró.</span><span class="sxs-lookup"><span data-stu-id="92303-160">Depending on the data and type of work to be performed, you may be able to split the work into independent tasks that can be performed by multiple nodes working in parallel.</span></span> <span data-ttu-id="92303-161">Lásd: [nagy számítási architektúra stílus][big-compute].</span><span class="sxs-lookup"><span data-stu-id="92303-161">See [Big compute architecture style][big-compute].</span></span>

<span data-ttu-id="92303-162">**Vezető választás használata koordinációs**.</span><span class="sxs-lookup"><span data-stu-id="92303-162">**Use leader election for coordination**.</span></span> <span data-ttu-id="92303-163">Olyan esetben, ahol kell műveletek koordinálására győződjön meg arról, a koordinátor nem válik a hibaérzékeny pontok kialakulását az alkalmazásban.</span><span class="sxs-lookup"><span data-stu-id="92303-163">In cases where you need to coordinate operations, make sure the coordinator does not become a single point of failure in the application.</span></span> <span data-ttu-id="92303-164">Használatával a [vezető választás mintát][leader-election], egy példány vezetője tetszőleges időpontban, és a koordinátor funkcionál.</span><span class="sxs-lookup"><span data-stu-id="92303-164">Using the [Leader Election pattern][leader-election], one instance is the leader at any time, and acts as the coordinator.</span></span> <span data-ttu-id="92303-165">A kitöltés nem sikerül, ha egy új példány kijelölt vezetője kell.</span><span class="sxs-lookup"><span data-stu-id="92303-165">If the leader fails, a new instance is elected to be the leader.</span></span> 
 

<!-- links -->

[big-compute]: ../architecture-styles/big-compute.md
[compensating-transaction]: ../../patterns/compensating-transaction.md
[cqrs-style]: ../architecture-styles/cqrs.md
[cqrs-pattern]: ../../patterns/cqrs.md
[docdb-faq]: /azure/documentdb/documentdb-faq
[domain-event]: https://martinfowler.com/eaaDev/DomainEvent.html
[event-sourcing]: ../../patterns/event-sourcing.md
[leader-election]: ../../patterns/leader-election.md
[sas-pattern]: ../../patterns/scheduler-agent-supervisor.md
[sql-snapshot-isolation]: /sql/t-sql/statements/set-transaction-isolation-level-transact-sql
[storage-concurrency]: https://azure.microsoft.com/blog/managing-concurrency-in-microsoft-azure-storage-2/