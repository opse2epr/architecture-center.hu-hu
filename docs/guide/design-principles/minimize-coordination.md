---
title: Minimalizálja a koordinációt
titleSuffix: Azure Application Architecture Guide
description: A skálázhatóság érdekében minimalizálja a koordinációt az alkalmazásszolgáltatások között.
author: MikeWasson
ms.date: 08/30/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: seojan19
ms.openlocfilehash: e124e6720b909bafc74a4c074454ec0a3ec30c59
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 01/23/2019
ms.locfileid: "54488579"
---
# <a name="minimize-coordination"></a><span data-ttu-id="97998-103">Minimalizálja a koordinációt</span><span class="sxs-lookup"><span data-stu-id="97998-103">Minimize coordination</span></span>

## <a name="minimize-coordination-between-application-services-to-achieve-scalability"></a><span data-ttu-id="97998-104">A skálázhatóság érdekében minimalizálja a koordinációt az alkalmazásszolgáltatások között.</span><span class="sxs-lookup"><span data-stu-id="97998-104">Minimize coordination between application services to achieve scalability</span></span>

<span data-ttu-id="97998-105">A legtöbb felhőalapú alkalmazás több alkalmazásszolgáltatásból áll, úgymint webes kezelőfelületek, adatbázisok, üzleti folyamatok, jelentés és elemzés.</span><span class="sxs-lookup"><span data-stu-id="97998-105">Most cloud applications consist of multiple application services &mdash; web front ends, databases, business processes, reporting and analysis, and so on.</span></span> <span data-ttu-id="97998-106">A skálázhatóság és megbízhatóság biztosításához mindegyik szolgáltatásnak több példányon kell futnia.</span><span class="sxs-lookup"><span data-stu-id="97998-106">To achieve scalability and reliability, each of those services should run on multiple instances.</span></span>

<span data-ttu-id="97998-107">Mi történik, ha két példány néhány megosztott állapotot érintő egyidejű műveletet próbál végrehajtani?</span><span class="sxs-lookup"><span data-stu-id="97998-107">What happens when two instances try to perform concurrent operations that affect some shared state?</span></span> <span data-ttu-id="97998-108">Ilyen esetekben koordináció szükséges a csomópontok között, például az ACID megvalósulásának fenntartása érdekében.</span><span class="sxs-lookup"><span data-stu-id="97998-108">In some cases, there must be coordination across nodes, for example to preserve ACID guarantees.</span></span> <span data-ttu-id="97998-109">Ezen az ábrán látható, hogy a `Node2` a `Node1` csomópontra vár, hogy az feloldja az adatbázis-zárolást:</span><span class="sxs-lookup"><span data-stu-id="97998-109">In this diagram, `Node2` is waiting for `Node1` to release a database lock:</span></span>

![Adatbázis-zárolást diagram](./images/database-lock.svg)

<span data-ttu-id="97998-111">A koordináció korlátozza a horizontális skálázás előnyeit, és szűk keresztmetszetet hoz létre.</span><span class="sxs-lookup"><span data-stu-id="97998-111">Coordination limits the benefits of horizontal scale and creates bottlenecks.</span></span> <span data-ttu-id="97998-112">Ebben a példában az alkalmazás horizontális felskálázása és további példányok hozzáadása közben megnövekedett zárolási versenyt fog tapasztalni.</span><span class="sxs-lookup"><span data-stu-id="97998-112">In this example, as you scale out the application and add more instances, you'll see increased lock contention.</span></span> <span data-ttu-id="97998-113">A legrosszabb esetben az előtérbeli példányok a legtöbb idejüket a zárolásra várva fogják tölteni.</span><span class="sxs-lookup"><span data-stu-id="97998-113">In the worst case, the front-end instances will spend most of their time waiting on locks.</span></span>

<span data-ttu-id="97998-114">A „pontosan egyszer” szemantika a koordináció egy másik gyakori forrása.</span><span class="sxs-lookup"><span data-stu-id="97998-114">"Exactly once" semantics are another frequent source of coordination.</span></span> <span data-ttu-id="97998-115">Egy megrendelést például pontosan egyszer szabad feldolgozni.</span><span class="sxs-lookup"><span data-stu-id="97998-115">For example, an order must be processed exactly once.</span></span> <span data-ttu-id="97998-116">Két feldolgozó új megrendelésekre vár.</span><span class="sxs-lookup"><span data-stu-id="97998-116">Two workers are listening for new orders.</span></span> <span data-ttu-id="97998-117">A `Worker1` felveszi a feldolgozási kérést.</span><span class="sxs-lookup"><span data-stu-id="97998-117">`Worker1` picks up an order for processing.</span></span> <span data-ttu-id="97998-118">Az alkalmazásnak biztosítania kell, hogy a `Worker2` nem ismétli meg a munkát, de ha a `Worker1` összeomlik, a megrendelést nem dobja el a rendszer.</span><span class="sxs-lookup"><span data-stu-id="97998-118">The application must ensure that `Worker2` doesn't duplicate the work, but also if `Worker1` crashes, the order isn't dropped.</span></span>

![Koordinációs diagramja](./images/coordination.svg)

<span data-ttu-id="97998-120">A feldolgozók közötti koordinációhoz olyan mintákat is használhat, mint például a [Feladatütemező ügynök felügyeleti mintája][sas-pattern], de ebben az esetben a munka particionálása jobb módszer lehet.</span><span class="sxs-lookup"><span data-stu-id="97998-120">You can use a pattern such as [Scheduler Agent Supervisor][sas-pattern] to coordinate between the workers, but in this case a better approach might be to partition the work.</span></span> <span data-ttu-id="97998-121">Minden egyes feldolgozóhoz megrendelések bizonyos tartománya van hozzárendelve (például számlázási régiónként).</span><span class="sxs-lookup"><span data-stu-id="97998-121">Each worker is assigned a certain range of orders (say, by billing region).</span></span> <span data-ttu-id="97998-122">Ha egy feldolgozó összeomlik, egy új példány ott folytatja a feladatot, ahol az előző abbahagyta, de a példányok nem versenyeznek egymással.</span><span class="sxs-lookup"><span data-stu-id="97998-122">If a worker crashes, a new instance picks up where the previous instance left off, but multiple instances aren't contending.</span></span>

## <a name="recommendations"></a><span data-ttu-id="97998-123">Javaslatok</span><span class="sxs-lookup"><span data-stu-id="97998-123">Recommendations</span></span>

<span data-ttu-id="97998-124">**Végső konzisztencia támogatása**.</span><span class="sxs-lookup"><span data-stu-id="97998-124">**Embrace eventual consistency**.</span></span> <span data-ttu-id="97998-125">Az adatok elosztásakor koordinációra van szükség az erős konzisztencia megvalósulásának kikényszerítésére.</span><span class="sxs-lookup"><span data-stu-id="97998-125">When data is distributed, it takes coordination to enforce strong consistency guarantees.</span></span> <span data-ttu-id="97998-126">Tegyük fel például, hogy egy művelet két adatbázist frissít.</span><span class="sxs-lookup"><span data-stu-id="97998-126">For example, suppose an operation updates two databases.</span></span> <span data-ttu-id="97998-127">Ahelyett, hogy egy tranzakciós hatókörbe helyezné, jobb, ha a rendszer képes végső konzisztenciát használni, például a [Kompenzáló tranzakció][compensating-transaction] minta használatával, a hiba utáni logikai visszavonáshoz.</span><span class="sxs-lookup"><span data-stu-id="97998-127">Instead of putting it into a single transaction scope, it's better if the system can accommodate eventual consistency, perhaps by using the [Compensating Transaction][compensating-transaction] pattern to logically roll back after a failure.</span></span>

<span data-ttu-id="97998-128">**Tartományi események használata az állapot szinkronizálásához**.</span><span class="sxs-lookup"><span data-stu-id="97998-128">**Use domain events to synchronize state**.</span></span> <span data-ttu-id="97998-129">A [tartományi esemény][domain-event] egy olyan esemény, amely rögzíti, ha valami fontos történik a tartományban.</span><span class="sxs-lookup"><span data-stu-id="97998-129">A [domain event][domain-event] is an event that records when something happens that has significance within the domain.</span></span> <span data-ttu-id="97998-130">Az érintett szolgáltatások figyelhetik az eseményt ahelyett, hogy globális tranzakciót használnának az erőforrások közötti koordinációhoz.</span><span class="sxs-lookup"><span data-stu-id="97998-130">Interested services can listen for the event, rather than using a global transaction to coordinate across multiple services.</span></span> <span data-ttu-id="97998-131">Ennek a módszernek a használatakor a rendszernek tolerálnia kell a végső konzisztenciát (lásd az előző elemet).</span><span class="sxs-lookup"><span data-stu-id="97998-131">If this approach is used, the system must tolerate eventual consistency (see previous item).</span></span>

<span data-ttu-id="97998-132">**Fontolja meg a CQRS, az Események forráskezelése és hasonló minták használatát**.</span><span class="sxs-lookup"><span data-stu-id="97998-132">**Consider patterns such as CQRS and event sourcing**.</span></span> <span data-ttu-id="97998-133">Ez a két minta segíthet a versengés csökkentésében az olvasási és az írási számítási feladatok között.</span><span class="sxs-lookup"><span data-stu-id="97998-133">These two patterns can help to reduce contention between read workloads and write workloads.</span></span>

- <span data-ttu-id="97998-134">A [CQRS minta][cqrs-pattern] elkülöníti az olvasási műveleteket az írási műveletektől.</span><span class="sxs-lookup"><span data-stu-id="97998-134">The [CQRS pattern][cqrs-pattern] separates read operations from write operations.</span></span> <span data-ttu-id="97998-135">Néhány megvalósítás esetében az adatok olvasása fizikailag is el van különítve az adatok írásától.</span><span class="sxs-lookup"><span data-stu-id="97998-135">In some implementations, the read data is physically separated from the write data.</span></span>

- <span data-ttu-id="97998-136">Az [Események forráskezelése mintában][event-sourcing] az állapotmódosításokat eseménysorozatként rögzíti a rendszer egy csak hozzáfűzéssel bővíthető adattárban.</span><span class="sxs-lookup"><span data-stu-id="97998-136">In the [Event Sourcing pattern][event-sourcing], state changes are recorded as a series of events to an append-only data store.</span></span> <span data-ttu-id="97998-137">Egy esemény hozzáfőzése a streamhez atomi művelet, amelyhez minimális zárolásra van szükség.</span><span class="sxs-lookup"><span data-stu-id="97998-137">Appending an event to the stream is an atomic operation, requiring minimal locking.</span></span>

<span data-ttu-id="97998-138">Ez a két minta kiegészíti egymást.</span><span class="sxs-lookup"><span data-stu-id="97998-138">These two patterns complement each other.</span></span> <span data-ttu-id="97998-139">Ha a CQRS-ben található, csak írási engedéllyel rendelkező adattár az Események forráskezelése mintát használja, a csak olvasható adattár figyelheti ugyanazokat az eseményeket egy lekérdezésekhez optimalizált, az aktuális állapotot tartalmazó, olvasható pillanatkép létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="97998-139">If the write-only store in CQRS uses event sourcing, the read-only store can listen for the same events to create a readable snapshot of the current state, optimized for queries.</span></span> <span data-ttu-id="97998-140">A CQRS vagy az Események forráskezelése minta alkalmazása előtt vegye figyelembe a módszer kihívást jelentő jellemzőit.</span><span class="sxs-lookup"><span data-stu-id="97998-140">Before adopting CQRS or event sourcing, however, be aware of the challenges of this approach.</span></span> <span data-ttu-id="97998-141">További információ: [CQRS architektúrastílus][cqrs-style].</span><span class="sxs-lookup"><span data-stu-id="97998-141">For more information, see [CQRS architecture style][cqrs-style].</span></span>

<span data-ttu-id="97998-142">**Adatok particionálása**.</span><span class="sxs-lookup"><span data-stu-id="97998-142">**Partition data**.</span></span>  <span data-ttu-id="97998-143">Ne helyezze minden adatát egyetlen, számos alkalmazásszolgáltatás között megosztott adatsémába.</span><span class="sxs-lookup"><span data-stu-id="97998-143">Avoid putting all of your data into one data schema that is shared across many application services.</span></span> <span data-ttu-id="97998-144">A mikroszolgáltatási architektúra úgy kényszeríti ki ezt az alapelvet, hogy minden szolgáltatást a saját adattáráért tesz felelőssé.</span><span class="sxs-lookup"><span data-stu-id="97998-144">A microservices architecture enforces this principle by making each service responsible for its own data store.</span></span> <span data-ttu-id="97998-145">Egy önálló adatbázison belül az adatok szilánkokba történő particionálása javíthatja az egyidejűséget, mivel az egyik adatszilánkba író szolgáltatás nem befolyásolja a másik adatszilánkba író szolgáltatást.</span><span class="sxs-lookup"><span data-stu-id="97998-145">Within a single database, partitioning the data into shards can improve concurrency, because a service writing to one shard does not affect a service writing to a different shard.</span></span>

<span data-ttu-id="97998-146">**Tervezzen idempotens műveleteket**.</span><span class="sxs-lookup"><span data-stu-id="97998-146">**Design idempotent operations**.</span></span> <span data-ttu-id="97998-147">Amikor lehetséges, az alkalmazásokat úgy tervezze meg, hogy idempotensek legyenek.</span><span class="sxs-lookup"><span data-stu-id="97998-147">When possible, design operations to be idempotent.</span></span> <span data-ttu-id="97998-148">Így azok legalább egy szemantikával kezelhetők.</span><span class="sxs-lookup"><span data-stu-id="97998-148">That way, they can be handled using at-least-once semantics.</span></span> <span data-ttu-id="97998-149">Például üzenetsorba helyezheti a munkaelemeket.</span><span class="sxs-lookup"><span data-stu-id="97998-149">For example, you can put work items on a queue.</span></span> <span data-ttu-id="97998-150">Ha egy feldolgozó a művelet közepén összeomlik, egy másik feldolgozó egyszerűen folytatja a munkaelemet.</span><span class="sxs-lookup"><span data-stu-id="97998-150">If a worker crashes in the middle of an operation, another worker simply picks up the work item.</span></span>

<span data-ttu-id="97998-151">**Használjon aszinkron párhuzamos feldolgozást**.</span><span class="sxs-lookup"><span data-stu-id="97998-151">**Use asynchronous parallel processing**.</span></span> <span data-ttu-id="97998-152">Ha egy művelethez több, aszinkron módon elvégzett lépésre van szükség (például távoli szolgáltatások meghívása), lehetséges, hogy párhuzamosan hívja meg őket, és összesíti az eredményeket.</span><span class="sxs-lookup"><span data-stu-id="97998-152">If an operation requires multiple steps that are performed asynchronously (such as remote service calls), you might be able to call them in parallel, and then aggregate the results.</span></span> <span data-ttu-id="97998-153">Ez a módszer azt feltételezi, hogy a lépések nem függnek az előző lépés eredményétől.</span><span class="sxs-lookup"><span data-stu-id="97998-153">This approach assumes that each step does not depend on the results of the previous step.</span></span>

<span data-ttu-id="97998-154">**Használjon optimista egyidejűséget, ha lehetséges**.</span><span class="sxs-lookup"><span data-stu-id="97998-154">**Use optimistic concurrency when possible**.</span></span> <span data-ttu-id="97998-155">A pesszimista egyidejűség-vezérlés adatbázis-zárolást használ az ütközések megelőzése érdekében.</span><span class="sxs-lookup"><span data-stu-id="97998-155">Pessimistic concurrency control uses database locks to prevent conflicts.</span></span> <span data-ttu-id="97998-156">Ez gyenge teljesítményt okozhat és csökkentheti a rendelkezésre állást.</span><span class="sxs-lookup"><span data-stu-id="97998-156">This can cause poor performance and reduce availability.</span></span> <span data-ttu-id="97998-157">Az optimista egyidejűség-vezérléssel minden tranzakció az adat egy pillanatfelvételének másolatát módosítja.</span><span class="sxs-lookup"><span data-stu-id="97998-157">With optimistic concurrency control, each transaction modifies a copy or snapshot of the data.</span></span> <span data-ttu-id="97998-158">A tranzakció véglegesítése után az adatbázismotor érvényesíti a tranzakciót, és visszautasítja az adatbázis konzisztenciáját befolyásoló tranzakciókat.</span><span class="sxs-lookup"><span data-stu-id="97998-158">When the transaction is committed, the database engine validates the transaction and rejects any transactions that would affect database consistency.</span></span>

<span data-ttu-id="97998-159">Az Azure SQL Database és SQL Server [pillanatkép-elkülönítéssel][sql-snapshot-isolation] támogatja az optimista egyidejűséget.</span><span class="sxs-lookup"><span data-stu-id="97998-159">Azure SQL Database and SQL Server support optimistic concurrency through [snapshot isolation][sql-snapshot-isolation].</span></span> <span data-ttu-id="97998-160">Bizonyos Azure Storage-szolgáltatások (például az [Azure Cosmos DB][cosmosdb-faq] és az [Azure Storage][storage-concurrency]) az ETagek használatán keresztül támogatják az optimista egyidejűséget.</span><span class="sxs-lookup"><span data-stu-id="97998-160">Some Azure storage services support optimistic concurrency through the use of Etags, including [Azure Cosmos DB][cosmosdb-faq] and [Azure Storage][storage-concurrency].</span></span>

<span data-ttu-id="97998-161">**Fontolja meg a MapReduce vagy egyéb párhuzamos, elosztott algoritmus használatát**.</span><span class="sxs-lookup"><span data-stu-id="97998-161">**Consider MapReduce or other parallel, distributed algorithms**.</span></span> <span data-ttu-id="97998-162">Az adatoktól és az elvégzendő munka típusától függően feloszthatja a munkát független feladatokra, amelyeket párhuzamosan működő csomópontok végezhetnek el.</span><span class="sxs-lookup"><span data-stu-id="97998-162">Depending on the data and type of work to be performed, you may be able to split the work into independent tasks that can be performed by multiple nodes working in parallel.</span></span> <span data-ttu-id="97998-163">Lásd: [Big Compute architektúrastílus][big-compute].</span><span class="sxs-lookup"><span data-stu-id="97998-163">See [Big compute architecture style][big-compute].</span></span>

<span data-ttu-id="97998-164">**Használja a vezetőválasztást a koordinációhoz**.</span><span class="sxs-lookup"><span data-stu-id="97998-164">**Use leader election for coordination**.</span></span> <span data-ttu-id="97998-165">Olyan esetben, ahol műveleteket kell koordinálnia, győződjön meg arról, hogy a koordinátor ne váljon kritikus meghibásodási ponttá az alkalmazásban.</span><span class="sxs-lookup"><span data-stu-id="97998-165">In cases where you need to coordinate operations, make sure the coordinator does not become a single point of failure in the application.</span></span> <span data-ttu-id="97998-166">A [Vezetőválasztási minta][leader-election] használatával egy példány bármikor vezető lehet, és koordinátorként működhet.</span><span class="sxs-lookup"><span data-stu-id="97998-166">Using the [Leader Election pattern][leader-election], one instance is the leader at any time, and acts as the coordinator.</span></span> <span data-ttu-id="97998-167">Ha a vezető összeomlik, a rendszer egy új példányt választ vezetőnek.</span><span class="sxs-lookup"><span data-stu-id="97998-167">If the leader fails, a new instance is elected to be the leader.</span></span>

<!-- links -->

[big-compute]: ../architecture-styles/big-compute.md
[compensating-transaction]: ../../patterns/compensating-transaction.md
[cqrs-style]: ../architecture-styles/cqrs.md
[cqrs-pattern]: ../../patterns/cqrs.md
[cosmosdb-faq]: /azure/cosmos-db/faq
[domain-event]: https://martinfowler.com/eaaDev/DomainEvent.html
[event-sourcing]: ../../patterns/event-sourcing.md
[leader-election]: ../../patterns/leader-election.md
[sas-pattern]: ../../patterns/scheduler-agent-supervisor.md
[sql-snapshot-isolation]: /sql/t-sql/statements/set-transaction-isolation-level-transact-sql
[storage-concurrency]: https://azure.microsoft.com/blog/managing-concurrency-in-microsoft-azure-storage-2/