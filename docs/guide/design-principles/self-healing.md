---
title: Tervezés az önjavítást szem előtt tartva
titleSuffix: Azure Application Architecture Guide
description: A rugalmas alkalmazások manuális beavatkozás nélkül is helyre tudnak állni a hibák után.
author: MikeWasson
ms.date: 08/30/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: seojan19
ms.openlocfilehash: 84bc6e5c8d78517e3dc1dc0ee8d250346a33ce43
ms.sourcegitcommit: 579c39ff4b776704ead17a006bf24cd4cdc65edd
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59641195"
---
# <a name="design-for-self-healing"></a><span data-ttu-id="38831-103">Tervezés az önjavítást szem előtt tartva</span><span class="sxs-lookup"><span data-stu-id="38831-103">Design for self healing</span></span>

## <a name="design-your-application-to-be-self-healing-when-failures-occur"></a><span data-ttu-id="38831-104">Az alkalmazás tervezése önmaga kijavítására, ha hiba történik</span><span class="sxs-lookup"><span data-stu-id="38831-104">Design your application to be self healing when failures occur</span></span>

<span data-ttu-id="38831-105">Az elosztott rendszerekben időnként fellépnek hibák.</span><span class="sxs-lookup"><span data-stu-id="38831-105">In a distributed system, failures happen.</span></span> <span data-ttu-id="38831-106">Meghibásodhatnak a hardverek.</span><span class="sxs-lookup"><span data-stu-id="38831-106">Hardware can fail.</span></span> <span data-ttu-id="38831-107">Átmeneti hibák lehetnek a hálózaton.</span><span class="sxs-lookup"><span data-stu-id="38831-107">The network can have transient failures.</span></span> <span data-ttu-id="38831-108">Ritkán a teljes szolgáltatásban vagy régióban üzemszünet állhat elő, de ezekre is fel kell készülni.</span><span class="sxs-lookup"><span data-stu-id="38831-108">Rarely, an entire service or region may experience a disruption, but even those must be planned for.</span></span>

<span data-ttu-id="38831-109">Ezért tervezze úgy az alkalmazását, hogy kijavítsa önmagát, ha hiba történik.</span><span class="sxs-lookup"><span data-stu-id="38831-109">Therefore, design an application to be self healing when failures occur.</span></span> <span data-ttu-id="38831-110">Ehhez az alábbi három pillérre támaszkodó megközelítésre van szükség:</span><span class="sxs-lookup"><span data-stu-id="38831-110">This requires a three-pronged approach:</span></span>

- <span data-ttu-id="38831-111">A hibák észlelése.</span><span class="sxs-lookup"><span data-stu-id="38831-111">Detect failures.</span></span>
- <span data-ttu-id="38831-112">A hibákra adott megfelelő válasz.</span><span class="sxs-lookup"><span data-stu-id="38831-112">Respond to failures gracefully.</span></span>
- <span data-ttu-id="38831-113">A hibák naplózása és monitorozása, ami információt biztosít a működéssel kapcsolatban.</span><span class="sxs-lookup"><span data-stu-id="38831-113">Log and monitor failures, to give operational insight.</span></span>

<span data-ttu-id="38831-114">Az adott hibatípusra adott válasz az alkalmazás rendelkezésreállási követelményeitől függhet.</span><span class="sxs-lookup"><span data-stu-id="38831-114">How you respond to a particular type of failure may depend on your application's availability requirements.</span></span> <span data-ttu-id="38831-115">Ha például nagyon magas rendelkezésre állásra van szüksége, akkor előfordulhat, hogy automatikusan egy másodlagos régióra végez feladatátvételt egy regionális kimaradás során.</span><span class="sxs-lookup"><span data-stu-id="38831-115">For example, if you require very high availability, you might automatically fail over to a secondary region during a regional outage.</span></span> <span data-ttu-id="38831-116">Ez azonban nagyobb költséget von magával, mint az egyetlen régióban történő üzembe helyezés.</span><span class="sxs-lookup"><span data-stu-id="38831-116">However, that will incur a higher cost than a single-region deployment.</span></span>

<span data-ttu-id="38831-117">Emellett ne csak az olyan nagy eseményeket vegye figyelembe, mint a regionális kimaradások, mert ezek általában ritkán fordulnak elő.</span><span class="sxs-lookup"><span data-stu-id="38831-117">Also, don't just consider big events like regional outages, which are generally rare.</span></span> <span data-ttu-id="38831-118">Legalább ennyire, vagy még jobban kell összpontosítania a helyi, rövid ideig tartó hibák, például a hálózati kapcsolathibák vagy a meghibásodott adatbázis-kapcsolatok kezelésére.</span><span class="sxs-lookup"><span data-stu-id="38831-118">You should focus as much, if not more, on handling local, short-lived failures, such as network connectivity failures or failed database connections.</span></span>

## <a name="recommendations"></a><span data-ttu-id="38831-119">Javaslatok</span><span class="sxs-lookup"><span data-stu-id="38831-119">Recommendations</span></span>

<span data-ttu-id="38831-120">**A sikertelen műveletek újrapróbálása**.</span><span class="sxs-lookup"><span data-stu-id="38831-120">**Retry failed operations**.</span></span> <span data-ttu-id="38831-121">Az átmeneti meghibásodások bekövetkezhetnek a hálózati kapcsolat pillanatnyi megszakadásából, az adatbázis-kapcsolat megszakadásából, vagy foglalt szolgáltatás miatti időtúllépésből kifolyólag.</span><span class="sxs-lookup"><span data-stu-id="38831-121">Transient failures may occur due to momentary loss of network connectivity, a dropped database connection, or a timeout when a service is busy.</span></span> <span data-ttu-id="38831-122">Építsen újrapróbálkozási logikát az alkalmazásba az átmeneti hibák kezelésére.</span><span class="sxs-lookup"><span data-stu-id="38831-122">Build retry logic into your application to handle transient failures.</span></span> <span data-ttu-id="38831-123">Sok Azure-szolgáltatás esetében az ügyfél SDK automatikus újrapróbálkozásokat valósít meg.</span><span class="sxs-lookup"><span data-stu-id="38831-123">For many Azure services, the client SDK implements automatic retries.</span></span> <span data-ttu-id="38831-124">További információkért lásd: [átmeneti hibák kezelése] [ transient-fault-handling] és a [újrapróbálkozási minta][retry].</span><span class="sxs-lookup"><span data-stu-id="38831-124">For more information, see [Transient fault handling][transient-fault-handling] and the [Retry pattern][retry].</span></span>

<span data-ttu-id="38831-125">**Hibás távoli szolgáltatások védelme (áramköri megszakító)**.</span><span class="sxs-lookup"><span data-stu-id="38831-125">**Protect failing remote services (Circuit Breaker)**.</span></span> <span data-ttu-id="38831-126">Az átmeneti hibák után érdemes újrapróbálkozni, ha azonban a hiba továbbra is fennáll, az ahhoz vezethet, hogy túl sok hívó próbál igénybe venni egy hibás szolgáltatást.</span><span class="sxs-lookup"><span data-stu-id="38831-126">It's good to retry after a transient failure, but if the failure persists, you can end up with too many callers hammering a failing service.</span></span> <span data-ttu-id="38831-127">Ez egymásra épülő hibához vezethet, ahogy a kérések felhalmozódnak.</span><span class="sxs-lookup"><span data-stu-id="38831-127">This can lead to cascading failures, as requests back up.</span></span> <span data-ttu-id="38831-128">Használja a [áramkör-megszakító minta] [ circuit-breaker] gyors (anélkül, hogy a távoli hívás) sikertelen művelet esetén nagy eséllyel lesz sikertelen.</span><span class="sxs-lookup"><span data-stu-id="38831-128">Use the [Circuit Breaker pattern][circuit-breaker] to fail fast (without making the remote call) when an operation is likely to fail.</span></span>

<span data-ttu-id="38831-129">**Kritikus erőforrások elkülönítése (válaszfal)**.</span><span class="sxs-lookup"><span data-stu-id="38831-129">**Isolate critical resources (Bulkhead)**.</span></span> <span data-ttu-id="38831-130">Egy alrendszerben bekövetkező meghibásodás időnként kaszkádolás révén elterjedhet.</span><span class="sxs-lookup"><span data-stu-id="38831-130">Failures in one subsystem can sometimes cascade.</span></span> <span data-ttu-id="38831-131">Ilyen akkor történhet, ha egy hiba miatt bizonyos erőforrások, mint például szálak vagy szoftvercsatornák, nem szabadulnak fel időben, ami erőforrásfogyáshoz vezet.</span><span class="sxs-lookup"><span data-stu-id="38831-131">This can happen if a failure causes some resources, such as threads or sockets, not to get freed in a timely manner, leading to resource exhaustion.</span></span> <span data-ttu-id="38831-132">Ennek elkerülése érdekében particionálja a rendszert elkülönített csoportokra, aminek eredményeképpen az egy partícióban bekövetkező hiba nem vezet a teljes rendszer leállásához.</span><span class="sxs-lookup"><span data-stu-id="38831-132">To avoid this, partition a system into isolated groups, so that a failure in one partition does not bring down the entire system.</span></span>

<span data-ttu-id="38831-133">**Terheléskiegyenlítés végrehajtása**.</span><span class="sxs-lookup"><span data-stu-id="38831-133">**Perform load leveling**.</span></span> <span data-ttu-id="38831-134">Az alkalmazások adatforgalmának esetleges hirtelen kiugrásai túlterhelhetik a háttérkiszolgálón futó szolgáltatásokat.</span><span class="sxs-lookup"><span data-stu-id="38831-134">Applications may experience sudden spikes in traffic that can overwhelm services on the backend.</span></span> <span data-ttu-id="38831-135">Ennek elkerülése érdekében használja a [terhelés üzenetsor-alapú terheléskiegyenlítési minta] [ load-level] az üzenetsorba a munkaelemeket aszinkron futáshoz.</span><span class="sxs-lookup"><span data-stu-id="38831-135">To avoid this, use the [Queue-Based Load Leveling pattern][load-level] to queue work items to run asynchronously.</span></span> <span data-ttu-id="38831-136">Az üzenetsor pufferként működik, amely csökkenti a terhelési kiugrásokat.</span><span class="sxs-lookup"><span data-stu-id="38831-136">The queue acts as a buffer that smooths out peaks in the load.</span></span>

<span data-ttu-id="38831-137">**Feladatátvétel**.</span><span class="sxs-lookup"><span data-stu-id="38831-137">**Fail over**.</span></span> <span data-ttu-id="38831-138">Ha egy példány nem érhető el, végezzen feladatátvételt egy másik példányra.</span><span class="sxs-lookup"><span data-stu-id="38831-138">If an instance can't be reached, fail over to another instance.</span></span> <span data-ttu-id="38831-139">Az állapot nélküli elemek, például webkiszolgálók esetén, helyezzen több példányt egy terheléselosztó vagy forgalomkezelő mögé.</span><span class="sxs-lookup"><span data-stu-id="38831-139">For things that are stateless, like a web server, put several instances behind a load balancer or traffic manager.</span></span> <span data-ttu-id="38831-140">Az állapotot tároló elemek, például adatbázisok esetén, replikákat és feladatátvételt használjon.</span><span class="sxs-lookup"><span data-stu-id="38831-140">For things that store state, like a database, use replicas and fail over.</span></span> <span data-ttu-id="38831-141">Az adattártól és replikálási módjától függően előfordulhat, hogy az alkalmazásnak végleges konzisztenciát kell kezelnie.</span><span class="sxs-lookup"><span data-stu-id="38831-141">Depending on the data store and how it replicates, this may require the application to deal with eventual consistency.</span></span>

<span data-ttu-id="38831-142">**A sikertelen tranzakciók kompenzálása**.</span><span class="sxs-lookup"><span data-stu-id="38831-142">**Compensate failed transactions**.</span></span> <span data-ttu-id="38831-143">Általában kerülje az elosztott tranzakciókat, mert a szolgáltatások és erőforrások közötti koordinációt igényelnek.</span><span class="sxs-lookup"><span data-stu-id="38831-143">In general, avoid distributed transactions, as they require coordination across services and resources.</span></span> <span data-ttu-id="38831-144">Helyette kisebb, önálló tranzakciókból állítsa össze a műveleteket.</span><span class="sxs-lookup"><span data-stu-id="38831-144">Instead, compose an operation from smaller individual transactions.</span></span> <span data-ttu-id="38831-145">Ha a művelet menet közben hiúsul meg, [kompenzáló tranzakciók][compensating-transactions] használatával vonhatja vissza a már végrehajtott lépéseket.</span><span class="sxs-lookup"><span data-stu-id="38831-145">If the operation fails midway through, use [Compensating Transactions][compensating-transactions] to undo any step that already completed.</span></span>

<span data-ttu-id="38831-146">**Ellenőrzőpontok elhelyezése a hosszú ideig futó tranzakciókban**.</span><span class="sxs-lookup"><span data-stu-id="38831-146">**Checkpoint long-running transactions**.</span></span> <span data-ttu-id="38831-147">Az ellenőrzőpontok rugalmasságot biztosítanak, ha egy hosszú ideig futó művelet meghiúsul.</span><span class="sxs-lookup"><span data-stu-id="38831-147">Checkpoints can provide resiliency if a long-running operation fails.</span></span> <span data-ttu-id="38831-148">Amikor a művelet újraindul (például átveszi egy másik virtuális gép), az utolsó ellenőrzőponttól folytatható.</span><span class="sxs-lookup"><span data-stu-id="38831-148">When the operation restarts (for example, it is picked up by another VM), it can be resumed from the last checkpoint.</span></span>

<span data-ttu-id="38831-149">**Leállás nélküli teljesítménycsökkenés**.</span><span class="sxs-lookup"><span data-stu-id="38831-149">**Degrade gracefully**.</span></span> <span data-ttu-id="38831-150">Néha nem lehet megkerülni egy problémát, ilyenkor azonban biztosíthat csökkentett funkciók, amelyek továbbra is hasznosak.</span><span class="sxs-lookup"><span data-stu-id="38831-150">Sometimes you can't work around a problem, but you can provide reduced functionality that is still useful.</span></span> <span data-ttu-id="38831-151">Vegyünk például egy könyvkatalógust megjelenítő alkalmazást.</span><span class="sxs-lookup"><span data-stu-id="38831-151">Consider an application that shows a catalog of books.</span></span> <span data-ttu-id="38831-152">Ha az alkalmazás nem tudja lekérni a borítók miniatűrjét, helyőrző képet jeleníthet meg helyette.</span><span class="sxs-lookup"><span data-stu-id="38831-152">If the application can't retrieve the thumbnail image for the cover, it might show a placeholder image.</span></span> <span data-ttu-id="38831-153">Előfordulhat, hogy teljes alrendszerek számítanak nem kritikus fontosságúnak az alkalmazás számára.</span><span class="sxs-lookup"><span data-stu-id="38831-153">Entire subsystems might be noncritical for the application.</span></span> <span data-ttu-id="38831-154">Egy elektronikus kereskedelmi webhelyen például a termékjavaslatok megjelenítése valószínűleg kevésbé fontos, mint a megrendelések feldolgozása.</span><span class="sxs-lookup"><span data-stu-id="38831-154">For example, in an e-commerce site, showing product recommendations is probably less critical than processing orders.</span></span>

<span data-ttu-id="38831-155">**Ügyfelek forgalmának szabályozása**.</span><span class="sxs-lookup"><span data-stu-id="38831-155">**Throttle clients**.</span></span> <span data-ttu-id="38831-156">Előfordulhat, hogy néhány felhasználó túlzott terhelést okoz, ami csökkentheti az alkalmazás rendelkezésre állását más felhasználók számára.</span><span class="sxs-lookup"><span data-stu-id="38831-156">Sometimes a small number of users create excessive load, which can reduce your application's availability for other users.</span></span> <span data-ttu-id="38831-157">Ilyen helyzetben bizonyos ideig szabályozhatja az ügyfél forgalmát.</span><span class="sxs-lookup"><span data-stu-id="38831-157">In this situation, throttle the client for a certain period of time.</span></span> <span data-ttu-id="38831-158">Tekintse meg a [sávszélesség-szabályozási minta][throttle].</span><span class="sxs-lookup"><span data-stu-id="38831-158">See the [Throttling pattern][throttle].</span></span>

<span data-ttu-id="38831-159">**Kártékony elemek blokkolása**.</span><span class="sxs-lookup"><span data-stu-id="38831-159">**Block bad actors**.</span></span> <span data-ttu-id="38831-160">Egy ügyfél forgalmának szabályozása még nem jelenti azt, hogy az ügyfél rosszindulatúan viselkedett.</span><span class="sxs-lookup"><span data-stu-id="38831-160">Just because you throttle a client, it doesn't mean client was acting maliciously.</span></span> <span data-ttu-id="38831-161">Pusztán azt jelenti, hogy az ügyfél túllépte a szolgáltatási kvótát.</span><span class="sxs-lookup"><span data-stu-id="38831-161">It just means the client exceeded their service quota.</span></span> <span data-ttu-id="38831-162">Ha azonban egy ügyfél rendszeresen túllépi a kvótát, vagy egyéb helytelen magatartást tanúsít, blokkolhatja az ügyfelet.</span><span class="sxs-lookup"><span data-stu-id="38831-162">But if a client consistently exceeds their quota or otherwise behaves badly, you might block them.</span></span> <span data-ttu-id="38831-163">Határozzon meg egy sávon kívüli folyamatot a felhasználó számára a blokkolás feloldásának kéréséhez.</span><span class="sxs-lookup"><span data-stu-id="38831-163">Define an out-of-band process for user to request getting unblocked.</span></span>

<span data-ttu-id="38831-164">**Vezetőválasztás használata**.</span><span class="sxs-lookup"><span data-stu-id="38831-164">**Use leader election**.</span></span> <span data-ttu-id="38831-165">Amikor koordinálnia kell egy feladatot, a [vezetőválasztás][leader-election] használatával válasszon koordinátort.</span><span class="sxs-lookup"><span data-stu-id="38831-165">When you need to coordinate a task, use [Leader Election][leader-election] to select a coordinator.</span></span> <span data-ttu-id="38831-166">Így a koordinátor nem lehet kritikus hibapont.</span><span class="sxs-lookup"><span data-stu-id="38831-166">That way, the coordinator is not a single point of failure.</span></span> <span data-ttu-id="38831-167">Ha a koordinátor meghiúsul, a rendszer újat választ.</span><span class="sxs-lookup"><span data-stu-id="38831-167">If the coordinator fails, a new one is selected.</span></span> <span data-ttu-id="38831-168">A vezetőválasztási algoritmus alapoktól való megvalósítása helyett vegye fontolóra egy azonnal használható megoldás, például a Zookeeper használatát.</span><span class="sxs-lookup"><span data-stu-id="38831-168">Rather than implement a leader election algorithm from scratch, consider an off-the-shelf solution such as Zookeeper.</span></span>

<span data-ttu-id="38831-169">**Tesztelés hibabeszúrással**.</span><span class="sxs-lookup"><span data-stu-id="38831-169">**Test with fault injection**.</span></span> <span data-ttu-id="38831-170">A sikerhez vezető utat gyakran túl sokszor tesztelik, a sikertelenséghez vezetőt azonban egyáltalán nem.</span><span class="sxs-lookup"><span data-stu-id="38831-170">All too often, the success path is well tested but not the failure path.</span></span> <span data-ttu-id="38831-171">Egy rendszer hosszú ideig futhat éles üzemben, mielőtt hiba történik.</span><span class="sxs-lookup"><span data-stu-id="38831-171">A system could run in production for a long time before a failure path is exercised.</span></span> <span data-ttu-id="38831-172">Hibabeszúrással tesztelheti a rendszer meghibásodásokkal szembeni rugalmasságát valódi hibák kiváltása vagy azok szimulálása révén.</span><span class="sxs-lookup"><span data-stu-id="38831-172">Use fault injection to test the resiliency of the system to failures, either by triggering actual failures or by simulating them.</span></span>

<span data-ttu-id="38831-173">**Véletlenszerű tesztelés alkalmazása**.</span><span class="sxs-lookup"><span data-stu-id="38831-173">**Embrace chaos engineering**.</span></span> <span data-ttu-id="38831-174">A véletlenszerű tesztelés a hibabeszúrás fogalmát kibővítve véletlenszerűen szúr be hibákat vagy rendellenes feltételeket az éles példányokba.</span><span class="sxs-lookup"><span data-stu-id="38831-174">Chaos engineering extends the notion of fault injection, by randomly injecting failures or abnormal conditions into production instances.</span></span>

<span data-ttu-id="38831-175">Alkalmazások készítésének strukturált megközelítését önjavító, lásd: [tervezése az Azure megbízható alkalmazások][resiliency-overview].</span><span class="sxs-lookup"><span data-stu-id="38831-175">For a structured approach to making your applications self healing, see [Design reliable applications for Azure][resiliency-overview].</span></span>

<!-- links -->

[circuit-breaker]: ../../patterns/circuit-breaker.md
[compensating-transactions]: ../../patterns/compensating-transaction.md
[leader-election]: ../../patterns/leader-election.md
[load-level]: ../../patterns/queue-based-load-leveling.md
[resiliency-overview]: ../../reliability/index.md
[retry]: ../../patterns/retry.md
[throttle]: ../../patterns/throttling.md
[transient-fault-handling]: ../../best-practices/transient-faults.md
