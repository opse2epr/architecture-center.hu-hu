---
title: CQRS architektúra stílus
description: Előnyeit, kihívást és ajánlott eljárások a CQRS architektúrák ismerteti
author: MikeWasson
ms.openlocfilehash: dd3da5886587159f57646ff1bfffa2094725f798
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 11/14/2017
ms.locfileid: "24539865"
---
# <a name="cqrs-architecture-style"></a><span data-ttu-id="8e8d5-103">CQRS architektúra stílus</span><span class="sxs-lookup"><span data-stu-id="8e8d5-103">CQRS architecture style</span></span>

<span data-ttu-id="8e8d5-104">A parancs és a lekérdezés felelősségi elkülönítése (CQRS) olyan architektúra stílus, amely elválasztja az olvasási műveletek az írási műveletek.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-104">Command and Query Responsibility Segregation (CQRS) is an architecture style that separates read operations from write operations.</span></span> 

![](./images/cqrs-logical.svg)

<span data-ttu-id="8e8d5-105">A hagyományos-architektúrák esetén az azonos adatmodell használt lekérdezése, és frissítse az adatbázist.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-105">In traditional architectures, the same data model is used to query and update a database.</span></span> <span data-ttu-id="8e8d5-106">Amely egyszerű és alapvető CRUD műveletek esetén működik.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-106">That's simple and works well for basic CRUD operations.</span></span> <span data-ttu-id="8e8d5-107">Összetett alkalmazások azonban ez a megközelítés válhat kezelése nehézkessé.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-107">In more complex applications, however, this approach can become unwieldy.</span></span> <span data-ttu-id="8e8d5-108">Olvasási oldalán, például az alkalmazás végezhet számos különböző lekérdezéseket, különböző alakzatok objektumok (DTOs) adatátvitel vissza.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-108">For example, on the read side, the application may perform many different queries, returning data transfer objects (DTOs) with different shapes.</span></span> <span data-ttu-id="8e8d5-109">Objektum leképezésének bonyolult válhat.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-109">Object mapping can become complicated.</span></span> <span data-ttu-id="8e8d5-110">A írási oldalon a modell nehéznek összetett érvényesítési és üzleti logikát.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-110">On the write side, the model may implement complex validation and business logic.</span></span> <span data-ttu-id="8e8d5-111">Ennek eredményeképpen fejezheti egy túl összetett modellt, amely túl sok.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-111">As a result, you can end up with an overly complex model that does too much.</span></span>

<span data-ttu-id="8e8d5-112">Egy másik lehetséges probléma olvasási és írási munkaterhelések gyakran aszimmetrikus, nagyon különböző teljesítmény és méretezhetőség követelményeknek.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-112">Another potential problem is that read and write workloads are often asymmetrical, with very different performance and scale requirements.</span></span> 

<span data-ttu-id="8e8d5-113">CQRS olvasási elválasztva megoldja ezeket a problémákat, és írja be különálló modellek segítségével **parancsok** frissíteni az adatokat, és **lekérdezések** adatokat olvasni.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-113">CQRS addresses these problems by separating reads and writes into separate models, using **commands** to update data, and **queries** to read data.</span></span>

- <span data-ttu-id="8e8d5-114">Parancsok kell lennie a feladatot ahelyett, hogy központú adatok alapján.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-114">Commands should be task based, rather than data centric.</span></span> <span data-ttu-id="8e8d5-115">("Könyv Szálloda helyiségben" nem "beállítás ReservationStatus fenntartott.") Az aszinkron feldolgozás ahelyett, hogy szinkron feldolgozás alatt várólistájának parancsok lehet helyezni.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-115">("Book hotel room," not "set ReservationStatus to Reserved.") Commands may be placed on a queue for asynchronous processing, rather than being processed synchronously.</span></span>

- <span data-ttu-id="8e8d5-116">Lekérdezések soha ne módosítsa az adatbázis.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-116">Queries never modify the database.</span></span> <span data-ttu-id="8e8d5-117">A lekérdezés egy DTO, amelyek nem foglalják magukban az bármilyen tartomány Tudásbázis adja vissza.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-117">A query returns a DTO that does not encapsulate any domain knowledge.</span></span>

<span data-ttu-id="8e8d5-118">A nagyobb elkülönítési fizikailag elkülönítheti a adatolvasási a az adatok írása.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-118">For greater isolation, you can physically separate the read data from the write data.</span></span> <span data-ttu-id="8e8d5-119">Ebben az esetben olvasható adatbázis használhatja a saját adatok séma optimalizált lekérdezések.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-119">In that case, the read database can use its own data schema that is optimized for queries.</span></span> <span data-ttu-id="8e8d5-120">Tárolhatja például a [materializált nézet] [ materialized-view] az adatok bonyolult illesztésekre vagy összetett O/RM-hozzárendelések elkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-120">For example, it can store a [materialized view][materialized-view] of the data, in order to avoid complex joins or complex O/RM mappings.</span></span> <span data-ttu-id="8e8d5-121">Adattár más típusú még akkor is használhatja.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-121">It might even use a different type of data store.</span></span> <span data-ttu-id="8e8d5-122">Például az írási adatbázis esetleg relációs, míg olvasható adatbázis egy dokumentum-adatbázis.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-122">For example, the write database might be relational, while the read database is a document database.</span></span>

<span data-ttu-id="8e8d5-123">Ha külön olvasási és írási adatbázisokat használnak, azok kell tartani szinkronban. Általában ez érhető el, mivel az egy eseményt, amikor frissíti az adatbázis közzététele írási modell.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-123">If separate read and write databases are used, they must be kept in sync. Typically this is accomplished by  having the write model publish an event whenever it updates the database.</span></span> <span data-ttu-id="8e8d5-124">Az adatbázis frissítése és az esemény közzétételéhez egy tranzakción belül kell megtörténnie.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-124">Updating the database and publishing the event must occur in a single transaction.</span></span> 

<span data-ttu-id="8e8d5-125">Egyes megvalósítások CQRS használati a [esemény forrás mintát][event-sourcing].</span><span class="sxs-lookup"><span data-stu-id="8e8d5-125">Some implementations of CQRS use the [Event Sourcing pattern][event-sourcing].</span></span> <span data-ttu-id="8e8d5-126">Ebben a mintában az alkalmazásállapot események sorozatát tárolja.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-126">With this pattern, application state is stored as a sequence of events.</span></span> <span data-ttu-id="8e8d5-127">Minden esemény módosítások készletét reprezentálja, az adatokhoz.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-127">Each event represents a set of changes to the data.</span></span> <span data-ttu-id="8e8d5-128">A jelenlegi állapota alapján az események visszajátszását összeállított.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-128">The current state is constructed by replaying the events.</span></span> <span data-ttu-id="8e8d5-129">CQRS környezetben, egy esemény forrásanyag előnye, hogy használható-e az azonos események értesíteni a többi összetevő &mdash; ebben az esetben, értesítse a olvasási modell.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-129">In a CQRS context, one benefit of Event Sourcing is that the same events can be used to notify other components &mdash; in particular, to notify the read model.</span></span> <span data-ttu-id="8e8d5-130">Az olvasási modellje a események készít pillanatképet az aktuális állapotát, amely a lekérdezések hatékonyabb.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-130">The read model uses the events to create a snapshot of the current state, which is more efficient for queries.</span></span> <span data-ttu-id="8e8d5-131">Azonban esemény forrás hozzáadása összetettsége a tervező.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-131">However, Event Sourcing adds complexity to the design.</span></span>

![](./images/cqrs-events.svg)

## <a name="when-to-use-this-architecture"></a><span data-ttu-id="8e8d5-132">Mikor érdemes használni, ez az architektúra</span><span class="sxs-lookup"><span data-stu-id="8e8d5-132">When to use this architecture</span></span>

<span data-ttu-id="8e8d5-133">Vegye figyelembe a CQRS sok érhetik el a ugyanazokat az adatokat, különösen akkor, ha az olvasási és írási munkaterhelések aszimmetrikus együttműködési tartományokhoz.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-133">Consider CQRS for collaborative domains where many users access the same data, especially when the read and write workloads are asymmetrical.</span></span>

<span data-ttu-id="8e8d5-134">CQRS nincs egy legfelső szintű architektúra, amely egy teljes rendszerre vonatkozik.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-134">CQRS is not a top-level architecture that applies to an entire system.</span></span> <span data-ttu-id="8e8d5-135">Csak a alrendszerrel CQRS érvényes Ha olvasási és írási elválasztó egyértelmű értéke van.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-135">Apply CQRS only to those subsystems where there is clear value in separating reads and writes.</span></span> <span data-ttu-id="8e8d5-136">Ellenkező esetben létrehozásakor nagyobb fokú összetettségével jár nem juttatásra.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-136">Otherwise, you are creating additional complexity for no benefit.</span></span>

## <a name="benefits"></a><span data-ttu-id="8e8d5-137">Előnyök</span><span class="sxs-lookup"><span data-stu-id="8e8d5-137">Benefits</span></span>

- <span data-ttu-id="8e8d5-138">**Egymástól függetlenül skálázás**.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-138">**Independently scaling**.</span></span> <span data-ttu-id="8e8d5-139">CQRS lehetővé teszi, hogy az Olvasás és munkaterhelések méretezését írás, és kevesebb zárolási contentions eredményezheti.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-139">CQRS allows the read and write workloads to scale independently, and may result in fewer lock contentions.</span></span>
- <span data-ttu-id="8e8d5-140">**Optimalizált adatok sémák.**</span><span class="sxs-lookup"><span data-stu-id="8e8d5-140">**Optimized data schemas.**</span></span>  <span data-ttu-id="8e8d5-141">Az olvasási oldalán optimalizált séma használható lekérdezéseket, miközben a írási oldalon frissítések optimalizált séma használja.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-141">The read side can use a schema that is optimized for queries, while the write side uses a schema that is optimized for updates.</span></span>  
- <span data-ttu-id="8e8d5-142">**Biztonság**.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-142">**Security**.</span></span> <span data-ttu-id="8e8d5-143">Célszerűbb győződjön meg arról, hogy csak a megfelelő tartományhoz entitások hajt végre írási műveleteket az adatokon.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-143">It's easier to ensure that only the right domain entities are performing writes on the data.</span></span>
- <span data-ttu-id="8e8d5-144">**Aggályokat elkülönítése**.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-144">**Separation of concerns**.</span></span> <span data-ttu-id="8e8d5-145">Az olvasási és írási oldalak elkülönítése modellek, amelyek több fenntarthatóvá és rugalmas eredményezhet.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-145">Segregating the read and write sides can result in models that are more maintainable and flexible.</span></span> <span data-ttu-id="8e8d5-146">A legtöbb bonyolult üzleti logikát a írási modell állapotba kerül.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-146">Most of the complex business logic goes into the write model.</span></span> <span data-ttu-id="8e8d5-147">Lehet, hogy az olvasási modell viszonylag egyszerű.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-147">The read model can be relatively simple.</span></span>
- <span data-ttu-id="8e8d5-148">**Egyszerűbb lekérdezések**.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-148">**Simpler queries**.</span></span> <span data-ttu-id="8e8d5-149">A materializált nézet tárolása olvasható adatbázis, az alkalmazás elkerülheti a bonyolult illesztésekre lekérdezésekor.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-149">By storing a materialized view in the read database, the application can avoid complex joins when querying.</span></span>

## <a name="challenges"></a><span data-ttu-id="8e8d5-150">Kihívásai</span><span class="sxs-lookup"><span data-stu-id="8e8d5-150">Challenges</span></span>

- <span data-ttu-id="8e8d5-151">**Összetettsége**.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-151">**Complexity**.</span></span> <span data-ttu-id="8e8d5-152">CQRS alapvető lényege egyszerű.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-152">The basic idea of CQRS is simple.</span></span> <span data-ttu-id="8e8d5-153">De azt is vezethet összetettebb alkalmazás tervét, különösen akkor, ha az esemény forrás mintát tartalmaznak.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-153">But it can lead to a more complex application design, especially if they include the Event Sourcing pattern.</span></span>

- <span data-ttu-id="8e8d5-154">**Üzenetküldési**.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-154">**Messaging**.</span></span> <span data-ttu-id="8e8d5-155">CQRS nem igényel üzenetküldési, bár általában üzenetküldési folyamat parancsok használata, és (update) események közzététele.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-155">Although CQRS does not require messaging, it's common to use messaging to process commands and publish update events.</span></span> <span data-ttu-id="8e8d5-156">Az alkalmazás ebben az esetben üzenet hibák vagy a duplikált üzenetek kell kezelni.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-156">In that case, the application must handle message failures or duplicate messages.</span></span> 

- <span data-ttu-id="8e8d5-157">**Végleges konzisztencia**.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-157">**Eventual consistency**.</span></span> <span data-ttu-id="8e8d5-158">Ha külön az olvasási és írási adatbázisok, előfordulhat, hogy az olvasható adatok elavult.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-158">If you separate the read and write databases, the read data may be stale.</span></span> 

## <a name="best-practices"></a><span data-ttu-id="8e8d5-159">Ajánlott eljárások</span><span class="sxs-lookup"><span data-stu-id="8e8d5-159">Best practices</span></span>

- <span data-ttu-id="8e8d5-160">CQRS kapcsolatos további információkért lásd: [CQRS mintát][cqrs-pattern].</span><span class="sxs-lookup"><span data-stu-id="8e8d5-160">For more information about implementing CQRS, see [CQRS Pattern][cqrs-pattern].</span></span>

- <span data-ttu-id="8e8d5-161">Érdemes lehet a [esemény forrás] [ event-sourcing] mintát frissítés ütközések elkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-161">Consider using the [Event Sourcing][event-sourcing] pattern to avoid update conflicts.</span></span>

- <span data-ttu-id="8e8d5-162">Érdemes lehet a [materializált nézet mintát] [ materialized-view] olvasási modell a séma lekérdezésekhez optimalizálja.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-162">Consider using the [Materialized View pattern][materialized-view] for the read model, to optimize the schema for queries.</span></span>

## <a name="cqrs-in-microservices"></a><span data-ttu-id="8e8d5-163">A mikroszolgáltatások CQRS</span><span class="sxs-lookup"><span data-stu-id="8e8d5-163">CQRS in microservices</span></span>

<span data-ttu-id="8e8d5-164">CQRS különösen hasznos lehet egy [mikroszolgáltatások architektúra][microservices].</span><span class="sxs-lookup"><span data-stu-id="8e8d5-164">CQRS can be especially useful in a [microservices architecture][microservices].</span></span> <span data-ttu-id="8e8d5-165">Mikroszolgáltatások alapelvei egyike, hogy a szolgáltatás nem tud közvetlenül elérni egy másik szolgáltatás adattár.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-165">One of the principles of microservices is that a service cannot directly access another service's data store.</span></span>

![](./images/cqrs-microservices-wrong.png)

<span data-ttu-id="8e8d5-166">Az alábbi diagram szemlélteti A szolgáltatás írja az adattárat, és szolgáltatás B tartja az adatok materializált nézet.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-166">In the following diagram, Service A writes to a data store, and Service B keeps a materialized view of the data.</span></span> <span data-ttu-id="8e8d5-167">A szolgáltatás egy eseményt, ha az adattár ír közzéteszi.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-167">Service A publishes an event whenever it writes to the data store.</span></span> <span data-ttu-id="8e8d5-168">B szolgáltatás számítógépcsoportra fizetett elő az eseményt.</span><span class="sxs-lookup"><span data-stu-id="8e8d5-168">Service B subscribes to the event.</span></span>

![](./images/cqrs-microservices-right.png)


<!-- links -->

[cqrs-pattern]: ../../patterns/cqrs.md
[event-sourcing]: ../../patterns/event-sourcing.md
[materialized-view]: ../../patterns/materialized-view.md
[microservices]: ./microservices.md
