---
title: CQRS architektúrastílus
titleSuffix: Azure Application Architecture Guide
description: Előnyeit, kihívásait és ajánlott eljárások a CQRS-architektúrák ismerteti.
author: MikeWasson
ms.date: 08/30/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: seojan19
ms.openlocfilehash: 35f37afa60f943f410f1fbd46c789c0b2c66e36e
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 03/20/2019
ms.locfileid: "58299252"
---
# <a name="cqrs-architecture-style"></a><span data-ttu-id="aeb7d-103">CQRS architektúrastílus</span><span class="sxs-lookup"><span data-stu-id="aeb7d-103">CQRS architecture style</span></span>

<span data-ttu-id="aeb7d-104">A Command and Query Responsibility Segregation (CQRS, azaz a parancskiadási és a lekérdezési felelősségek elkülönítése) egy olyan architektúrastílus, amely elkülöníti az olvasási műveleteket az írási műveletektől.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-104">Command and Query Responsibility Segregation (CQRS) is an architecture style that separates read operations from write operations.</span></span>

![A CQRS architektúrastílus logikai diagramja](./images/cqrs-logical.svg)

<span data-ttu-id="aeb7d-106">A hagyományos architektúrák esetében ugyanaz az adatmodell használatos az adatbázisok lekérdezésére és frissítésére.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-106">In traditional architectures, the same data model is used to query and update a database.</span></span> <span data-ttu-id="aeb7d-107">Ez egyszerű és jól működik, ha alapszintű CRUD-műveletekről van szó.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-107">That's simple and works well for basic CRUD operations.</span></span> <span data-ttu-id="aeb7d-108">Összetettebb alkalmazások esetében azonban ez a megközelítés nehézkessé válhat.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-108">In more complex applications, however, this approach can become unwieldy.</span></span> <span data-ttu-id="aeb7d-109">Például az olvasási oldalon az alkalmazás számos különböző lekérdezést végezhet, amelyek különböző típusú adatátviteli objektumokat (DTO-kat) adnak vissza.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-109">For example, on the read side, the application may perform many different queries, returning data transfer objects (DTOs) with different shapes.</span></span> <span data-ttu-id="aeb7d-110">Az objektumok leképezése igen bonyolulttá válthat.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-110">Object mapping can become complicated.</span></span> <span data-ttu-id="aeb7d-111">A írási oldalon a modell összetett érvényesítési és üzleti logikát valósíthat meg.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-111">On the write side, the model may implement complex validation and business logic.</span></span> <span data-ttu-id="aeb7d-112">Ennek eredményeképpen egy túlzottan összetett, túl sok feladatot végző modell jöhet létre.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-112">As a result, you can end up with an overly complex model that does too much.</span></span>

<span data-ttu-id="aeb7d-113">Egy másik lehetséges probléma, hogy az olvasási és írási számítási feladatok gyakran aszimmetrikusak, amelyek teljesítménybeli és méretezhetőségi igényei nagyban eltérhetnek egymástól.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-113">Another potential problem is that read and write workloads are often asymmetrical, with very different performance and scale requirements.</span></span>

<span data-ttu-id="aeb7d-114">A CQRS ezeket a problémákat úgy oldja meg, hogy az olvasást és az írást önálló modellekbe különíti: az adatok frissítéséhez **parancsokat**, az olvasásukhoz pedig **lekérdezéseket** használ.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-114">CQRS addresses these problems by separating reads and writes into separate models, using **commands** to update data, and **queries** to read data.</span></span>

- <span data-ttu-id="aeb7d-115">A parancsoknak feladatalapúnak kell lenniük ahelyett, hogy adatközpontúak lennének.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-115">Commands should be task based, rather than data centric.</span></span> <span data-ttu-id="aeb7d-116">(Például „Book hotel room” a „set ReservationStatus to Reserved” helyett.) A parancsok a szinkron feldolgozás helyett egy aszinkron feldolgozási sorba kerülnek.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-116">("Book hotel room," not "set ReservationStatus to Reserved.") Commands may be placed on a queue for asynchronous processing, rather than being processed synchronously.</span></span>

- <span data-ttu-id="aeb7d-117">A lekérdezések soha nem módosítják az adatbázist.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-117">Queries never modify the database.</span></span> <span data-ttu-id="aeb7d-118">A lekérdezés egy olyan DTO-t ad vissza, amely nem tartalmaz a környezettel kapcsolatos ismerteket.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-118">A query returns a DTO that does not encapsulate any domain knowledge.</span></span>

<span data-ttu-id="aeb7d-119">A nagyobb mértékű elkülönítés érdekében fizikailag is elkülönítheti az olvasási és az írási adatokat.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-119">For greater isolation, you can physically separate the read data from the write data.</span></span> <span data-ttu-id="aeb7d-120">Ebben az esetben az olvasási adatbázis használhatja a saját, lekérdezésekhez optimalizált adatsémáját.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-120">In that case, the read database can use its own data schema that is optimized for queries.</span></span> <span data-ttu-id="aeb7d-121">Például tárolhatja az adatok [materializált nézetét][materialized-view], a bonyolult illesztések vagy O/RM-leképezések elkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-121">For example, it can store a [materialized view][materialized-view] of the data, in order to avoid complex joins or complex O/RM mappings.</span></span> <span data-ttu-id="aeb7d-122">Sőt, akár eltérő típusú adattárat is használhat.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-122">It might even use a different type of data store.</span></span> <span data-ttu-id="aeb7d-123">Például az írási adatbázis lehet relációs, míg az olvasási adatbázis lehet egy dokumentum-adatbázis.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-123">For example, the write database might be relational, while the read database is a document database.</span></span>

<span data-ttu-id="aeb7d-124">Különálló olvasási és írási adatbázisok használata esetén az adatbázisokat szinkronban kell tartani. Általában ez történik úgy, hogy az írási modell egy eseményt, az adatbázis frissítésekor közzé.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-124">If separate read and write databases are used, they must be kept in sync. Typically this is accomplished by having the write model publish an event whenever it updates the database.</span></span> <span data-ttu-id="aeb7d-125">Az adatbázis frissítésének és az esemény közzétételének egy tranzakción belül kell megtörténnie.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-125">Updating the database and publishing the event must occur in a single transaction.</span></span>

<span data-ttu-id="aeb7d-126">Egyes CQRS-megvalósítások az [Event Sourcing mintát][event-sourcing] használják.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-126">Some implementations of CQRS use the [Event Sourcing pattern][event-sourcing].</span></span> <span data-ttu-id="aeb7d-127">Ebben a mintában az alkalmazásállapot események sorozataként tárolódik.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-127">With this pattern, application state is stored as a sequence of events.</span></span> <span data-ttu-id="aeb7d-128">Az egyes események az adatok módosításainak egy halmazát jelölik.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-128">Each event represents a set of changes to the data.</span></span> <span data-ttu-id="aeb7d-129">A jelenlegi állapot az események visszajátszása alapján áll össze.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-129">The current state is constructed by replaying the events.</span></span> <span data-ttu-id="aeb7d-130">Egy CQRS-környezetben az Event Sourcing egyik előnye, hogy ugyanazok az események használhatók a többi összetevő, jelen esetben az olvasási modell értesítéséhez.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-130">In a CQRS context, one benefit of Event Sourcing is that the same events can be used to notify other components &mdash; in particular, to notify the read model.</span></span> <span data-ttu-id="aeb7d-131">Az olvasási modell az események használatával pillanatképet készít az aktuális állapotról, ami a lekérdezések esetében hatékonyabb megoldásnak bizonyul.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-131">The read model uses the events to create a snapshot of the current state, which is more efficient for queries.</span></span> <span data-ttu-id="aeb7d-132">Az Event Sourcing azonban bonyolultabbá teszi a kialakítást.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-132">However, Event Sourcing adds complexity to the design.</span></span>

![A CQRS-események](./images/cqrs-events.svg)

## <a name="when-to-use-this-architecture"></a><span data-ttu-id="aeb7d-134">Mikor érdemes ezt az architektúrát használni?</span><span class="sxs-lookup"><span data-stu-id="aeb7d-134">When to use this architecture</span></span>

<span data-ttu-id="aeb7d-135">A CQRST olyan együttműködési tartományok esetében érdemes használni, ahol több felhasználó dolgozik ugyanazokkal az adatokkal, különösen, ha az olvasási és írási számítási feladatok aszimmetrikusak.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-135">Consider CQRS for collaborative domains where many users access the same data, especially when the read and write workloads are asymmetrical.</span></span>

<span data-ttu-id="aeb7d-136">A CQRS nem legfelső szintű architektúra, amely a teljes rendszerre vonatkozik.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-136">CQRS is not a top-level architecture that applies to an entire system.</span></span> <span data-ttu-id="aeb7d-137">A CQRST-t csak azokra az alrendszerekre alkalmazza, ahol az olvasás és az írás különválasztása egyértelműen megéri.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-137">Apply CQRS only to those subsystems where there is clear value in separating reads and writes.</span></span> <span data-ttu-id="aeb7d-138">Különben csak nagyobb fokú összetettséget hoz létre, különösebb előny nélkül.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-138">Otherwise, you are creating additional complexity for no benefit.</span></span>

## <a name="benefits"></a><span data-ttu-id="aeb7d-139">Előnyök</span><span class="sxs-lookup"><span data-stu-id="aeb7d-139">Benefits</span></span>

- <span data-ttu-id="aeb7d-140">**Függetlenül méretezhető**.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-140">**Independently scaling**.</span></span> <span data-ttu-id="aeb7d-141">A CQRS lehetővé teszi az olvasási és írási számítási feladatok egymástól független méretezését, ezáltal kevesebb zárolási versenyt eredményezhet.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-141">CQRS allows the read and write workloads to scale independently, and may result in fewer lock contentions.</span></span>
- <span data-ttu-id="aeb7d-142">**Optimalizált adatsémák**.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-142">**Optimized data schemas**.</span></span> <span data-ttu-id="aeb7d-143">Az olvasási oldal lekérdezésekre optimalizált sémát, az írási oldal pedig frissítésekhez optimalizált sémát használhat.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-143">The read side can use a schema that is optimized for queries, while the write side uses a schema that is optimized for updates.</span></span>
- <span data-ttu-id="aeb7d-144">**Biztonság**.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-144">**Security**.</span></span> <span data-ttu-id="aeb7d-145">Egyszerűbb meggyőződni arról, hogy csak a megfelelő tartományi entitások végeznek írást az adatokon.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-145">It's easier to ensure that only the right domain entities are performing writes on the data.</span></span>
- <span data-ttu-id="aeb7d-146">**Kockázatok elkülönítése**.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-146">**Separation of concerns**.</span></span> <span data-ttu-id="aeb7d-147">Az olvasási és írási oldalak elkülönítésével könnyebben fenntartható és rugalmas modellek hozhatók létre.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-147">Segregating the read and write sides can result in models that are more maintainable and flexible.</span></span> <span data-ttu-id="aeb7d-148">A bonyolult üzleti logika legnagyobb része az írási modellbe kerül.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-148">Most of the complex business logic goes into the write model.</span></span> <span data-ttu-id="aeb7d-149">Az olvasási modell lehet viszonylag egyszerű.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-149">The read model can be relatively simple.</span></span>
- <span data-ttu-id="aeb7d-150">**Egyszerűbb lekérdezések**.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-150">**Simpler queries**.</span></span> <span data-ttu-id="aeb7d-151">A materializált nézet olvasási adatbázisban való tárolásával elkerülhető, hogy az alkalmazásnak bonyolult illesztésekre legyen szüksége a lekérdezések során.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-151">By storing a materialized view in the read database, the application can avoid complex joins when querying.</span></span>

## <a name="challenges"></a><span data-ttu-id="aeb7d-152">Problémák</span><span class="sxs-lookup"><span data-stu-id="aeb7d-152">Challenges</span></span>

- <span data-ttu-id="aeb7d-153">**Összetettség**.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-153">**Complexity**.</span></span> <span data-ttu-id="aeb7d-154">A CQRS alapvető működése egyszerű.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-154">The basic idea of CQRS is simple.</span></span> <span data-ttu-id="aeb7d-155">Viszont bonyolultabbá teheti az alkalmazások kialakítását, különösen akkor, ha az Event Sourcing mintát is tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-155">But it can lead to a more complex application design, especially if they include the Event Sourcing pattern.</span></span>

- <span data-ttu-id="aeb7d-156">**Üzenetkezelés**.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-156">**Messaging**.</span></span> <span data-ttu-id="aeb7d-157">Bár a CQRS használatához nincs szükség üzenetkezelésre, az üzenetkezelési szolgáltatást gyakorta használják a parancsok feldolgozására és a frissítési események közzétételére.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-157">Although CQRS does not require messaging, it's common to use messaging to process commands and publish update events.</span></span> <span data-ttu-id="aeb7d-158">Ebben az esetben az alkalmazásnak kezelnie kell az üzenethibákat és az ismétlődő üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-158">In that case, the application must handle message failures or duplicate messages.</span></span>

- <span data-ttu-id="aeb7d-159">**Végleges konzisztencia**.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-159">**Eventual consistency**.</span></span> <span data-ttu-id="aeb7d-160">Ha elkülöníti az olvasási és írási adatbázisokat, az olvasási adatok elavulttá válhatnak.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-160">If you separate the read and write databases, the read data may be stale.</span></span>

## <a name="best-practices"></a><span data-ttu-id="aeb7d-161">Ajánlott eljárások</span><span class="sxs-lookup"><span data-stu-id="aeb7d-161">Best practices</span></span>

- <span data-ttu-id="aeb7d-162">A CQRS megvalósításával kapcsolatos további információkért tekintse meg a [CQRS minta][cqrs-pattern].</span><span class="sxs-lookup"><span data-stu-id="aeb7d-162">For more information about implementing CQRS, see the [CQRS pattern][cqrs-pattern].</span></span>

- <span data-ttu-id="aeb7d-163">A frissítések ütközésének elkerülése érdekében fontolja meg az [Event Sourcing][event-sourcing] minta használatát.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-163">Consider using the [Event Sourcing][event-sourcing] pattern to avoid update conflicts.</span></span>

- <span data-ttu-id="aeb7d-164">Az olvasási modell esetében fontolja meg a [Materialized View minta][materialized-view] használatát a séma a lekérdezésekhez való optimalizálása érdekében.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-164">Consider using the [Materialized View pattern][materialized-view] for the read model, to optimize the schema for queries.</span></span>

## <a name="cqrs-in-microservices"></a><span data-ttu-id="aeb7d-165">CQRS használata a mikroszolgáltatásokban</span><span class="sxs-lookup"><span data-stu-id="aeb7d-165">CQRS in microservices</span></span>

<span data-ttu-id="aeb7d-166">A CQRS különösen hasznos lehet [mikroszolgáltatásokra épülő architektúrák esetében][microservices].</span><span class="sxs-lookup"><span data-stu-id="aeb7d-166">CQRS can be especially useful in a [microservices architecture][microservices].</span></span> <span data-ttu-id="aeb7d-167">A mikroszolgáltatások egyik alapelve, hogy a szolgáltatások nem érhetik el közvetlenül egy másik szolgáltatás adattárát.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-167">One of the principles of microservices is that a service cannot directly access another service's data store.</span></span>

![Egy helytelen mikroszolgáltatási megközelítést bemutató ábra](./images/cqrs-microservices-wrong.png)

<span data-ttu-id="aeb7d-169">Az alábbi diagramon az A szolgáltatás egy adattárba ír, a B szolgáltatás pedig megőrzi az adatok materializált nézetét.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-169">In the following diagram, Service A writes to a data store, and Service B keeps a materialized view of the data.</span></span> <span data-ttu-id="aeb7d-170">Az A szolgáltatás közzétesz egy eseményt, valahányszor az adattárba ír.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-170">Service A publishes an event whenever it writes to the data store.</span></span> <span data-ttu-id="aeb7d-171">A B szolgáltatás feliratkozik az eseményre.</span><span class="sxs-lookup"><span data-stu-id="aeb7d-171">Service B subscribes to the event.</span></span>

![A mikroszolgáltatások a megfelelő megközelítést bemutató ábra](./images/cqrs-microservices-right.png)

<!-- links -->

[cqrs-pattern]: ../../patterns/cqrs.md
[event-sourcing]: ../../patterns/event-sourcing.md
[materialized-view]: ../../patterns/materialized-view.md
[microservices]: ./microservices.md
