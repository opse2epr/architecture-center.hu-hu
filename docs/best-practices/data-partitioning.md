---
title: Adatparticionálási útmutató
description: Útmutató a partíciók megfelelő elkülönítéséhez a független felügyelet és hozzáférés érdekében.
author: dragon119
ms.date: 07/13/2016
pnp.series.title: Best Practices
ms.openlocfilehash: 579f78004a662fe412cb8dcc25b9ad1db9782125
ms.sourcegitcommit: 94d50043db63416c4d00cebe927a0c88f78c3219
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 09/28/2018
ms.locfileid: "47429502"
---
# <a name="data-partitioning"></a><span data-ttu-id="6ddd2-103">Adatparticionálás</span><span class="sxs-lookup"><span data-stu-id="6ddd2-103">Data partitioning</span></span>

<span data-ttu-id="6ddd2-104">Számos nagyobb léptékű megoldásban az adatok egymástól függetlenül felügyelhető és elérhető partíciókba osztva tárolhatók.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-104">In many large-scale solutions, data is divided into separate partitions that can be managed and accessed separately.</span></span> <span data-ttu-id="6ddd2-105">A particionálási stratégiát gondosan kell megválasztani az előnyök maximalizálása és a negatív hatások minimalizálása érdekében.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-105">The partitioning strategy must be chosen carefully to maximize the benefits while minimizing adverse effects.</span></span> <span data-ttu-id="6ddd2-106">A particionálás segíthet javítani a skálázhatóságot, csökkenteni a versengést és optimalizálni a teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-106">Partitioning can help improve scalability, reduce contention, and optimize performance.</span></span> <span data-ttu-id="6ddd2-107">A particionálás egy másik előnye, hogy egy olyan mechanizmust kínál, amellyel az adatok a használati minták mentén oszthatóak fel.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-107">Another benefit of partitioning is that it can provide a mechanism for dividing data by the pattern of use.</span></span> <span data-ttu-id="6ddd2-108">Például a régebbi, kevésbé aktív (hideg) adatok olcsóbb adattárolókban archiválhatóak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-108">For example, you can archive older, less active (cold) data in cheaper data storage.</span></span>

## <a name="why-partition-data"></a><span data-ttu-id="6ddd2-109">Miért kell particionálni az adatokat?</span><span class="sxs-lookup"><span data-stu-id="6ddd2-109">Why partition data?</span></span>
<span data-ttu-id="6ddd2-110">A legtöbb felhőalapú alkalmazás és szolgáltatás a működése során adatokat tárol és kér le.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-110">Most cloud applications and services store and retrieve data as part of their operations.</span></span> <span data-ttu-id="6ddd2-111">Az alkalmazás által használt adattároló kialakítása jelentős hatással lehet a rendszer teljesítményére, feldolgozási sebességére és skálázhatóságára.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-111">The design of the data stores that an application uses can have a significant bearing on the performance, throughput, and scalability of a system.</span></span> <span data-ttu-id="6ddd2-112">A nagy rendszerekben gyakran alkalmazott módszerek egyike az adatok külön partíciókra való felosztása.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-112">One technique that is commonly applied in large-scale systems is to divide the data into separate partitions.</span></span>

> <span data-ttu-id="6ddd2-113">Ebben a cikkben a *particionálás* kifejezés alatt az adatok külön adattárakba való fizikai felosztásának folyamatát értjük.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-113">In this article, the term *partitioning* means the process of physically dividing data into separate data stores.</span></span> <span data-ttu-id="6ddd2-114">Ez nem ugyanaz, mint az SQL Server táblaparticionálása.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-114">It is not the same as SQL Server table partitioning.</span></span>

<span data-ttu-id="6ddd2-115">Az adatok particionálása számos előnyt kínál.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-115">Partitioning data can offer a number of benefits.</span></span> <span data-ttu-id="6ddd2-116">Például a következők érdekében alkalmazható:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-116">For example, it can be applied in order to:</span></span>

* <span data-ttu-id="6ddd2-117">**A skálázhatóság javítása**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-117">**Improve scalability**.</span></span> <span data-ttu-id="6ddd2-118">Az önálló adatbázisrendszerek vertikális felskálázásakor a rendszer végül eléri a fizikai hardver korlátait.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-118">When you scale up a single database system, it will eventually reach a physical hardware limit.</span></span> <span data-ttu-id="6ddd2-119">Ha az adatokat több partícióra osztjuk, amelyek mindegyike külön kiszolgálón üzemel, a rendszer horizontálisan szinte végtelenül felskálázható.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-119">If you divide data across multiple partitions, each of which is hosted on a separate server, you can scale out the system almost indefinitely.</span></span>
* <span data-ttu-id="6ddd2-120">**A teljesítmény javítása**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-120">**Improve performance**.</span></span> <span data-ttu-id="6ddd2-121">Az egyes partíciókon az adatelérési műveletek kisebb mennyiségű adatot érintenek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-121">Data access operations on each partition take place over a smaller volume of data.</span></span> <span data-ttu-id="6ddd2-122">Amennyiben az adatok megfelelő módon vannak particionálva, a particionálás révén növelhető a rendszer hatékonysága.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-122">Provided that the data is partitioned in a suitable way, partitioning can make your system more efficient.</span></span> <span data-ttu-id="6ddd2-123">Az egyszerre több partíciót érintő műveletek párhuzamosan futtathatóak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-123">Operations that affect more than one partition can run in parallel.</span></span> <span data-ttu-id="6ddd2-124">Az egyes partíciók az azokat használó alkalmazások közelében helyezhetőek el, így minimalizálható a hálózati késés.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-124">Each partition can be located near the application that uses it to minimize network latency.</span></span>
* <span data-ttu-id="6ddd2-125">**A rendelkezésre állás javítása**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-125">**Improve availability**.</span></span> <span data-ttu-id="6ddd2-126">Az adatok több kiszolgálóra való leosztásával kiküszöbölhető az egypontos meghibásodás kockázata.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-126">Separating data across multiple servers avoids a single point of failure.</span></span> <span data-ttu-id="6ddd2-127">Ha valamely kiszolgáló működése leáll vagy tervezett karbantartás történik, csak az adott partíció adatai válnak elérhetetlenné.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-127">If a server fails, or is undergoing planned maintenance, only the data in that partition is unavailable.</span></span> <span data-ttu-id="6ddd2-128">A többi partíción folytatódhatnak a műveletek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-128">Operations on other partitions can continue.</span></span> <span data-ttu-id="6ddd2-129">A partíciók számának növelésével csökkenthető az egyes kieső kiszolgálók relatív hatása, mivel arányaiban kevesebb adat válik elérhetetlenné.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-129">Increasing the number of partitions reduces the relative impact of a single server failure by reducing the percentage of data that will be unavailable.</span></span> <span data-ttu-id="6ddd2-130">Az egyes partíciók replikálásával tovább csökkenthető az esélye, hogy egyetlen partíció kiesése kihatna a működésre.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-130">Replicating each partition can further reduce the chance of a single partition failure affecting operations.</span></span> <span data-ttu-id="6ddd2-131">Emellett lehetővé teszi a folyamatos magas rendelkezésre állást igénylő kritikus adatok elkülönítését az alacsonyabb rendelkezésre állási követelményekkel rendelkező értéktelenebb adatoktól (amilyenek például a naplófájlok).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-131">It also makes it possible to separate critical data that must be continually and highly available from low-value data that has lower availability requirements (log files, for example).</span></span>
* <span data-ttu-id="6ddd2-132">**A biztonság javítása**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-132">**Improve security**.</span></span> <span data-ttu-id="6ddd2-133">Az adatok természetétől és particionálásának módjától függően a bizalmas és a nem bizalmas adatok esetleg külön partíciókba, és ezáltal külön kiszolgálókra vagy adattárakba helyezhetőek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-133">Depending on the nature of the data and how it is partitioned, it might be possible to separate sensitive and non-sensitive data into different partitions, and therefore into different servers or data stores.</span></span> <span data-ttu-id="6ddd2-134">A biztonságot ezután hatékonyabban lehet kifejezetten a bizalmas adatokra optimalizálni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-134">Security can then be specifically optimized for the sensitive data.</span></span>
* <span data-ttu-id="6ddd2-135">**A működési rugalmasság megteremtése**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-135">**Provide operational flexibility**.</span></span> <span data-ttu-id="6ddd2-136">A particionálás rengeteg lehetőséget kínál a működés finomhangolására, a felügyelet hatékonyságának maximalizálására és a költségek minimalizálására.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-136">Partitioning offers many opportunities for fine tuning operations, maximizing administrative efficiency, and minimizing cost.</span></span> <span data-ttu-id="6ddd2-137">Például különböző stratégiák határozhatók meg a felügyelethez, a monitorozáshoz, a biztonsági mentéshez és helyreállításhoz, valamint egyéb felügyeleti tevékenységekhez az egyes partíciók adatainak fontossága alapján.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-137">For example, you can define different strategies for management, monitoring, backup and restore, and other administrative tasks based on the importance of the data in each partition.</span></span>
* <span data-ttu-id="6ddd2-138">**A használati mintának megfelelő adattárak használata**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-138">**Match the data store to the pattern of use**.</span></span> <span data-ttu-id="6ddd2-139">A particionálás révén az egyes partíciók különböző típusú adattárakban futtathatóak az ilyen adattárak költségei és beépített szolgáltatásai alapján.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-139">Partitioning allows each partition to be deployed on a different type of data store, based on cost and the built-in features that data store offers.</span></span> <span data-ttu-id="6ddd2-140">Például a nagy mennyiségű bináris adatot blobtárolókban, míg a strukturáltabb adatot dokumentum-adatbázisokban tárolhatja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-140">For example, large binary data can be stored in a blob data store, while more structured data can be held in a document database.</span></span> <span data-ttu-id="6ddd2-141">További információkért lásd a minta- és gyakorlati útmutató [Többnyelvű megoldások létrehozása] foglalkozó szakaszát, valamint a Microsoft webhelyén a [Adathozzáférés nagymértékben skálázható megoldások esetén: az SQL, NoSQL és többnyelvű adatmegőrzés használata] bemutató cikket.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-141">For more information, see [Building a polyglot solution] in the patterns & practices guide and [Data access for highly-scalable solutions: Using SQL, NoSQL, and polyglot persistence] on the Microsoft website.</span></span>

<span data-ttu-id="6ddd2-142">Egyes rendszerek nem valósítják meg a particionálást, mivel inkább költségnek, mint előnynek tekintik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-142">Some systems do not implement partitioning because it is considered a cost rather than an advantage.</span></span> <span data-ttu-id="6ddd2-143">Az ilyen gondolkodásnak általában a következők az okai:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-143">Common reasons for this rationale include:</span></span>

* <span data-ttu-id="6ddd2-144">Számos adattároló rendszer nem támogatja a partíciók közti összekapcsolásokat, és esetenként a hivatkozások integritásának fenntartása is nehézkes lehet egy particionált rendszerben.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-144">Many data storage systems do not support joins across partitions, and it can be difficult to maintain referential integrity in a partitioned system.</span></span> <span data-ttu-id="6ddd2-145">Gyakran az összekapcsolásokat és az integritás-ellenőrzést az alkalmazáskódban (a particionálási rétegben) kell megvalósítani, ami növelheti az I/O-terhelést és alkalmazás összetettségét.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-145">It is frequently necessary to implement joins and integrity checks in application code (in the partitioning layer), which can result in additional I/O and application complexity.</span></span>
* <span data-ttu-id="6ddd2-146">A partíciók karbantartása néha nem triviális feladat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-146">Maintaining partitions is not always a trivial task.</span></span> <span data-ttu-id="6ddd2-147">Az ideiglenes adatokat tartalmazó rendszerekben időnként újra ki kell egyensúlyozni a partíciókat a versengés és a kritikus pontok elkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-147">In a system where the data is volatile, you might need to rebalance partitions periodically to reduce contention and hot spots.</span></span>
* <span data-ttu-id="6ddd2-148">Némely általános eszköz nem működik természetesen a particionált adatokkal.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-148">Some common tools do not work naturally with partitioned data.</span></span>

## <a name="designing-partitions"></a><span data-ttu-id="6ddd2-149">Partíciók tervezése</span><span class="sxs-lookup"><span data-stu-id="6ddd2-149">Designing partitions</span></span>
<span data-ttu-id="6ddd2-150">Az adatok különböző módokon particionálhatóak: vízszintesen, függőlegesen vagy funkcionálisan.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-150">Data can be partitioned in different ways: horizontally, vertically, or functionally.</span></span> <span data-ttu-id="6ddd2-151">A választott stratégia az adatok particionálásának okaitól, valamint az adatokat használó alkalmazások és szolgáltatások követelményeitől függ.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-151">The strategy you choose depends on the reason for partitioning the data, and the requirements of the applications and services that will use the data.</span></span>

> [!NOTE]
> <span data-ttu-id="6ddd2-152">Az ebben az útmutatóban leírt particionálási sémákat a mögöttes adattárolási módszerektől független módon mutatjuk be.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-152">The partitioning schemes described in this guidance are explained in a way that is independent of the underlying data storage technology.</span></span> <span data-ttu-id="6ddd2-153">A sémák számos különböző típusú adattárra alkalmazhatóak, beleértve a relációs és NoSQL-adatbázisokat is.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-153">They can be applied to many types of data stores, including relational and NoSQL databases.</span></span>
>
>

### <a name="partitioning-strategies"></a><span data-ttu-id="6ddd2-154">Particionálási stratégiák</span><span class="sxs-lookup"><span data-stu-id="6ddd2-154">Partitioning strategies</span></span>
<span data-ttu-id="6ddd2-155">A három tipikus adatparticionálási stratégia:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-155">The three typical strategies for partitioning data are:</span></span>

* <span data-ttu-id="6ddd2-156">**Horizontális particionálás** (vagy más néven *horizontális skálázás*).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-156">**Horizontal partitioning** (often called *sharding*).</span></span> <span data-ttu-id="6ddd2-157">Ebben a stratégiában mindegyik partíció egy önálló, teljes jogú adattár, de mindegyik partíció ugyanazzal a sémával rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-157">In this strategy, each partition is a data store in its own right, but all partitions have the same schema.</span></span> <span data-ttu-id="6ddd2-158">Az egyes partíciókat *szegmensnek* nevezik, és az adatok egy-egy alhalmazát tárolják, például egy e-kereskedelmi alkalmazásban az ügyfelek adott halmazának megrendeléseit.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-158">Each partition is known as a *shard* and holds a specific subset of the data, such as all the orders for a specific set of customers in an e-commerce application.</span></span>
* <span data-ttu-id="6ddd2-159">**Vertikális particionálás**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-159">**Vertical partitioning**.</span></span> <span data-ttu-id="6ddd2-160">Ebben a stratégiában mindegyik partíció az adattárban tárolt elemek mezőinek egy alhalmazát tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-160">In this strategy, each partition holds a subset of the fields for items in the data store.</span></span> <span data-ttu-id="6ddd2-161">A mezők a használati mintáik alapján vannak felosztva.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-161">The fields are divided according to their pattern of use.</span></span> <span data-ttu-id="6ddd2-162">Például a gyakran használt mezők az egyik, a kevésbé gyakran használtak egy másik partícióba kerülhetnek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-162">For example, frequently accessed fields might be placed in one vertical partition and less frequently accessed fields in another.</span></span>
* <span data-ttu-id="6ddd2-163">**Funkcionális particionálás**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-163">**Functional partitioning**.</span></span> <span data-ttu-id="6ddd2-164">Ebben a stratégiában az adatok összesítése az alapján történik, hogy a rendszer egyes körülhatárolt kontextusai hogyan használják őket.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-164">In this strategy, data is aggregated according to how it is used by each bounded context in the system.</span></span> <span data-ttu-id="6ddd2-165">Egy, a számlázáshoz és a készletkezeléshez külön üzleti funkciókat megvalósító e-kereskedelmi rendszer az egyik partícióban tárolhatja például a számlázási adatokat, egy másikban pedig a készlettel kapcsolatos adatokat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-165">For example, an e-commerce system that implements separate business functions for invoicing and managing product inventory might store invoice data in one partition and product inventory data in another.</span></span>

<span data-ttu-id="6ddd2-166">Fontos megjegyezni, hogy a fenti három stratégia kombinálható is.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-166">It’s important to note that the three strategies described here can be combined.</span></span> <span data-ttu-id="6ddd2-167">Az egyik használata nem zárja ki a többit, ezért a particionálási séma kialakításakor érdemes mindhármat számításba venni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-167">They are not mutually exclusive, and we recommend that you consider them all when you design a partitioning scheme.</span></span> <span data-ttu-id="6ddd2-168">Például az adatokat először feloszthatja szegmensekre, majd az egyes szegmensekben lévő adatokat vertikálisan tovább particionálhatja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-168">For example, you might divide data into shards and then use vertical partitioning to further subdivide the data in each shard.</span></span> <span data-ttu-id="6ddd2-169">Ugyanígy egy funkcionális partícióban lévő adatok is szegmensekre bonthatók (majd ezek akár vertikálisan tovább particionálhatóak).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-169">Similarly, the data in a functional partition can be split into shards (which can also be vertically partitioned).</span></span>

<span data-ttu-id="6ddd2-170">Az egyes stratégiák eltérő követelményei azonban ütközéseket okozhatnak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-170">However, the differing requirements of each strategy can raise a number of conflicting issues.</span></span> <span data-ttu-id="6ddd2-171">A rendszer átfogó adatfeldolgozási teljesítménycéljait kiszolgáló particionálási séma kidolgozásához ezeket mindenképp ki kell értékelnie és egyensúlyba kell hoznia.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-171">You must evaluate and balance all of these when designing a partitioning scheme that meets the overall data processing performance targets for your system.</span></span> <span data-ttu-id="6ddd2-172">Az alábbi szakaszokban az egyes stratégiákat mutatjuk be részletesebben.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-172">The following sections explore each of the strategies in more detail.</span></span>

### <a name="horizontal-partitioning-sharding"></a><span data-ttu-id="6ddd2-173">Horizontális particionálás</span><span class="sxs-lookup"><span data-stu-id="6ddd2-173">Horizontal partitioning (sharding)</span></span>
<span data-ttu-id="6ddd2-174">Az 1. ábrán a horizontális particionálás áttekintése látható.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-174">Figure 1 shows an overview of horizontal partitioning or sharding.</span></span> <span data-ttu-id="6ddd2-175">Ebben a példában a készletadatok termékkulcs alapján vannak szegmensekre bontva.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-175">In this example, product inventory data is divided into shards based on the product key.</span></span> <span data-ttu-id="6ddd2-176">Minden egyes szegmens a szegmenskulcsok betűrend szerint egybefüggő tartományát (A–G és H–Z) tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-176">Each shard holds the data for a contiguous range of shard keys (A-G and H-Z), organized alphabetically.</span></span>

![Adatok horizontális particionálása partíciókulcs alapján](./images/data-partitioning/DataPartitioning01.png)

<span data-ttu-id="6ddd2-178">*1. ábra Adatok horizontális particionálása partíciókulcs alapján*</span><span class="sxs-lookup"><span data-stu-id="6ddd2-178">*Figure 1. Horizontally partitioning (sharding) data based on a partition key*</span></span>

<span data-ttu-id="6ddd2-179">A horizontális particionálás segítségével több számítógépre oszthatja le a terhelést, ami csökkenti a versengést és javítja a teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-179">Sharding helps you spread the load over more computers, which reduces contention and improves performance.</span></span> <span data-ttu-id="6ddd2-180">A rendszer más kiszolgálókon futó további szegmensek hozzáadásával horizontálisan felskálázható.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-180">You can scale the system out by adding further shards that run on additional servers.</span></span>

<span data-ttu-id="6ddd2-181">Ennek a particionálási stratégiának az alkalmazásakor a legfontosabb tényező a szegmenskulcs megfelelő megválasztása.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-181">The most important factor when implementing this partitioning strategy is the choice of sharding key.</span></span> <span data-ttu-id="6ddd2-182">A rendszer beüzemelését követően a kulcs nehezen módosítható.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-182">It can be difficult to change the key after the system is in operation.</span></span> <span data-ttu-id="6ddd2-183">A kulcsnak biztosítania kell, hogy az adatok particionálása olyan legyen, hogy a terhelés a lehető legegyenletesebb oszoljon meg a szegmensek között.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-183">The key must ensure that data is partitioned so that the workload is as even as possible across the shards.</span></span>

<span data-ttu-id="6ddd2-184">Az egyes szegmenseknek nem kell hasonló adatmennyiséget tartalmaznia.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-184">Note that different shards do not have to contain similar volumes of data.</span></span> <span data-ttu-id="6ddd2-185">Sokkal fontosabb a kérelmek számát egyensúlyba hozni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-185">Rather, the more important consideration is to balance the number of requests.</span></span> <span data-ttu-id="6ddd2-186">Előfordulhat, hogy egyes szegmensek nagy méretűek, de az egyes elemeikre csak kevés adatelérési művelet irányul.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-186">Some shards might be very large, but each item is the subject of a low number of access operations.</span></span> <span data-ttu-id="6ddd2-187">Más szegmensek esetleg kisebbek ugyan, de az egyes elemeket többször érik el.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-187">Other shards might be smaller, but each item is accessed much more frequently.</span></span> <span data-ttu-id="6ddd2-188">Fontos arról is gondoskodni, hogy az egyes szegmensek ne lépjék túl az adott szegmenst futtató adattár skálázási korlátait (kapacitás és feldolgozási erőforrások tekintetében).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-188">It is also important to ensure that a single shard does not exceed the scale limits (in terms of capacity and processing resources) of the data store that's being used to host that shard.</span></span>

<span data-ttu-id="6ddd2-189">Amennyiben horizontális particionálási sémát alkalmaz, kerülje a kritikus pontok (vagy forró partíciók) kialakítását, amelyek hatással lehetnek a teljesítményre és a rendelkezésre állásra.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-189">If you use a sharding scheme, avoid creating hotspots (or hot partitions) that can affect performance and availability.</span></span> <span data-ttu-id="6ddd2-190">Ha például a felhasználó nevének első betűje helyett a felhasználóazonosító kivonatát alkalmazza szegmenskulcsként, elkerülheti a gyakoribb és ritkább kezdőbetűk okozta egyenetlen eloszlást.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-190">For example, if you use a hash of a customer identifier instead of the first letter of a customer’s name, you prevent the unbalanced distribution that results from common and less common initial letters.</span></span> <span data-ttu-id="6ddd2-191">Ez egy tipikus módszer arra, hogy az adatokat egyenletesebben osszák el a partíciók között.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-191">This is a typical technique that helps distribute data more evenly across partitions.</span></span>

<span data-ttu-id="6ddd2-192">Válasszon olyan szegmenskulcsot, amely révén elkerülhető, hogy később a nagy szegmenseket kisebbekre kelljen felosztani, a kisebbeket nagyobbakká egyesíteni, vagy a partíciók egy halmazában tárolt adatokat leíró sémát módosítani.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-192">Choose a sharding key that minimizes any future requirements to split large shards into smaller pieces, coalesce small shards into larger partitions, or change the schema that describes the data stored in a set of partitions.</span></span> <span data-ttu-id="6ddd2-193">Az ilyen műveletek nagyon időigényesek lehetnek, és a végrehajtásuk során esetleg néhány szegmenst le is kell állítani.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-193">These operations can be very time consuming, and might require taking one or more shards offline while they are performed.</span></span>

<span data-ttu-id="6ddd2-194">Ha a szegmensek replikálva vannak, a replikák némelyike esetleg online tartható, amíg a többi felosztása, egyesítése vagy átkonfigurálása folyik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-194">If shards are replicated, it might be possible to keep some of the replicas online while others are split, merged, or reconfigured.</span></span> <span data-ttu-id="6ddd2-195">A rendszernek azonban esetleg korlátoznia kell az ezekben a szegmensekben lévő adatokon végrehajtható műveleteket, amíg az átkonfigurálás folyamatban van.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-195">However, the system might need to limit the operations that can be performed on the data in these shards while the reconfiguration is taking place.</span></span> <span data-ttu-id="6ddd2-196">Például a replikákon lévő adatok esetleg írásvédetté tehetőek a szegmensek átstrukturálása során esetleg fellépő inkonzisztenciák hatókörének korlátozása végett.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-196">For example, the data in the replicas can be marked as read-only to limit the scope of inconsistences that might occur while shards are being restructured.</span></span>

> <span data-ttu-id="6ddd2-197">A fenti szempontokkal kapcsolatos részletesebb információkért és útmutatást, valamint a horizontális particionálást megvalósító adattárak kialakítására vonatkozó ajánlott eljárásokat [Horizontális particionálási minta] ismertető részben talál.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-197">For more detailed information and guidance about many of these considerations, and good practice techniques for designing data stores that implement horizontal partitioning, see [Sharding pattern].</span></span>
>
>

### <a name="vertical-partitioning"></a><span data-ttu-id="6ddd2-198">Vertikális particionálás</span><span class="sxs-lookup"><span data-stu-id="6ddd2-198">Vertical partitioning</span></span>
<span data-ttu-id="6ddd2-199">A vertikális particionálást általában a leggyakrabban elért adatok lekérésével kapcsolatos I/O- és teljesítményköltségek csökkentésére alkalmazzák.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-199">The most common use for vertical partitioning is to reduce the I/O and performance costs associated with fetching the items that are accessed most frequently.</span></span> <span data-ttu-id="6ddd2-200">A 2. ábrán a vertikális particionálás egy példája látható.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-200">Figure 2 shows an example of vertical partitioning.</span></span> <span data-ttu-id="6ddd2-201">Ebben a példában az egyes adatelemek különböző tulajdonságai különböző partíciókon találhatók.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-201">In this example, different properties for each data item are held in different partitions.</span></span> <span data-ttu-id="6ddd2-202">Az egyik partíció a gyakrabban elért adatokat, például a termékek nevét, leírását és árát tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-202">One partition holds data that is accessed more frequently, including the name, description, and price information for products.</span></span> <span data-ttu-id="6ddd2-203">Egy másik a készletmennyiséget és az utolsó rendelés dátumát tárolja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-203">Another holds the volume in stock and the last ordered date.</span></span>

![Adatok vertikális particionálása a használati minta alapján](./images/data-partitioning/DataPartitioning02.png)

<span data-ttu-id="6ddd2-205">*2. ábra Adatok vertikális particionálása a használati minta alapján*</span><span class="sxs-lookup"><span data-stu-id="6ddd2-205">*Figure 2. Vertically partitioning data by its pattern of use*</span></span>

<span data-ttu-id="6ddd2-206">Ebben a példában az alkalmazás rendszeresen lekérdezi a termékek nevét, leírását és árát, amikor megjeleníti a termékek részleteit az ügyfelek számára.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-206">In this example, the application regularly queries the product name, description, and price when displaying the product details to customers.</span></span> <span data-ttu-id="6ddd2-207">A készleten lévő mennyiségeket és a gyártótól való utolsó rendelés időpontját egy külön partíció tárolja, mivel ezt a két elemet általában együtt használják.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-207">The stock level and date when the product was last ordered from the manufacturer are held in a separate partition because these two items are commonly used together.</span></span>

<span data-ttu-id="6ddd2-208">Ennek a particionálási sémának további előnye, hogy a relatíve ritkábban frissített adatokat (a termékek nevét, leírását és árát) elkülöníti a dinamikusabbaktól (a készleten lévő mennyiségektől és az utolsó megrendelések dátumától).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-208">This partitioning scheme has the added advantage that the relatively slow-moving data (product name, description, and price) is separated from the more dynamic data (stock level and last ordered date).</span></span> <span data-ttu-id="6ddd2-209">Az alkalmazásnak érdemes lehet a ritkában frissített adatokat gyorsítótáraznia, ha azokat gyakran kell elérni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-209">An application might find it beneficial to cache the slow-moving data in memory if it is frequently accessed.</span></span>

<span data-ttu-id="6ddd2-210">Egy másik tipikus forgatókönyv a bizalmas adatok biztonságának növelése.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-210">Another typical scenario for this partitioning strategy is to maximize the security of sensitive data.</span></span> <span data-ttu-id="6ddd2-211">Például ennek megvalósításához a hitelkártyaszámokat és a kártyák kapcsolódó biztonsági hitelesítő számait külön partíciókon tárolják.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-211">For example, you can do this by storing credit card numbers and the corresponding card security verification numbers in separate partitions.</span></span>

<span data-ttu-id="6ddd2-212">A vertikális particionálás használatával csökkenthető továbbá az adatok egyidejű elérésének mennyisége.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-212">Vertical partitioning can also reduce the amount of concurrent access that's needed to the data.</span></span>

> <span data-ttu-id="6ddd2-213">A vertikális particionálás az entitások szintjén működik a tárolóban, részlegesen normalizálja az entitásokat, és *széles* elemekből *keskeny* elemekké bontja le azokat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-213">Vertical partitioning operates at the entity level within a data store, partially normalizing an entity to break it down from a *wide* item to a set of *narrow* items.</span></span> <span data-ttu-id="6ddd2-214">Kiválóan alkalmazható oszlopalapú, például HBase és Cassandra adattárakhoz.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-214">It is ideally suited for column-oriented data stores such as HBase and Cassandra.</span></span> <span data-ttu-id="6ddd2-215">Ha az oszlopok egy gyűjteményében lévő adatok valószínűleg nem változnak majd, megpróbálhat oszloptárolókat is használni az SQL Serverben.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-215">If the data in a collection of columns is unlikely to change, you can also consider using column stores in SQL Server.</span></span>
>
>

### <a name="functional-partitioning"></a><span data-ttu-id="6ddd2-216">Funkcionális particionálás</span><span class="sxs-lookup"><span data-stu-id="6ddd2-216">Functional partitioning</span></span>
<span data-ttu-id="6ddd2-217">Az olyan rendszerekben, ahol az alkalmazásban lévő minden egyes külön üzleti területhez vagy szolgáltatáshoz azonosítható egy körülhatárolt kontextus, a funkcionális particionálás megfelelő módszer lehet az elkülönítés és az adatelérési teljesítmény javításához.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-217">For systems where it is possible to identify a bounded context for each distinct business area or service in the application, functional partitioning provides a technique for improving isolation and data access performance.</span></span> <span data-ttu-id="6ddd2-218">A funkcionális particionálás egy másik gyakori alkalmazási módja az írható és a jelentési célokat szolgáló írásvédett adatok elkülönítése.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-218">Another common use of functional partitioning is to separate read-write data from read-only data that's used for reporting purposes.</span></span> <span data-ttu-id="6ddd2-219">A 3. ábrán a funkcionális particionálás áttekintése látható egy példán, ahol a készletadatok elkülönülnek az ügyféladatoktól.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-219">Figure 3 shows an overview of functional partitioning where inventory data is separated from customer data.</span></span>

![Adatok funkcionális particionálása körülhatárolt kontextus vagy részterület alapján](./images/data-partitioning/DataPartitioning03.png)

<span data-ttu-id="6ddd2-221">*3. ábra Adatok funkcionális particionálása körülhatárolt kontextus vagy részterület alapján*</span><span class="sxs-lookup"><span data-stu-id="6ddd2-221">*Figure 3. Functionally partitioning data by bounded context or subdomain*</span></span>

<span data-ttu-id="6ddd2-222">Ez a particionálási stratégia csökkentheti az adatelérési versengést a rendszer egyes részei között.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-222">This partitioning strategy can help reduce data access contention across different parts of a system.</span></span>

## <a name="designing-partitions-for-scalability"></a><span data-ttu-id="6ddd2-223">Partíciók tervezése skálázhatóságra</span><span class="sxs-lookup"><span data-stu-id="6ddd2-223">Designing partitions for scalability</span></span>
<span data-ttu-id="6ddd2-224">Elengedhetetlen az egyes partíciók méretének és munkaterhelésének mérlegelése és kiegyensúlyozása, hogy az adatok megfelelően legyenek elosztva a maximális skálázhatóság érdekében.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-224">It's vital to consider size and workload for each partition and balance them so that data is distributed to achieve maximum scalability.</span></span> <span data-ttu-id="6ddd2-225">Azonban az adatok particionálása során arra is figyelni kell, hogy ne haladják meg az egypartíciós tárolók skálázási korlátait.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-225">However, you must also partition the data so that it does not exceed the scaling limits of a single partition store.</span></span>

<span data-ttu-id="6ddd2-226">A partíciók skálázhatóságra tervezése során kövesse az alábbi lépéseket:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-226">Follow these steps when designing partitions for scalability:</span></span>

1. <span data-ttu-id="6ddd2-227">Az alkalmazás elemzésével ismerje meg a hozzáférési mintákat, például az egyes lekérdezések által visszaadott eredményhalmazok méretét, az adatelérési gyakoriságot, az eredendő késést és a kiszolgálóoldali számítási feldolgozás követelményeit.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-227">Analyze the application to understand the data access patterns, such as the size of the result set returned by each query, the frequency of access, the inherent latency, and the server-side compute processing requirements.</span></span> <span data-ttu-id="6ddd2-228">Sok esetben néhány nagyobb entitás igényli a szükséges erőforrások többségét.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-228">In many cases, a few major entities will demand most of the processing resources.</span></span>
2. <span data-ttu-id="6ddd2-229">Az elemzés segítségével határozza meg az aktuális és a jövőbeli skálázhatósági célokat, például az adatok méretét és a munkaterhelést.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-229">Use this analysis to determine the current and future scalability targets, such as data size and workload.</span></span> <span data-ttu-id="6ddd2-230">Ezután ossza el az adatokat a partíciók közt a skálázhatósági célok teljesítéséhez.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-230">Then distribute the data across the partitions to meet the scalability target.</span></span> <span data-ttu-id="6ddd2-231">A horizontális particionálási stratégiában az egyenletes eloszláshoz fontos a megfelelő szegmenskulcs megválasztása.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-231">In the horizontal partitioning strategy, choosing the appropriate shard key is important to make sure distribution is even.</span></span> <span data-ttu-id="6ddd2-232">További információkért lásd [Horizontális particionálási minta].</span><span class="sxs-lookup"><span data-stu-id="6ddd2-232">For more information, see the [Sharding pattern].</span></span>
3. <span data-ttu-id="6ddd2-233">Gondoskodjon róla, hogy az egyes partíciók erőforrásai elegendőek legyenek a skálázhatósági követelmények kezelésére az adatméret és a feldolgozási sebesség tekintetében.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-233">Make sure that the resources available to each partition are sufficient to handle the scalability requirements in terms of data size and throughput.</span></span> <span data-ttu-id="6ddd2-234">Például az egyes partíciókat futtató csomópontok korlátozhatják az általuk biztosított tárterület mennyiségét, a feldolgozási teljesítményt vagy a hálózati sávszélességet.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-234">For example, the node that's hosting a partition might impose a hard limit on the amount of storage space, processing power, or network bandwidth that it provides.</span></span> <span data-ttu-id="6ddd2-235">Ha az adattárolási és feldolgozási követelmények valószínűleg meghaladják majd ezeket a korlátokat, szükség lehet a particionálási stratégia finomítására vagy az adatok további felosztására.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-235">If the data storage and processing requirements are likely to exceed these limits, it might be necessary to refine your partitioning strategy or split data out further.</span></span> <span data-ttu-id="6ddd2-236">Például egy lehetséges skálázhatósági megközelítés a naplózási adatok elkülönítése az alkalmazás alapszolgáltatásaitól.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-236">For example, one scalability approach might be to separate logging data from the core application features.</span></span> <span data-ttu-id="6ddd2-237">Ez az adattárak elkülönítésével oldható meg, hogy a teljes adattárolási igény ne haladja meg a csomópont skálázási korlátait.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-237">You do this by using separate data stores to prevent the total data storage requirements from exceeding the scaling limit of the node.</span></span> <span data-ttu-id="6ddd2-238">Ha az adattárak teljes száma meghaladja a csomópont korlátait, szükséges lehet további tárolócsomópontokat üzembe helyezni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-238">If the total number of data stores exceeds the node limit, it might be necessary to use separate storage nodes.</span></span>
4. <span data-ttu-id="6ddd2-239">Monitorozza a rendszert az éles üzem során, és győződjön meg róla, hogy az adatok a várakozásnak megfelelően vannak elosztva, és hogy a partíciók képesek kezelni a rájuk osztott terhelést.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-239">Monitor the system under use to verify that the data is distributed as expected and that the partitions can handle the load that is imposed on them.</span></span> <span data-ttu-id="6ddd2-240">Lehetséges, hogy a tényleges használat nem egyezik az elemzés alapján várható használattal.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-240">It's possible that the usage does not match the usage that's anticipated by the analysis.</span></span> <span data-ttu-id="6ddd2-241">Ebben az esetben újra kiegyensúlyozhatók a partíciók.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-241">In that case, it might be possible to rebalance the partitions.</span></span> <span data-ttu-id="6ddd2-242">Ennek hiányában esetleg át kell alakítani a rendszer bizonyos részeit, hogy elérhető legyen a szükséges egyensúly.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-242">Failing that, it might be necessary to redesign some parts of the system to gain the required balance.</span></span>

<span data-ttu-id="6ddd2-243">Vegye figyelembe, hogy egyes felhőkörnyezetek az infrastruktúra határai mentén foglalják le az erőforrásokat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-243">Note that some cloud environments allocate resources in terms of infrastructure boundaries.</span></span> <span data-ttu-id="6ddd2-244">Bizonyosodjon meg róla, hogy a kiválasztott határ korlátai elegendő teret biztosítanak az adatmennyiség várható növekedéséhez az adattárolás, a feldolgozási teljesítmény és a sávszélesség tekintetében.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-244">Ensure that the limits of your selected boundary provide enough room for any anticipated growth in the volume of data, in terms of data storage, processing power, and bandwidth.</span></span>

<span data-ttu-id="6ddd2-245">Például Azure-táblatárolók használata esetén a nagy terhelésű szegmensek több erőforrást igényelhetnek, mint amennyi egy adott partíció számára elérhető a kérelmek feldolgozásához.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-245">For example, if you use Azure table storage, a busy shard might require more resources than are available to a single partition to handle requests.</span></span> <span data-ttu-id="6ddd2-246">(Az egy partíció által egy adott időszakban feldolgozható kérelmek mennyisége korlátozva van.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-246">(There is a limit to the volume of requests that can be handled by a single partition in a particular period of time.</span></span> <span data-ttu-id="6ddd2-247">További információkat [Az Azure Storage skálázhatósági és teljesítménycéljai] bemutató oldalon talál a Microsoft webhelyén.)</span><span class="sxs-lookup"><span data-stu-id="6ddd2-247">See the page [Azure storage scalability and performance targets] on the Microsoft website for more details.)</span></span>

 <span data-ttu-id="6ddd2-248">Amennyiben valóban ez a helyzet, a szegmenst esetleg újra kell particionálni a terhelés szétosztása érdekében.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-248">If this is the case, the shard might need to be repartitioned to spread the load.</span></span> <span data-ttu-id="6ddd2-249">Ha a táblák teljes mérete vagy feldolgozási sebessége meghaladja a tárfiók kapacitását, szükséges lehet további tárfiókokat létrehozni, és elosztani a táblákat a fiókok közt.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-249">If the total size or throughput of these tables exceeds the capacity of a storage account, it might be necessary to create additional storage accounts and spread the tables across these accounts.</span></span> <span data-ttu-id="6ddd2-250">Ha a tárfiókok száma meghaladja az egy előfizetésben elérhető fiókok számát, több előfizetésre lehet szükség.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-250">If the number of storage accounts exceeds the number of accounts that are available to a subscription, then it might be necessary to use multiple subscriptions.</span></span>

## <a name="designing-partitions-for-query-performance"></a><span data-ttu-id="6ddd2-251">Partíciók tervezése lekérdezési teljesítményre</span><span class="sxs-lookup"><span data-stu-id="6ddd2-251">Designing partitions for query performance</span></span>
<span data-ttu-id="6ddd2-252">A lekérdezési teljesítmény gyakran kisebb adatkészletek használatával és a lekérdezések párhuzamos futtatásával növelhető.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-252">Query performance can often be boosted by using smaller data sets and by running parallel queries.</span></span> <span data-ttu-id="6ddd2-253">Mindegyik partíciónak a teljes adatkészlet egy kis részét kell tartalmaznia.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-253">Each partition should contain a small proportion of the entire data set.</span></span> <span data-ttu-id="6ddd2-254">A mennyiség csökkenésével javulhat a lekérdezések teljesítménye.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-254">This reduction in volume can improve the performance of queries.</span></span> <span data-ttu-id="6ddd2-255">A particionálás azonban nem váltja ki az adatbázis megfelelő kialakítását és konfigurálását.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-255">However, partitioning is not an alternative for designing and configuring a database appropriately.</span></span> <span data-ttu-id="6ddd2-256">Például relációs adatbázisok használata esetén mindenképp gondoskodnia kell róla, hogy az tartalmazza a szükséges indexeket.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-256">For example, make sure that you have the necessary indexes in place if you are using a relational database.</span></span>

<span data-ttu-id="6ddd2-257">A partíciók lekérdezési teljesítményre tervezése során kövesse az alábbi lépéseket:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-257">Follow these steps when designing partitions for query performance:</span></span>

1. <span data-ttu-id="6ddd2-258">Vizsgálja meg az alkalmazás követelményeit és teljesítményét:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-258">Examine the application requirements and performance:</span></span>
   * <span data-ttu-id="6ddd2-259">Az üzleti követelmények alapján határozza meg a kritikus lekérdezéseket, amelyeknek mindig gyorsan kell lefutnia.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-259">Use the business requirements to determine the critical queries that must always perform quickly.</span></span>
   * <span data-ttu-id="6ddd2-260">A rendszer monitorozásával azonosítsa a mindig lassan lefutó lekérdezéseket.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-260">Monitor the system to identify any queries that perform slowly.</span></span>
   * <span data-ttu-id="6ddd2-261">Határozza meg, hogy melyik lekérdezések futnak a leggyakrabban.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-261">Establish which queries are performed most frequently.</span></span> <span data-ttu-id="6ddd2-262">Az egyes lekérdezés egyes példányai önmagukban talán minimális költséggel járnak, az összesített erőforrás-használatuk azonban jelentős lehet.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-262">A single instance of each query might have minimal cost, but the cumulative consumption of resources could be significant.</span></span> <span data-ttu-id="6ddd2-263">Esetleg érdemes lehet az ilyen lekérdezések által beolvasott adatokat leválasztani egy külön partícióba, vagy akár egy gyorsítótárba.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-263">It might be beneficial to separate the data that's retrieved by these queries into a distinct partition, or even a cache.</span></span>
2. <span data-ttu-id="6ddd2-264">Particionálja a teljesítményt csökkentő adatokat:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-264">Partition the data that is causing slow performance:</span></span>
   * <span data-ttu-id="6ddd2-265">Korlátozza az egyes partíciók méretét, hogy a lekérdezések válaszideje a célon belül maradjon.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-265">Limit the size of each partition so that the query response time is within target.</span></span>
   * <span data-ttu-id="6ddd2-266">A szegmenskulcsot úgy alakítsa ki, hogy az alkalmazás könnyen megtalálja a partíciót, ha horizontális particionálást alkalmaz.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-266">Design the shard key so that the application can easily find the partition if you are implementing horizontal partitioning.</span></span> <span data-ttu-id="6ddd2-267">Így a lekérdezésnek nem kell az összes partíciót átvizsgálnia.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-267">This prevents the query from having to scan through every partition.</span></span>
   * <span data-ttu-id="6ddd2-268">Mérlegelje a partíciók elhelyezését.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-268">Consider the location of a partition.</span></span> <span data-ttu-id="6ddd2-269">Ha lehetséges, próbálja az adatokat olyan partíciókban tárolni, amelyek földrajzilag közel helyezkednek el az adatokhoz hozzáférő alkalmazásokhoz és felhasználókhoz.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-269">If possible, try to keep data in partitions that are geographically close to the applications and users that access it.</span></span>
3. <span data-ttu-id="6ddd2-270">Ha egy entitás a feldolgozási sebességre vagy lekérdezési teljesítményre vonatkozó követelményekkel rendelkezik, alkalmazzon funkcionális particionálást az adott entitás alapján.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-270">If an entity has throughput and query performance requirements, use functional partitioning based on that entity.</span></span> <span data-ttu-id="6ddd2-271">Ha ez még mindig nem elégíti ki a követelményeket, alkalmazzon horizontális particionálást is.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-271">If this still doesn't satisfy the requirements, apply horizontal partitioning as well.</span></span> <span data-ttu-id="6ddd2-272">A legtöbb esetben egyetlen particionálási stratégia elegendő lesz, egyes esetekben azonban a két stratégia kombinálása hatékonyabbnak bizonyul.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-272">In most cases a single partitioning strategy will suffice, but in some cases it is more efficient to combine both strategies.</span></span>
4. <span data-ttu-id="6ddd2-273">Vegye fontolóra aszinkron lekérdezések párhuzamos futtatását a partíciókon a teljesítmény javítása érdekében.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-273">Consider using asynchronous queries that run in parallel across partitions to improve performance.</span></span>

## <a name="designing-partitions-for-availability"></a><span data-ttu-id="6ddd2-274">Partíciók tervezése rendelkezésre állásra</span><span class="sxs-lookup"><span data-stu-id="6ddd2-274">Designing partitions for availability</span></span>
<span data-ttu-id="6ddd2-275">Az adatok particionálásával javítható az alkalmazások rendelkezésre állása, mivel így a teljes adatkészlet nem jelent egypontos meghibásodási helyet, és az adatkészlet egyes részhalmazai egymástól függetlenül kezelhetők.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-275">Partitioning data can improve the availability of applications by ensuring that the entire dataset does not constitute a single point of failure and that individual subsets of the dataset can be managed independently.</span></span> <span data-ttu-id="6ddd2-276">A kritikus adatokat tartalmazó partíciók replikálása szintén javíthatja a rendelkezésre állást.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-276">Replicating partitions that contain critical data can also improve availability.</span></span>

<span data-ttu-id="6ddd2-277">A partíciók kialakítása és megvalósítása során vegye figyelembe a rendelkezésre állást befolyásoló alábbi tényezőket:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-277">When designing and implementing partitions, consider the following factors that affect availability:</span></span>

* <span data-ttu-id="6ddd2-278">**Mennyire kritikusak az adatok az üzleti tevékenységek szempontjából**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-278">**How critical the data is to business operations**.</span></span> <span data-ttu-id="6ddd2-279">Bizonyos adatok kritikus üzleti információkat tartalmazhatnak, például számlázási adatokat vagy banki tranzakciók adatait.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-279">Some data might include critical business information such as invoice details or bank transactions.</span></span> <span data-ttu-id="6ddd2-280">Más adatok kevésbé fontos működési adatok, például naplófájlok, teljesítmény-nyomkövetések és hasonlók lehetnek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-280">Other data might include less critical operational data, such as log files, performance traces, and so on.</span></span> <span data-ttu-id="6ddd2-281">Az egyes adattípusok azonosítását követően mérlegelje a következőket:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-281">After identifying each type of data, consider:</span></span>
  * <span data-ttu-id="6ddd2-282">A kritikus fontosságú adatokat tárolja magas rendelkezésre állású partíciókon, megfelelő biztonsági mentési tervvel.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-282">Storing critical data in highly-available partitions with an appropriate backup plan.</span></span>
  * <span data-ttu-id="6ddd2-283">Hozzon létre külön felügyeleti és monitorozási mechanizmusokat vagy eljárásokat az egyes adatkészletek különböző kritikusságú elemeihez.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-283">Establishing separate management and monitoring mechanisms or procedures for the different criticalities of each dataset.</span></span> <span data-ttu-id="6ddd2-284">Az ugyanolyan kritikusságú adatokat helyezze ugyanabba a partícióba, hogy megfelelő gyakorisággal egyszerre készíthessen biztonsági másolatot róluk.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-284">Place data that has the same level of criticality in the same partition so that it can be backed up together at an appropriate frequency.</span></span> <span data-ttu-id="6ddd2-285">Például a banki tranzakciók adatait tároló partíciókról valószínűleg gyakrabban kell biztonsági másolatot készíteni, mint a naplózási és nyomkövetési információkat tartalmazóakról.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-285">For example, partitions that hold data for bank transactions might need to be backed up more frequently than partitions that hold logging or trace information.</span></span>
* <span data-ttu-id="6ddd2-286">**Hogyan felügyelhetőek az egyes partíciók**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-286">**How individual partitions can be managed**.</span></span> <span data-ttu-id="6ddd2-287">A partíciók a független felügyeletet és karbantartást biztosító kialakítása több előnnyel is jár.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-287">Designing partitions to support independent management and maintenance provides several advantages.</span></span> <span data-ttu-id="6ddd2-288">Példa:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-288">For example:</span></span>
  * <span data-ttu-id="6ddd2-289">Ha valamelyik partíció leáll, önállóan helyreállítható, anélkül, hogy befolyásolná a többi partíció adatait használó alkalmazáspéldányok működését.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-289">If a partition fails, it can be recovered independently without affecting instances of applications that access data in other partitions.</span></span>
  * <span data-ttu-id="6ddd2-290">Az adatok földrajzi területek szerinti particionálásával az ütemezett karbantartás minden helyen a csúcsidőn kívül végezhető el.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-290">Partitioning data by geographical area allows scheduled maintenance tasks to occur at off-peak hours for each location.</span></span> <span data-ttu-id="6ddd2-291">Gondoskodjon róla, hogy a partíciók ne legyenek túl nagyok a tervezett karbantartás adott időablakban való elvégzéséhez.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-291">Ensure that partitions are not too big to prevent any planned maintenance from being completed during this period.</span></span>
* <span data-ttu-id="6ddd2-292">**Érdemes-e a kritikus fontosságú adatokat a partíciók közt replikálni**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-292">**Whether to replicate critical data across partitions**.</span></span> <span data-ttu-id="6ddd2-293">Ez a stratégia javíthatja a rendelkezésre állást és a teljesítményt, bár konzisztenciaproblémákat okozhat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-293">This strategy can improve availability and performance, although it can also introduce consistency issues.</span></span> <span data-ttu-id="6ddd2-294">Bizonyos időt igénybe vesz, amíg az egyes partíciók adatain végzett módosítások szinkronizálódnak az összes replikára.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-294">It takes time for changes made to data in a partition to be synchronized with every replica.</span></span> <span data-ttu-id="6ddd2-295">Ez alatt az idő alatt az adatértékek a különböző partíciókban különbözőek lesznek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-295">During this period, different partitions will contain different data values.</span></span>

## <a name="understanding-how-partitioning-affects-design-and-development"></a><span data-ttu-id="6ddd2-296">A particionálás tervezési és fejlesztési szempontjai</span><span class="sxs-lookup"><span data-stu-id="6ddd2-296">Understanding how partitioning affects design and development</span></span>
<span data-ttu-id="6ddd2-297">A particionálás használata bonyolultabbá teszi a rendszer tervezését és fejlesztését.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-297">Using partitioning adds complexity to the design and development of your system.</span></span> <span data-ttu-id="6ddd2-298">A particionálást a rendszer alapvető részeként kell tekinteni a tervezés során, még ha a rendszer eleinte csak egyetlen partícióval rendelkezik is.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-298">Consider partitioning as a fundamental part of system design even if the system initially only contains a single partition.</span></span> <span data-ttu-id="6ddd2-299">Ha a particionálást csak utólag kezdi tervezni, amikor a rendszer már teljesítmény- és skálázhatósági problémákkal küzd, a feladat sokkal bonyolultabb lesz, mivel a már működő rendszert karban kell tartani.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-299">If you address partitioning as an afterthought, when the system starts to suffer performance and scalability issues, the complexity increases because you already have a live system to maintain.</span></span>

<span data-ttu-id="6ddd2-300">Amikor ebben a környezetben a particionálás bevezetéséhez frissíti a rendszert, módosítania kell az adathozzáférési logikát.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-300">If you update the system to incorporate partitioning in this environment, it necessitates modifying the data access logic.</span></span> <span data-ttu-id="6ddd2-301">Emellett a partíciók közötti elosztáshoz nagy mennyiségű meglévő adatot kell migrálni, gyakran úgy, hogy a felhasználók továbbra is elvárják a rendszer megfelelő működését.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-301">It can also involve migrating large quantities of existing data to distribute it across partitions, often while users expect to be able to continue using the system.</span></span>

<span data-ttu-id="6ddd2-302">Esetenként a particionálást nem tekintik fontosnak, mivel kezdetben még kisméretű az adatkészlet, és egy kiszolgáló könnyen képes kezelni azt.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-302">In some cases, partitioning is not considered important because the initial dataset is small and can be easily handled by a single server.</span></span> <span data-ttu-id="6ddd2-303">Ez lehet például a helyzet egy olyan rendszer esetében, amelynek a méretét nem tervezik növelni az induló állapothoz képest, a legtöbb kereskedelmi rendszernek azonban mégis növekednie kell a felhasználók számának növekedésével.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-303">This might be true in a system that is not expected to scale beyond its initial size, but many commercial systems need to expand as the number of users increases.</span></span> <span data-ttu-id="6ddd2-304">Az ilyen növekedés általában az adatok mennyiségének növekedésével is jár.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-304">This expansion is typically accompanied by a growth in the volume of data.</span></span>

<span data-ttu-id="6ddd2-305">Azt is fontos megérteni, hogy a particionálás nem mindig a nagyméretű adattárak függvénye.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-305">It's also important to understand that partitioning is not always a function of large data stores.</span></span> <span data-ttu-id="6ddd2-306">Például egy kisméretű adattárnak is lehet intenzív forgalma több száz egyidejű ügyfél irányában.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-306">For example, a small data store might be heavily accessed by hundreds of concurrent clients.</span></span> <span data-ttu-id="6ddd2-307">Ilyen esetben az adatok particionálása segíthet csökkenteni a versengést és növelni a teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-307">Partitioning the data in this situation can help to reduce contention and improve throughput.</span></span>

<span data-ttu-id="6ddd2-308">Az adatparticionálási sémák kialakításakor vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-308">Consider the following points when you design a data partitioning scheme:</span></span>

* <span data-ttu-id="6ddd2-309">**Amikor csak lehetséges, a leggyakrabban használt adatbázis-műveletekben érintett adatokat tartsa együtt az egyes partíciókban a több partíciót érintő adatelérési műveletek minimalizálása érdekében**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-309">**Where possible, keep data for the most common database operations together in each partition to minimize cross-partition data access operations**.</span></span> <span data-ttu-id="6ddd2-310">A több partícióra kiterjedő lekérdezések több időt vehetnek igénybe, mint az egyetlen partíciót érintőek, azonban a partíciók a lekérdezések egy adott halmazra való optimalizálása kedvezőtlenül befolyásolhatja a többi lekérdezéshalmazt.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-310">Querying across partitions can be more time-consuming than querying only within a single partition, but optimizing partitions for one set of queries might adversely affect other sets of queries.</span></span> <span data-ttu-id="6ddd2-311">Ha a több partícióra kiterjedő lekérdezések nem kerülhetők el, a lekérdezések ideje a lekérdezések párhuzamos futtatásával és az eredmények az alkalmazásban való összegzésével minimalizálható.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-311">When you can't avoid querying across partitions, minimize query time by running parallel queries and aggregating the results within the application.</span></span> <span data-ttu-id="6ddd2-312">Ez a módszer bizonyos esetekben nem alkalmazható, például ha egy lekérdezés eredményét a következő lekérdezésben kell használni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-312">This approach might not be possible in some cases, such as when it's necessary to obtain a result from one query and use it in the next query.</span></span>
* <span data-ttu-id="6ddd2-313">**Ha a lekérdezések viszonylag statikus referenciaadatokra vonatkoznak, például az irányítószámok táblázatára vagy terméklistákra, ezeket az adatokat érdemes lehet az összes partícióra replikálni, hogy ne kelljen annyi külön keresési műveletet végezni a különböző partíciókban**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-313">**If queries make use of relatively static reference data, such as postal code tables or product lists, consider replicating this data in all of the partitions to reduce the requirement for separate lookup operations in different partitions**.</span></span> <span data-ttu-id="6ddd2-314">Ez a megközelítés annak a valószínűségét is csökkentheti, hogy a referenciaadatok olyan „forró” adatkészletté váljanak, amelyre a rendszer egészéből intenzív forgalom irányul.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-314">This approach can also reduce the likelihood of the reference data becoming a "hot" dataset that is subject to heavy traffic from across the entire system.</span></span> <span data-ttu-id="6ddd2-315">Az ilyen referenciaadatok esetleges szinkronizálása azonban további költségekkel járhat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-315">However,   there is an additional cost associated with synchronizing any changes that might occur to this reference data.</span></span>
* <span data-ttu-id="6ddd2-316">**Ahol csak lehetséges, a vertikális és funkcionális partíciókban minimalizálja a hivatkozásintegritás-igényeket**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-316">**Where possible, minimize requirements for referential integrity across vertical and functional partitions**.</span></span> <span data-ttu-id="6ddd2-317">Ezekben a sémákban az alkalmazás feladata a hivatkozásintegritás fenntartása a különböző partíciók között az adatok frissítése és használata során.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-317">In these schemes, the application itself is responsible for maintaining referential integrity across partitions when data is updated and consumed.</span></span> <span data-ttu-id="6ddd2-318">Az olyan lekérdezések, amelyeknek több partíció adatait kell összekapcsolni, lassabban futnak az egy partíció adatait összekapcsolóknál, mivel az alkalmazásnak általában egymást követő lekérdezéseket kell végrehajtania, egyiket a másik után, különböző idegen kulcsokkal.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-318">Queries that must join data across multiple partitions run more slowly than queries that join data only within the same partition because the application typically needs to perform consecutive queries based on a key and then on a foreign key.</span></span> <span data-ttu-id="6ddd2-319">Ehelyett érdemes replikálni a vonatkozó adatokat vagy megszüntetni azok normalizáltságát.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-319">Instead, consider replicating or de-normalizing the relevant data.</span></span> <span data-ttu-id="6ddd2-320">A partíciók közti összekapcsolást nem igénylő lekérdezések idejének minimalizálásához futtassa párhuzamosan a lekérdezéseket a külön partíciókban, és az adatokat az alkalmazásban kapcsolja össze.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-320">To minimize the query time where cross-partition joins are necessary, run parallel queries over the partitions and join the data within the application.</span></span>
* <span data-ttu-id="6ddd2-321">**Mérlegelje, hogy a particionálási séma milyen hatással lehet az adatok a partíciók közti konzisztenciájára.**</span><span class="sxs-lookup"><span data-stu-id="6ddd2-321">**Consider the effect that the partitioning scheme might have on the data consistency across partitions.**</span></span> <span data-ttu-id="6ddd2-322">Mérje fel, hogy az erős konzisztencia valóban követelmény-e.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-322">Evaluate whether strong consistency is actually a requirement.</span></span> <span data-ttu-id="6ddd2-323">Ehelyett egy, a felhőben gyakran alkalmazott megközelítés a végső konzisztencia megvalósítása.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-323">Instead, a common approach in the cloud is to implement eventual consistency.</span></span> <span data-ttu-id="6ddd2-324">Az egyes partíciók adatainak frissítése külön történik, és az alkalmazáslogika biztosítja, hogy a frissítések mind sikeresen mennek végbe.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-324">The data in each partition is updated separately, and the application logic ensures that the updates are all completed successfully.</span></span> <span data-ttu-id="6ddd2-325">A logika emellett a végül konzisztens műveletek keretében futtatott adatlekérdezésekből eredő esetleges inkonzisztenciákat is kezeli.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-325">It also handles the inconsistencies that can arise from querying data while an eventually consistent operation is running.</span></span> <span data-ttu-id="6ddd2-326">A végső konzisztenciával kapcsolatos további információkat az [Adatkonzisztencia – Ismertető] szakaszban találja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-326">For more information about implementing eventual consistency, see the [Data consistency primer].</span></span>
* <span data-ttu-id="6ddd2-327">**Mérlegelje, hogyan találják meg a lekérdezések a megfelelő partíciót**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-327">**Consider how queries locate the correct partition**.</span></span> <span data-ttu-id="6ddd2-328">Ha egy lekérdezésnek az összes partíciót át kell vizsgálnia a szükséges adatok megtalálásához, az jelentős mértékben kihathat a teljesítményre, még akkor is, ha több párhuzamos lekérdezés fut.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-328">If a query must scan all partitions to locate the required data, there is a significant impact on performance, even when multiple parallel queries are running.</span></span> <span data-ttu-id="6ddd2-329">A vertikális és a funkcionális particionálási stratégiákkal használt lekérdezések természetes módon képesek meghatározni a partíciókat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-329">Queries that are used with vertical and functional partitioning strategies can naturally specify the partitions.</span></span> <span data-ttu-id="6ddd2-330">A horizontális particionálás esetében azonban az egyes elemek helyének megkeresése nehézkes lehet, mert minden szegmens ugyanazt a sémát használja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-330">However, horizontal partitioning (sharding) can make locating an item difficult because every shard has the same schema.</span></span> <span data-ttu-id="6ddd2-331">Egy tipikus megoldás erre a horizontálisan particionált rendszerekben egy olyan térkép fenntartása, amelynek használatával meg lehet határozni az egyes adatelemek helyét a szegmensek közt.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-331">A typical solution for sharding is to maintain a map that can be used to look up the shard location for specific items of data.</span></span> <span data-ttu-id="6ddd2-332">Ez a térkép az alkalmazás horizontális particionálási logikájában valósítható meg, vagy az adattár is karbantarthatja, ha támogatja a transzparens horizontális particionálást.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-332">This map can be implemented in the sharding logic of the application, or maintained by the data store if it supports transparent sharding.</span></span>
* <span data-ttu-id="6ddd2-333">**Horizontális particionálási stratégia alkalmazása esetén mérlegelje a szegmensek rendszeres kiegyensúlyozásának szükségességét**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-333">**When using a horizontal partitioning strategy, consider periodically rebalancing the shards**.</span></span> <span data-ttu-id="6ddd2-334">Ez segíti az adatok egyenletes elosztását méret és munkaterhelés alapján a kritikus pontok elkerülése, a lekérdezési teljesítmény maximalizálása és a fizikai tárhelykorlátok megkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-334">This helps distribute the data evenly by size and by workload to minimize hotspots, maximize query performance, and work around physical storage limitations.</span></span> <span data-ttu-id="6ddd2-335">Ez azonban egy összetett feladat, amelyhez általában egy egyéni eszköz vagy folyamat használata szükséges.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-335">However, this is a complex task that often requires the use of a custom tool or process.</span></span>
* <span data-ttu-id="6ddd2-336">**Ha mindegyik partíciót replikálja, ez további védelmet biztosít a meghibásodások ellen**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-336">**If you replicate each partition, it provides additional protection against failure**.</span></span> <span data-ttu-id="6ddd2-337">Ha valamelyik replika leáll, a lekérdezések egy másik, működő példányra irányíthatóak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-337">If a single replica fails, queries can be directed towards a working copy.</span></span>
* <span data-ttu-id="6ddd2-338">**Ha eléri valamely particionálási stratégia fizikai korlátait, érdemes lehet a skálázhatóságot egy másik szintre kiterjeszteni**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-338">**If you reach the physical limits of a partitioning strategy, you might need to extend the scalability to a different level**.</span></span> <span data-ttu-id="6ddd2-339">Például ha a particionálás az adatbázis szintjén valósul meg, a partíciókat esetleg több adatbázisban szükséges elhelyezni vagy replikálni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-339">For example, if partitioning is at the database level, you might need to locate or replicate partitions in multiple databases.</span></span> <span data-ttu-id="6ddd2-340">Ha a particionálás már eleve az adatbázis szintjén van megvalósítva, és a fizikai korlátok problémát jelentenek, ez jelezheti azt, hogy a partíciókat esetleg több üzemeltetési fiókban szükséges elhelyezni vagy replikálni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-340">If partitioning is already at the database level, and physical limitations are an issue, it might mean that you need to locate or replicate partitions in multiple hosting accounts.</span></span>
* <span data-ttu-id="6ddd2-341">**Kerülje a több partícióban lévő adatokat használó tranzakciókat**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-341">**Avoid transactions that access data in multiple partitions**.</span></span> <span data-ttu-id="6ddd2-342">Egyes adattárak tranzakció-konzisztenciát és integritást valósítanak meg az adatokat módosító műveletekre, de csak abban az esetben, ha az adatok egyetlen partíción találhatóak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-342">Some data stores implement transactional consistency and integrity for operations that modify data, but only when the data is located in a single partition.</span></span> <span data-ttu-id="6ddd2-343">Ha több partícióra kiterjedő tranzakciótámogatás szükséges, ezt valószínűleg az alkalmazáslogika részeként kell megvalósítania, mivel a legtöbb particionálási rendszer ezt natív módon nem támogatja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-343">If you need transactional support across multiple partitions, you will probably need to implement this as part of your application logic because most partitioning systems do not provide native support.</span></span>

<span data-ttu-id="6ddd2-344">Minden adattárhoz bizonyos üzemeltetési felügyeleti és monitorozási tevékenységeket is végezni kell.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-344">All data stores require some operational management and monitoring activity.</span></span> <span data-ttu-id="6ddd2-345">Ilyen feladat lehet az adatok betöltése, az adatok biztonsági mentése és helyreállítása, az adatok átrendezése, valamint a rendszer megfelelő és hatékony működésének biztosítása.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-345">The tasks can range from loading data, backing up and restoring data, reorganizing data, and ensuring that the system is performing correctly and efficiently.</span></span>

<span data-ttu-id="6ddd2-346">Mérlegelje az üzemeltetési felügyeletet befolyásoló alábbi tényezőket:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-346">Consider the following factors that affect operational management:</span></span>

* <span data-ttu-id="6ddd2-347">**Hogyan valósíthatóak meg a megfelelő felügyeleti és üzemeltetési feladatok az adatok particionálása esetén**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-347">**How to implement appropriate management and operational tasks when the data is partitioned**.</span></span> <span data-ttu-id="6ddd2-348">Ilyen feladatok lehetnek a biztonsági mentés és visszaállítás, az adatok archiválása, a rendszer monitorozása, valamint egyéb felügyeleti feladatok.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-348">These tasks might include backup and restore, archiving data, monitoring the system, and other administrative tasks.</span></span> <span data-ttu-id="6ddd2-349">Például a logikai konzisztencia fenntartása a biztonsági mentési és visszaállítási műveletek során kihívást jelenthet.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-349">For example, maintaining logical consistency during backup and restore operations can be a challenge.</span></span>
* <span data-ttu-id="6ddd2-350">**Hogyan tölthetőek be az adatok több partícióba, és hogyan adhatók hozzá a külső forrásokból érkező új adatok**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-350">**How to load the data into multiple partitions and add new data that's arriving from other sources**.</span></span> <span data-ttu-id="6ddd2-351">Egyes eszközök és segédprogramok esetleg nem támogatják a horizontálisan particionált adatműveleteket, például az adatok a megfelelő partícióba való betöltését.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-351">Some tools and utilities might not support sharded data operations such as loading data into the correct partition.</span></span> <span data-ttu-id="6ddd2-352">Ez azt jelenti, hogy esetleg új eszközöket és segédprogramokat kell fejlesztenie vagy beszereznie.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-352">This means that you might have to create or obtain new tools and utilities.</span></span>
* <span data-ttu-id="6ddd2-353">**Hogyan oldható meg az adatok rendszeres archiválása és törlése**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-353">**How to archive and delete the data on a regular basis**.</span></span> <span data-ttu-id="6ddd2-354">A partíciók méretének túlzott növekedését elkerülendő az adatokat rendszeresen (például havonta) archiválni és törölni kell.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-354">To prevent the excessive growth of partitions, you need to archive and delete data on a regular basis (perhaps monthly).</span></span> <span data-ttu-id="6ddd2-355">Szükség lehet az adatok egy másik archiválási sémának megfelelő átalakítására.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-355">It might be necessary to transform the data to match a different archive schema.</span></span>
* <span data-ttu-id="6ddd2-356">**Hogyan találhatók meg az adatintegritási problémák**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-356">**How to locate data integrity issues**.</span></span> <span data-ttu-id="6ddd2-357">Vegye fontolóra egy rendszeres folyamat futtatását az adatintegritási problémák felderítésére, például ha egy adott partíció adatai egy másik partíció hiányzó adataira hivatkoznak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-357">Consider running a periodic process to locate any data integrity issues such as data in one partition that references missing information in another.</span></span> <span data-ttu-id="6ddd2-358">A folyamat megpróbálhatja automatikusan javítani ezeket a problémákat, vagy riaszthatja a kezelőt, aki manuálisan oldhatja meg a problémát.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-358">The process can either attempt to fix these issues automatically or raise an alert to an operator to correct the problems manually.</span></span> <span data-ttu-id="6ddd2-359">Például egy e-kereskedelmi alkalmazásban a megrendelések információit tárolhatja az egyik partíció, míg a megrendelésekben szereplő sortételeket egy másik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-359">For example, in an e-commerce application, order information might be held in one partition but the line items that constitute each order might be held in another.</span></span> <span data-ttu-id="6ddd2-360">A megrendelések feladását végző folyamatnak így más partíciókhoz kell adatokat hozzáadni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-360">The process of placing an order needs to add data to other partitions.</span></span> <span data-ttu-id="6ddd2-361">Ha a folyamat hibázik, egyes tárolt sortételekhez esetleg nem tartozik majd megfelelő megrendelés.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-361">If this process fails, there might be line items stored for which there is no corresponding order.</span></span>

<span data-ttu-id="6ddd2-362">A különféle adattárolási technológiák általában saját funkciókat biztosítanak a particionálás támogatására.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-362">Different data storage technologies typically provide their own features to support partitioning.</span></span> <span data-ttu-id="6ddd2-363">A következő szakaszok az Azure-alkalmazások által általánosságban használt adattárakban megvalósított lehetőségeket összegzik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-363">The following sections summarize the options that are implemented by data stores commonly used by Azure applications.</span></span> <span data-ttu-id="6ddd2-364">Ezen felül leírnak különböző szempontokat is az ezeket a lehetőségeket optimálisan kiaknázó alkalmazások tervezéséhez.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-364">They also describe considerations for designing applications that can best take advantage of these features.</span></span>

## <a name="partitioning-strategies-for-azure-sql-database"></a><span data-ttu-id="6ddd2-365">Az Azure SQL Database particionálási stratégiái</span><span class="sxs-lookup"><span data-stu-id="6ddd2-365">Partitioning strategies for Azure SQL Database</span></span>
<span data-ttu-id="6ddd2-366">Az Azure SQL Database egy felhőben futó, szolgáltatásként nyújtott relációs adatbázis.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-366">Azure SQL Database is a relational database-as-a-service that runs in the cloud.</span></span> <span data-ttu-id="6ddd2-367">Az alapját a Microsoft SQL Server képezi.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-367">It is based on Microsoft SQL Server.</span></span> <span data-ttu-id="6ddd2-368">A relációs adatbázis az adatokat táblákba osztja le, és mindegyik tábla sorok sorozataként tárolja az entitásokkal kapcsolatos információkat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-368">A relational database divides information into tables, and each table holds information about entities as a series of rows.</span></span> <span data-ttu-id="6ddd2-369">Az egyes sorok oszlopai tárolják az adott entitás egyes mezőiben lévő adatokat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-369">Each row contains columns that hold the data for the individual fields of an entity.</span></span> <span data-ttu-id="6ddd2-370">A Microsoft webhely [Mi az Azure SQL Database?] című oldala részletes dokumentációval szolgál az SQL-adatbázisok létrehozásához és használatához.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-370">The page [What is Azure SQL Database?] on the Microsoft website provides detailed documentation about creating and using SQL databases.</span></span>

## <a name="horizontal-partitioning-with-elastic-database"></a><span data-ttu-id="6ddd2-371">Horizontális particionálás az Elastic Database-zel</span><span class="sxs-lookup"><span data-stu-id="6ddd2-371">Horizontal partitioning with Elastic Database</span></span>
<span data-ttu-id="6ddd2-372">Az egyes SQL-adatbázisokban tárolható adatok mennyisége korlátozott.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-372">A single SQL database has a limit to the volume of data that it can contain.</span></span> <span data-ttu-id="6ddd2-373">A feldolgozási sebességet architekturális tényezők és az adatbázis által támogatott egyidejű kapcsolatok száma korlátozzák.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-373">Throughput is constrained by architectural factors and the number of concurrent connections that it supports.</span></span> <span data-ttu-id="6ddd2-374">A SQL Database Elastic Database szolgáltatása támogatja az SQL-adatbázisok horizontális skálázását.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-374">The Elastic Database feature of SQL Database supports horizontal scaling for a SQL database.</span></span> <span data-ttu-id="6ddd2-375">Az Elastic Database használatával az adatokat több SQL-adatbázisra elosztott szegmensekre particionálhatja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-375">Using Elastic Database, you can partition your data into shards that are spread across multiple SQL databases.</span></span> <span data-ttu-id="6ddd2-376">A kezelendő adatok mennyiségének növekedésével vagy csökkenésével hozzá is adhat és el is távolíthat szegmenseket.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-376">You can also add or remove shards as the volume of data that you need to handle grows and shrinks.</span></span> <span data-ttu-id="6ddd2-377">Az Elastic Database szolgáltatás emellett segít csökkenteni a versengést is, mivel elosztja a terhelést az adatbázisok között.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-377">Using Elastic Database can also help reduce contention by distributing the load across databases.</span></span>

> [!NOTE]
> <span data-ttu-id="6ddd2-378">Az Elastic Database az Azure SQL Database Federation szolgáltatásait váltotta le.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-378">Elastic Database is a replacement for the Federations feature of Azure SQL Database.</span></span> <span data-ttu-id="6ddd2-379">A meglévő SQL Database Federation telepítések az összevonás-migrálási segédprogrammal migrálhatóak az Elastic Database-re.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-379">Existing SQL Database Federation installations can be migrated to Elastic Database by using the Federations migration utility.</span></span> <span data-ttu-id="6ddd2-380">Kialakíthat egy saját horizontális particionálási mechanizmust is, amennyiben a megvalósítani kívánt forgatókönyv nem adja magát természetesen az Elastic Database által nyújtott szolgáltatásokhoz.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-380">Alternatively, you can implement your own sharding mechanism if your scenario does not lend itself naturally to the features that are provided by Elastic Database.</span></span>
>
>

<span data-ttu-id="6ddd2-381">Minden egyes szegmens egy SQL-adatbázisként van megvalósítva.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-381">Each shard is implemented as a SQL database.</span></span> <span data-ttu-id="6ddd2-382">Az egyes szegmensek több adatkészletet (a továbbiakban *shardletet*) is tartalmazhatnak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-382">A shard can hold more than one dataset (referred to as a *shardlet*).</span></span> <span data-ttu-id="6ddd2-383">Minden egyes adatbázis maga biztosítja a benne található shardleteket leíró metaadatokat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-383">Each database maintains metadata that describes the shardlets that it contains.</span></span> <span data-ttu-id="6ddd2-384">A shardlet lehet egyetlen adatelem, vagy az elemek egy csoportja, amelyek mind ugyanazzal a shardletkulccsal rendelkeznek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-384">A shardlet can be a single data item, or it can be a group of items that share the same shardlet key.</span></span> <span data-ttu-id="6ddd2-385">Például ha egy több-bérlős alkalmazás adatainak horizontális particionálását végzi, a shardletkulcs lehet a bérlő azonosítója, és egy adott bérlő összes adatát ugyanaz a shardlet tárolhatja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-385">For example, if you are sharding data in a multitenant application, the shardlet key can be the tenant ID, and all data for a given tenant can be held as part of the same shardlet.</span></span> <span data-ttu-id="6ddd2-386">A többi bérlő adatai különböző shardletekben lehetnek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-386">Data for other tenants would be held in different shardlets.</span></span>

<span data-ttu-id="6ddd2-387">A programozói feladata, hogy az egyes adatkészletekhez shardletkulcsokat rendeljen.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-387">It is the programmer's responsibility to associate a dataset with a shardlet key.</span></span> <span data-ttu-id="6ddd2-388">Egy külön SQL-adatbázis szolgál globális szegmenstérkép-kezelőként.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-388">A separate SQL database acts as a global shard map manager.</span></span> <span data-ttu-id="6ddd2-389">Ez az adatbázis a rendszerben lévő összes szegmens és shardlet listáját tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-389">This database contains a list of all the shards and shardlets in the system.</span></span> <span data-ttu-id="6ddd2-390">Az adatokat elérő ügyfélalkalmazások először a globális szegmenstérkép-kezelő adatbázishoz kapcsolódnak, ahonnan lekérik, majd helyben gyorsítótárazzák a szegmenstérképet (amely a szegmenseket és shardleteket sorolja fel).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-390">A client application that accesses data connects first to the global shard map manager database to obtain a copy of the shard map (listing shards and shardlets), which it then caches locally.</span></span>

<span data-ttu-id="6ddd2-391">Az alkalmazás ezután az információk alapján irányítja a megfelelő szegmensre az adatkérelmet.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-391">The application then uses this information to route data requests to the appropriate shard.</span></span> <span data-ttu-id="6ddd2-392">Ezek a funkciók egy sor API mögé vannak bújtatva, amelyeket az Azure SQL Database NuGet-csomagként elérhető Elastic Database-ügyfélkódtára tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-392">This functionality is hidden behind a series of APIs that are contained in the Azure SQL Database Elastic Database Client Library, which is available as a NuGet package.</span></span> <span data-ttu-id="6ddd2-393">A Microsoft webhely [Az Elastic Database szolgáltatásainak áttekintése] oldala átfogóbban ismerteti az Elastic Database szolgáltatást.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-393">The page [Elastic Database features overview] on the Microsoft website provides a more comprehensive introduction to Elastic Database.</span></span>

> [!NOTE]
> <span data-ttu-id="6ddd2-394">A globális szegmenstérkép-kezelő adatbázis replikálásával csökkenthető a késés, és javítható a rendelkezésre állás.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-394">You can replicate the global shard map manager database to reduce latency and improve availability.</span></span> <span data-ttu-id="6ddd2-395">Ha az adatbázist valamelyik prémium tarifacsomag használatával valósítja meg, az aktív georeplikáció megfelelő konfigurálásával folyamatosan replikálhatja az adatokat különböző régiókban lévő adatbázisokba.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-395">If you implement the database by using one of the Premium pricing tiers, you can configure active geo-replication to continuously copy data to databases in different regions.</span></span> <span data-ttu-id="6ddd2-396">Minden olyan régióban hozzon létre egy másolatot az adatbázisról, ahol találhatók felhasználók.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-396">Create a copy of the database in each region in which users are based.</span></span> <span data-ttu-id="6ddd2-397">Ezután konfigurálja az alkalmazást, hogy ehhez a másolathoz kapcsolódjon a szegmenstérkép lekéréséhez.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-397">Then configure your application to connect to this copy to obtain the shard map.</span></span>
>
> <span data-ttu-id="6ddd2-398">Egy másik módszerrel a szegmenstérkép-kezelő adatbázis az Azure SQL Data Sync vagy egy Azure Data Factory-folyamat használatával is replikálható a régiók közt.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-398">An alternative approach is to use Azure SQL Data Sync or an Azure Data Factory pipeline to replicate the shard map manager database across regions.</span></span> <span data-ttu-id="6ddd2-399">Az ilyen típusú replikáció időközönként fut csak, és az olyan esetekben megfelelő, ha a szegmenstérkép ritkán módosul.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-399">This form of replication runs periodically and is more suitable if the shard map changes infrequently.</span></span> <span data-ttu-id="6ddd2-400">Megjegyzendő, hogy a szegmenstérkép-kezelő adatbázist nem szükséges prémium tarifacsomag használatával hozni létre.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-400">Additionally, the shard map manager database does not have to be created by using a Premium pricing tier.</span></span>
>
>

<span data-ttu-id="6ddd2-401">Az Elastic Database két sémát kínál az adatok shardletekre való leképezésére és a szegmenseken való eltárolására:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-401">Elastic Database provides two schemes for mapping data to shardlets and storing them in shards:</span></span>

* <span data-ttu-id="6ddd2-402">A **listás szegmenstérkép** egyetlen kulcs és egy shardlet közti társításokat ír le.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-402">A **list shard map** describes an association between a single key and a shardlet.</span></span> <span data-ttu-id="6ddd2-403">Például egy több-bérlős rendszerben az egyes bérlők adatai egy egyedi kulccsal lehetnek társítva, majd egy külön shardletben tárolhatók.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-403">For example, in a multitenant system, the data for each tenant can be associated with a unique key and stored in its own shardlet.</span></span> <span data-ttu-id="6ddd2-404">Az adatvédelem és az elkülönítés érdekében (ez utóbbi megakadályozza, hogy az egyes bérlők kimerítsék a többi bérlő számára elérhető adattárolási erőforrásokat) az egyes shardletek tárolhatóak külön szegmensekben is.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-404">To guarantee privacy and isolation (that is, to prevent one tenant from exhausting the data storage resources available to others), each shardlet can be held within its own shard.</span></span>

![Bérlők adatainak tárolása külön szegmensekben listás szegmenstérkép használatával](./images/data-partitioning/PointShardlet.png)

<span data-ttu-id="6ddd2-406">*4. ábra Bérlők adatainak tárolása külön szegmensekben listás szegmenstérkép használatával*</span><span class="sxs-lookup"><span data-stu-id="6ddd2-406">*Figure 4. Using a list shard map to store tenant data in separate shards*</span></span>

* <span data-ttu-id="6ddd2-407">A **tartomány-szegmenstérkép** az összefüggő tartományba eső értékű kulcsok és egy shardlet közti társításokat írja le.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-407">A **range shard map** describes an association between a set of contiguous key values and a shardlet.</span></span> <span data-ttu-id="6ddd2-408">Az előzőekben leírt több-bérlős példában a dedikált shardletek megvalósításának alternatívájaként bérlők egy csoportjának (mindegyik saját kulccsal rendelkezik) adatait csoportosíthatja ugyanabba a shardletbe.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-408">In the multitenant example described previously, as an alternative to implementing dedicated shardlets, you can group the data for a set of tenants (each with their own key) within the same shardlet.</span></span> <span data-ttu-id="6ddd2-409">Ez a séma kevésbé költséges, mint az első (mivel a bérlők osztoznak az adattárolási erőforrásokon), de fennáll a kockázata az adatvédelem és az elkülönítés sérülésének.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-409">This scheme is less expensive than the first (because tenants share data storage resources), but it also creates a risk of reduced data privacy and isolation.</span></span>

![Bérlőtartomány adatainak tárolása tartomány-szegmenstérkép használatával](./images/data-partitioning/RangeShardlet.png)

<span data-ttu-id="6ddd2-411">*5. ábra Bérlőtartomány adatainak tárolása tartomány-szegmenstérkép használatával*</span><span class="sxs-lookup"><span data-stu-id="6ddd2-411">*Figure 5. Using a range shard map to store data for a range of tenants in a shard*</span></span>

<span data-ttu-id="6ddd2-412">Ne feledje, hogy egyetlen szegmens több shardlet adatait is tartalmazhatja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-412">Note that a single shard can contain the data for several shardlets.</span></span> <span data-ttu-id="6ddd2-413">Például listás shardletek használatával több nem egymást követő shardlet adatait is tárolhatja egyetlen szegmensben.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-413">For example, you can use list shardlets to store data for different non-contiguous tenants in the same shard.</span></span> <span data-ttu-id="6ddd2-414">A tartományshardleteket és a listás shardleteket keverheti is egyazon szegmensen belül, bár ekkor külön térképeken szerepelnek majd a globális szegmenstérkép-kezelő adatbázisban.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-414">You can also mix range shardlets and list shardlets in the same shard, although they will be addressed through different maps in the global shard map manager database.</span></span> <span data-ttu-id="6ddd2-415">(A globális szegmenstérkép-kezelő adatbázis több szegmenstérképet is tartalmazhat.) A 6. ábra ezt a megközelítést mutatja be.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-415">(The global shard map manager database can contain multiple shard maps.) Figure 6 depicts this approach.</span></span>

![Több szegmenstérkép megvalósítása](./images/data-partitioning/MultipleShardMaps.png)

<span data-ttu-id="6ddd2-417">*6. ábra Több szegmenstérkép megvalósítása*</span><span class="sxs-lookup"><span data-stu-id="6ddd2-417">*Figure 6. Implementing multiple shard maps*</span></span>

<span data-ttu-id="6ddd2-418">A megvalósított particionálási séma jelentős hatással lehet a rendszer teljesítményére.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-418">The partitioning scheme that you implement can have a significant bearing on the performance of your system.</span></span> <span data-ttu-id="6ddd2-419">Emellett befolyásolhatja a szegmensek hozzáadásának és eltávolításának, vagy az adatok az egyes szegmensekre való particionálásának szükséges sebességét is.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-419">It can also affect the rate at which shards have to be added or removed, or the rate at which data must be repartitioned across shards.</span></span> <span data-ttu-id="6ddd2-420">Ha az adatokat az Elastic Database-zel tervezi particionálni, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-420">Consider the following points when you use Elastic Database to partition data:</span></span>

* <span data-ttu-id="6ddd2-421">Az együtt használt adatokat csoportosítsa egy szegmensre, és kerülje az olyan műveleteket, amelyeknek több szegmenset is el kell érniük.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-421">Group data that is used together in the same shard, and avoid operations that need to access data that's held in multiple shards.</span></span> <span data-ttu-id="6ddd2-422">Ne feledje, hogy az Elastic Database használata esetén mindegyik szegmens egy önálló SQL-adatbázis, és az Azure SQL Database nem támogatja az adatbázisok közti összekapcsolásokat (amelyeket az ügyféloldalon kell végrehajtani).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-422">Keep in mind that with Elastic Database, a shard is a SQL database in its own right, and Azure SQL Database does not support cross-database joins (which have to be performed on the client side).</span></span> <span data-ttu-id="6ddd2-423">Azt se feledje, hogy az Azure SQL Database-ben egyik adatbázis hivatkozásintegritási megkötései, triggerei és tárolt eljárásai nem hivatkozhatnak egy másik objektumaira.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-423">Remember also that in Azure SQL Database, referential integrity constraints, triggers, and stored procedures in one database cannot reference objects in another.</span></span> <span data-ttu-id="6ddd2-424">Ezért kerülje az olyan rendszerek kialakítását, amelyek szegmensek közti függőségeket tartalmaznak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-424">Therefore, don't design a system that has dependencies between shards.</span></span> <span data-ttu-id="6ddd2-425">Az SQL-adatbázisok azonban tartalmazhatnak olyan táblákat, amelyek a lekérdezések és egyéb műveletek által gyakran használt referenciaadatok másolatát tárolják.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-425">A SQL database can, however, contain tables that hold copies of reference data frequently used by queries and other operations.</span></span> <span data-ttu-id="6ddd2-426">Ezeknek a tábláknak nem szükséges egyik adott shardlethez sem tartoznia.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-426">These tables do not have to belong to any specific shardlet.</span></span> <span data-ttu-id="6ddd2-427">Az ilyen adatok szegmensek közötti replikálásával elkerülhető, hogy több adatbázis adatait kelljen összekapcsolni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-427">Replicating this data across shards can help remove the need to join data that spans databases.</span></span> <span data-ttu-id="6ddd2-428">Ideális esetben az ilyen adatoknak statikusnak vagy ritkán frissítettnek kell lenniük, hogy minimalizálható legyen a replikációigény és az adatok elévülésének esélye.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-428">Ideally, such data should be static or slow-moving to minimize the replication effort and reduce the chances of it becoming stale.</span></span>

  > [!NOTE]
  > <span data-ttu-id="6ddd2-429">Bár az SQL Database nem támogatja az adatbázisok közti összekapcsolásokat, szegmensek közötti lekérdezéseket végrehajthat az Elastic Database API-val.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-429">Although SQL Database does not support cross-database joins, you can perform cross-shard queries with the Elastic Database API.</span></span> <span data-ttu-id="6ddd2-430">Ezek a lekérdezések transzparens módon iterálhatóak a szegmenstérképek által hivatkozott összes shardlet adatain.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-430">These queries can transparently iterate through the data held in all the shardlets that are referenced by a shard map.</span></span> <span data-ttu-id="6ddd2-431">Az Elastic Database API a szegmensek közti lekérdezéseket külön lekérdezések sorozatára bontja (adatbázisonként egy lekérdezésre), majd egyesíti az eredményeket.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-431">The Elastic Database API breaks cross-shard queries down into a series of individual queries (one for each database) and then merges the results.</span></span> <span data-ttu-id="6ddd2-432">További információkat [Többszegmenses lekérdezés] foglalkozó oldalon talál a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-432">For more information, see the page [Multi-shard querying] on the Microsoft website.</span></span>
  >
  >
* <span data-ttu-id="6ddd2-433">Az ugyanahhoz a szegmenstérképhez tartozó shardletekben tárolt adatoknak ugyanazzal a sémával kell rendelkezniük.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-433">The data stored in shardlets that belong to the same shard map should have the same schema.</span></span> <span data-ttu-id="6ddd2-434">Például ne hozzon létre olyan listás szegmenstérképet, amely egyfelől bérlőadatokat tartalmazó szegmensekre, másfelől termékinformációkat tartalmazó szegmensekre is mutat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-434">For example, don't create a list shard map that points to some shardlets containing tenant data and other shardlets containing product information.</span></span> <span data-ttu-id="6ddd2-435">Ezt a szabályt az Elastic Database nem tartatja be, azonban az adatok kezelése és lekérdezése rendkívül bonyolulttá válik, ha az egyes shardletek különböző sémákkal rendelkeznek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-435">This rule is not enforced by Elastic Database, but data management and querying becomes very complex if each shardlet has a different schema.</span></span> <span data-ttu-id="6ddd2-436">Az iménti példában jó megoldás lehet, ha két listás szegmenstérképet hoz létre: egy olyat, amely a bérlőadatokra, és egy másikat, amely a termékinformációkra mutat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-436">In the example just cited, a good solution is to create two list shard maps: one that references tenant data and another that points to product information.</span></span> <span data-ttu-id="6ddd2-437">Ne feledje, hogy a különböző shardleteken tárolt adatok tárolhatók ugyanabban a szegmensben.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-437">Remember that the data belonging to different shardlets can be stored in the same shard.</span></span>

  > [!NOTE]
  > <span data-ttu-id="6ddd2-438">Az Elastic Database API szegmensek közötti lekérdezési funkcionalitásának alapja, hogy a szegmenstérképen szereplő mindegyik shardlet ugyanazzal a sémával rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-438">The cross-shard query functionality of the Elastic Database API depends on each shardlet in the shard map containing the same schema.</span></span>
  >
  >
* <span data-ttu-id="6ddd2-439">A tranzakciós műveletek csak egyazon szegmensen belül tárolt adatokon működnek, szegmensek között nem.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-439">Transactional operations are only supported for data that's held within the same shard, and not across shards.</span></span> <span data-ttu-id="6ddd2-440">A tranzakciók több shardletet is érinthetnek, amennyiben azok egyazon szegmens részét képezik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-440">Transactions can span shardlets as long as they are part of the same shard.</span></span> <span data-ttu-id="6ddd2-441">Így ha az üzleti logikának kell tranzakciókat végrehajtania, az érintett adatokat tárolja ugyanazon a szegmensen, vagy valósítson meg végső konzisztenciát.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-441">Therefore, if your business logic needs to perform transactions, either store the affected data in the same shard or implement eventual consistency.</span></span> <span data-ttu-id="6ddd2-442">További információkat az [Adatkonzisztencia – Ismertető] szakaszban talál.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-442">For more information, see the [Data consistency primer].</span></span>
* <span data-ttu-id="6ddd2-443">A szegmenseket tárolja az azokban lévő adatokat használó felhasználók közelében (azaz ügyeljen a szegmensek megfelelő földrajzi elhelyezésére).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-443">Place shards close to the users that access the data in those shards (in other words, geo-locate the shards).</span></span> <span data-ttu-id="6ddd2-444">Ezzel a stratégiával csökkenthetők a késések.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-444">This strategy helps reduce latency.</span></span>
* <span data-ttu-id="6ddd2-445">Figyeljen arra, hogy ne legyenek egyszerre a rendszerben rendkívül aktív (kritikus pont) és viszonylag inaktív szegmensek is.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-445">Avoid having a mixture of highly active (hotspots) and relatively inactive shards.</span></span> <span data-ttu-id="6ddd2-446">Próbálja a terhelést egyenletesen elosztani a szegmensek között.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-446">Try to spread the load evenly across shards.</span></span> <span data-ttu-id="6ddd2-447">Ehhez kivonatalapú szegmenskulcsokra lehet szükség.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-447">This might require hashing the shardlet keys.</span></span>
* <span data-ttu-id="6ddd2-448">Ha a szegmensek földrajzi elhelyezkedése lényeges, gondoskodjon róla, hogy a kivonatalapú kulcsok az adatokat használó felhasználókhoz közeli szegmensekben tárolt shardletekre mutatnak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-448">If you are geo-locating shards, make sure that the hashed keys map to shardlets held in shards stored close to the users that access that data.</span></span>
* <span data-ttu-id="6ddd2-449">Jelenleg az SQL-adattípusok korlátozott halmaza használható csak shardletkulcsként: az *int, a bigint, a varbinary* és a *uniqueidentifier*.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-449">Currently, only a limited set of SQL data types are supported as shardlet keys; *int, bigint, varbinary,* and *uniqueidentifier*.</span></span> <span data-ttu-id="6ddd2-450">Az SQL *int* és *bigint* típusai a C# *int* és *long* adattípusainak felelnek meg, és ugyanazokkal a tartományokkal rendelkeznek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-450">The SQL *int* and *bigint* types correspond to the *int* and *long* data types in C#, and have the same ranges.</span></span> <span data-ttu-id="6ddd2-451">Az SQL *varbinary* típusa a C#-ban *Byte*-tömbökkel kezelhető, az SQL *uniqueidentier* típusa pedig a .NET-keretrendszer *Guid* osztályának felel meg.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-451">The SQL *varbinary* type can be handled by using a *Byte* array in C#, and the SQL *uniqueidentier* type corresponds to the *Guid* class in the .NET Framework.</span></span>

<span data-ttu-id="6ddd2-452">Ahogy a neve is mutatja, az Elastic Database (azaz rugalmas adatbázis) használatával az adatok mennyiségének növekedésének vagy csökkenésének megfelelően adhatók hozzá vagy távolíthatók el a szegmensek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-452">As the name implies, Elastic Database makes it possible for a system to add and remove shards as the volume of data shrinks and grows.</span></span> <span data-ttu-id="6ddd2-453">Az Azure SQL Database Elastic Database ügyfélkódtár API-jaival az alkalmazások dinamikusan hozhatnak létre és törölhetnek szegmenseket (és transzparens módon frissíthetik a szegmenstérkép-kezelőt).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-453">The APIs in the Azure SQL Database Elastic Database client library enable an application to create and delete shards dynamically (and transparently update the shard map manager).</span></span> <span data-ttu-id="6ddd2-454">A szegmensek eltávolítása azonban egy destruktív művelet, amelyet követően a szegmensben lévő összes adatot törölni kell.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-454">However, removing a shard is a destructive operation that also requires deleting all the data in that shard.</span></span>

<span data-ttu-id="6ddd2-455">Ha egy alkalmazásban fel kell osztani vagy egyesíteni kell a szegmenseket, az Elastic Database ehhez egy külön felosztási-egyesítési szolgáltatást kínál.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-455">If an application needs to split a shard into two separate shards or combine shards, Elastic Database provides a separate split-merge service.</span></span> <span data-ttu-id="6ddd2-456">Ez a szolgáltatás egy felhőben üzemeltetett szolgáltatáson fut (ezt a fejlesztőnek kell létrehoznia), és biztonságosan migrálja az adatokat a szegmensek közt.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-456">This service runs in a cloud-hosted service (which must be created by the developer) and migrates data safely between shards.</span></span> <span data-ttu-id="6ddd2-457">További információkat [Skálázás az Elastic Database felosztási-egyesítési eszközének használatával] témában talál a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-457">For more information, see the topic [Scaling using the Elastic Database split-merge tool] on the Microsoft website.</span></span>

## <a name="partitioning-strategies-for-azure-storage"></a><span data-ttu-id="6ddd2-458">Az Azure Storage particionálási stratégiái</span><span class="sxs-lookup"><span data-stu-id="6ddd2-458">Partitioning strategies for Azure Storage</span></span>
<span data-ttu-id="6ddd2-459">Az Azure Storage négy absztrakt entitást kínál az adatok kezeléséhez:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-459">Azure storage provides four abstractions for managing data:</span></span>

* <span data-ttu-id="6ddd2-460">A Blob Storage a strukturálatlan objektumadatokat tárolja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-460">Blob Storage stores unstructured object data.</span></span> <span data-ttu-id="6ddd2-461">Egy blob állhat bármilyen szövegből vagy bináris adatból, lehet például egy dokumentum, egy médiafájl vagy egy alkalmazástelepítő.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-461">A blob can be any type of text or binary data, such as a document, media file, or application installer.</span></span> <span data-ttu-id="6ddd2-462">A Blob Storage más néven Objektumtárnak is hívható.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-462">Blob storage is also referred to as Object storage.</span></span>
* <span data-ttu-id="6ddd2-463">A Table Storage a strukturált adatkészleteket tárolja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-463">Table Storage stores structured datasets.</span></span> <span data-ttu-id="6ddd2-464">A Table Storage a NoSQL-kulcsattribútumok adattára, amely gyors fejlesztési lehetőségeket és nagy adatmennyiségek gyors elérését biztosítja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-464">Table storage is a NoSQL key-attribute data store, which allows for rapid development and fast access to large quantities of data.</span></span>
* <span data-ttu-id="6ddd2-465">A Queue Storage megbízható üzenetküldést biztosít a munkafolyamat-feldolgozáshoz és a felhőszolgáltatás összetevői közötti kommunikációhoz.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-465">Queue Storage provides reliable messaging for workflow processing and for communication between components of cloud services.</span></span>
* <span data-ttu-id="6ddd2-466">A File Storage közös tárterületet biztosít a szabványos SMB-protokollt használó örökölt alkalmazások számára.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-466">File Storage offers shared storage for legacy applications using the standard SMB protocol.</span></span> <span data-ttu-id="6ddd2-467">Az Azure virtuális gépek és a felhőszolgáltatás csatlakoztatott megosztásokon keresztül adatokat oszthatnak meg az alkalmazások összetevői között, a helyszíni alkalmazások pedig a fájlszolgáltatás REST API-ján keresztül hozzáférhetnek a megosztott fájladatokhoz.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-467">Azure virtual machines and cloud services can share file data across application components via mounted shares, and on-premises applications can access file data in a share via the File service REST API.</span></span>

<span data-ttu-id="6ddd2-468">A táblatárolók és a blobtárolók lényegében kulcs-érték tárolók. A táblatárolók strukturált, a blobtárolók pedig strukturálatlan adatok tárolására vannak optimalizálva.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-468">Table storage and blob storage are essentially key-value stores that are optimized to hold structured and unstructured data respectively.</span></span> <span data-ttu-id="6ddd2-469">A tárolók üzenetsorai egy megfelelő mechanizmust biztosítanak a lazán kapcsolt, skálázható alkalmazások létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-469">Storage queues provide a mechanism for building loosely coupled, scalable applications.</span></span> <span data-ttu-id="6ddd2-470">A tábla-, fájl- és blobtárolók, valamint a tároló-üzenetsorok az Azure tárfiókok környezetében jönnek létre.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-470">Table storage, file storage, blob storage, and storage queues are created within the context of an Azure storage account.</span></span> <span data-ttu-id="6ddd2-471">A tárfiókok a redundancia három formáját támogatják:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-471">Storage accounts support three forms of redundancy:</span></span>

* <span data-ttu-id="6ddd2-472">A **helyileg redundáns tárolás** az adatokat három példányban tárolja egyetlen adatközponton belül.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-472">**Locally redundant storage**, which maintains three copies of data within a single datacenter.</span></span> <span data-ttu-id="6ddd2-473">Az ilyen típusú redundancia a hardverhibákkal szemben védelmet nyújt, az olyan katasztrófák esetén azonban nem, amelyek az egész adatközpontot érintik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-473">This form of redundancy protects against hardware failure but not against a disaster that encompasses the entire datacenter.</span></span>
* <span data-ttu-id="6ddd2-474">A **zónaredundáns tárolás** az adatokat három példányban tárolja különböző adatközpontokban ugyanabban a régióban (vagy két földrajzilag egymás közelében lévő régióban).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-474">**Zone-redundant storage**, which maintains three copies of data spread across different datacenters within the same region (or across two geographically close regions).</span></span> <span data-ttu-id="6ddd2-475">Az ilyen típusú redundancia védelmet nyújt a teljes adatközpontot érintő katasztrófákkal szemben, egy teljes régiót érintő, nagy hálózati kimaradások esetén azonban nem.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-475">This form of redundancy can protect against disasters that occur within a single datacenter, but cannot protect against large-scale network disconnects that affect an entire region.</span></span> <span data-ttu-id="6ddd2-476">Megjegyzendő, hogy a zónaredundáns tárolás jelenleg csak blokkblobok esetén érhető el.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-476">Note that zone-redundant storage is currently only available for block blobs.</span></span>
* <span data-ttu-id="6ddd2-477">A **georedundáns tárolás** az adatokat hat példányban tárolja: három példányt egy adott régióban (a helyi régióban), és másik három példányt egy távoli régióban.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-477">**Geo-redundant storage**, which maintains six copies of data: three copies in one region (your local region), and another three copies in a remote region.</span></span> <span data-ttu-id="6ddd2-478">Az ilyen típusú redundancia a legmagasabb szintű katasztrófavédelmet biztosítja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-478">This form of redundancy provides the highest level of disaster protection.</span></span>

<span data-ttu-id="6ddd2-479">A Microsoft közzétett skálázhatósági célokat az Azure Storage-re vonatkozóan.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-479">Microsoft has published scalability targets for Azure Storage.</span></span> <span data-ttu-id="6ddd2-480">További információkat [Az Azure Storage skálázhatósági és teljesítménycéljai] bemutató oldalon talál a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-480">For more information, see the page [Azure Storage scalability and performance targets] on the Microsoft website.</span></span> <span data-ttu-id="6ddd2-481">A teljes tárfiók-kapacitás jelenleg legfeljebb 500 TB lehet.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-481">Currently, the total storage account capacity cannot exceed 500 TB.</span></span> <span data-ttu-id="6ddd2-482">(Ez a tábla-, fiók- és blobtárolókban tárolt adatokat, valamint a tároló-üzenetsorokban található nem feldolgozott üzeneteket foglalja magában.)</span><span class="sxs-lookup"><span data-stu-id="6ddd2-482">(This includes the size of data that's held in table storage, file storage and blob storage, as well as outstanding messages that are held in storage queue).</span></span>

<span data-ttu-id="6ddd2-483">A tárfiókok maximális kérelemsebessége (1 KB-os entitás-, blob- vagy üzenetméretet feltételezve) másodpercenként 20 000 kérelem.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-483">The maximum request rate for a storage account (assuming a 1-KB entity, blob, or message size) is 20,000 requests per second.</span></span> <span data-ttu-id="6ddd2-484">A tárfiók maximális IOPS-korlátja fájlmegosztásonként legfeljebb 1000 (8 KB-os mérettel).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-484">A storage account has a maximum of 1000 IOPS (8 KB in size) per file share.</span></span> <span data-ttu-id="6ddd2-485">Ha a rendszer várhatóan meghaladja majd ezeket a korlátokat, vegye fontolóra a terhelés elosztását több tárfiókra.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-485">If your system is likely to exceed these limits, consider partitioning the load across multiple storage accounts.</span></span> <span data-ttu-id="6ddd2-486">Egyetlen Azure-előfizetés alatt legfeljebb 200 tárfiók hozható létre.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-486">A single Azure subscription can create up to 200 storage accounts.</span></span> <span data-ttu-id="6ddd2-487">Ezek a korlátok azonban idővel változhatnak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-487">However, note that these limits might change over time.</span></span>

## <a name="partitioning-azure-table-storage"></a><span data-ttu-id="6ddd2-488">Az Azure Table Storage particionálása</span><span class="sxs-lookup"><span data-stu-id="6ddd2-488">Partitioning Azure table storage</span></span>
<span data-ttu-id="6ddd2-489">Az Azure Table Storage egy particionálási célokra kifejlesztett kulcs-érték tároló.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-489">Azure table storage is a key-value store that's designed around partitioning.</span></span> <span data-ttu-id="6ddd2-490">Minden entitás tárolása egy partícióban történik, és a partíciókat belsőleg az Azure Table Storage kezeli.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-490">All entities are stored in a partition, and partitions are managed internally by Azure table storage.</span></span> <span data-ttu-id="6ddd2-491">A táblákban tárolt minden entitásnak meg kell adnia egy kétrészes kulcsot, amely a következőkből épül fel:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-491">Each entity that's stored in a table must provide a two-part key that includes:</span></span>

* <span data-ttu-id="6ddd2-492">**A partíciókulcs**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-492">**The partition key**.</span></span> <span data-ttu-id="6ddd2-493">Ez egy sztringérték, amely azt adja meg, hogy az Azure Table Storage melyik partícióba helyezi az entitást.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-493">This is a string value that determines in which partition Azure table storage will place the entity.</span></span> <span data-ttu-id="6ddd2-494">Az azonos partíciókulccsal rendelkező entitások mind ugyanazon a partíción találhatók.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-494">All entities with the same partition key will be stored in the same partition.</span></span>
* <span data-ttu-id="6ddd2-495">**A sorkulcs**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-495">**The row key**.</span></span> <span data-ttu-id="6ddd2-496">Ez egy másik sztringérték, amely az entitást azonosítja a partíción belül.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-496">This is another string value that identifies the entity within the partition.</span></span> <span data-ttu-id="6ddd2-497">A partícióban lévő entitások a sorkulcs alapján vannak növekvő betűrendbe rendezve.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-497">All entities within a partition are sorted lexically, in ascending order, by this key.</span></span> <span data-ttu-id="6ddd2-498">Minden egyes entitásnak egyedi partíciókulcs-sorkulcs kombinációval kell rendelkeznie, amelynek a hossza legfeljebb 1 KB lehet.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-498">The partition key/row key combination must be unique for each entity and cannot exceed 1 KB in length.</span></span>

<span data-ttu-id="6ddd2-499">Az entitásokhoz tartozó többi adat az alkalmazás által meghatározott mezőket tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-499">The remainder of the data for an entity consists of application-defined fields.</span></span> <span data-ttu-id="6ddd2-500">Nincs semmilyen séma kikényszerítve, és minden egyes sor más és más alkalmazás-specifikus mezők halmazát tartalmazhatja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-500">No particular schemas are enforced, and each row can contain a different set of application-defined fields.</span></span> <span data-ttu-id="6ddd2-501">Az egyetlen megkötés, hogy az egyes entitások maximális mérete (beleértve a partíció- és sorkulcsot is) jelenleg legfeljebb 1 MB lehet.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-501">The only limitation is that the maximum size of an entity (including the partition and row keys) is currently 1 MB.</span></span> <span data-ttu-id="6ddd2-502">A tábla maximális mérete 200 TB, bár ezek az értékek a későbbiekben változhatnak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-502">The maximum size of a table is 200 TB, although these figures might change in the future.</span></span> <span data-ttu-id="6ddd2-503">(A korlátokkal kapcsolatos legfrissebb információkat [Az Azure Storage skálázhatósági és teljesítménycéljai] bemutató oldalon ellenőrizheti a Microsoft webhelyén.)</span><span class="sxs-lookup"><span data-stu-id="6ddd2-503">(Check the page [Azure Storage scalability and performance targets] on the Microsoft website for the most recent information about these limits.)</span></span>

<span data-ttu-id="6ddd2-504">Amennyiben ezt meghaladó méretű entitásokat próbál letárolni, esetleg több táblára felosztva teheti ezt meg.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-504">If you are attempting to store entities that exceed this capacity, then consider splitting them into multiple tables.</span></span> <span data-ttu-id="6ddd2-505">Vertikális particionálás használatával ossza fel a mezőket csoportokra aszerint, hogy várhatóan melyik mezőkhöz férnek hozzá együtt.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-505">Use vertical partitioning to divide the fields into the groups that are most likely to be accessed together.</span></span>

<span data-ttu-id="6ddd2-506">A 7. ábra egy fiktív e-kereskedelmi alkalmazás példatárfiókjának (Contoso Data) logikai szerkezetét mutatja be.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-506">Figure 7 shows the logical structure of an example storage account (Contoso Data) for a fictitious e-commerce application.</span></span> <span data-ttu-id="6ddd2-507">A tárfiók három táblát tartalmaz: Customer Info (ügyféladatok), Product Info (termékadatok) és Order Info (megrendelésadatok).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-507">The storage account contains three tables: Customer Info, Product Info, and Order Info.</span></span> <span data-ttu-id="6ddd2-508">Mindegyik tábla több partíciót tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-508">Each table has multiple partitions.</span></span>

<span data-ttu-id="6ddd2-509">A Customer Info táblában az adatok a felhasználó városa szerint vannak particionálva, a sorkulcs pedig az ügyfél-azonosító.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-509">In the Customer Info table, the data is partitioned according to the city in which the customer is located, and the row key contains the customer ID.</span></span> <span data-ttu-id="6ddd2-510">A Product Info táblában a termékek a termékkategória szerint vannak particionálva, a sorkulcs pedig a termékszám.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-510">In the Product Info table, the products are partitioned by product category, and the row key contains the product number.</span></span> <span data-ttu-id="6ddd2-511">Az Order Info táblában a megrendelések a feladásuk dátuma szerint vannak particionálva, a sorkulcs pedig a megrendelések fogadásának időpontja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-511">In the Order Info table, the orders are partitioned by the date on which they were placed, and the row key specifies the time the order was received.</span></span> <span data-ttu-id="6ddd2-512">Az adatok az egyes partíciókban a sorkulcs alapján vannak rendezve.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-512">Note that all data is ordered by the row key in each partition.</span></span>

![Táblák és partíciók egy példatárfiókban](./images/data-partitioning/TableStorage.png)

<span data-ttu-id="6ddd2-514">*7. ábra Táblák és partíciók egy példatárfiókban*</span><span class="sxs-lookup"><span data-stu-id="6ddd2-514">*Figure 7. The tables and partitions in an example storage account*</span></span>

> [!NOTE]
> <span data-ttu-id="6ddd2-515">Az Azure Table Storage minden entitáshoz felvesz egy időbélyegmezőt is.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-515">Azure table storage also adds a timestamp field to each entity.</span></span> <span data-ttu-id="6ddd2-516">Az időbélyegmezőt a Table Storage tartja karban, és minden alkalommal frissíti, amikor az entitást módosítják és visszaírják valamelyik partícióba.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-516">The timestamp field is maintained by table storage and is updated each time the entity is modified and written back to a partition.</span></span> <span data-ttu-id="6ddd2-517">A Table Storage szolgáltatás ennek a mezőnek a használatával valósítja meg az optimista egyidejűséget.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-517">The table storage service uses this field to implement optimistic concurrency.</span></span> <span data-ttu-id="6ddd2-518">(Minden alkalommal, amikor az alkalmazás visszaírja valamelyik entitást a táblatárolóba, a Table Storage szolgáltatás összehasonlítja az entitás időbélyegzőjének értékét a táblatárolóban tárolt értékkel.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-518">(Each time an application writes an entity back to table storage, the table storage service compares the value of the timestamp in the entity that's being written with the value that's held in table storage.</span></span> <span data-ttu-id="6ddd2-519">Ha az értékek különböznek, ez azt jelenti, hogy egy másik alkalmazás módosította az entitást annak utolsó lekérése óta, és az írási művelet meghiúsul.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-519">If the values are different, it means that another application must have modified the entity since it was last retrieved, and the write operation fails.</span></span> <span data-ttu-id="6ddd2-520">Ne módosítsa ezt a mezőt az alkalmazás saját kódjában, és ne is adja meg az értékét az új entitások létrehozásakor.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-520">Don't modify this field in your own code, and don't specify a value for this field when you create a new entity.</span></span>
>
>

<span data-ttu-id="6ddd2-521">Az Azure Table Storage a partíciókulcs alapján határozza meg az adatok tárolásának módját.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-521">Azure table storage uses the partition key to determine how to store the data.</span></span> <span data-ttu-id="6ddd2-522">Ha egy korábban nem használt partíciókulccsal rendelkező entitást vesz fel egy táblába, az Azure Table Storage egy új partíciót hoz létre az entitás számára.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-522">If an entity is added to a table with a previously unused partition key, Azure table storage creates a new partition for this entity.</span></span> <span data-ttu-id="6ddd2-523">Az ezzel a partíciókulccsal rendelkező többi entitás is ugyanezen a partíción lesz tárolva.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-523">Other entities with the same partition key will be stored in the same partition.</span></span>

<span data-ttu-id="6ddd2-524">Ez az eljárás lényegében egy automatikus horizontális felskálázási stratégiát valósít meg.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-524">This mechanism effectively implements an automatic scale-out strategy.</span></span> <span data-ttu-id="6ddd2-525">Mindegyik partíció egyetlen kiszolgálón helyezkedik el az Azure-adatközpontban annak biztosításához, hogy az adatokat egyetlen partícióról lekérő lekérdezések gyorsan futhassanak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-525">Each partition is stored on a single server in an Azure datacenter to help ensure that queries that retrieve data from a single partition run quickly.</span></span> <span data-ttu-id="6ddd2-526">A különböző partíciók azonban esetleg több kiszolgálóra annak leosztva.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-526">However, different partitions can be distributed across multiple servers.</span></span> <span data-ttu-id="6ddd2-527">Emellett egyetlen kiszolgáló több partíciót is futtathat, ha a partíciók mérete korlátozva van.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-527">Additionally, a single server can host multiple partitions if these partitions are limited in size.</span></span>

<span data-ttu-id="6ddd2-528">Az Azure Table Storage-ben használt entitások kialakításakor vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-528">Consider the following points when you design your entities for Azure table storage:</span></span>

* <span data-ttu-id="6ddd2-529">A partíciókulcs és a sorkulcs értékeit az adatelérés módja alapján kell meghatározni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-529">The selection of partition key and row key values should be driven by the way in which the data is accessed.</span></span> <span data-ttu-id="6ddd2-530">Válasszon olyan partíciókulcs-sorkulcs kombinációt, amely a lekérdezések nagyobb részét támogatja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-530">Choose a partition key/row key combination that supports the majority of your queries.</span></span> <span data-ttu-id="6ddd2-531">A leghatékonyabb lekérdezések a partíciókulcs és a sorkulcs megadásával kérik le az adatokat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-531">The most efficient queries retrieve data by specifying the partition key and the row key.</span></span> <span data-ttu-id="6ddd2-532">Az egy partíciókulcsot és a sorkulcsok egy tartományát megadó lekérdezések egy partíció vizsgálatával hajthatók végre.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-532">Queries that specify a partition key and a range of row keys can be completed by scanning a single partition.</span></span> <span data-ttu-id="6ddd2-533">Ez viszonylag gyorsan megy, mivel az adatok a sorkulcs szerint vannak rendezve.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-533">This is relatively fast because the data is held in row key order.</span></span> <span data-ttu-id="6ddd2-534">Ha a lekérdezésben nincs megadva, hogy melyik partíciót kell átvizsgálni, a partíciókulcs alapján az Azure Table Storage-nek esetleg minden partíciót át kell vizsgálnia az adatok után.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-534">If queries don't specify which partition to scan, the partition key might require Azure table storage to scan every partition for your data.</span></span>

  > [!TIP]
  > <span data-ttu-id="6ddd2-535">Ha valamely entitás természetes kulccsal rendelkezik, használja azt partíciókulcsként, és adjon meg egy üres sztringet sorkulcsként.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-535">If an entity has one natural key, then use it as the partition key and specify an empty string as the row key.</span></span> <span data-ttu-id="6ddd2-536">Ha egy entitás két tulajdonságból álló összetett kulccsal rendelkezik, használja a ritkábban változó tulajdonságot partíciókulcsként, a másikat pedig sorkulcsként.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-536">If an entity has a composite key comprising two properties, select the slowest changing property as the partition key and the other as the row key.</span></span> <span data-ttu-id="6ddd2-537">Ha egy entitás kettőnél több kulcstulajdonsággal rendelkezik, a tulajdonságok összefűzésével adja meg a partíció- és a sorkulcsot.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-537">If an entity has more than two key properties, use a concatenation of properties to provide the partition and row keys.</span></span>
  >
  >
* <span data-ttu-id="6ddd2-538">Ha rendszeresen hajt végre olyan lekérdezéseket, amelyek a partíció- és a sorkulcstól eltérő mezők alapján keresik az adatokat, vegye fontolóra az [Indextábla minta] használatát.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-538">If you regularly perform queries that look up data by using fields other than the partition and row keys, consider implementing the [index table pattern].</span></span>
* <span data-ttu-id="6ddd2-539">Ha a partíciókulcsokat egy monoton növekvő vagy csökkenő sorozat alapján (például 0001, 0002, 0003 és így tovább) hozza létre, és minden partíció csak korlátozott mennyiségű adatot tartalmaz, az Azure Table Storage képes fizikailag csoportosítani ezeket a partíciókat egyazon kiszolgálóra.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-539">If you generate partition keys by using a monotonic increasing or decreasing sequence (such as "0001", "0002", "0003", and so on) and each partition only contains a limited amount of data, then Azure table storage can physically group these partitions together on the same server.</span></span> <span data-ttu-id="6ddd2-540">Ez a mechanizmus feltételezi, hogy az alkalmazás valószínűleg partíciók egymást követő összefüggő tartományán hajtja majd végre a lekérdezéseket (tartománylekérdezések), és erre a forgatókönyvre van optimalizálva.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-540">This mechanism assumes that the application is most likely to perform queries across a contiguous range of partitions (range queries) and is optimized for this case.</span></span> <span data-ttu-id="6ddd2-541">Ez a megközelítés azonban kritikus pontokat eredményezhet egyes kiszolgálók körül, mivel az új entitások beszúrása valószínűleg az összefüggő tartomány egyik vagy másik végén koncentrálódik majd.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-541">However, this approach can lead to hotspots focused on a single server because all insertions of new entities are likely to be concentrated at one end or the other of the contiguous ranges.</span></span> <span data-ttu-id="6ddd2-542">Emellett a skálázhatóságot is csökkentheti.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-542">It can also reduce scalability.</span></span> <span data-ttu-id="6ddd2-543">A terhelés kiszolgálók közötti egyenletesebb elosztása érdekében érdemes kivonatolnia a partíciókulcsot, hogy a sorozat véletlenszerűbb legyen.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-543">To spread the load more evenly across servers, consider hashing the partition key to make the sequence more random.</span></span>
* <span data-ttu-id="6ddd2-544">Az Azure Table Storage támogatja a tranzakciós műveletek végrehajtását az egyazon partíción lévő entitásokon.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-544">Azure table storage supports transactional operations for entities that belong to the same partition.</span></span> <span data-ttu-id="6ddd2-545">Ez azt jelenti, hogy az alkalmazás egyidejűleg több beszúrás, frissítés, törlés, csere vagy egyesítés műveletet hajthat végre egyetlen elemi egységként (feltéve, hogy a tranzakció nem tartalmaz 100-nál több entitást és a kérelem hasznos adattartalma nem haladja meg a 4 MB méretet).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-545">This means that an application can perform multiple insert, update, delete, replace, or merge operations as an atomic unit (as long as the transaction doesn't include more than 100 entities and the payload of the request doesn't exceed 4 MB).</span></span> <span data-ttu-id="6ddd2-546">A több partíciót érintő műveletek nem tranzakciószintűek, és ezért lehetséges, hogy végső konzisztenciát kell megvalósítania az [Adatkonzisztencia – Ismertető] szakaszban leírtak szerint.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-546">Operations that span multiple partitions are not transactional, and might require you to implement eventual consistency as described by the [Data consistency primer].</span></span> <span data-ttu-id="6ddd2-547">A Table Storage és a tranzakciók részletesebb leírását a Microsoft webhelyén, [Entitáscsoport-tranzakciók végrehajtása] foglalkozó oldalon találja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-547">For more information about table storage and transactions, go to the page [Performing entity group transactions] on the Microsoft website.</span></span>
* <span data-ttu-id="6ddd2-548">Gondosan mérlegelje a partíciókulcs részletességét a következő okok miatt:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-548">Give careful attention to the granularity of the partition key because of the following reasons:</span></span>
  * <span data-ttu-id="6ddd2-549">Ha minden entitás ugyanazzal a partíciókulccsal rendelkezik, a Table Storage szolgáltatás egyetlen nagy partíciót hoz létre egyetlen kiszolgálón.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-549">Using the same partition key for every entity causes the table storage service to create a single large partition that's held on one server.</span></span> <span data-ttu-id="6ddd2-550">Ez megakadályozza a horizontális felskálázást, és a terhelés egy kiszolgálóra összpontosul.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-550">This prevents it from scaling out and instead focuses the load on a single server.</span></span> <span data-ttu-id="6ddd2-551">Ez a megközelítés ezért csak olyan rendszerekhez alkalmas, amelyek kis számú entitást kezelnek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-551">As a result, this approach is only suitable for systems that manage a small number of entities.</span></span> <span data-ttu-id="6ddd2-552">Mindazonáltal ez a megközelítés biztosítja, hogy valamennyi entitás részt vehet entitáscsoport-tranzakciókban.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-552">However, this approach does ensure that all entities can participate in entity group transactions.</span></span>
  * <span data-ttu-id="6ddd2-553">Ha minden entitás egyedi partíciókulccsal rendelkezik, a Table Storage szolgáltatás egy külön partíciót hoz létre mindegyik entitás számára, és így nagy számú kis partíció keletkezhet (az entitások méretétől függően).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-553">Using a unique partition key for every entity causes the table storage service to create a separate partition for each entity, possibly resulting in a large number of small partitions (depending on the size of the entities).</span></span> <span data-ttu-id="6ddd2-554">Ez a megközelítés jobban skálázható, mint az, amelyik egyetlen partíciókulcsot használ, de az entitáscsoportokon végzett tranzakciók nem lehetségesek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-554">This approach is more scalable than using a single partition key, but entity group transactions are not possible.</span></span> <span data-ttu-id="6ddd2-555">Emellett a több entitást érintő lekérdezések esetén esetleg több kiszolgálót is olvasni kell.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-555">Also, queries that fetch more than one entity might involve reading from more than one server.</span></span> <span data-ttu-id="6ddd2-556">Azonban ha az alkalmazás tartománylekérdezéseket végez, a lekérdezések optimalizálhatóak, ha a partíciókulcsokat monoton sorozat mentén hozza létre.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-556">However, if the application performs range queries, then using a monotonic sequence to generate the partition keys might help to optimize these queries.</span></span>
  * <span data-ttu-id="6ddd2-557">Ha az entitások egy részhalmazához ugyanazt a partíciókulcsot használja, a kapcsolódó entitások egy partícióba csoportosíthatóak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-557">Sharing the partition key across a subset of entities makes it possible for you to group related entities in the same partition.</span></span> <span data-ttu-id="6ddd2-558">A kapcsolódó entitásokat érintő műveletek végrehajthatók entitáscsoport-tranzakciók használatával, és a több kapcsolódó entitást olvasó lekérdezések egyetlen kiszolgáló elérésével teljesíthetőek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-558">Operations that involve related entities can be performed by using entity group transactions, and queries that fetch a set of related entities can be satisfied by accessing a single server.</span></span>

<span data-ttu-id="6ddd2-559">Az adatok Azure Table Storage-ben való particionálásra vonatkozó további információkat [Az Azure Storage Table tervezési útmutatója] találja a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-559">For additional information about partitioning data in Azure table storage, see the article [Azure storage table design guide] on the Microsoft website.</span></span>

## <a name="partitioning-azure-blob-storage"></a><span data-ttu-id="6ddd2-560">Az Azure Blob Storage particionálása</span><span class="sxs-lookup"><span data-stu-id="6ddd2-560">Partitioning Azure blob storage</span></span>
<span data-ttu-id="6ddd2-561">Az Azure Blob Storage segítségével nagyméretű bináris objektumok tárolhatóak – jelenleg akár 5 TB méretű blokkblobok vagy 1 TB méretű lapblobok.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-561">Azure blob storage makes it possible to hold large binary objects--currently up to 5 TB in size for block blobs or 1 TB for page blobs.</span></span> <span data-ttu-id="6ddd2-562">(A legfrissebb információkat [Az Azure Storage skálázhatósági és teljesítménycéljai] bemutató oldalon ellenőrizheti a Microsoft webhelyén.) A blokkblobok olyan forgatókönyvekben használhatóak, ahol nagy mennyiségű adatot kell gyorsan fel- vagy letölteni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-562">(For the most recent information, go to the page [Azure Storage scalability and performance targets] on the Microsoft website.) Use block blobs in scenarios such as streaming where you need to upload or download large volumes of data quickly.</span></span> <span data-ttu-id="6ddd2-563">A lapblobok olyan alkalmazásokban használhatóak, ahol nem sorban, hanem véletlenszerűen kell elérni az adathalmaz egyes részeit.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-563">Use page blobs for applications that require random rather than serial access to parts of the data.</span></span>

<span data-ttu-id="6ddd2-564">Minden blob (blokk vagy lap) külön tárolóban található egy Azure-tárfiókban.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-564">Each blob (either block or page) is held in a container in an Azure storage account.</span></span> <span data-ttu-id="6ddd2-565">A tárolók használatával csoportokba rendezhetőek a hasonló biztonsági követelményekkel rendelkező kapcsolódó blobok.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-565">You can use containers to group related blobs that have the same security requirements.</span></span> <span data-ttu-id="6ddd2-566">A csoportosítás nem fizikai, hanem logikai alapon történik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-566">This grouping is logical rather than physical.</span></span> <span data-ttu-id="6ddd2-567">A tárolókon belül minden egyes blob egyedi névvel rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-567">Inside a container, each blob has a unique name.</span></span>

<span data-ttu-id="6ddd2-568">A blobok partíciókulcsa a fiók neve + a tároló neve + a blob neve.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-568">The partition key for a blob is account name + container name + blob name.</span></span> <span data-ttu-id="6ddd2-569">Ez azt jelenti, hogy minden egyes blob saját partícióval rendelkezhet, ha a blob terhelése megköveteli.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-569">This means each blob can have its own partition if load on the blob demands it.</span></span> <span data-ttu-id="6ddd2-570">A blobok leoszthatóak több kiszolgálóra a hozzáférés horizontális felskálázása érdekében, egy blobot azonban csak egyetlen kiszolgáló szolgálhat ki.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-570">Blobs can be distributed across many servers in order to scale out access to them, but a single blob can only be served by a single server.</span></span> 

<span data-ttu-id="6ddd2-571">Az egyetlen blokk (blokkblob) vagy lap (lapblob) írására vonatkozó műveletek elemiek, a több blokkra, lapra vagy blobra vonatkozóak azonban nem elemiek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-571">The actions of writing a single block (block blob) or page (page blob) are atomic, but operations that span blocks, pages, or blobs are not.</span></span> <span data-ttu-id="6ddd2-572">Ha biztosítania kell a blokkokon, lapokon és blobokon végzett írási műveletek során a konzisztenciát, blobbérlet alkalmazásával zárolhatja az írásukat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-572">If you need to ensure consistency when performing write operations across blocks, pages, and blobs, take out a write lock by using a blob lease.</span></span>

<span data-ttu-id="6ddd2-573">Az Azure Blob Storage átviteli sebességre vonatkozó célértéke blobonként 60 MB vagy 500 kérelem másodpercenként.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-573">Azure blob storage targets transfer rates of up to 60 MB per second or 500 requests per second for each blob.</span></span> <span data-ttu-id="6ddd2-574">Ha várhatóan túllépi ezeket a korlátokat, és a blobban lévő adatok viszonylag statikusak, érdemes lehet az Azure Content Delivery Network használatával replikálni a blobokat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-574">If you anticipate surpassing these limits, and the blob data is relatively static, then consider replicating blobs by using the Azure Content Delivery Network.</span></span> <span data-ttu-id="6ddd2-575">További információkat az [Azure Content Delivery Network] oldalon talál a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-575">For more information, see the page [Azure Content Delivery Network] on the Microsoft website.</span></span> <span data-ttu-id="6ddd2-576">További útmutatást és szempontokat [Az Azure Content Delivery Network használata] ismertető cikkben talál.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-576">For additional guidance and considerations, see [Using Azure Content Delivery Network].</span></span>

## <a name="partitioning-azure-storage-queues"></a><span data-ttu-id="6ddd2-577">Az Azure tároló-üzenetsorok particionálása</span><span class="sxs-lookup"><span data-stu-id="6ddd2-577">Partitioning Azure storage queues</span></span>
<span data-ttu-id="6ddd2-578">Az Azure tároló-üzenetsorok használatával folyamatok közötti aszinkron üzenetkezelés valósítható meg.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-578">Azure storage queues enable you to implement asynchronous messaging between processes.</span></span> <span data-ttu-id="6ddd2-579">Minden egyes Azure-tárfiók korlátlan számú üzenetsort, és mindegyik üzenetsor korlátlan számú üzenetet tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-579">An Azure storage account can contain any number of queues, and each queue can contain any number of messages.</span></span> <span data-ttu-id="6ddd2-580">Az egyetlen korlát a tárfiókban rendelkezésre álló hely mennyisége.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-580">The only limitation is the space that's available in the storage account.</span></span> <span data-ttu-id="6ddd2-581">Egy egyes üzenetek maximális mérete 64 KB.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-581">The maximum size of an individual message is 64 KB.</span></span> <span data-ttu-id="6ddd2-582">Ha ennél nagyobb méretű üzenetekre van szüksége, vegye fontolóra az Azure Service Bus-üzenetsorok használatát.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-582">If you require messages bigger than this, then consider using Azure Service Bus queues instead.</span></span>

<span data-ttu-id="6ddd2-583">Minden egyes üzenetsor egyedi névvel rendelkezik a tárfiókon belül, amelyben található.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-583">Each storage queue has a unique name within the storage account that contains it.</span></span> <span data-ttu-id="6ddd2-584">Az Azure név alapján particionálja az üzenetsorokat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-584">Azure partitions queues based on the name.</span></span> <span data-ttu-id="6ddd2-585">Az egy üzenetsorba tartozó üzeneteket egy partíció tárolja, amelyet egy kiszolgáló vezérel.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-585">All messages for the same queue are stored in the same partition, which is controlled by a single server.</span></span> <span data-ttu-id="6ddd2-586">A különböző üzenetsorok a terhelés elosztása érdekében futtathatók külön kiszolgálókon.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-586">Different queues can be managed by different servers to help balance the load.</span></span> <span data-ttu-id="6ddd2-587">Az üzenetsorok kiszolgálókra való leosztása az alkalmazások és a felhasználók számára transzparens módon történik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-587">The allocation of queues to servers is transparent to applications and users.</span></span>

 <span data-ttu-id="6ddd2-588">A nagy alkalmazásokban ne ugyanazt az üzenetsort használja az alkalmazás összes példányához, mivel így az üzenetsort futtató kiszolgáló kritikus ponttá válhat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-588">In a large-scale application, don't use the same storage queue for all instances of the application because this approach might cause the server that's hosting the queue to become a hotspot.</span></span> <span data-ttu-id="6ddd2-589">Használjon inkább külön üzenetsorokat az alkalmazás különböző funkcionális területei szerint.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-589">Instead, use different queues for different functional areas of the application.</span></span> <span data-ttu-id="6ddd2-590">Az Azure tároló-üzenetsorok nem támogatják a tranzakciókat, ezért ha az üzeneteket külön üzenetsorokra irányítja, ez nem befolyásolja az üzenetkonzisztenciát.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-590">Azure storage queues do not support transactions, so directing messages to different queues should have little impact on messaging consistency.</span></span>

<span data-ttu-id="6ddd2-591">Az egyes Azure tároló-üzenetsorok másodpercenként 2000 üzenetet képesek feldolgozni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-591">An Azure storage queue can handle up to 2,000 messages per second.</span></span>  <span data-ttu-id="6ddd2-592">Ha ennél nagyobb sebességre van szüksége, érdemes több üzenetsort létrehoznia.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-592">If you need to process messages at a greater rate than this, consider creating multiple queues.</span></span> <span data-ttu-id="6ddd2-593">Például egy globális alkalmazás esetében hozzon létre külön tároló-üzenetsorokat külön tárfiókokban az egyes régiókban futó alkalmazáspéldányok kezelésére.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-593">For example, in a global application, create separate storage queues in separate storage accounts to handle application instances that are running in each region.</span></span>

## <a name="partitioning-strategies-for-azure-service-bus"></a><span data-ttu-id="6ddd2-594">Az Azure Service Bus particionálási stratégiái</span><span class="sxs-lookup"><span data-stu-id="6ddd2-594">Partitioning strategies for Azure Service Bus</span></span>
<span data-ttu-id="6ddd2-595">Az Azure Service Bus egy üzenetközvetítő használatával dolgozza fel a Service Bus-üzenetsorokra vagy -témakörökbe küldött üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-595">Azure Service Bus uses a message broker to handle messages that are sent to a Service Bus queue or topic.</span></span> <span data-ttu-id="6ddd2-596">Alapértelmezés szerint az üzenetsorra vagy témakörbe küldött összes üzenetet ugyanaz az üzenetközvetítő folyamat kezeli.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-596">By default, all messages that are sent to a queue or topic are handled by the same message broker process.</span></span> <span data-ttu-id="6ddd2-597">Az ilyen architektúra korlátozhatja az üzenetsor teljes feldolgozási sebességét.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-597">This architecture can place a limitation on the overall throughput of the message queue.</span></span> <span data-ttu-id="6ddd2-598">Az üzenetsorok és témakörök azonban a létrehozásukkor particionálhatóak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-598">However, you can also partition a queue or topic when it is created.</span></span> <span data-ttu-id="6ddd2-599">Ezt az üzenetsor vagy témakör *EnablePartitioning* tulajdonságának *true* értékre állításával teheti meg.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-599">You do this by setting the *EnablePartitioning* property of the queue or topic description to *true*.</span></span>

<span data-ttu-id="6ddd2-600">A particionált üzenetsor vagy témakör több töredékre osztható fel, amelyek mindegyikét egy külön üzenettár és üzenetközvetítő szolgálja ki.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-600">A partitioned queue or topic is divided into multiple fragments, each of which is backed by a separate message store and message broker.</span></span> <span data-ttu-id="6ddd2-601">A töredékek létrehozása és felügyelete a Service Bus feladata.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-601">Service Bus takes responsibility for creating and managing these fragments.</span></span> <span data-ttu-id="6ddd2-602">Amikor egy alkalmazás üzenetet küld egy particionált üzenetsorra vagy témakörbe, a Service Bus hozzárendeli az üzenetet az üzenetsor vagy témakör valamelyik töredékéhez.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-602">When an application posts a message to a partitioned queue or topic, Service Bus assigns the message to a fragment for that queue or topic.</span></span> <span data-ttu-id="6ddd2-603">Amikor egy alkalmazás üzenetet fogad egy üzenetsorról vagy előfizetésről, a Service Bus az összes töredékben ellenőrzi, hogy melyik a következő elérhető üzenet, és azt továbbítja az alkalmazásba feldolgozásra.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-603">When an application receives a message from a queue or subscription, Service Bus checks each fragment for the next available message and then passes it to the application for processing.</span></span>

<span data-ttu-id="6ddd2-604">Ez a struktúra segít elosztani a terhelést az üzenetközvetítők és üzenettárak közt, így növeli a skálázhatóságot és javítja a rendelkezésre állást.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-604">This structure helps distribute the load across message brokers and message stores, increasing scalability and improving availability.</span></span> <span data-ttu-id="6ddd2-605">Ha valamelyik töredék üzenetközvetítője vagy üzenettára átmenetileg nem érhető el, a Service Bus a többi elérhető töredék valamelyikéből ki tudja olvasni az üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-605">If the message broker or message store for one fragment is temporarily unavailable, Service Bus can retrieve messages from one of the remaining available fragments.</span></span>

<span data-ttu-id="6ddd2-606">A Service Bus az üzeneteket az alábbiak szerint osztja le a töredékekre:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-606">Service Bus assigns a message to a fragment as follows:</span></span>

* <span data-ttu-id="6ddd2-607">Ha az üzenet egy munkamenet részét képezi, az azonos értékű *SessionId* tulajdonsággal rendelkező üzenetek ugyanarra a töredékre lesznek küldve.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-607">If the message belongs to a session, all messages with the same value for the \* SessionId\*  property are sent to the same fragment.</span></span>
* <span data-ttu-id="6ddd2-608">Ha az üzenet nem képezi munkamenet részét, de a feladó megadta a *PartitionKey* tulajdonság értéket, az összes azonos *PartitionKey* értékű üzenet ugyanarra a töredékre lesz küldve.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-608">If the message does not belong to a session, but the sender has specified a value for the *PartitionKey* property, then all messages with the same *PartitionKey* value are sent to the same fragment.</span></span>

  > [!NOTE]
  > <span data-ttu-id="6ddd2-609">Ha a *SessionId* és a *PartitionKey* tulajdonságok értéke egyaránt meg van adva, ezeket ugyanarra az értékre kell állítani, vagy az üzenet el lesz utasítva.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-609">If the *SessionId* and *PartitionKey* properties are both specified, then they must be set to the same value or the message will be rejected.</span></span>
  >
  >
* <span data-ttu-id="6ddd2-610">Ha egy üzenet *SessionId* és *PartitionKey* tulajdonságai nincsenek megadva, de a duplikálásészlelés engedélyezve van, a rendszer a *MessageId* tulajdonságot használja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-610">If the *SessionId* and *PartitionKey* properties for a message are not specified, but duplicate detection is enabled, the *MessageId* property will be used.</span></span> <span data-ttu-id="6ddd2-611">Az azonos *MessageId* értékű üzenetek ugyanarra a töredékre lesznek küldve.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-611">All messages with the same *MessageId* will be directed to the same fragment.</span></span>
* <span data-ttu-id="6ddd2-612">Ha az üzeneteknek nincs *SessionId, PartitionKey* vagy *MessageId* tulajdonsága, a Service Bus szekvenciálisan osztja le az üzeneteket a töredékekre.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-612">If messages do not include a *SessionId, PartitionKey,* or *MessageId* property, then Service Bus assigns messages to fragments sequentially.</span></span> <span data-ttu-id="6ddd2-613">Ha egy töredék nem érhető el, a Service Bus továbblép a következőre.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-613">If a fragment is unavailable, Service Bus will move on to the next.</span></span> <span data-ttu-id="6ddd2-614">Ez azt jelenti, hogy az üzenetkezelési infrastruktúra ideiglenes hibája nem okozza az üzenetküldési művelet meghiúsulását.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-614">This means that a temporary fault in the messaging infrastructure does not cause the message-send operation to fail.</span></span>

<span data-ttu-id="6ddd2-615">A Service Bus-üzenetsorok vagy -témakörök particionálásának tervezése során mérlegelje a következőket:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-615">Consider the following points when deciding if or how to partition a Service Bus message queue or topic:</span></span>

* <span data-ttu-id="6ddd2-616">A Service Bus-üzenetsorok és -témakörök egy Service Bus-névtér hatókörén belül jönnek létre.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-616">Service Bus queues and topics are created within the scope of a Service Bus namespace.</span></span> <span data-ttu-id="6ddd2-617">A Service Bus névterenként jelenleg 100 particionált üzenetsort vagy témakört képes kezelni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-617">Service Bus currently allows up to 100 partitioned queues or topics per namespace.</span></span>
* <span data-ttu-id="6ddd2-618">Az egyes Service Bus-névterek kvótákat írnak elő a rendelkezésre álló erőforrásokra, például az egyes témakörök előfizetőinek számára, az egyidejű küldési és fogadási kérelmek számára, valamint a létrehozható egyidejű kapcsolatok maximális számára vonatkozóan.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-618">Each Service Bus namespace imposes quotas on the available resources, such as the number of subscriptions per topic, the number of concurrent send and receive requests per second, and the maximum number of concurrent connections that can be established.</span></span> <span data-ttu-id="6ddd2-619">A kvóták dokumentált értékeit a Microsoft webhelyén, a [Service Bus-kvóták] ismertető lapon találja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-619">These quotas are documented on the Microsoft website on the page [Service Bus quotas].</span></span> <span data-ttu-id="6ddd2-620">Ha várhatóan túllépi majd ezeket az értékeket, hozzon létre további névtereket a maguk üzenetsoraival és témaköreivel, és ossza le a terhelést ezekre a névterekre.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-620">If you expect to exceed these values, then create additional namespaces with their own queues and topics, and spread the work across these namespaces.</span></span> <span data-ttu-id="6ddd2-621">Például egy globális alkalmazás esetében hozzon létre külön névtereket mindegyik régióban, és konfigurálja az alkalmazáspéldányokat, hogy a legközelebbi névtér üzenetsorait és témaköreit használják.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-621">For example, in a global application, create separate namespaces in each region and configure application instances to use the queues and topics in the nearest namespace.</span></span>
* <span data-ttu-id="6ddd2-622">A tranzakciók keretében küldött üzenetekben meg kell adni egy partíciókulcsot.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-622">Messages that are sent as part of a transaction must specify a partition key.</span></span> <span data-ttu-id="6ddd2-623">Ez lehet egy *SessionId*, egy *PartitionKey* vagy egy *MessageId* tulajdonság.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-623">This can be a *SessionId*, *PartitionKey*, or *MessageId* property.</span></span> <span data-ttu-id="6ddd2-624">Az egy tranzakció keretében küldött üzenetekben ugyanazt a partíciókulcsot kell megadni, mivel ugyanannak az üzenetközvetítő folyamatnak kell feldolgoznia azokat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-624">All messages that are sent as part of the same transaction must specify the same partition key because they must be handled by the same message broker process.</span></span> <span data-ttu-id="6ddd2-625">Az egy tranzakcióba tartozó üzeneteket nem küldheti külön üzenetsorokra vagy témakörökbe.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-625">You cannot send messages to different queues or topics within the same transaction.</span></span>
* <span data-ttu-id="6ddd2-626">A particionált üzenetsorok és témakörök nem konfigurálhatóak automatikus törlésre tétlenség esetére.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-626">Partitioned queues and topics can't be configured to be automatically deleted when they become idle.</span></span>
* <span data-ttu-id="6ddd2-627">A particionált üzenetsorok és témakörök jelenleg nem használhatóak az Advanced Message Queueing Protocol (AMQP) protokollal, ha platformfüggetlen vagy hibrid megoldásokat épít fel.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-627">Partitioned queues and topics can't currently be used with the Advanced Message Queuing Protocol (AMQP) if you are building cross-platform or hybrid solutions.</span></span>

## <a name="partitioning-strategies-for-cosmos-db"></a><span data-ttu-id="6ddd2-628">A Cosmos DB particionálási stratégiái</span><span class="sxs-lookup"><span data-stu-id="6ddd2-628">Partitioning strategies for Cosmos DB</span></span>

<span data-ttu-id="6ddd2-629">Az Azure Cosmos DB egy NoSQL-adatbázis, amely az [Azure Cosmos DB SQL API][cosmosdb-sql-api] használatával képes JSON-dokumentumokat tárolni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-629">Azure Cosmos DB is a NoSQL database that can store JSON documents using the [Azure Cosmos DB SQL API][cosmosdb-sql-api].</span></span> <span data-ttu-id="6ddd2-630">A Cosmos DB-adatbázisban lévő objektumok vagy egyéb adatok JSON-szerializált ábrázolásai.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-630">A document in a Cosmos DB database is a JSON-serialized representation of an object or other piece of data.</span></span> <span data-ttu-id="6ddd2-631">A rendszer nem tartat be rögzített sémákat, ez alól az egyetlen kivétel az, hogy minden dokumentumnak tartalmaznia kell egy egyedi azonosítót.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-631">No fixed schemas are enforced except that every document must contain a unique ID.</span></span>

<span data-ttu-id="6ddd2-632">A dokumentumok gyűjteményekbe vannak rendezve.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-632">Documents are organized into collections.</span></span> <span data-ttu-id="6ddd2-633">A kapcsolódó dokumentumokat gyűjteménybe foglalhatja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-633">You can group related documents together in a collection.</span></span> <span data-ttu-id="6ddd2-634">Például egy blogbejegyzéseket karbantartó rendszerben mindegyik blogbejegyzés tartalmát külön dokumentumban tárolhatja egy gyűjteményben.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-634">For example, in a system that maintains blog postings, you can store the contents of each blog post as a document in a collection.</span></span> <span data-ttu-id="6ddd2-635">Az egyes tématípusok szerint is létrehozhat gyűjteményeket.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-635">You can also create collections for each subject type.</span></span> <span data-ttu-id="6ddd2-636">Egy több-bérlős alkalmazásban, például egy olyan rendszerben, ahol több szerző is kezelheti és irányíthatja a saját blogbejegyzéseit, a blogokat particionálhatja szerző szerint, és mindegyik szerző számára külön gyűjteményeket hozhat létre.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-636">Alternatively, in a multitenant application, such as a system where different authors control and manage their own blog posts, you can partition blogs by author and create separate collections for each author.</span></span> <span data-ttu-id="6ddd2-637">A gyűjtemények számára lefoglalt tárhely rugalmas, szükség szerint csökkenthető vagy növelhető.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-637">The storage space that's allocated to collections is elastic and can shrink or grow as needed.</span></span>

<span data-ttu-id="6ddd2-638">A Cosmos DB támogatja az adatok automatikus particionálását az alkalmazásban definiált partíciókulcs alapján.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-638">Cosmos DB supports automatic partitioning of data based on an application-defined partition key.</span></span> <span data-ttu-id="6ddd2-639">A *logikai partíció* egy olyan partíció, amely egy adott partíciókulcs-értékhez tartozó adatokat tárolja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-639">A *logical partition* is a partition that stores all the data for a single partition key value.</span></span> <span data-ttu-id="6ddd2-640">Az adott partíciókulcs-értékkel rendelkező összes dokumentum ugyanabba a logikai partícióba kerül.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-640">All documents that share the same value for the partition key are placed within the same logical partition.</span></span> <span data-ttu-id="6ddd2-641">A Cosmos DB az értékeket a partíciókulcs kivonata alapján osztja el.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-641">Cosmos DB distributes values according to hash of the partition key.</span></span> <span data-ttu-id="6ddd2-642">Az egyes logikai partíciók maximális mérete 10 GB.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-642">A logical partition has a maximum size of 10 GB.</span></span> <span data-ttu-id="6ddd2-643">Így a partíciókulcs megfelelő megválasztása fontos szempont a tervezés során.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-643">Therefore, the choice of the partition key is an important decision at design time.</span></span> <span data-ttu-id="6ddd2-644">Válasszon egy olyan tulajdonságot, amelynek az értékei és a hozzáférési mintái széles skálán mozognak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-644">Choose a property with a wide range of values and even access patterns.</span></span> <span data-ttu-id="6ddd2-645">További információkat az [Azure Cosmos DB particionálási és horizontális leskálázási eljárásait](/azure/cosmos-db/partition-data) ismertető cikkben talál.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-645">For more information, see [Partition and scale in Azure Cosmos DB](/azure/cosmos-db/partition-data).</span></span>

> [!NOTE]
> <span data-ttu-id="6ddd2-646">Mindegyik Cosmos DB-adatbázis rendelkezik *teljesítményszinttel*, amely az adatbázis számára elérhető erőforrások mennyiségét határozza meg.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-646">Each Cosmos DB database has a *performance level* that determines the amount of resources it gets.</span></span> <span data-ttu-id="6ddd2-647">A teljesítményszinthez egy *kérelemegység* (RU) sebességkorlát tartozik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-647">A performance level is associated with a *request unit* (RU) rate limit.</span></span> <span data-ttu-id="6ddd2-648">Az RU-sebességkorlát az adott gyűjtemény számára fenntartott, kizárólag általa használható erőforrások mennyiségét határozza meg.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-648">The RU rate limit specifies the volume of resources that's reserved and available for exclusive use by that collection.</span></span> <span data-ttu-id="6ddd2-649">A gyűjtemény költségei az adott gyűjtemény számára kiválasztott teljesítményszinttől függenek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-649">The cost of a collection depends on the performance level that's selected for that collection.</span></span> <span data-ttu-id="6ddd2-650">A nagyobb teljesítményszint (és RU-sebességkorlát) nagyobb költségekkel jár.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-650">The higher the performance level (and RU rate limit) the higher the charge.</span></span> <span data-ttu-id="6ddd2-651">A gyűjtemények teljesítményszintjét az Azure Portalon módosíthatja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-651">You can adjust the performance level of a collection by using the Azure portal.</span></span> <span data-ttu-id="6ddd2-652">További információkat [az Azure Cosmos DB kérelemegységeit ismertető][cosmos-db-ru] cikkben talál.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-652">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span>
>
>

<span data-ttu-id="6ddd2-653">Ha a Cosmos DB által biztosított particionálás mechanizmus nem bizonyul elegendőnek, az adatokat esetleg az alkalmazás szintjén kell szegmensekre osztania.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-653">If the paritioning mechanism that Cosmos DB provides is not sufficient, you may need to shard the data at the application level.</span></span> <span data-ttu-id="6ddd2-654">A dokumentumgyűjtemények egy természetes mechanizmust kínálnak az adatok particionálására egy adott adatbázisban.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-654">Document collections provide a natural mechanism for partitioning data within a single database.</span></span> <span data-ttu-id="6ddd2-655">A szegmensekre particionálás legegyszerűbben úgy valósítható meg, ha mindegyik szegmenshez létrehoz egy gyűjteményt.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-655">The simplest way to implement sharding is to create a collection for each shard.</span></span> <span data-ttu-id="6ddd2-656">A tárolók logikai erőforrások, és több kiszolgálóra is kiterjedhetnek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-656">Containers are logical resources and can span one or more servers.</span></span> <span data-ttu-id="6ddd2-657">A rögzített méretű tárolók mérete legfeljebb 10 GB, feldolgozási sebessége legfeljebb 10000 RU/s lehet.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-657">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="6ddd2-658">A nem korlátozott tárolók nem rendelkeznek tárhelykorláttal, azonban meg kell adni hozzájuk egy partíciókulcsot.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-658">Unlimited containers do not have a maximum sotrage size, but must specify a partition key.</span></span> <span data-ttu-id="6ddd2-659">Az alkalmazások horizontális particionálása esetén az ügyfélalkalmazásnak a kérelmeket a megfelelő szegmensre kell irányítania, ez általában az adatok a szegmenskulcsot meghatározó egyes attribútumain alapuló leképezési mechanizmussal valósítható meg.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-659">With application sharding, the client application must direct requests to the appropriate shard, usually by implementing its own mapping mechanism based on some attributes of the data that define the shard key.</span></span> 

<span data-ttu-id="6ddd2-660">Az összes adatbázis egy Cosmos DB-adatbázis adatbázisfiók környezetében jön létre.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-660">All databases are created in the context of a Cosmos DB database account.</span></span> <span data-ttu-id="6ddd2-661">Egy fiók több adatbázist is tartalmazhat, és meghatározza, hogy az adatbázisok mely régiókban lesznek létrehozva.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-661">A single account can contain several databases, and it specifies in which regions the databases are created.</span></span> <span data-ttu-id="6ddd2-662">Mindegyik fiók betartatja a saját hozzáférés-vezérlését.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-662">Each account also enforces its own access control.</span></span> <span data-ttu-id="6ddd2-663">A Cosmos DB fiókok használatával a szegmenseket (az adatbázisokon belüli gyűjteményeket) az azokat használó felhasználókhoz földrajzilag közel helyezheti el, és kikényszerítheti, hogy csak az adott felhasználók érhessék el azokat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-663">You can use Cosmos DB accounts to geo-locate shards (collections within databases) close to the users who need to access them, and enforce restrictions so that only those users can connect to them.</span></span>

<span data-ttu-id="6ddd2-664">Ha az adatokat a Cosmos DB SQL API-val tervezi particionálni, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-664">Consider the following points when deciding how to partition data with the Cosmos DB SQL API:</span></span>

* <span data-ttu-id="6ddd2-665">**A Cosmos DB-adatbázis számára elérhető erőforrások mennyisége a fiók kvótakorlátainak függvénye**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-665">**The resources available to a Cosmos DB database are subject to the quota limitations of the account**.</span></span> <span data-ttu-id="6ddd2-666">Mindegyik adatbázis több gyűjteményt is tárolhat, és mindegyik gyűjteményhez tartozik egy teljesítményszint, amely az adott gyűjtemény RU-sebességkorlátját (a fenntartott feldolgozási sebességet) határozza meg.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-666">Each database can hold a number of collections, and each collection is associated with a performance level that governs the RU rate limit (reserved throughput) for that collection.</span></span> <span data-ttu-id="6ddd2-667">További információk: [Az Azure-előfizetések és -szolgáltatások korlátozásai, kvótái és megkötései][azure-limits].</span><span class="sxs-lookup"><span data-stu-id="6ddd2-667">For more information, see [Azure subscription and service limits, quotas, and constraints][azure-limits].</span></span>
* <span data-ttu-id="6ddd2-668">**Mindegyik dokumentumnak rendelkeznie kell egy attribútummal, amely alapján egyedileg azonosítható a gyűjteményen belül**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-668">**Each document must have an attribute that can be used to uniquely identify that document within the collection in which it is held**.</span></span> <span data-ttu-id="6ddd2-669">Ez az attribútum nem azonos a partíciókulccsal, amely azt határozza meg, hogy melyik gyűjteményben található a dokumentum.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-669">This attribute is different from the shard key, which defines which collection holds the document.</span></span> <span data-ttu-id="6ddd2-670">Egy gyűjtemény nagy számú dokumentumot tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-670">A collection can contain a large number of documents.</span></span> <span data-ttu-id="6ddd2-671">Ezt elméletileg csak a dokumentumazonosító hossza korlátozza.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-671">In theory, it's limited only by the maximum length of the document ID.</span></span> <span data-ttu-id="6ddd2-672">A dokumentumazonosító legfeljebb 255 karakter hosszúságú lehet.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-672">The document ID can be up to 255 characters.</span></span>
* <span data-ttu-id="6ddd2-673">**A dokumentumokra irányuló műveletek egy tranzakció környezetében lesznek végrehajtva. A tranzakciók hatóköre a dokumentumot tároló gyűjtemény.**</span><span class="sxs-lookup"><span data-stu-id="6ddd2-673">**All operations against a document are performed within the context of a transaction. Transactions are scoped to the collection in which the document is contained.**</span></span> <span data-ttu-id="6ddd2-674">Ha egy művelet meghiúsul, az általa végrehajtott feldolgozás vissza lesz vonva.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-674">If an operation fails, the work that it has performed is rolled back.</span></span> <span data-ttu-id="6ddd2-675">Az épp feldolgozás alatt álló dokumentumokon végrehajtott módosítások pillanatképszinten el vannak különítve.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-675">While a document is subject to an operation, any changes that are made are subject to snapshot-level isolation.</span></span> <span data-ttu-id="6ddd2-676">Ez a mechanizmus biztosítja, hogy ha például egy új dokumentum létrehozására irányuló kérelem meghiúsul, az adatbázist egyidejűleg lekérdező többi felhasználó nem látja a félkész, majd eltávolított dokumentumot.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-676">This mechanism guarantees that if, for example, a request to create a new document fails, another user who's querying the database simultaneously will not see a partial document that is then removed.</span></span>
* <span data-ttu-id="6ddd2-677">**Az adatbázis-lekérdezések hatóköre szintén a gyűjtemény**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-677">**Database queries are also scoped to the collection level**.</span></span> <span data-ttu-id="6ddd2-678">Egy lekérdezés csak egyetlen gyűjtemény adatait kérdezheti le.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-678">A single query can retrieve data from only one collection.</span></span> <span data-ttu-id="6ddd2-679">Ha több gyűjteményből kell lekérdeznie adatokat, mindegyik gyűjteményt külön-külön kell lekérdeznie, majd az eredményeket az alkalmazás kódjában egyesítenie.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-679">If you need to retrieve data from multiple collections, you must query each collection individually and merge the results in your application code.</span></span>
* <span data-ttu-id="6ddd2-680">**A Cosmos DB támogatja a programozható elemek használatát, amelyek a gyűjteményben a dokumentumok mellett tárolhatóak**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-680">**Cosmos DB supports programmable items that can all be stored in a collection alongside documents**.</span></span> <span data-ttu-id="6ddd2-681">Ezek lehetnek tárolt eljárások, felhasználó által definiált függvények és eseményindítók (JavaScript nyelven).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-681">These include stored procedures, user-defined functions, and triggers (written in JavaScript).</span></span> <span data-ttu-id="6ddd2-682">Ezek az elemek a gyűjteményen belül az összes dokumentumot elérhetik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-682">These items can access any document within the same collection.</span></span> <span data-ttu-id="6ddd2-683">Ezen felül ezek az elemek a környezeti tranzakció hatókörében (egy, valamely dokumentumon végrehajtott létrehozás, törlés vagy csere művelet eredményeként aktiválódó trigger esetén) vagy egy új tranzakció indításával (egy, valamely kifejezett ügyfélkérelem eredményeképp futtatott tárolt eljárás esetén) futtatható.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-683">Furthermore, these items run either inside the scope of the ambient transaction (in the case of a trigger that fires as the result of a create, delete, or replace operation performed against a document), or by starting a new transaction (in the case of a stored procedure that is run as the result of an explicit client request).</span></span> <span data-ttu-id="6ddd2-684">Ha egy programozható elem kódja kivételt dob, a tranzakció vissza lesz vonva.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-684">If the code in a programmable item throws an exception, the transaction is rolled back.</span></span> <span data-ttu-id="6ddd2-685">A tárolt eljárások és eseményindítók használatával tartható fent az integritás és a konzisztencia a dokumentumok közt, de a dokumentumoknak ugyanabba a gyűjteménybe kell tartoznia.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-685">You can use stored procedures and triggers to maintain integrity and consistency between documents, but these documents must all be part of the same collection.</span></span>
* <span data-ttu-id="6ddd2-686">**Törekedni kell rá, hogy az adatbázisban tárolni kívánt gyűjtemények ne haladják meg a teljesítményszintjeik által meghatározott feldolgozási sebességeket**.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-686">**The collections that you intend to hold in the databases should be unlikely to exceed the throughput limits defined by the performance levels of the collections**.</span></span> <span data-ttu-id="6ddd2-687">További információkat [az Azure Cosmos DB kérelemegységeit ismertető][cosmos-db-ru] cikkben talál.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-687">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span> <span data-ttu-id="6ddd2-688">Ha várhatóan meghaladja majd ezeket a korlátokat, érdemes a gyűjteményeket különböző fiókokban lévő adatbázisokra szétosztani a terhelés csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-688">If you anticipate reaching these limits, consider splitting collections across databases in different accounts to reduce the load per collection.</span></span>

## <a name="partitioning-strategies-for-azure-search"></a><span data-ttu-id="6ddd2-689">Az Azure Search particionálási stratégiái</span><span class="sxs-lookup"><span data-stu-id="6ddd2-689">Partitioning strategies for Azure Search</span></span>
<span data-ttu-id="6ddd2-690">Az adatkeresési funkcionalitás a webalkalmazások biztosított leggyakoribb navigációs és felfedezési módszer.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-690">The ability to search for data is often the primary method of navigation and exploration that's provided by many web applications.</span></span> <span data-ttu-id="6ddd2-691">Segítségével a felhasználók gyorsan találhatják meg az erőforrásokat (például a termékeket egy e-kereskedelmi alkalmazásban) a keresési feltételek kombinációja alapján.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-691">It helps users find resources quickly (for example, products in an e-commerce application) based on combinations of search criteria.</span></span> <span data-ttu-id="6ddd2-692">Az Azure Search szolgáltatás teljes szöveges keresési funkcionalitást biztosít a webes tartalmakban, és olyan szolgáltatásokat kínál, mint a szövegkiegészítés, a közeli találatokon alapuló lekérdezési javaslatok és a jellemzőalapú navigáció.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-692">The Azure Search service provides full-text search capabilities over web content, and includes features such as type-ahead, suggested queries based on near matches, and faceted navigation.</span></span> <span data-ttu-id="6ddd2-693">Ezeknek a képességeknek a teljes leírását a [Mi az az Azure Search?] című oldalon találja a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-693">A full description of these capabilities is available on the page [What is Azure Search?] on the Microsoft website.</span></span>

<span data-ttu-id="6ddd2-694">Az Azure Search a kereshető tartalmakat JSON-dokumentumokként tárolja egy adatbázisban.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-694">Azure Search stores searchable content as JSON documents in a database.</span></span> <span data-ttu-id="6ddd2-695">Definiálhat indexeket a dokumentumok kereshető mezőinek a meghatározásához, majd ezeket a definíciókat megadhatja az Azure Searchnek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-695">You define indexes that specify the searchable fields in these documents and provide these definitions to Azure Search.</span></span> <span data-ttu-id="6ddd2-696">Amikor egy felhasználó beküld egy keresési kérelmet, az Azure Search a megfelelő indexek használatával találja meg az egyező elemeket.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-696">When a user submits a search request, Azure Search uses the appropriate indexes to find matching items.</span></span>

<span data-ttu-id="6ddd2-697">A versengés csökkentése érdekében az Azure Search által használt tárterület 1, 2, 3, 4, 6 vagy 12 partícióra osztható, és mindegyik partíció 6 példányban replikálható.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-697">To reduce contention, the storage that's used by Azure Search can be divided into 1, 2, 3, 4, 6, or 12 partitions, and each partition can be replicated up to 6 times.</span></span> <span data-ttu-id="6ddd2-698">A partíciók és a replikák számának szorzatát *keresési egységnek* (SU) nevezzük.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-698">The product of the number of partitions multiplied by the number of replicas is called the *search unit* (SU).</span></span> <span data-ttu-id="6ddd2-699">Az Azure Search egyetlen példánya legfeljebb 36 SU-t tartalmazhat (tehát egy 12 partícióval rendelkező adatbázis legfeljebb 3 replikát támogat).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-699">A single instance of Azure Search can contain a maximum of 36 SUs (a database with 12 partitions only supports a maximum of 3 replicas).</span></span>

<span data-ttu-id="6ddd2-700">A számlázás a szolgáltatásban lefoglalt SU-k száma alapján történik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-700">You are billed for each SU that is allocated to your service.</span></span> <span data-ttu-id="6ddd2-701">A kereshető tartalom mennyiségének vagy a keresési kérelmek számának növekedtével a meglévő Azure Search-példányok SU-inak száma is növelhető a többletterhelés kezelése érdekében.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-701">As the volume of searchable content increases or the rate of search requests grows, you can add SUs to an existing instance of Azure Search to handle the extra load.</span></span> <span data-ttu-id="6ddd2-702">Maga az Azure Search a dokumentumokat egyenletesen osztja el a partíciók közt.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-702">Azure Search itself distributes the documents evenly across the partitions.</span></span> <span data-ttu-id="6ddd2-703">A manuális particionálási stratégiák jelenleg nem támogatottak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-703">No manual partitioning strategies are currently supported.</span></span>

<span data-ttu-id="6ddd2-704">Mindegyik partíció legfeljebb 15 millió dokumentumot tartalmazhat vagy 300 GB tárterületet foglalhat el (amelyik érték kisebb).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-704">Each partition can contain a maximum of 15 million documents or occupy 300 GB of storage space (whichever is smaller).</span></span> <span data-ttu-id="6ddd2-705">Legfeljebb 50 indexet hozhat létre.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-705">You can create up to 50 indexes.</span></span> <span data-ttu-id="6ddd2-706">A szolgáltatás teljesítménye a dokumentumok összetettségétől, a rendelkezésre álló indexektől és a hálózati késés hatásaitól függően változik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-706">The performance of the service varies and depends on the complexity of the documents, the available indexes, and the effects of network latency.</span></span> <span data-ttu-id="6ddd2-707">Átlagosan egyetlen replika (1 SU) másodpercenként 15 lekérdezést (QPS) képes feldolgozni, bár javasolt saját adatok használatával teljesítménymérést végezni a feldolgozási sebesség pontosabb mérése érdekében.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-707">On average, a single replica (1 SU) should be able to handle 15 queries per second (QPS), although we recommend performing benchmarking with your own data to obtain a more precise measure of throughput.</span></span> <span data-ttu-id="6ddd2-708">További információkért lásd [Az Azure Search szolgáltatási korlátozásai] foglalkozó oldalt a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-708">For more information, see the page [Service limits in Azure Search] on the Microsoft website.</span></span>

> [!NOTE]
> <span data-ttu-id="6ddd2-709">A kereshető dokumentumokban tárolható adatok típusa egy korlátozott halmazba tartozhat: sztringek, logikai értékek, numerikus adatok, dátum és idő adatok és egyes földrajzi adatok.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-709">You can store a limited set of data types in searchable documents, including strings, Booleans, numeric data, datetime data, and some geographical data.</span></span> <span data-ttu-id="6ddd2-710">További információkért lásd [Támogatott adattípusok (Azure Search)] foglalkozó oldalt a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-710">For more details, see the page [Supported data types (Azure Search)] on the Microsoft website.</span></span>
>
>

<span data-ttu-id="6ddd2-711">Csak korlátozottan szabályozható, hogy az Azure Search hogyan particionálja az adatokat a szolgáltatás egyes példányaiban.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-711">You have limited control over how Azure Search partitions data for each instance of the service.</span></span> <span data-ttu-id="6ddd2-712">Azonban egy globális környezetben esetleg növelhető a teljesítmény, valamint csökkenthető a késés és a versengés magának a szolgáltatásnak a particionálásával a következő stratégiák valamelyike mentén:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-712">However, in a global environment you might be able to improve performance and reduce latency and contention further by partitioning the service itself using either of the following strategies:</span></span>

* <span data-ttu-id="6ddd2-713">Hozzon létre egy Azure Search-példányt minden egyes földrajzi régióban, és gondoskodjon róla, hogy az ügyfélalkalmazások a legközelebbi elérhető példányra legyenek irányítva.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-713">Create an instance of Azure Search in each geographic region, and ensure that client applications are directed towards the nearest available instance.</span></span> <span data-ttu-id="6ddd2-714">Ehhez a stratégiához a kereshető tartalmak frissítéseit időben kell replikálni a szolgáltatás minden példányán.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-714">This strategy requires that any updates to searchable content are replicated in a timely manner across all instances of the service.</span></span>
* <span data-ttu-id="6ddd2-715">Hozzon létre két szintet az Azure Searchben:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-715">Create two tiers of Azure Search:</span></span>

  * <span data-ttu-id="6ddd2-716">Egy helyi szolgáltatást minden egyes régióban, amely az adott régióban lévő felhasználók által leggyakrabban lekérdezett adatokat tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-716">A local service in each region that contains the data that's most frequently accessed by users in that region.</span></span> <span data-ttu-id="6ddd2-717">A felhasználók a kérelmeket ide irányítva gyors, de korlátozott eredményeket kaphatnak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-717">Users can direct requests here for fast but limited results.</span></span>
  * <span data-ttu-id="6ddd2-718">Egy globális szolgáltatást, amely az összes adatot tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-718">A global service that encompasses all the data.</span></span> <span data-ttu-id="6ddd2-719">A felhasználók a kérelmeket ide irányítva lassabb, de teljesebb eredményeket kaphatnak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-719">Users can direct requests here for slower but more complete results.</span></span>

<span data-ttu-id="6ddd2-720">Ez a megközelítés akkor a legmegfelelőbb, ha a keresett adatok az egyes régiókban jelentősen eltérnek.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-720">This approach is most suitable when there is a significant regional variation in the data that's being searched.</span></span>

## <a name="partitioning-strategies-for-azure-redis-cache"></a><span data-ttu-id="6ddd2-721">Az Azure Redis Cache particionálási stratégiái</span><span class="sxs-lookup"><span data-stu-id="6ddd2-721">Partitioning strategies for Azure Redis Cache</span></span>
<span data-ttu-id="6ddd2-722">Az Azure Redis Cache egy, a Redis kulcs-érték adattáron alapuló megosztott gyorsítótárazási szolgáltatást biztosít a felhőben.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-722">Azure Redis Cache provides a shared caching service in the cloud that's based on the Redis key-value data store.</span></span> <span data-ttu-id="6ddd2-723">Ahogy a neve is mutatja (cache = gyorsítótár), az Azure Redis Cache egy gyorsítótárazási megoldásnak készült.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-723">As its name implies, Azure Redis Cache is intended as a caching solution.</span></span> <span data-ttu-id="6ddd2-724">Csak átmeneti adatok tárolására készült, és nem állandó adattárként szolgál.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-724">Use it only for holding transient data and not as a permanent data store.</span></span> <span data-ttu-id="6ddd2-725">Az Azure Redis Cache-t használó alkalmazásokat úgy érdemes kialakítani, hogy tovább működjenek, ha a gyorsítótár nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-725">Applications that utilize Azure Redis Cache should be able to continue functioning if the cache is unavailable.</span></span> <span data-ttu-id="6ddd2-726">Az Azure Redis Cache támogatja az elsődleges/másodlagos replikációt a magas rendelkezésre állás biztosítása érdekében, de jelenleg a gyorsítótár maximális mérete 53 GB-ra van korlátozva.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-726">Azure Redis Cache supports primary/secondary replication to provide high availability, but currently limits the maximum cache size to 53 GB.</span></span> <span data-ttu-id="6ddd2-727">Ha ennél több tárhely szükséges, további gyorsítótárakat kell létrehoznia.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-727">If you need more space than this, you must create additional caches.</span></span> <span data-ttu-id="6ddd2-728">További információkat az [Azure Redis Cache] oldal tartalmaz a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-728">For more information, go to the page [Azure Redis Cache] on the Microsoft website.</span></span>

<span data-ttu-id="6ddd2-729">A Redis-adattárak particionálása szétosztja az adatokat a Redis szolgáltatás példányai között.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-729">Partitioning a Redis data store involves splitting the data across instances of the Redis service.</span></span> <span data-ttu-id="6ddd2-730">Minden példány egy külön partíciót alkot.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-730">Each instance constitutes a single partition.</span></span> <span data-ttu-id="6ddd2-731">Az Azure Redis Cache a Redis-szolgáltatásokat egy előtár mögött kivonatolja, és nem teszi azokat közvetlenül közzé.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-731">Azure Redis Cache abstracts the Redis services behind a façade and does not expose them directly.</span></span> <span data-ttu-id="6ddd2-732">A particionálás legegyszerűbben úgy valósítható meg, ha létrehoz több Azure Redis Cache-példányt, és az adatokat azok között osztja el.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-732">The simplest way to implement partitioning is to create multiple Azure Redis Cache instances and spread the data across them.</span></span>

<span data-ttu-id="6ddd2-733">Ez egyes adatelemekhez hozzárendelhet egy azonosítót (a partíciókulcsot), amely meghatározza, hogy melyik gyorsítótár tárolja az adatelemet.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-733">You can associate each data item with an identifier (a partition key) that specifies which cache stores the data item.</span></span> <span data-ttu-id="6ddd2-734">Az ügyfélalkalmazás logikája azután ennek az azonosítónak a használatával irányíthatja a kérelmeket a megfelelő partícióra.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-734">The client application logic can then use this identifier to route requests to the appropriate partition.</span></span> <span data-ttu-id="6ddd2-735">Ez a séma nagyon egyszerű, de ha a particionálási séma módosul (például további Azure Redis Cache-példányok létrehozása esetén), az ügyfélalkalmazások újrakonfigurálására lehet szükség.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-735">This scheme is very simple, but if the partitioning scheme changes (for example, if additional Azure Redis Cache instances are created), client applications might need to be reconfigured.</span></span>

<span data-ttu-id="6ddd2-736">A natív Redis (nem az Azure Redis Cache) támogatja a Redis-fürtözésen alapuló kiszolgálóoldali particionálást.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-736">Native Redis (not Azure Redis Cache) supports server-side partitioning based on Redis clustering.</span></span> <span data-ttu-id="6ddd2-737">Ebben a megközelítésben az adatok egyenletesen oszthatók meg a kiszolgálók között egy kivonatoló mechanizmus segítségével.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-737">In this approach, you can divide the data evenly across servers by using a hashing mechanism.</span></span> <span data-ttu-id="6ddd2-738">Mindegyik Redis-kiszolgáló tárolja a partíción tárolt kivonatkulcsokat leíró metaadatokat, és arra vonatkozóan is tartalmaz információkat, hogy mely kivonatkulcsok találhatók a más kiszolgálókon lévő partíciókon.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-738">Each Redis server stores metadata that describes the range of hash keys that the partition holds, and also contains information about which hash keys are located in the partitions on other servers.</span></span>

<span data-ttu-id="6ddd2-739">Az ügyfélalkalmazások egyszerűen beküldik a kérelmeket valamelyik résztvevő Redis-kiszolgálóra (valószínűleg a legközelebbire).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-739">Client applications simply send requests to any of the participating Redis servers (probably the closest one).</span></span> <span data-ttu-id="6ddd2-740">A Redis-kiszolgáló megvizsgálja az ügyfélkérelmet.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-740">The Redis server examines the client request.</span></span> <span data-ttu-id="6ddd2-741">Ha az helyileg megoldható, akkor elvégzi a kért műveletet.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-741">If it can be resolved locally, it performs the requested operation.</span></span> <span data-ttu-id="6ddd2-742">Ha nem oldható meg, továbbítja a kérést a megfelelő kiszolgálóra.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-742">Otherwise it forwards the request on to the appropriate server.</span></span>

<span data-ttu-id="6ddd2-743">Erről a Redis-fürtözés használatával megvalósított modellről további részleteket a Redis webhelyén, a [Oktatóanyag Redis-fürtökhöz] tartalmazó oldalon talál.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-743">This model is implemented by using Redis clustering, and is described in more detail on the [Redis cluster tutorial] page on the Redis website.</span></span> <span data-ttu-id="6ddd2-744">A Redis-fürtözés az ügyfélalkalmazások számára transzparens módon történik.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-744">Redis clustering is transparent to client applications.</span></span> <span data-ttu-id="6ddd2-745">A fürthöz további Redis-kiszolgálók is hozzáadhatók (és az adatok újraparticionálhatók) anélkül, hogy az ügyfeleket újra kellene konfigurálni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-745">Additional Redis servers can be added to the cluster (and the data can be re-partitioned) without requiring that you reconfigure the clients.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="6ddd2-746">Az Azure Redis Cache jelenleg nem támogatja a Redis-fürtözést.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-746">Azure Redis Cache does not currently support Redis clustering.</span></span> <span data-ttu-id="6ddd2-747">Ha szeretné megvalósítani ezt a megközelítést az Azure-ban is, saját Redis-kiszolgálókat kell kialakítania a Redis Azure-beli virtuális gépekre való telepítésével és manuális konfigurálásával.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-747">If you want to implement this approach with Azure, then you must implement your own Redis servers by installing Redis on a set of Azure virtual machines and configuring them manually.</span></span> <span data-ttu-id="6ddd2-748">A Microsoft webhelyének [A Redis futtatása CentOS Linux rendszerű virtuális gépen az Azure-ban] tárgyaló oldala egy példán keresztül mutatja be, hogyan hozható létre és konfigurálható egy Azure-beli virtuális gépként futó Redis-csomópont.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-748">The page [Running Redis on a CentOS Linux VM in Azure] on the Microsoft website walks through an example that shows you how to build and configure a Redis node running as an Azure VM.</span></span>
>
>

<span data-ttu-id="6ddd2-749">A Redis használatával történő particionálásról további információkat a Redis webhelyén elérhető, [Particionálás: adatok felosztása több Redis-példány között] leíró oldalon talál.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-749">The page [Partitioning: how to split data among multiple Redis instances] on the Redis website provides more information about implementing partitioning with Redis.</span></span> <span data-ttu-id="6ddd2-750">A szakasz további része feltételezi, hogy ügyféloldali vagy proxyval támogatott particionálást végez.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-750">The remainder of this section assumes that you are implementing client-side or proxy-assisted partitioning.</span></span>

<span data-ttu-id="6ddd2-751">Ha az adatokat az Azure Redis Cache-sel tervezi particionálni, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-751">Consider the following points when deciding how to partition data with Azure Redis Cache:</span></span>

* <span data-ttu-id="6ddd2-752">Az Azure Redis Cache nem végleges adattárolásra lett kialakítva, ezért bármilyen particionálási sémát választ is, az alkalmazás kódjának az adatokat egy, a gyorsítótártól különböző helyről kell tudnia lekérdezni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-752">Azure Redis Cache is not intended to act as a permanent data store, so whatever partitioning scheme you implement, your application code must be able to retrieve data from a location that's not the cache.</span></span>
* <span data-ttu-id="6ddd2-753">A gyakran együtt használt adatokat érdemes egy partíción tartani.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-753">Data that is frequently accessed together should be kept in the same partition.</span></span> <span data-ttu-id="6ddd2-754">A Redis egy hatékony kulcs-érték tároló, amely több magas szinten optimalizált mechanizmust biztosít az adatok rendszerezéséhez.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-754">Redis is a powerful key-value store that provides several highly optimized mechanisms for structuring data.</span></span> <span data-ttu-id="6ddd2-755">Ezek a mechanizmusok a következők lehetnek:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-755">These mechanisms can be one of the following:</span></span>

  * <span data-ttu-id="6ddd2-756">Egyszerű sztringek (legfeljebb 512 MB hosszúságú bináris adatok)</span><span class="sxs-lookup"><span data-stu-id="6ddd2-756">Simple strings (binary data up to 512 MB in length)</span></span>
  * <span data-ttu-id="6ddd2-757">Összesített típusok, például listák (amelyek szolgálhatnak üzenetsorként vagy veremként)</span><span class="sxs-lookup"><span data-stu-id="6ddd2-757">Aggregate types such as lists (which can act as queues and stacks)</span></span>
  * <span data-ttu-id="6ddd2-758">Halmazok (rendezett és rendezetlen)</span><span class="sxs-lookup"><span data-stu-id="6ddd2-758">Sets (ordered and unordered)</span></span>
  * <span data-ttu-id="6ddd2-759">Kivonatok (amelyekkel csoportosíthatóak a kapcsolódó mezők, például az egy objektum mezőit jelölő elemek)</span><span class="sxs-lookup"><span data-stu-id="6ddd2-759">Hashes (which can group related fields together, such as the items that represent the fields in an object)</span></span>
* <span data-ttu-id="6ddd2-760">Az összesített típusok összerendelhető segítségével több kapcsolódó mező ugyanazzal a kulccsal.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-760">The aggregate types enable you to associate many related values with the same key.</span></span> <span data-ttu-id="6ddd2-761">A Redis-kulcsok listákat, halmazokat vagy kivonatokat azonosítanak, nem pedig az azokban tárolt adatelemeket.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-761">A Redis key identifies a list, set, or hash rather than the data items that it contains.</span></span> <span data-ttu-id="6ddd2-762">Ezek a típusok az Azure Redis Cache-ben mind elérhetők, és a Redis webhelyén, az [Adattípusok] lapon ismerhetőek meg.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-762">These types are all available with Azure Redis Cache and are described by the [Data types] page on the Redis website.</span></span> <span data-ttu-id="6ddd2-763">Például egy e-kereskedelmi rendszer az ügyfelek által feladott megrendeléseket követő részében az egyes ügyfelek adatai tárolhatóak egy Redis-kivonatban, amelynek a kulcsa lehet a felhasználó azonosítója.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-763">For example, in part of an e-commerce system that tracks the orders that are placed by customers, the details of each customer can be stored in a Redis hash that is keyed by using the customer ID.</span></span> <span data-ttu-id="6ddd2-764">Mindegyik kivonat az ügyfél megrendelésazonosítóinak egy gyűjteményét tárolja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-764">Each hash can hold a collection of order IDs for the customer.</span></span> <span data-ttu-id="6ddd2-765">Egy külön Redis-halmaz tárolhatja a megrendeléseket, ezeket is kivonatként strukturálva, és kulcsként a megrendelésazonosítót használva.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-765">A separate Redis set can hold the orders, again structured as hashes, and keyed by using the order ID.</span></span> <span data-ttu-id="6ddd2-766">A 8. ábrán ez a struktúra látható.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-766">Figure 8 shows this structure.</span></span> <span data-ttu-id="6ddd2-767">Vegye figyelembe, hogy a Redis nem valósít meg semmilyen hivatkozásintegritást, így a fejlesztő feladata, hogy fenntartsa az ügyfelek és a megrendelések kapcsolatát.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-767">Note that Redis does not implement any form of referential integrity, so it is the developer's responsibility to maintain the relationships between customers and orders.</span></span>

![Javasolt struktúra a Redis-tárolóban a megrendelések és adataik rögzítéséhez](./images/data-partitioning/RedisCustomersandOrders.png)

<span data-ttu-id="6ddd2-769">*8. ábra Javasolt struktúra a Redis-tárolóban a megrendelések és adataik rögzítéséhez*</span><span class="sxs-lookup"><span data-stu-id="6ddd2-769">*Figure 8. Suggested structure in Redis storage for recording customer orders and their details*</span></span>

> [!NOTE]
> <span data-ttu-id="6ddd2-770">A Redisben a kulcsok bináris adatértékek (mint a Redis-sztringek), és legfeljebb 512 MB adatot tartalmazhatnak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-770">In Redis, all keys are binary data values (like Redis strings) and can contain up to 512 MB of data.</span></span> <span data-ttu-id="6ddd2-771">Elméletileg a kulcsok szinte bármilyen információt tartalmazhatnak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-771">In theory, a key can contain almost any information.</span></span> <span data-ttu-id="6ddd2-772">Javasoljuk azonban egy egységes kulcselnevezési konvenció bevezetését, amely leírja az adatok típusát és azonosítja az entitásokat, de nem túl hosszú.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-772">However, we recommend adopting a consistent naming convention for keys that is descriptive of the type of data and that identifies the entity, but is not excessively long.</span></span> <span data-ttu-id="6ddd2-773">Általános megközelítésként javasolt „entitástípus:azonosító” formátumú kulcsokat használni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-773">A common approach is to use keys of the form "entity_type:ID".</span></span> <span data-ttu-id="6ddd2-774">Például a „user:99” névvel jelölheti egy 99-es azonosítójú ügyfél kulcsát.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-774">For example, you can use "customer:99" to indicate the key for a customer with the ID 99.</span></span>
>
>

* <span data-ttu-id="6ddd2-775">A vertikális particionálás megvalósítható, ha a különböző összesítésekben lévő kapcsolódó információkat ugyanabban az adatbázisban tárolja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-775">You can implement vertical partitioning by storing related information in different aggregations in the same database.</span></span> <span data-ttu-id="6ddd2-776">Például egy e-kereskedelmi alkalmazásban tárolhatja a termékekkel kapcsolatos gyakran használt adatokat az egyik Redis-kivonatban, a kevésbé gyakran használt felhasználóadatokat pedig egy másikban.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-776">For example, in an e-commerce application, you can store commonly accessed information about products in one Redis hash and less frequently used detailed information in another.</span></span>
  <span data-ttu-id="6ddd2-777">Mindkét kivonat használhatja ugyanazt a termékazonosítót a kulcs részeként.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-777">Both hashes can use the same product ID as part of the key.</span></span> <span data-ttu-id="6ddd2-778">Használhatja például "termék: *Neurális hálózat*" (ahol *Neurális hálózat* a termékazonosító) a termékinformációkhoz és a "product_details: *Neurális hálózat*" a részletes adatokhoz.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-778">For example, you can use "product: *nn*" (where *nn* is the product ID) for the product information and "product_details: *nn*" for the detailed data.</span></span> <span data-ttu-id="6ddd2-779">Ezzel a stratégiával csökkenthető a legtöbb lekérdezés által várhatóan beolvasott adatok mennyisége.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-779">This strategy can help reduce the volume of data that most queries are likely to retrieve.</span></span>
* <span data-ttu-id="6ddd2-780">A Redis-adattárak újraparticionálhatóak, de érdemes figyelembe venni, hogy ez összetett és időigényes feladat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-780">You can repartition a Redis data store, but keep in mind that it's a complex and time-consuming task.</span></span> <span data-ttu-id="6ddd2-781">A Redis-fürtszolgáltatás képes automatikusan újraparticionálni az adatokat, ez a funkció azonban az Azure Redis Cache-ben nem elérhető.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-781">Redis clustering can repartition data automatically, but this capability is not available with Azure Redis Cache.</span></span> <span data-ttu-id="6ddd2-782">Ezért a particionálási séma tervezésekor igyekezzen elegendő szabad helyet hagyni az egyes partíciókon az adatmennyiség idővel várható növekedésének megfelelően.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-782">Therefore, when you design your partitioning scheme, try to leave sufficient free space in each partition to allow for expected data growth over time.</span></span> <span data-ttu-id="6ddd2-783">Ne feledje azonban, hogy az Azure Redis Cache az adatok ideiglenes gyorsítótárazására szolgál, valamint hogy a gyorsítótárban tárolt adatok élettartama korlátozható az élettartam (TTL) érték megadásával.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-783">However, remember that Azure Redis Cache is intended to cache data temporarily, and that data held in the cache can have a limited lifetime specified as a time-to-live (TTL) value.</span></span> <span data-ttu-id="6ddd2-784">A viszonylag rövid életű adatok esetében az élettartam rövidre vehető, a statikus adatok esetében azonban sokkal hosszabbra.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-784">For relatively volatile data, the TTL can be short, but for static data the TTL can be a lot longer.</span></span> <span data-ttu-id="6ddd2-785">Lehetőleg ne tároljon nagy mennyiségű hosszabb élettartamú adatot a gyorsítótárban, amennyiben azok mennyisége feltehetően megtöltené a gyorsítótárat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-785">Avoid storing large amounts of long-lived data in the cache if the volume of this data is likely to fill the cache.</span></span> <span data-ttu-id="6ddd2-786">Meghatározhat egy kiürítési szabályzatot, amely törli az adatokat az Azure Redis Cache-ből, ha a hely kiemelt fontosságú.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-786">You can specify an eviction policy that causes Azure Redis Cache to remove data if space is at a premium.</span></span>

  > [!NOTE]
  > <span data-ttu-id="6ddd2-787">Az Azure Redis Cache használata esetén a gyorsítótár maximális mérete (250 MB és 53 GB között) a megfelelő tarifacsomag kiválasztásával határozható meg.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-787">When you use Azure Redis cache, you specify the maximum size of the cache (from 250 MB to 53 GB) by selecting the appropriate pricing tier.</span></span> <span data-ttu-id="6ddd2-788">Azonban a méret az Azure Redis Cache-gyorsítótár létrehozása után nem növelhető (és nem is csökkenthető).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-788">However, after an Azure Redis Cache has been created, you cannot increase (or decrease) its size.</span></span>
  >
  >
* <span data-ttu-id="6ddd2-789">A Redis-kötegek és -tranzakciók nem terjedhetnek ki több kapcsolatra, így az egyes kötegek vagy tranzakciók által érintett összes adatot ugyanabban az adatbázisban (szegmensben) kell tárolni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-789">Redis batches and transactions cannot span multiple connections, so all data that is affected by a batch or transaction should be held in the same database (shard).</span></span>

  > [!NOTE]
  > <span data-ttu-id="6ddd2-790">A Redis-tranzakcióban foglalt műveletszekvencia nem feltétlenül elemi jellegű.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-790">A sequence of operations in a Redis transaction is not necessarily atomic.</span></span> <span data-ttu-id="6ddd2-791">A tranzakciókat alkotó parancsokat a rendszer a futtatás előtt ellenőrzi, majd az üzenetsorba küldi azokat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-791">The commands that compose a transaction are verified and queued before they run.</span></span> <span data-ttu-id="6ddd2-792">Ha ebben a fázisban hiba történik, a rendszer a teljes üzenetsort elveti.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-792">If an error occurs during this phase, the entire queue is discarded.</span></span> <span data-ttu-id="6ddd2-793">Azonban miután a tranzakció sikeresen el lett küldve, az üzenetsorban lévő parancsok sorrendben lefutnak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-793">However, after the transaction has been successfully submitted, the queued commands run in sequence.</span></span> <span data-ttu-id="6ddd2-794">Ha bármely parancs meghiúsul, csak az adott parancs futása áll le.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-794">If any command fails, only that command stops running.</span></span> <span data-ttu-id="6ddd2-795">A rendszer az üzenetsorban lévő összes megelőző és követő parancsot végrehajtja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-795">All previous and subsequent commands in the queue are performed.</span></span> <span data-ttu-id="6ddd2-796">További információkat a Redis webhelyén, a [tranzakciók] lapján talál.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-796">For more information, go to the [Transactions] page on the Redis website.</span></span>
  >
  >
* <span data-ttu-id="6ddd2-797">A Redis korlátozott számú elemi műveletet támogat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-797">Redis supports a limited number of atomic operations.</span></span> <span data-ttu-id="6ddd2-798">Az ilyen típusú műveletek közül több kulcs és érték használatát kizárólag az MGET és az MSET művelet támogatja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-798">The only operations of this type that support multiple keys and values are MGET and MSET operations.</span></span> <span data-ttu-id="6ddd2-799">Az MGET műveletek kulcsok egy megadott listájához tartozó értékek gyűjteményét adják vissza, az MSET műveletek pedig ugyanezeket tárolják.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-799">MGET operations return a collection of values for a specified list of keys, and MSET operations store a collection of values for a specified list of keys.</span></span> <span data-ttu-id="6ddd2-800">Ha használni szeretné ezeket a műveleteket, az MSET és az MGET parancsok által hivatkozott kulcs-érték párokat ugyanabban az adatbázisban kell tárolnia.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-800">If you need to use these operations, the key-value pairs that are referenced by the MSET and MGET commands must be stored within the same database.</span></span>

## <a name="partitioning-strategies-for-azure-service-fabric"></a><span data-ttu-id="6ddd2-801">Az Azure Service Fabric particionálási stratégiái</span><span class="sxs-lookup"><span data-stu-id="6ddd2-801">Partitioning Strategies for Azure Service Fabric</span></span>
<span data-ttu-id="6ddd2-802">Az Azure Service Fabric egy mikroszolgáltatás-platform, amely futtatókörnyezetet biztosít az elosztott alkalmazások felhőben végzett futtatására.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-802">Azure Service Fabric is a microservices platform that provides a runtime for distributed applications in the cloud.</span></span> <span data-ttu-id="6ddd2-803">A Service Fabric támogatja a .Net vendégrendszer futtatható fájljait, az állapotalapú és az állapotmentes szolgáltatásokat és a tárolókat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-803">Service Fabric supports .Net guest executables, stateful and stateless services, and containers.</span></span> <span data-ttu-id="6ddd2-804">Az állapotalapú szolgáltatások egy [megbízható gyűjteményt][service-fabric-reliable-collections] biztosítanak az adatok kulcs-érték gyűjteményben való tartós tárolásához a Service Fabric-fürtben.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-804">Stateful services provide a [reliable collection][service-fabric-reliable-collections] to persistently store data in a key-value collection within the Service Fabric cluster.</span></span> <span data-ttu-id="6ddd2-805">A kulcsok megbízható gyűjteményekben való particionálására vonatkozó stratégiákkal kapcsolatos további információkat [Irányelvek és javaslatok az Azure Service Fabric megbízható gyűjteményeihez] tartalmaznak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-805">For more information about strategies for partioning keys in a reliable collection, see [guidelines and recommendations for reliable collections in Azure Service Fabric].</span></span>

### <a name="more-information"></a><span data-ttu-id="6ddd2-806">További információ</span><span class="sxs-lookup"><span data-stu-id="6ddd2-806">More information</span></span>
* <span data-ttu-id="6ddd2-807">[Az Azure Service Fabric áttekintése] egy bevezető az Azure Service Fabric szolgáltatáshoz.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-807">[Overview of Azure Service Fabric] is an introduction to Azure Service Fabric.</span></span>
* <span data-ttu-id="6ddd2-808">[A Service Fabric Reliable Services particionálása] további információkat szolgáltat az Azure Service Fabric Reliable Services szolgáltatásairól.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-808">[Partition Service Fabric reliable services] provides more information about reliable services in Azure Service Fabric.</span></span>

## <a name="partitioning-strategies-for-azure-event-hubs"></a><span data-ttu-id="6ddd2-809">Az Azure Event Hubs particionálási stratégiái</span><span class="sxs-lookup"><span data-stu-id="6ddd2-809">Partitioning strategies for Azure Event Hubs</span></span>

<span data-ttu-id="6ddd2-810">Az [Azure Event Hubs][event-hubs] nagy léptékű adatstreamelésre lett kifejlesztve, és a particionálás integrált részét képezi a horizontális skálázás lehetővé tétele érdekében.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-810">[Azure Event Hubs][event-hubs] is designed for data streaming at massive scale, and partitioning is built into the service to enable horizontal scaling.</span></span> <span data-ttu-id="6ddd2-811">Mindegyik felhasználó az üzenetstreamnek csak egy adott partícióját olvassa.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-811">Each consumer only reads a specific partition of the message stream.</span></span> 

<span data-ttu-id="6ddd2-812">Az esemény-közzétevő csak a partíciókulcsot ismeri, azt a partíciót nem, amelyre az esemény közzé lesz téve.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-812">The event publisher is only aware of its partition key, not the partition to which the events are published.</span></span> <span data-ttu-id="6ddd2-813">A kulcs és a partíció szétválasztása révén a küldőnek nem szükséges behatóan ismernie az alárendelt feldolgozási folyamatokat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-813">This decoupling of key and partition insulates the sender from needing to know too much about the downstream processing.</span></span> <span data-ttu-id="6ddd2-814">(Eseményeket közvetlenül is küldhet adott partíciókra, az azonban általában nem ajánlott.)</span><span class="sxs-lookup"><span data-stu-id="6ddd2-814">(It's also possible send events directly to a given partition, but generally that's not recommended.)</span></span>  

<span data-ttu-id="6ddd2-815">A partíciószám megadásakor hosszú távú szempontokat érdemes mérlegelni.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-815">Consider long-term scale when you select the partition count.</span></span> <span data-ttu-id="6ddd2-816">Az eseményközpontok létrehozását követően a partíciók száma nem módosítható.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-816">After an event hub is created, you can't change the number of partitions.</span></span> 

<span data-ttu-id="6ddd2-817">Az Event Hubs-partíciók használatával kapcsolatos további információkat a [Mi az Event Hubs?] című cikk tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-817">For more information about using partitions in Event Hubs, see [What is Event Hubs?].</span></span>

<span data-ttu-id="6ddd2-818">A rendelkezésre állás és a konzisztencia közti kompromisszummal kapcsolatos megfontolásokat a [Rendelkezésre állás és konzisztencia az Event Hubsban] című cikk tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-818">For considerations about trade-offs between availability and consistency, see [Availability and consistency in Event Hubs].</span></span>

## <a name="rebalancing-partitions"></a><span data-ttu-id="6ddd2-819">Partíciók kiegyenlítése</span><span class="sxs-lookup"><span data-stu-id="6ddd2-819">Rebalancing partitions</span></span>
<span data-ttu-id="6ddd2-820">Ahogy a rendszer egyre kiforrottabbá válik, és a használati minták jobban láthatóak, esetenként módosítani kell a particionálási sémát.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-820">As a system matures and you understand the usage patterns better, you might have to adjust the partitioning scheme.</span></span> <span data-ttu-id="6ddd2-821">Például előfordulhat, hogy az egyes partíciók forgalma aránytalanná válik, és kritikus pontokká válnak, ami túlzott versengést okozhat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-821">For example, individual partitions might start attracting a disproportionate volume of traffic and become hot, leading to excessive contention.</span></span> <span data-ttu-id="6ddd2-822">Emellett elképzelhető, hogy alábecsülte egyes partíciók adatmennyiségét, így ezekben lassan eléri a tárhelykapacitás korlátait.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-822">Additionally, you might have underestimated the volume of data in some partitions, causing you to approach the limits of the storage capacity in these partitions.</span></span> <span data-ttu-id="6ddd2-823">Bármi legyen is az oka, néha szükségessé válik a partíciók kiegyenlítése a terhelés egyenletesebb elosztása érdekében.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-823">Whatever the cause, it is sometimes necessary to rebalance partitions to spread the load more evenly.</span></span>

<span data-ttu-id="6ddd2-824">Egyes adattároló rendszerek, amelyek az adatok kiszolgálókra való elosztásának módját nem hozzák nyilvánosságra, esetenként automatikusan kiegyenlíthetik a partíciókat a rendelkezésre álló erőforrások keretein belül.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-824">In some cases, data storage systems that don't publicly expose how data is allocated to servers can automatically rebalance partitions within the limits of the resources available.</span></span> <span data-ttu-id="6ddd2-825">Más helyzetekben a kiegyenlítés egy felügyeleti feladat, amely két szakaszból áll:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-825">In other situations, rebalancing is an administrative task that consists of two stages:</span></span>

1. <span data-ttu-id="6ddd2-826">Az új particionálási stratégia kialakítása a következők meghatározásához:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-826">Determining the new partitioning strategy to ascertain:</span></span>
   * <span data-ttu-id="6ddd2-827">A felosztandó (vagy épp egyesítendő) partíciók.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-827">Which partitions might need to be split (or possibly combined).</span></span>
   * <span data-ttu-id="6ddd2-828">Az adatok új partíciókra való leosztásának módja új partíciókulcsok kialakításával.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-828">How to allocate data to these new partitions by designing new partition keys.</span></span>
2. <span data-ttu-id="6ddd2-829">Az érintett adatok migrálása a régi particionálási sémáról az újonnan létrehozott partícióhalmazra.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-829">Migrating the affected data from the old partitioning scheme to the new set of partitions.</span></span>

> [!NOTE]
> <span data-ttu-id="6ddd2-830">Az adatbázis-gyűjtemények a kiszolgálókra való leképezése transzparens, azonban előfordulhat, hogy eléri a Cosmos DB-fiókok tárhelykapacitás- és feldolgozásisebesség-korlátait.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-830">The mapping of database collections to servers is transparent, but you can still reach the storage capacity and throughput limits of a Cosmos DB account.</span></span> <span data-ttu-id="6ddd2-831">Amennyiben ez történne, érdemes lehet átdolgoznia a particionálási sémát, és migrálnia az adatokat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-831">If this happens, you might need to redesign your partitioning scheme and migrate the data.</span></span>
>
>

<span data-ttu-id="6ddd2-832">Az adattárolási módszertől és az adattároló rendszer kialakításától függően az adatok a partíciók közti migrálása esetleg azok használata közben is lehetséges (online migrálás).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-832">Depending on the data storage technology and the design of your data storage system, you might be able to migrate data between partitions while they are in use (online migration).</span></span> <span data-ttu-id="6ddd2-833">Ha ez nem lehetséges, szükség lehet az érintett partíciók átmeneti lekapcsolására az adatok migrálása idejére (offline migrálás).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-833">If this isn't possible, you might need to make the affected partitions temporarily unavailable while the data is relocated (offline migration).</span></span>

## <a name="offline-migration"></a><span data-ttu-id="6ddd2-834">Offline migrálás</span><span class="sxs-lookup"><span data-stu-id="6ddd2-834">Offline migration</span></span>
<span data-ttu-id="6ddd2-835">Az offline migrálás valószínűleg a legegyszerűbb megközelítés, mivel ez csökkenti az esélyét annak, hogy versengés lépjen fel.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-835">Offline migration is arguably the simplest approach because it reduces the chances of contention occurring.</span></span> <span data-ttu-id="6ddd2-836">Nem módosítja az adatokat, amíg azok migrálása ás átstrukturálása folyamatban van.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-836">Don't make any changes to the data while it is being moved and restructured.</span></span>

<span data-ttu-id="6ddd2-837">Elméleti szinten a folyamat a következő lépéseket foglalja magában:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-837">Conceptually, this process includes the following steps:</span></span>

1. <span data-ttu-id="6ddd2-838">A szegmens megjelölése offline állapotúként.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-838">Mark the shard offline.</span></span>
2. <span data-ttu-id="6ddd2-839">Az adatok felosztása/egyesítése és áthelyezése az új szegmensekre.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-839">Split-merge and move the data to the new shards.</span></span>
3. <span data-ttu-id="6ddd2-840">Az adatok ellenőrzése.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-840">Verify the data.</span></span>
4. <span data-ttu-id="6ddd2-841">Az új szegmensek online állapotba állítása.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-841">Bring the new shards online.</span></span>
5. <span data-ttu-id="6ddd2-842">A régi szegmens eltávolítása.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-842">Remove the old shard.</span></span>

<span data-ttu-id="6ddd2-843">A rendelkezésre állás korlátozott megőrzése érdekében az 1. lépésben az eredeti szegmens offline állapotú helyett írásvédettként is megjelölhető.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-843">To retain some availability, you can mark the original shard as read-only in step 1 rather than making it unavailable.</span></span> <span data-ttu-id="6ddd2-844">Így az alkalmazások a migrálás közben is olvashatják, de nem módosíthatják az adatokat.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-844">This allows applications to read the data while it is being moved but not to change it.</span></span>

## <a name="online-migration"></a><span data-ttu-id="6ddd2-845">Online migrálás</span><span class="sxs-lookup"><span data-stu-id="6ddd2-845">Online migration</span></span>
<span data-ttu-id="6ddd2-846">Az online migrálás nehezebben végrehajtható, de kevésbé zavaró a felhasználók számára, mivel az adatok a teljes folyamat során elérhetőek maradnak.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-846">Online migration is more complex to perform but less disruptive to users because data remains available during the entire procedure.</span></span> <span data-ttu-id="6ddd2-847">A folyamat hasonlít az offline migrálás folyamatára, azzal a különbséggel, hogy az eredeti szegmenst nem kell megjelölni offline állapotúként (1. lépés).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-847">The process is similar to that used by offline migration, except that the original shard is not marked offline (step 1).</span></span> <span data-ttu-id="6ddd2-848">A migrálási folyamat részletességétől függően (tehát hogy a migrálás például elemenként vagy szegmensenként történik-e), az ügyfélalkalmazások kódjának adatelérésért felelős részének le kell tudnia kezelni azt, hogy az adatok olvasása és írása két helyen történik (az eredeti és az új szegmensen).</span><span class="sxs-lookup"><span data-stu-id="6ddd2-848">Depending on the granularity of the migration process (for example, whether it's done item by item or shard by shard), the data access code in the client applications might have to handle reading and writing data that's held in two locations (the original shard and the new shard).</span></span>

<span data-ttu-id="6ddd2-849">Az online migrálást támogató megoldásokra mutat példát [Skálázás az Elastic Database felosztási-egyesítési eszközének használatával] cikk a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-849">For an example of a solution that supports online migration, see the article [Scaling using the Elastic Database split-merge tool] on the Microsoft website.</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="6ddd2-850">Kapcsolódó minták és útmutatók</span><span class="sxs-lookup"><span data-stu-id="6ddd2-850">Related patterns and guidance</span></span>
<span data-ttu-id="6ddd2-851">Az adatkonzisztencia megvalósítását célzó stratégiák kialakításakor az alábbi minták szintén relevánsak lehetnek a forgatókönyv szempontjából:</span><span class="sxs-lookup"><span data-stu-id="6ddd2-851">When considering strategies for implementing data consistency, the following patterns might also be relevant to your scenario:</span></span>

* <span data-ttu-id="6ddd2-852">A Microsoft webhelyének [Adatkonzisztencia – Ismertető] oldala a konzisztencia az elosztott környezetekben, például a felhőben való fenntartására vonatkozó stratégiákat ismerteti.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-852">The [Data consistency primer] page on the Microsoft website describes strategies for maintaining consistency in a distributed environment such as the cloud.</span></span>
* <span data-ttu-id="6ddd2-853">A Microsoft webhelyének [adatparticionálási útmutató] oldala általános áttekintést nyújt az elosztott megoldások különféle feltételeinek megfelelő partíciók kialakításáról.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-853">The [Data partitioning guidance] page on the Microsoft website provides a general overview of how to design partitions to meet various criteria in a distributed solution.</span></span>
* <span data-ttu-id="6ddd2-854">A Microsoft webhelyén leírt [Horizontális particionálási minta] néhány gyakori stratégiát ír le az adatok horizontális particionálásához.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-854">The [sharding pattern] as described on the Microsoft website summarizes some common strategies for sharding data.</span></span>
* <span data-ttu-id="6ddd2-855">A Microsoft webhelyén leírt [Indextábla minta] az adatokra vonatkozó másodlagos indexek létrehozását mutatja be.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-855">The [index table pattern] as described on the Microsoft website illustrates how to create secondary indexes over data.</span></span> <span data-ttu-id="6ddd2-856">Az alkalmazás ezzel a megközelítéssel gyorsan kérheti le az adatokat olyan lekérdezések használatával, amelyek nem hivatkoznak a gyűjtemények elsődleges kulcsára.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-856">An application can quickly retrieve data with this approach, by using queries that do not reference the primary key of a collection.</span></span>
* <span data-ttu-id="6ddd2-857">A Microsoft webhelyén leírt [Materializált nézet minta] az adatokat a gyors lekérdezési műveletek támogatása érdekében összegző, adatokkal előre feltöltött nézetek létrehozását írja le.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-857">The [materialized view pattern] as described on the Microsoft website describes how to generate pre-populated views that summarize data to support fast query operations.</span></span> <span data-ttu-id="6ddd2-858">Ez a megközelítés akkor lehet hasznos a particionált tárolókban, ha az összegzendő adatokat tartalmazó partíciók több helyre vannak osztva.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-858">This approach can be useful in a partitioned data store if the partitions that contain the data being summarized are distributed across multiple sites.</span></span>
* <span data-ttu-id="6ddd2-859">A Microsoft webhelyének [Az Azure Content Delivery Network használata] foglalkozó cikke további útmutatást tartalmaz a Content Delivery Network Azure-ban való és konfigurálásához és használatához.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-859">The [Using Azure Content Delivery Network] article on the Microsoft website provides additional guidance on configuring and using Content Delivery Network with Azure.</span></span>

## <a name="more-information"></a><span data-ttu-id="6ddd2-860">További információ</span><span class="sxs-lookup"><span data-stu-id="6ddd2-860">More information</span></span>
* <span data-ttu-id="6ddd2-861">A Microsoft webhely [Mi az Azure SQL Database?] című oldala részletes dokumentációval szolgál az SQL-adatbázisok létrehozásával és használatával kapcsolatban.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-861">The page [What is Azure SQL Database?] on the Microsoft website provides detailed documentation that describes how to create and use SQL databases.</span></span>
* <span data-ttu-id="6ddd2-862">A Microsoft webhely [Az Elastic Database szolgáltatásainak áttekintése] oldala átfogóan ismerteti az Elastic Database szolgáltatást.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-862">The page [Elastic Database features overview] on the Microsoft website provides a comprehensive introduction to Elastic Database.</span></span>
* <span data-ttu-id="6ddd2-863">A Microsoft webhelyének [Skálázás az Elastic Database felosztási-egyesítési eszközének használatával] oldala a felosztás/egyesítés szolgáltatás az Elastic Database-szegmensek felügyeletéhez való használatával kapcsolatos információkat tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-863">The page [Scaling using the Elastic Database split-merge tool] on the Microsoft website contains information about using the split-merge service to manage Elastic Database shards.</span></span>
* <span data-ttu-id="6ddd2-864">A Microsoft webhelyének [Azure Storage skálázhatósági és teljesítménycéljait](https://msdn.microsoft.com/library/azure/dn249410.aspx) bemutató oldala az Azure Storage jelenlegi méret- és feldolgozásisebesség-korlátait dokumentálja.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-864">The page [Azure storage scalability and performance targets](https://msdn.microsoft.com/library/azure/dn249410.aspx) on the Microsoft website documents the current sizing and throughput limits of Azure Storage.</span></span>
* <span data-ttu-id="6ddd2-865">A Microsoft webhelyének [Entitáscsoport-tranzakciók végrehajtása] foglalkozó oldala részletes információkat tartalmaz a tranzakcióműveletek Azure Table Storage-ben tárolt entitásokon való végrehajtásával kapcsolatban.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-865">The page [Performing entity group transactions] on the Microsoft website provides detailed information about implementing transactional operations over entities that are stored in Azure table storage.</span></span>
* <span data-ttu-id="6ddd2-866">A Microsoft webhelyének [Az Azure Storage Table tervezési útmutatója] részletes információkat tartalmaz az adatok Azure Table Storage-ben való particionálásával kapcsolatban.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-866">The article [Azure Storage table design guide] on the Microsoft website contains detailed information about partitioning data in Azure table storage.</span></span>
* <span data-ttu-id="6ddd2-867">A Microsoft webhelyének [Az Azure Content Delivery Network használata] foglalkozó oldala az Azure-blobtárolókban tárolt adatok Azure Content Delivery Network használatával való replikálását írja le.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-867">The page [Using Azure Content Delivery Network] on the Microsoft website describes how to replicate data that's held in Azure blob storage by using the Azure Content Delivery Network.</span></span>
* <span data-ttu-id="6ddd2-868">A Microsoft webhelyének [Mi az az Azure Search?] című oldala az Azure Searchben elérhető képességek teljes leírását tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-868">The page [What is Azure Search?] on the Microsoft website provides a full description of the capabilities that are available in Azure Search.</span></span>
* <span data-ttu-id="6ddd2-869">A Microsoft webhelyének [Az Azure Search szolgáltatási korlátozásai] foglalkozó oldala az egyes Azure Search-példányok kapacitását írja le.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-869">The page [Service limits in Azure Search] on the Microsoft website contains information about the capacity of each instance of Azure Search.</span></span>
* <span data-ttu-id="6ddd2-870">A Microsoft webhelyének [Támogatott adattípusok (Azure Search)] foglalkozó oldala a kereshető dokumentumokban és indexekben használható adattípusokat foglalja össze.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-870">The page [Supported data types (Azure Search)] on the Microsoft website summarizes the data types that you can use in searchable documents and indexes.</span></span>
* <span data-ttu-id="6ddd2-871">A Microsoft webhelyének az [Azure Redis Cache] foglalkozó oldala az Azure Redis Cache bemutatását tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-871">The page [Azure Redis Cache] on the Microsoft website provides an introduction to Azure Redis Cache.</span></span>
* <span data-ttu-id="6ddd2-872">A Redis használatával történő particionálásról információkat a Redis webhelyén, az [Particionálás: adatok felosztása több Redis-példány között] oldalán talál.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-872">The [Partitioning: how to split data among multiple Redis instances] page on the Redis website provides information about how to implement partitioning with Redis.</span></span>
* <span data-ttu-id="6ddd2-873">A Microsoft webhelyének [A Redis futtatása CentOS Linux rendszerű virtuális gépen az Azure-ban] tárgyaló oldala egy példán keresztül mutatja be, hogyan hozható létre és konfigurálható egy Azure-beli virtuális gépként futó Redis-csomópont.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-873">The page [Running Redis on a CentOS Linux VM in Azure] on the Microsoft website walks through an example that shows you how to build and configure a Redis node running as an Azure VM.</span></span>
* <span data-ttu-id="6ddd2-874">A Redis webhelyének [Adattípusok] bemutató oldala a Redisben és az Azure Redis Cache-ben elérhető adattípusokat mutatja be.</span><span class="sxs-lookup"><span data-stu-id="6ddd2-874">The [Data types] page on the Redis website describes the data types that are available with Redis and Azure Redis Cache.</span></span>

[Rendelkezésre állás és konzisztencia az Event Hubsban]: /azure/event-hubs/event-hubs-availability-and-consistency
[Availability and consistency in Event Hubs]: /azure/event-hubs/event-hubs-availability-and-consistency
[azure-limits]: /azure/azure-subscription-service-limits
[Azure Content Delivery Network]: /azure/cdn/cdn-overview
[Azure Redis Cache]: https://azure.microsoft.com/services/cache/
[Az Azure Storage skálázhatósági és teljesítménycéljai]: /azure/storage/storage-scalability-targets
[Azure Storage Scalability and Performance Targets]: /azure/storage/storage-scalability-targets
[Az Azure Storage Table tervezési útmutatója]: /azure/storage/storage-table-design-guide
[Azure Storage Table Design Guide]: /azure/storage/storage-table-design-guide
[Többnyelvű megoldások létrehozása]: https://msdn.microsoft.com/library/dn313279.aspx
[Building a Polyglot Solution]: https://msdn.microsoft.com/library/dn313279.aspx
[cosmos-db-ru]: /azure/cosmos-db/request-units
[Adathozzáférés nagymértékben skálázható megoldások esetén: az SQL, NoSQL és többnyelvű adatmegőrzés használata]: https://msdn.microsoft.com/library/dn271399.aspx
[Data Access for Highly-Scalable Solutions: Using SQL, NoSQL, and Polyglot Persistence]: https://msdn.microsoft.com/library/dn271399.aspx
[Adatkonzisztencia – Ismertető]: https://aka.ms/Data-Consistency-Primer
[Data consistency primer]: https://aka.ms/Data-Consistency-Primer
[Adatparticionálási útmutató]: https://msdn.microsoft.com/library/dn589795.aspx
[Data Partitioning Guidance]: https://msdn.microsoft.com/library/dn589795.aspx
[Adattípusok]: https://redis.io/topics/data-types
[Data Types]: https://redis.io/topics/data-types
[cosmosdb-sql-api]: /azure/cosmos-db/sql-api-introduction
[Az Elastic Database szolgáltatásainak áttekintése]: /azure/sql-database/sql-database-elastic-scale-introduction
[Elastic Database features overview]: /azure/sql-database/sql-database-elastic-scale-introduction
[event-hubs]: /azure/event-hubs
[Federations Migration Utility]: https://code.msdn.microsoft.com/vstudio/Federations-Migration-ce61e9c1
[Irányelvek és javaslatok az Azure Service Fabric megbízható gyűjteményeihez]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[guidelines and recommendations for reliable collections in Azure Service Fabric]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[Indextábla minta]: ../patterns/index-table.md
[Index Table Pattern]: ../patterns/index-table.md
[Materializált nézet minta]: ../patterns/materialized-view.md
[Materialized View Pattern]: ../patterns/materialized-view.md
[Többszegmenses lekérdezés]: /azure/sql-database/sql-database-elastic-scale-multishard-querying
[Multi-shard querying]: /azure/sql-database/sql-database-elastic-scale-multishard-querying
[Az Azure Service Fabric áttekintése]: /azure/service-fabric/service-fabric-overview
[Overview of Azure Service Fabric]: /azure/service-fabric/service-fabric-overview
[A Service Fabric Reliable Services particionálása]: /azure/service-fabric/service-fabric-concepts-partitioning
[Partition Service Fabric reliable services]: /azure/service-fabric/service-fabric-concepts-partitioning
[Particionálás: adatok felosztása több Redis-példány között]: https://redis.io/topics/partitioning
[Partitioning: how to split data among multiple Redis instances]: https://redis.io/topics/partitioning
[Entitáscsoport-tranzakciók végrehajtása]: https://msdn.microsoft.com/library/azure/dd894038.aspx
[Performing Entity Group Transactions]: https://msdn.microsoft.com/library/azure/dd894038.aspx
[Oktatóanyag Redis-fürtökhöz]: https://redis.io/topics/cluster-tutorial
[Redis cluster tutorial]: https://redis.io/topics/cluster-tutorial
[A Redis futtatása CentOS Linux rendszerű virtuális gépen az Azure-ban]: https://blogs.msdn.microsoft.com/tconte/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure/
[Running Redis on a CentOS Linux VM in Azure]: https://blogs.msdn.microsoft.com/tconte/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure/
[Skálázás az Elastic Database felosztási-egyesítési eszközének használatával]: /azure/sql-database/sql-database-elastic-scale-overview-split-and-merge
[Scaling using the Elastic Database split-merge tool]: /azure/sql-database/sql-database-elastic-scale-overview-split-and-merge
[Az Azure Content Delivery Network használata]: /azure/cdn/cdn-create-new-endpoint
[Using Azure Content Delivery Network]: /azure/cdn/cdn-create-new-endpoint
[Service Bus-kvóták]: /azure/service-bus-messaging/service-bus-quotas
[Service Bus quotas]: /azure/service-bus-messaging/service-bus-quotas
[service-fabric-reliable-collections]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections
[Az Azure Search szolgáltatási korlátozásai]:  /azure/search/search-limits-quotas-capacity
[Service limits in Azure Search]:  /azure/search/search-limits-quotas-capacity
[Horizontális particionálási minta]: ../patterns/sharding.md
[Sharding pattern]: ../patterns/sharding.md
[Támogatott adattípusok (Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Supported Data Types (Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Tranzakciók]: https://redis.io/topics/transactions
[Transactions]: https://redis.io/topics/transactions
[Mi az Event Hubs?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[What is Event Hubs?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[Mi az az Azure Search?]: /azure/search/search-what-is-azure-search
[What is Azure Search?]: /azure/search/search-what-is-azure-search
[Mi az Azure SQL Database?]: /azure/sql-database/sql-database-technical-overview
[What is Azure SQL Database?]: /azure/sql-database/sql-database-technical-overview
