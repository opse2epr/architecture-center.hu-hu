---
title: Adatparticionálási útmutató
description: Útmutató a szétválasztásának kezelhető és külön-külön elérhető partíciókat.
author: dragon119
ms.date: 07/13/2016
pnp.series.title: Best Practices
ms.openlocfilehash: d1d9c1b3cf07f724eb010fc260d86ceb84b789ca
ms.sourcegitcommit: 2e8b06e9c07875d65b91d5431bfd4bc465a7a242
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 02/09/2018
ms.locfileid: "29059972"
---
# <a name="data-partitioning"></a><span data-ttu-id="5645c-103">Adatparticionálás</span><span class="sxs-lookup"><span data-stu-id="5645c-103">Data partitioning</span></span>

<span data-ttu-id="5645c-104">A sok nagy méretű megoldások adatok, kezelhető és érhető el külön külön partíciókra oszlik.</span><span class="sxs-lookup"><span data-stu-id="5645c-104">In many large-scale solutions, data is divided into separate partitions that can be managed and accessed separately.</span></span> <span data-ttu-id="5645c-105">A jó particionálási stratégia a következő előnyöket maximalizálása ugyanakkor minimalizálja a negatív hatások gondosan kell kiválasztani.</span><span class="sxs-lookup"><span data-stu-id="5645c-105">The partitioning strategy must be chosen carefully to maximize the benefits while minimizing adverse effects.</span></span> <span data-ttu-id="5645c-106">Particionálás segíthet a méretezhetőség javítása, csökkentse a versengés és teljesítményének optimalizálásához.</span><span class="sxs-lookup"><span data-stu-id="5645c-106">Partitioning can help improve scalability, reduce contention, and optimize performance.</span></span> <span data-ttu-id="5645c-107">Egy másik particionálás előnye, hogy egy olyan mechanizmus adatok elosztjuk használatának nyújthat.</span><span class="sxs-lookup"><span data-stu-id="5645c-107">Another benefit of partitioning is that it can provide a mechanism for dividing data by the pattern of use.</span></span> <span data-ttu-id="5645c-108">Például úgy archiválhatók régebbi, kevésbé aktív (ritkán használt) adatok olcsóbb adattárolásra.</span><span class="sxs-lookup"><span data-stu-id="5645c-108">For example, you can archive older, less active (cold) data in cheaper data storage.</span></span>

## <a name="why-partition-data"></a><span data-ttu-id="5645c-109">Miért partícióazonosító adatokat?</span><span class="sxs-lookup"><span data-stu-id="5645c-109">Why partition data?</span></span>
<span data-ttu-id="5645c-110">A legtöbb felhőalapú alkalmazások és szolgáltatások tárolja, és a műveletek részeként adatainak beolvasása.</span><span class="sxs-lookup"><span data-stu-id="5645c-110">Most cloud applications and services store and retrieve data as part of their operations.</span></span> <span data-ttu-id="5645c-111">Az adattároló, amely egy alkalmazás tervét a teljesítményt, adatátvitelt és méretezhetőséget biztosít a rendszer jelentős hatással lehet.</span><span class="sxs-lookup"><span data-stu-id="5645c-111">The design of the data stores that an application uses can have a significant bearing on the performance, throughput, and scalability of a system.</span></span> <span data-ttu-id="5645c-112">A nagy méretű rendszerekhez gyakran alkalmazott egyik módszer-az adatok felosztása külön partíciókra.</span><span class="sxs-lookup"><span data-stu-id="5645c-112">One technique that is commonly applied in large-scale systems is to divide the data into separate partitions.</span></span>

> <span data-ttu-id="5645c-113">Ebben a cikkben kifejezés *particionálás* azt jelenti, hogy fizikailag felosztásával adatok be különálló adattároló folyamatán.</span><span class="sxs-lookup"><span data-stu-id="5645c-113">In this article, the term *partitioning* means the process of physically dividing data into separate data stores.</span></span> <span data-ttu-id="5645c-114">Nincs ugyanaz, mint az SQL Server táblaparticionálást.</span><span class="sxs-lookup"><span data-stu-id="5645c-114">It is not the same as SQL Server table partitioning.</span></span>

<span data-ttu-id="5645c-115">Adatok particionálása kínálhat több előnnyel jár.</span><span class="sxs-lookup"><span data-stu-id="5645c-115">Partitioning data can offer a number of benefits.</span></span> <span data-ttu-id="5645c-116">Például is alkalmazható annak érdekében, hogy:</span><span class="sxs-lookup"><span data-stu-id="5645c-116">For example, it can be applied in order to:</span></span>

* <span data-ttu-id="5645c-117">**Méretezhetőség javítása**.</span><span class="sxs-lookup"><span data-stu-id="5645c-117">**Improve scalability**.</span></span> <span data-ttu-id="5645c-118">Ha egy önálló adatbázis rendszer növelheti, azt idővel eléri a fizikai hardver korlátozni.</span><span class="sxs-lookup"><span data-stu-id="5645c-118">When you scale up a single database system, it will eventually reach a physical hardware limit.</span></span> <span data-ttu-id="5645c-119">Ha több partíciót, amelyek mindegyike külön kiszolgáló üzemelteti, között megoszthatjuk az adatokat ki lehet terjeszteni a rendszer szinte határozatlan ideig.</span><span class="sxs-lookup"><span data-stu-id="5645c-119">If you divide data across multiple partitions, each of which is hosted on a separate server, you can scale out the system almost indefinitely.</span></span>
* <span data-ttu-id="5645c-120">**A teljesítmény javítása**.</span><span class="sxs-lookup"><span data-stu-id="5645c-120">**Improve performance**.</span></span> <span data-ttu-id="5645c-121">Minden egyes partícióra adatelérési műveletek történjen az adatok kisebb kötetet.</span><span class="sxs-lookup"><span data-stu-id="5645c-121">Data access operations on each partition take place over a smaller volume of data.</span></span> <span data-ttu-id="5645c-122">Feltéve, hogy az adatok particionálása megfelelő módon, particionálás is hatékonyabbá teszi a rendszer.</span><span class="sxs-lookup"><span data-stu-id="5645c-122">Provided that the data is partitioned in a suitable way, partitioning can make your system more efficient.</span></span> <span data-ttu-id="5645c-123">Egynél több partíció-műveletek párhuzamosan futtatható.</span><span class="sxs-lookup"><span data-stu-id="5645c-123">Operations that affect more than one partition can run in parallel.</span></span> <span data-ttu-id="5645c-124">Mindegyik partíció található a hálózati késés csökkentése érdekében érdemes használó alkalmazások közelében.</span><span class="sxs-lookup"><span data-stu-id="5645c-124">Each partition can be located near the application that uses it to minimize network latency.</span></span>
* <span data-ttu-id="5645c-125">**Rendelkezésre állás fejlesztése a**.</span><span class="sxs-lookup"><span data-stu-id="5645c-125">**Improve availability**.</span></span> <span data-ttu-id="5645c-126">Az adatok elkülönítését a több kiszolgálóra Ezzel elkerülheti a hibaérzékeny pontok kialakulását.</span><span class="sxs-lookup"><span data-stu-id="5645c-126">Separating data across multiple servers avoids a single point of failure.</span></span> <span data-ttu-id="5645c-127">Ha egy kiszolgáló működése leáll, vagy éppen karbantartják tervezett, csak azokat az adatokat abban a partíció nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="5645c-127">If a server fails, or is undergoing planned maintenance, only the data in that partition is unavailable.</span></span> <span data-ttu-id="5645c-128">A többi partíció műveletek továbbra is.</span><span class="sxs-lookup"><span data-stu-id="5645c-128">Operations on other partitions can continue.</span></span> <span data-ttu-id="5645c-129">A partíciók számának növelésével csökkenthető az egyetlen kiszolgáló hibát relatív hatása nem érhető el adat csökkentésével.</span><span class="sxs-lookup"><span data-stu-id="5645c-129">Increasing the number of partitions reduces the relative impact of a single server failure by reducing the percentage of data that will be unavailable.</span></span> <span data-ttu-id="5645c-130">Mindegyik partíció replikálása is csökkenthető a érintő műveletek egypartíciós hiba esélyét.</span><span class="sxs-lookup"><span data-stu-id="5645c-130">Replicating each partition can further reduce the chance of a single partition failure affecting operations.</span></span> <span data-ttu-id="5645c-131">Is lehetővé teszi, hogy külön kritikus fontosságú adatok, amelyek folyamatosan kell lennie, és magas rendelkezésre állású az alacsony érték, amely rendelkezik alacsonyabb rendelkezésre állási követelmények (például a rendszernapló fájljaiban).</span><span class="sxs-lookup"><span data-stu-id="5645c-131">It also makes it possible to separate critical data that must be continually and highly available from low-value data that has lower availability requirements (log files, for example).</span></span>
* <span data-ttu-id="5645c-132">**A webalkalmazások biztonságának fokozására**.</span><span class="sxs-lookup"><span data-stu-id="5645c-132">**Improve security**.</span></span> <span data-ttu-id="5645c-133">Az adatok és hogyan van particionálva természetétől függően esetleg a bizalmas és nem érzékeny adatok különböző külön partíciót, és ezért különböző kiszolgálókra vagy adatokat tárolja.</span><span class="sxs-lookup"><span data-stu-id="5645c-133">Depending on the nature of the data and how it is partitioned, it might be possible to separate sensitive and non-sensitive data into different partitions, and therefore into different servers or data stores.</span></span> <span data-ttu-id="5645c-134">Biztonsági majd kifejezetten optimalizálva a bizalmas adatok.</span><span class="sxs-lookup"><span data-stu-id="5645c-134">Security can then be specifically optimized for the sensitive data.</span></span>
* <span data-ttu-id="5645c-135">**Működési rugalmasságot biztosítanak**.</span><span class="sxs-lookup"><span data-stu-id="5645c-135">**Provide operational flexibility**.</span></span> <span data-ttu-id="5645c-136">Sok lehetőségek finom műveletek hangolása, maximalizálva felügyelet hatékonysága és a költségek minimalizálása particionálás kínál.</span><span class="sxs-lookup"><span data-stu-id="5645c-136">Partitioning offers many opportunities for fine tuning operations, maximizing administrative efficiency, and minimizing cost.</span></span> <span data-ttu-id="5645c-137">Például megadhatja különböző stratégiák felügyeletének, megfigyelésének, biztonsági mentés és visszaállítás és más felügyeleti feladatokra mindegyik partíció adatainak fontossága alapján.</span><span class="sxs-lookup"><span data-stu-id="5645c-137">For example, you can define different strategies for management, monitoring, backup and restore, and other administrative tasks based on the importance of the data in each partition.</span></span>
* <span data-ttu-id="5645c-138">**Az adattároló használatának egyezés**.</span><span class="sxs-lookup"><span data-stu-id="5645c-138">**Match the data store to the pattern of use**.</span></span> <span data-ttu-id="5645c-139">Particionálás lehetővé teszi, hogy mindegyik partíció adattár, a költségek és a beépített szolgáltatásokat, hogy az adattárolási ajánlatok alapján más típusú telepít.</span><span class="sxs-lookup"><span data-stu-id="5645c-139">Partitioning allows each partition to be deployed on a different type of data store, based on cost and the built-in features that data store offers.</span></span> <span data-ttu-id="5645c-140">Például nagy bináris adatokat tárolhatja a blob-tárolóban, amíg a strukturált adatok több lehessen vonni a dokumentum-adatbázisban.</span><span class="sxs-lookup"><span data-stu-id="5645c-140">For example, large binary data can be stored in a blob data store, while more structured data can be held in a document database.</span></span> <span data-ttu-id="5645c-141">További információkért lásd: [polyglot megoldás kialakításának] minták és gyakorlatok útmutató és [adatelérési kiválóan méretezhető megoldások: SQL használatával, nosql-alapú és polyglot adatmegőrzési] meg a A Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="5645c-141">For more information, see [Building a polyglot solution] in the patterns & practices guide and [Data access for highly-scalable solutions: Using SQL, NoSQL, and polyglot persistence] on the Microsoft website.</span></span>

<span data-ttu-id="5645c-142">Egyes rendszerek nem valósítja meg particionálásból, mert akkor tekinthető előnyös, hanem egy költség.</span><span class="sxs-lookup"><span data-stu-id="5645c-142">Some systems do not implement partitioning because it is considered a cost rather than an advantage.</span></span> <span data-ttu-id="5645c-143">A profilkategóriák gyakori okai:</span><span class="sxs-lookup"><span data-stu-id="5645c-143">Common reasons for this rationale include:</span></span>

* <span data-ttu-id="5645c-144">Sok adattároló rendszerek nem támogatja az olyan illesztéseket partíciók között, és karbantartása a hivatkozási integritás egy particionált rendszerben nehéz lehet.</span><span class="sxs-lookup"><span data-stu-id="5645c-144">Many data storage systems do not support joins across partitions, and it can be difficult to maintain referential integrity in a partitioned system.</span></span> <span data-ttu-id="5645c-145">Gyakran illesztések végrehajtásához szükséges integritási ellenőrzések és alkalmazáskód (a particionálási réteg), a kiegészítő i/o és alkalmazás bonyolultságát ennek eredményeként.</span><span class="sxs-lookup"><span data-stu-id="5645c-145">It is frequently necessary to implement joins and integrity checks in application code (in the partitioning layer), which can result in additional I/O and application complexity.</span></span>
* <span data-ttu-id="5645c-146">Karbantartása partíciókra nincs mindig egy jelentéktelen feladat.</span><span class="sxs-lookup"><span data-stu-id="5645c-146">Maintaining partitions is not always a trivial task.</span></span> <span data-ttu-id="5645c-147">A rendszer, ahol az adatokat az "volatile" szükség lehet egyensúlyba partíciók rendszeres időközönként a versengés és interaktív területek csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="5645c-147">In a system where the data is volatile, you might need to rebalance partitions periodically to reduce contention and hot spots.</span></span>
* <span data-ttu-id="5645c-148">Néhány gyakori eszközök nem működnek természetes particionált adatokkal.</span><span class="sxs-lookup"><span data-stu-id="5645c-148">Some common tools do not work naturally with partitioned data.</span></span>

## <a name="designing-partitions"></a><span data-ttu-id="5645c-149">Partíciók tervezése</span><span class="sxs-lookup"><span data-stu-id="5645c-149">Designing partitions</span></span>
<span data-ttu-id="5645c-150">Adatok különböző módokon lehet particionálni: vízszintesen, függőlegesen vagy funkciók.</span><span class="sxs-lookup"><span data-stu-id="5645c-150">Data can be partitioned in different ways: horizontally, vertically, or functionally.</span></span> <span data-ttu-id="5645c-151">Stratégia attól függ, hogy az adatokat, és az alkalmazások és szolgáltatások által használt adatok követelményeinek particionálás okát.</span><span class="sxs-lookup"><span data-stu-id="5645c-151">The strategy you choose depends on the reason for partitioning the data, and the requirements of the applications and services that will use the data.</span></span>

> [!NOTE]
> <span data-ttu-id="5645c-152">Ez az útmutató ismerteti a particionálási sémák oly módon, amely független a mögöttes adatokat tároló technológia magyarázatát olvashatja.</span><span class="sxs-lookup"><span data-stu-id="5645c-152">The partitioning schemes described in this guidance are explained in a way that is independent of the underlying data storage technology.</span></span> <span data-ttu-id="5645c-153">A számos különböző típusú adatokról, beleértve a relációs és NoSQL-adatbázisok alkalmazhatók.</span><span class="sxs-lookup"><span data-stu-id="5645c-153">They can be applied to many types of data stores, including relational and NoSQL databases.</span></span>
>
>

### <a name="partitioning-strategies"></a><span data-ttu-id="5645c-154">Particionálási stratégia</span><span class="sxs-lookup"><span data-stu-id="5645c-154">Partitioning strategies</span></span>
<span data-ttu-id="5645c-155">Az adatok particionálása három tipikus stratégia a következő:</span><span class="sxs-lookup"><span data-stu-id="5645c-155">The three typical strategies for partitioning data are:</span></span>

* <span data-ttu-id="5645c-156">**Vízszintes particionálás** (gyakran nevezik *horizontális*).</span><span class="sxs-lookup"><span data-stu-id="5645c-156">**Horizontal partitioning** (often called *sharding*).</span></span> <span data-ttu-id="5645c-157">Ezt a stratégiát mindegyik partíció önálló adattárat, de az összes partíció rendelkezik ugyanazon séma.</span><span class="sxs-lookup"><span data-stu-id="5645c-157">In this strategy, each partition is a data store in its own right, but all partitions have the same schema.</span></span> <span data-ttu-id="5645c-158">Mindegyik partíció is ismert, egy *shard* , valamint az adatok, például az ügyfelek e-kereskedelmi alkalmazás meghatározott készletének a rendeléseket megadott részhalmazára.</span><span class="sxs-lookup"><span data-stu-id="5645c-158">Each partition is known as a *shard* and holds a specific subset of the data, such as all the orders for a specific set of customers in an e-commerce application.</span></span>
* <span data-ttu-id="5645c-159">**A vertikális particionálás**.</span><span class="sxs-lookup"><span data-stu-id="5645c-159">**Vertical partitioning**.</span></span> <span data-ttu-id="5645c-160">Ezt a stratégiát mindegyik partíció rendelkezik elemek mezők az adattárban.</span><span class="sxs-lookup"><span data-stu-id="5645c-160">In this strategy, each partition holds a subset of the fields for items in the data store.</span></span> <span data-ttu-id="5645c-161">A mezők használati a minta alapján vannak felosztva.</span><span class="sxs-lookup"><span data-stu-id="5645c-161">The fields are divided according to their pattern of use.</span></span> <span data-ttu-id="5645c-162">Gyakran használt mezőket kell elhelyezni, például egy függőleges partícióban, és kevesebb mint egy másik gyakran használt mezőket.</span><span class="sxs-lookup"><span data-stu-id="5645c-162">For example, frequently accessed fields might be placed in one vertical partition and less frequently accessed fields in another.</span></span>
* <span data-ttu-id="5645c-163">**Funkcionális particionálás**.</span><span class="sxs-lookup"><span data-stu-id="5645c-163">**Functional partitioning**.</span></span> <span data-ttu-id="5645c-164">Ezt a stratégiát, az adatok szerint felhasználásukról minden kötött környezet által a rendszer összesített értéket.</span><span class="sxs-lookup"><span data-stu-id="5645c-164">In this strategy, data is aggregated according to how it is used by each bounded context in the system.</span></span> <span data-ttu-id="5645c-165">Például az elektronikus kereskedelmi rendszer, hogy megvalósítja külön üzleti funkciók számlázásra, és Termékleltár kezelése számla adatokat tárolhatnak egy partíció és a termék leltáradatok egy másik.</span><span class="sxs-lookup"><span data-stu-id="5645c-165">For example, an e-commerce system that implements separate business functions for invoicing and managing product inventory might store invoice data in one partition and product inventory data in another.</span></span>

<span data-ttu-id="5645c-166">Fontos megjegyezni, hogy az itt leírt három stratégiák egyesíthetők.</span><span class="sxs-lookup"><span data-stu-id="5645c-166">It’s important to note that the three strategies described here can be combined.</span></span> <span data-ttu-id="5645c-167">Nem találhatók kölcsönösen kizárja egymást, és azt javasoljuk, hogy érdemes azokat az összes particionálási sémát tervezésekor.</span><span class="sxs-lookup"><span data-stu-id="5645c-167">They are not mutually exclusive, and we recommend that you consider them all when you design a partitioning scheme.</span></span> <span data-ttu-id="5645c-168">Például előfordulhat, hogy adatokat felosztani szilánkok, és majd a vertikális particionálást használnak a további megkönnyíti az egyes shard lévő adatokat.</span><span class="sxs-lookup"><span data-stu-id="5645c-168">For example, you might divide data into shards and then use vertical partitioning to further subdivide the data in each shard.</span></span> <span data-ttu-id="5645c-169">Ehhez hasonlóan az adatok egy funkcionális partíció szilánkok (amely szintén függőleges particionálhatónak) felosztható.</span><span class="sxs-lookup"><span data-stu-id="5645c-169">Similarly, the data in a functional partition can be split into shards (which can also be vertically partitioned).</span></span>

<span data-ttu-id="5645c-170">Minden egyes stratégia eltérő követelmények azonban egy ütköző problémák száma is módosíthatja.</span><span class="sxs-lookup"><span data-stu-id="5645c-170">However, the differing requirements of each strategy can raise a number of conflicting issues.</span></span> <span data-ttu-id="5645c-171">Értékelje ki és elosztása mindegyik egy particionálási sémát, amely megfelel az általános adatfeldolgozás teljesítménycéloknak, a rendszer tervezésekor kell.</span><span class="sxs-lookup"><span data-stu-id="5645c-171">You must evaluate and balance all of these when designing a partitioning scheme that meets the overall data processing performance targets for your system.</span></span> <span data-ttu-id="5645c-172">Az alábbi szakaszok részletesebben stratégiák mindegyikének vizsgálatát.</span><span class="sxs-lookup"><span data-stu-id="5645c-172">The following sections explore each of the strategies in more detail.</span></span>

### <a name="horizontal-partitioning-sharding"></a><span data-ttu-id="5645c-173">Vízszintes particionálás (horizontális)</span><span class="sxs-lookup"><span data-stu-id="5645c-173">Horizontal partitioning (sharding)</span></span>
<span data-ttu-id="5645c-174">1. ábra a vízszintes particionálás vagy horizontális áttekintését tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="5645c-174">Figure 1 shows an overview of horizontal partitioning or sharding.</span></span> <span data-ttu-id="5645c-175">Ebben a példában a termék leltáradatokat a termékkulcs alapján szilánkok van felosztva.</span><span class="sxs-lookup"><span data-stu-id="5645c-175">In this example, product inventory data is divided into shards based on the product key.</span></span> <span data-ttu-id="5645c-176">Minden egyes shard shard kulcsok (A – G és H-Z), ábécésorrendben vannak rendszerezve összefüggő számos adatait tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="5645c-176">Each shard holds the data for a contiguous range of shard keys (A-G and H-Z), organized alphabetically.</span></span>

![A partíciós kulcs alapján vízszintesen particionálási (horizontális) adatok](./images/data-partitioning/DataPartitioning01.png)

<span data-ttu-id="5645c-178">*1. ábra. A partíciós kulcs alapján vízszintesen particionálási (horizontális) adatok*</span><span class="sxs-lookup"><span data-stu-id="5645c-178">*Figure 1. Horizontally partitioning (sharding) data based on a partition key*</span></span>

<span data-ttu-id="5645c-179">Horizontális segít a terhelés eloszlatva további számítógépek, ami csökkenti a versengés, és javítja a teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="5645c-179">Sharding helps you spread the load over more computers, which reduces contention and improves performance.</span></span> <span data-ttu-id="5645c-180">A további kiszolgálók futó szilánkok további hozzáadásával, méretezhető, a rendszer.</span><span class="sxs-lookup"><span data-stu-id="5645c-180">You can scale the system out by adding further shards that run on additional servers.</span></span>

<span data-ttu-id="5645c-181">A legfontosabb tényező, ha a particionálási stratégia megvalósítása a választott horizontális kulcs.</span><span class="sxs-lookup"><span data-stu-id="5645c-181">The most important factor when implementing this partitioning strategy is the choice of sharding key.</span></span> <span data-ttu-id="5645c-182">A kulcs módosítása után a rendszer a művelet nehézkes lehet.</span><span class="sxs-lookup"><span data-stu-id="5645c-182">It can be difficult to change the key after the system is in operation.</span></span> <span data-ttu-id="5645c-183">A kulcs győződjön meg arról, hogy adatok particionálása, hogy a munkaterhelés, még akkor is lehetséges a szilánkok között.</span><span class="sxs-lookup"><span data-stu-id="5645c-183">The key must ensure that data is partitioned so that the workload is as even as possible across the shards.</span></span>

<span data-ttu-id="5645c-184">Ne feledje, hogy különböző szilánkok nem hasonló adatmennyiséggel tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="5645c-184">Note that different shards do not have to contain similar volumes of data.</span></span> <span data-ttu-id="5645c-185">Ehelyett a további fontos szempont kérések száma elosztása érdekében.</span><span class="sxs-lookup"><span data-stu-id="5645c-185">Rather, the more important consideration is to balance the number of requests.</span></span> <span data-ttu-id="5645c-186">Lehet, hogy néhány szilánkok nagyon nagy, de minden elem egy kevés hozzáférési művelet tárgyát.</span><span class="sxs-lookup"><span data-stu-id="5645c-186">Some shards might be very large, but each item is the subject of a low number of access operations.</span></span> <span data-ttu-id="5645c-187">Előfordulhat, hogy más szilánkok kisebb, de egyes elemek gyakrabban érhető el.</span><span class="sxs-lookup"><span data-stu-id="5645c-187">Other shards might be smaller, but each item is accessed much more frequently.</span></span> <span data-ttu-id="5645c-188">Fontos továbbá győződjön meg arról, hogy egyetlen shard nem haladja meg a skála korlátoknak (kapacitás és egyéb feldolgozási erőforrás) az adattár tárolására a shard használt.</span><span class="sxs-lookup"><span data-stu-id="5645c-188">It is also important to ensure that a single shard does not exceed the scale limits (in terms of capacity and processing resources) of the data store that's being used to host that shard.</span></span>

<span data-ttu-id="5645c-189">Ha egy horizontális skálázási sémát használja, ne hozzon létre olyan csatlakozási pontokhoz (vagy a működés közbeni partíciók), amely hatással lehet a teljesítmény és rendelkezésre állás.</span><span class="sxs-lookup"><span data-stu-id="5645c-189">If you use a sharding scheme, avoid creating hotspots (or hot partitions) that can affect performance and availability.</span></span> <span data-ttu-id="5645c-190">Például helyett a felhasználó nevében első betűjének használatakor kivonatát, ügyfél-azonosító, hogy akadályozza meg, amelyek közös és ritkább kezdeti betűket való egyenetlen eloszlását.</span><span class="sxs-lookup"><span data-stu-id="5645c-190">For example, if you use a hash of a customer identifier instead of the first letter of a customer’s name, you prevent the unbalanced distribution that results from common and less common initial letters.</span></span> <span data-ttu-id="5645c-191">Ez a egy tipikus technika, amely segít az adatok több egyenletesen szét partíciókat.</span><span class="sxs-lookup"><span data-stu-id="5645c-191">This is a typical technique that helps distribute data more evenly across partitions.</span></span>

<span data-ttu-id="5645c-192">Válasszon egy horizontális skálázási kulcsot, amely minimálisra csökkenti a nagy szilánkok ossza fel kisebb kódrészletek, minden jövőbeli követelmények nagyobb partíciókra kis szilánkok coalesce, vagy módosítsa a séma, amely leírja a partíciók készlete tárolt adatokat.</span><span class="sxs-lookup"><span data-stu-id="5645c-192">Choose a sharding key that minimizes any future requirements to split large shards into smaller pieces, coalesce small shards into larger partitions, or change the schema that describes the data stored in a set of partitions.</span></span> <span data-ttu-id="5645c-193">Ezek a műveletek nagyon időigényes lehet, és előfordulhat, hogy egy vagy több szilánkok offline állapotba helyezése, hogy végrehajtása közben.</span><span class="sxs-lookup"><span data-stu-id="5645c-193">These operations can be very time consuming, and might require taking one or more shards offline while they are performed.</span></span>

<span data-ttu-id="5645c-194">Ha a rendszer replikálja a szilánkok, esetleg megőrzése a replikák online amíg mások vágási, egyesített, vagy újra konfigurálni.</span><span class="sxs-lookup"><span data-stu-id="5645c-194">If shards are replicated, it might be possible to keep some of the replicas online while others are split, merged, or reconfigured.</span></span> <span data-ttu-id="5645c-195">Azonban a rendszer módosítania kell a újrakonfigurálását közben az alábbi szilánkok található adatok végrehajtható műveletek korlátozására.</span><span class="sxs-lookup"><span data-stu-id="5645c-195">However, the system might need to limit the operations that can be performed on the data in these shards while the reconfiguration is taking place.</span></span> <span data-ttu-id="5645c-196">Például a replikák adatait, amely akkor jelentkezhet, amíg a szilánkok átalakult inconsistences korlátozhatja a csak olvasásra jelölhető.</span><span class="sxs-lookup"><span data-stu-id="5645c-196">For example, the data in the replicas can be marked as read-only to limit the scope of inconsistences that might occur while shards are being restructured.</span></span>

> <span data-ttu-id="5645c-197">További részletes információt és útmutatást ezeket a szempontokat számos, és hasznos technikákat tervezése adatokat tárolja, hogy megvalósítása vízszintes particionálás, a következő témakörben: [horizontális mintát].</span><span class="sxs-lookup"><span data-stu-id="5645c-197">For more detailed information and guidance about many of these considerations, and good practice techniques for designing data stores that implement horizontal partitioning, see [Sharding pattern].</span></span>
>
>

### <a name="vertical-partitioning"></a><span data-ttu-id="5645c-198">A vertikális particionálás</span><span class="sxs-lookup"><span data-stu-id="5645c-198">Vertical partitioning</span></span>
<span data-ttu-id="5645c-199">A tevékenység leggyakoribb felhasználási függőleges particionálásból, hogy csökkentse az i/o és beolvasása az elemek, társított teljesítmény költségek a leggyakrabban elért.</span><span class="sxs-lookup"><span data-stu-id="5645c-199">The most common use for vertical partitioning is to reduce the I/O and performance costs associated with fetching the items that are accessed most frequently.</span></span> <span data-ttu-id="5645c-200">2. ábrán látható egy példa a vertikális particionálás.</span><span class="sxs-lookup"><span data-stu-id="5645c-200">Figure 2 shows an example of vertical partitioning.</span></span> <span data-ttu-id="5645c-201">Ebben a példában minden egyes adatelem más tulajdonságokkal különböző partíciók vannak használatban.</span><span class="sxs-lookup"><span data-stu-id="5645c-201">In this example, different properties for each data item are held in different partitions.</span></span> <span data-ttu-id="5645c-202">Egy partíció, amelyhez a gyakrabban, beleértve a nevét, leírását és termék adatait ára adatokat tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="5645c-202">One partition holds data that is accessed more frequently, including the name, description, and price information for products.</span></span> <span data-ttu-id="5645c-203">Egy másik tartalmazza a kötet árfolyam- és az utolsó rendezett dátum.</span><span class="sxs-lookup"><span data-stu-id="5645c-203">Another holds the volume in stock and the last ordered date.</span></span>

![A minta használati függőleges particionálási adatforgalma](./images/data-partitioning/DataPartitioning02.png)

<span data-ttu-id="5645c-205">*2. ábra. A minta használati függőleges particionálási adatforgalma*</span><span class="sxs-lookup"><span data-stu-id="5645c-205">*Figure 2. Vertically partitioning data by its pattern of use*</span></span>

<span data-ttu-id="5645c-206">Ebben a példában az alkalmazás rendszeresen lekérdezi a termék nevét, leírását és ár az ügyfél számára a termék részletei megjelenítésekor.</span><span class="sxs-lookup"><span data-stu-id="5645c-206">In this example, the application regularly queries the product name, description, and price when displaying the product details to customers.</span></span> <span data-ttu-id="5645c-207">A készlet szinten, és ha a gyártó által rendezett az a termék utolsó dátuma tartják külön partícióra, mert a két elem általában együtt használhatók.</span><span class="sxs-lookup"><span data-stu-id="5645c-207">The stock level and date when the product was last ordered from the manufacturer are held in a separate partition because these two items are commonly used together.</span></span>

<span data-ttu-id="5645c-208">A particionálási sémát rendelkezik előnye, hogy a viszonylag lassú-áthelyezése adatokat (a termék nevét, leírását és ár) elkülönül a dinamikus adatokat (készlet szint és utolsó rendezett dátuma).</span><span class="sxs-lookup"><span data-stu-id="5645c-208">This partitioning scheme has the added advantage that the relatively slow-moving data (product name, description, and price) is separated from the more dynamic data (stock level and last ordered date).</span></span> <span data-ttu-id="5645c-209">Egy alkalmazás hasznosnak találja a hasznos gyorsítótárazza a lassan adatokat a memóriában, ha a gyakori hozzáférést igénylő azt.</span><span class="sxs-lookup"><span data-stu-id="5645c-209">An application might find it beneficial to cache the slow-moving data in memory if it is frequently accessed.</span></span>

<span data-ttu-id="5645c-210">Jellemző még például az a jó particionálási stratégia, hogy a legbiztonságosabbá bizalmas adatokat.</span><span class="sxs-lookup"><span data-stu-id="5645c-210">Another typical scenario for this partitioning strategy is to maximize the security of sensitive data.</span></span> <span data-ttu-id="5645c-211">Például ehhez hitelkártyaszámokat és a megfelelő biztonsági-ellenőrzési számok tárolása különálló partíció.</span><span class="sxs-lookup"><span data-stu-id="5645c-211">For example, you can do this by storing credit card numbers and the corresponding card security verification numbers in separate partitions.</span></span>

<span data-ttu-id="5645c-212">A vertikális particionálás egyidejű hozzáférés szükséges az adatok mennyisége is csökkentheti.</span><span class="sxs-lookup"><span data-stu-id="5645c-212">Vertical partitioning can also reduce the amount of concurrent access that's needed to the data.</span></span>

> <span data-ttu-id="5645c-213">A vertikális particionálás belül a tárolóban, részben normalizálása szeretné bontani a entitás entitás szinten működik egy *széles* egy elem *szűkítéséhez* elemek.</span><span class="sxs-lookup"><span data-stu-id="5645c-213">Vertical partitioning operates at the entity level within a data store, partially normalizing an entity to break it down from a *wide* item to a set of *narrow* items.</span></span> <span data-ttu-id="5645c-214">Az kiválóan oszlop célú adatok tárolókhoz, például a HBase és Cassandra.</span><span class="sxs-lookup"><span data-stu-id="5645c-214">It is ideally suited for column-oriented data stores such as HBase and Cassandra.</span></span> <span data-ttu-id="5645c-215">Ha az adatok egy gyűjtemény az oszlopok nem valószínű, hogy módosítsa, is megpróbálhatja oszlop tárolók az SQL Server használatával.</span><span class="sxs-lookup"><span data-stu-id="5645c-215">If the data in a collection of columns is unlikely to change, you can also consider using column stores in SQL Server.</span></span>
>
>

### <a name="functional-partitioning"></a><span data-ttu-id="5645c-216">Funkcionális particionálás</span><span class="sxs-lookup"><span data-stu-id="5645c-216">Functional partitioning</span></span>
<span data-ttu-id="5645c-217">A rendszerek, ahol egy kötött környezet különböző üzleti terület vagy az alkalmazás szolgáltatások azonosítható működési particionálás biztosít technika elkülönítési és az adatok teljesítmény javításához.</span><span class="sxs-lookup"><span data-stu-id="5645c-217">For systems where it is possible to identify a bounded context for each distinct business area or service in the application, functional partitioning provides a technique for improving isolation and data access performance.</span></span> <span data-ttu-id="5645c-218">Egy másik közös működési particionálás használata csak olvasható adatok számára a jelentéskészítéshez használt írható-olvasható adatok elkülönítéséhez.</span><span class="sxs-lookup"><span data-stu-id="5645c-218">Another common use of functional partitioning is to separate read-write data from read-only data that's used for reporting purposes.</span></span> <span data-ttu-id="5645c-219">3. ábra működési particionálás áttekintése látható, ahol a leltáradatok ügyféladatok elkülönül.</span><span class="sxs-lookup"><span data-stu-id="5645c-219">Figure 3 shows an overview of functional partitioning where inventory data is separated from customer data.</span></span>

![A kötött környezetére vagy nevű altartomány funkcionálisan particionálási adatforgalma](./images/data-partitioning/DataPartitioning03.png)

<span data-ttu-id="5645c-221">*3. ábra. A kötött környezetére vagy nevű altartomány funkcionálisan particionálási adatforgalma*</span><span class="sxs-lookup"><span data-stu-id="5645c-221">*Figure 3. Functionally partitioning data by bounded context or subdomain*</span></span>

<span data-ttu-id="5645c-222">A jó particionálási stratégia csökkentheti az adatok hozzáférési versengés a rendszer különböző részei között.</span><span class="sxs-lookup"><span data-stu-id="5645c-222">This partitioning strategy can help reduce data access contention across different parts of a system.</span></span>

## <a name="designing-partitions-for-scalability"></a><span data-ttu-id="5645c-223">Partíciók méretezhetőségének tervezése</span><span class="sxs-lookup"><span data-stu-id="5645c-223">Designing partitions for scalability</span></span>
<span data-ttu-id="5645c-224">Elengedhetetlen méretét és a munkaterhelés minden partíció esetében fontolja meg, és elosztása őket, hogy az adatok maximális méretezhetőség eléréséhez terjesztése.</span><span class="sxs-lookup"><span data-stu-id="5645c-224">It's vital to consider size and workload for each partition and balance them so that data is distributed to achieve maximum scalability.</span></span> <span data-ttu-id="5645c-225">Azonban meg kell is partícióazonosító az adatokat, hogy nem haladja meg a egypartíciós tárolók méretezési korlátok.</span><span class="sxs-lookup"><span data-stu-id="5645c-225">However, you must also partition the data so that it does not exceed the scaling limits of a single partition store.</span></span>

<span data-ttu-id="5645c-226">Partíciókat méretezhetőséget a tervezésekor, kövesse az alábbi lépéseket:</span><span class="sxs-lookup"><span data-stu-id="5645c-226">Follow these steps when designing partitions for scalability:</span></span>

1. <span data-ttu-id="5645c-227">Elemezze az alkalmazást a hozzáférési minták, például a minden egyes lekérdezés által visszaadott eredményhalmaz megértéséhez, a hozzáférést, a kiszolgálókezelőtől késés és a kiszolgálóoldali gyakoriságát számítási ügyféloldali bővítmények feldolgozási követelményeivel.</span><span class="sxs-lookup"><span data-stu-id="5645c-227">Analyze the application to understand the data access patterns, such as the size of the result set returned by each query, the frequency of access, the inherent latency, and the server-side compute processing requirements.</span></span> <span data-ttu-id="5645c-228">Sok esetben néhány főbb entitások a szükséges erőforrások a legtöbb fog igény.</span><span class="sxs-lookup"><span data-stu-id="5645c-228">In many cases, a few major entities will demand most of the processing resources.</span></span>
2. <span data-ttu-id="5645c-229">Az elemzés segítségével határozhatja meg a jelenlegi és jövőbeli méretezhetőségi célok, például az adatok méretével és a munkaterhelés.</span><span class="sxs-lookup"><span data-stu-id="5645c-229">Use this analysis to determine the current and future scalability targets, such as data size and workload.</span></span> <span data-ttu-id="5645c-230">A partíciókat méretezhetőséget cél teljesítéséhez majd el az adatokat.</span><span class="sxs-lookup"><span data-stu-id="5645c-230">Then distribute the data across the partitions to meet the scalability target.</span></span> <span data-ttu-id="5645c-231">A vízszintes particionálási stratégia kiválasztása a megfelelő shard kulcs fontos győződjön meg arról, hogy a terjesztés még az.</span><span class="sxs-lookup"><span data-stu-id="5645c-231">In the horizontal partitioning strategy, choosing the appropriate shard key is important to make sure distribution is even.</span></span> <span data-ttu-id="5645c-232">További információkért lásd: a [horizontális mintát].</span><span class="sxs-lookup"><span data-stu-id="5645c-232">For more information, see the [Sharding pattern].</span></span>
3. <span data-ttu-id="5645c-233">Győződjön meg arról, hogy megfelelőek-e mindegyik partíció számára elérhető erőforrások kezeléséhez a méretezhetőségi követelményeinek adatok mérete és a teljesítmény tekintetében.</span><span class="sxs-lookup"><span data-stu-id="5645c-233">Make sure that the resources available to each partition are sufficient to handle the scalability requirements in terms of data size and throughput.</span></span> <span data-ttu-id="5645c-234">Például a csomópont, amelyen egy partíció lehet, hogy korlátozzák rögzített tárhely, feldolgozás power, vagy a hálózati sávszélességet biztosít mennyiségét.</span><span class="sxs-lookup"><span data-stu-id="5645c-234">For example, the node that's hosting a partition might impose a hard limit on the amount of storage space, processing power, or network bandwidth that it provides.</span></span> <span data-ttu-id="5645c-235">Ha az adatok tárolási és feldolgozási követelményei valószínűleg meghaladja ezt a korlátot, pontosítsa a particionálási stratégia, vagy ossza fel a kimenő adatforgalmat tovább szükség lehet.</span><span class="sxs-lookup"><span data-stu-id="5645c-235">If the data storage and processing requirements are likely to exceed these limits, it might be necessary to refine your partitioning strategy or split data out further.</span></span> <span data-ttu-id="5645c-236">Például egy méretezhetőség megközelítés lehet eltérő a naplózási adatokat, az alkalmazás alapszolgáltatások külön.</span><span class="sxs-lookup"><span data-stu-id="5645c-236">For example, one scalability approach might be to separate logging data from the core application features.</span></span> <span data-ttu-id="5645c-237">Ez a teljes adattárolási követelmények az a csomópont a méretezési túllépő megelőzése érdekében különálló adattároló használatával teheti meg.</span><span class="sxs-lookup"><span data-stu-id="5645c-237">You do this by using separate data stores to prevent the total data storage requirements from exceeding the scaling limit of the node.</span></span> <span data-ttu-id="5645c-238">Ha adattárolókhoz teljes száma túllépi ezt a csomópontot, külön tárolócsomópontok használandó szükség lehet.</span><span class="sxs-lookup"><span data-stu-id="5645c-238">If the total number of data stores exceeds the node limit, it might be necessary to use separate storage nodes.</span></span>
4. <span data-ttu-id="5645c-239">Segítségével győződjön meg arról, hogy a várt módon terjeszt-e az adatok, és, hogy a partíciók kezelni tud-e be, hogy ki őket a rendszer figyelni.</span><span class="sxs-lookup"><span data-stu-id="5645c-239">Monitor the system under use to verify that the data is distributed as expected and that the partitions can handle the load that is imposed on them.</span></span> <span data-ttu-id="5645c-240">Akkor lehet, hogy a nem egyezik az elemzés várható használat.</span><span class="sxs-lookup"><span data-stu-id="5645c-240">It's possible that the usage does not match the usage that's anticipated by the analysis.</span></span> <span data-ttu-id="5645c-241">Ebben az esetben esetleg a partíciók egyensúlyba.</span><span class="sxs-lookup"><span data-stu-id="5645c-241">In that case, it might be possible to rebalance the partitions.</span></span> <span data-ttu-id="5645c-242">Ennek hiányában szükség lehet ahhoz, hogy a szükséges egyenleg a rendszer bizonyos részeihez átírása.</span><span class="sxs-lookup"><span data-stu-id="5645c-242">Failing that, it might be necessary to redesign some parts of the system to gain the required balance.</span></span>

<span data-ttu-id="5645c-243">Vegye figyelembe, hogy néhány felhőkörnyezetekben erőforrásokat infrastruktúra határok tekintetében.</span><span class="sxs-lookup"><span data-stu-id="5645c-243">Note that some cloud environments allocate resources in terms of infrastructure boundaries.</span></span> <span data-ttu-id="5645c-244">Győződjön meg arról, hogy a kiválasztott határ határain biztosít-e az adatok tárolására, a feldolgozási teljesítmény és a sávszélesség mennyiségét várható növekedésének elegendő helyet.</span><span class="sxs-lookup"><span data-stu-id="5645c-244">Ensure that the limits of your selected boundary provide enough room for any anticipated growth in the volume of data, in terms of data storage, processing power, and bandwidth.</span></span>

<span data-ttu-id="5645c-245">Például az Azure table storage használatakor egy foglalt shard további erőforrások, mint amennyi rendelkezésre áll a tanúsítványigénylések egyetlen partícióra lehet szükség.</span><span class="sxs-lookup"><span data-stu-id="5645c-245">For example, if you use Azure table storage, a busy shard might require more resources than are available to a single partition to handle requests.</span></span> <span data-ttu-id="5645c-246">(Nincs a megadott korlát a kötet, hogy egy adott időn belül egyetlen partícióra által is kezelt kérelem.</span><span class="sxs-lookup"><span data-stu-id="5645c-246">(There is a limit to the volume of requests that can be handled by a single partition in a particular period of time.</span></span> <span data-ttu-id="5645c-247">A lap [az Azure storage méretezhetőségi és Teljesítménycélok] a Microsoft webhelyén olvashat.)</span><span class="sxs-lookup"><span data-stu-id="5645c-247">See the page [Azure storage scalability and performance targets] on the Microsoft website for more details.)</span></span>

 <span data-ttu-id="5645c-248">Ha ez a helyzet, a shard módosítania kell particionálni a terhelés terjednek.</span><span class="sxs-lookup"><span data-stu-id="5645c-248">If this is the case, the shard might need to be repartitioned to spread the load.</span></span> <span data-ttu-id="5645c-249">Ha a teljes méret vagy a sebességét, ezek a táblázatok meghaladja a kapacitását, egy tárfiókot, további tárhely-fiókok létrehozásához, és ezek a fiókok a táblák elosztva szükség lehet.</span><span class="sxs-lookup"><span data-stu-id="5645c-249">If the total size or throughput of these tables exceeds the capacity of a storage account, it might be necessary to create additional storage accounts and spread the tables across these accounts.</span></span> <span data-ttu-id="5645c-250">Ha a storage-fiókok száma meghaladja az előfizetés rendelkezésre álló fiókok számát, majd szükség lehet több előfizetéssel használandó.</span><span class="sxs-lookup"><span data-stu-id="5645c-250">If the number of storage accounts exceeds the number of accounts that are available to a subscription, then it might be necessary to use multiple subscriptions.</span></span>

## <a name="designing-partitions-for-query-performance"></a><span data-ttu-id="5645c-251">A lekérdezési teljesítmény partíciók tervezése</span><span class="sxs-lookup"><span data-stu-id="5645c-251">Designing partitions for query performance</span></span>
<span data-ttu-id="5645c-252">Gyakran is súlyozott lekérdezési teljesítményt, kisebb adatkészletek használatával, és futtassa a párhuzamos lekérdezések.</span><span class="sxs-lookup"><span data-stu-id="5645c-252">Query performance can often be boosted by using smaller data sets and by running parallel queries.</span></span> <span data-ttu-id="5645c-253">Mindegyik partíció kell tartalmaznia a teljes adatkészlet kis részét.</span><span class="sxs-lookup"><span data-stu-id="5645c-253">Each partition should contain a small proportion of the entire data set.</span></span> <span data-ttu-id="5645c-254">A kötet csökkenése javíthatja a lekérdezések teljesítményét.</span><span class="sxs-lookup"><span data-stu-id="5645c-254">This reduction in volume can improve the performance of queries.</span></span> <span data-ttu-id="5645c-255">Particionálás azonban nem tervezéséhez és megfelelő konfigurálása egy adatbázis helyett.</span><span class="sxs-lookup"><span data-stu-id="5645c-255">However, partitioning is not an alternative for designing and configuring a database appropriately.</span></span> <span data-ttu-id="5645c-256">Például győződjön meg arról, hogy rendelkezik a szükséges indexek helyen egy relációs adatbázis használata.</span><span class="sxs-lookup"><span data-stu-id="5645c-256">For example, make sure that you have the necessary indexes in place if you are using a relational database.</span></span>

<span data-ttu-id="5645c-257">A lekérdezési teljesítmény partíciók tervezésekor, kövesse az alábbi lépéseket:</span><span class="sxs-lookup"><span data-stu-id="5645c-257">Follow these steps when designing partitions for query performance:</span></span>

1. <span data-ttu-id="5645c-258">Vizsgálja meg az alkalmazás követelményeket és a teljesítmény:</span><span class="sxs-lookup"><span data-stu-id="5645c-258">Examine the application requirements and performance:</span></span>
   * <span data-ttu-id="5645c-259">Az üzleti követelmények segítségével határozhatja meg a kritikus lekérdezések, amelyek mindig gyorsan kell elvégezni.</span><span class="sxs-lookup"><span data-stu-id="5645c-259">Use the business requirements to determine the critical queries that must always perform quickly.</span></span>
   * <span data-ttu-id="5645c-260">A rendszer lassan végző lekérdezéseket azonosításához figyelése.</span><span class="sxs-lookup"><span data-stu-id="5645c-260">Monitor the system to identify any queries that perform slowly.</span></span>
   * <span data-ttu-id="5645c-261">Hoz létre, mely lekérdezéseket gyakran kerül sor.</span><span class="sxs-lookup"><span data-stu-id="5645c-261">Establish which queries are performed most frequently.</span></span> <span data-ttu-id="5645c-262">Előfordulhat, hogy minden egyes lekérdezés egyetlen példányát minimális költség, de lehet, hogy az erőforrások összesített felhasználása jelentős.</span><span class="sxs-lookup"><span data-stu-id="5645c-262">A single instance of each query might have minimal cost, but the cumulative consumption of resources could be significant.</span></span> <span data-ttu-id="5645c-263">Előfordulhat, hogy a különböző partíció, vagy akár egy gyorsítótár lekérdezések által beolvasott adatok elválasztásához előnyös.</span><span class="sxs-lookup"><span data-stu-id="5645c-263">It might be beneficial to separate the data that's retrieved by these queries into a distinct partition, or even a cache.</span></span>
2. <span data-ttu-id="5645c-264">Az adatok, amelyek teljesítménycsökkenést okoz. partíció:</span><span class="sxs-lookup"><span data-stu-id="5645c-264">Partition the data that is causing slow performance:</span></span>
   * <span data-ttu-id="5645c-265">Mindegyik partíció méretének korlátozására, hogy a lekérdezési válaszidőt a cél.</span><span class="sxs-lookup"><span data-stu-id="5645c-265">Limit the size of each partition so that the query response time is within target.</span></span>
   * <span data-ttu-id="5645c-266">A szilánkok kulcs tervezze meg, hogy az alkalmazás könnyedén megtalálhatja a partíció Ha webkiszolgálókból vízszintes particionálás.</span><span class="sxs-lookup"><span data-stu-id="5645c-266">Design the shard key so that the application can easily find the partition if you are implementing horizontal partitioning.</span></span> <span data-ttu-id="5645c-267">Ez megakadályozza, hogy a lekérdezés nem kell minden partíció keresztül vizsgálata.</span><span class="sxs-lookup"><span data-stu-id="5645c-267">This prevents the query from having to scan through every partition.</span></span>
   * <span data-ttu-id="5645c-268">Érdemes lehet a partíció helyét.</span><span class="sxs-lookup"><span data-stu-id="5645c-268">Consider the location of a partition.</span></span> <span data-ttu-id="5645c-269">Ha lehetséges próbálja meg, amely földrajzilag megközelítik az alkalmazások és az azt elérő felhasználók partíciók adatok tartása.</span><span class="sxs-lookup"><span data-stu-id="5645c-269">If possible, try to keep data in partitions that are geographically close to the applications and users that access it.</span></span>
3. <span data-ttu-id="5645c-270">Ha egy entitás átviteli sebesség és a lekérdezési teljesítmény követelmények, használja a működési particionálás, hogy az entitás alapján.</span><span class="sxs-lookup"><span data-stu-id="5645c-270">If an entity has throughput and query performance requirements, use functional partitioning based on that entity.</span></span> <span data-ttu-id="5645c-271">Ha ez nem megfelel, alkalmazza a vízszintes particionálás is.</span><span class="sxs-lookup"><span data-stu-id="5645c-271">If this still doesn't satisfy the requirements, apply horizontal partitioning as well.</span></span> <span data-ttu-id="5645c-272">A legtöbb esetben elegendő egyetlen jó particionálási stratégia, de egyes esetekben hatékonyabb, ha mindkét stratégia kombinálni.</span><span class="sxs-lookup"><span data-stu-id="5645c-272">In most cases a single partitioning strategy will suffice, but in some cases it is more efficient to combine both strategies.</span></span>
4. <span data-ttu-id="5645c-273">Érdemes lehet aszinkron teljesítmény javítása érdekében partíció párhuzamosan futó lekérdezések.</span><span class="sxs-lookup"><span data-stu-id="5645c-273">Consider using asynchronous queries that run in parallel across partitions to improve performance.</span></span>

## <a name="designing-partitions-for-availability"></a><span data-ttu-id="5645c-274">A rendelkezésre állás érdekében partíciók tervezése</span><span class="sxs-lookup"><span data-stu-id="5645c-274">Designing partitions for availability</span></span>
<span data-ttu-id="5645c-275">Adatok particionálása javíthatja az alkalmazások rendelkezésre állását biztosítja, hogy a teljes adatkészlet nem jelent-e a hibaérzékeny pontok kialakulását, és, hogy az adatkészlet egyes részhalmaza függetlenül is kezelhetők.</span><span class="sxs-lookup"><span data-stu-id="5645c-275">Partitioning data can improve the availability of applications by ensuring that the entire dataset does not constitute a single point of failure and that individual subsets of the dataset can be managed independently.</span></span> <span data-ttu-id="5645c-276">Kritikus fontosságú adatok partíciók replikálása szintén javíthatják a rendelkezésre állási.</span><span class="sxs-lookup"><span data-stu-id="5645c-276">Replicating partitions that contain critical data can also improve availability.</span></span>

<span data-ttu-id="5645c-277">Tervezése és megvalósítása partíciók, vegye figyelembe a következő rendelkezésre állási befolyásoló tényezők:</span><span class="sxs-lookup"><span data-stu-id="5645c-277">When designing and implementing partitions, consider the following factors that affect availability:</span></span>

* <span data-ttu-id="5645c-278">**Hogyan kritikus az adatokat, hogy az üzleti tevékenységre**.</span><span class="sxs-lookup"><span data-stu-id="5645c-278">**How critical the data is to business operations**.</span></span> <span data-ttu-id="5645c-279">Egyes adatok közé tartozik a kritikus üzleti adatok, például banki tranzakciók vagy számlázási adatokat.</span><span class="sxs-lookup"><span data-stu-id="5645c-279">Some data might include critical business information such as invoice details or bank transactions.</span></span> <span data-ttu-id="5645c-280">Egyéb adatok közé tartozik a kevésbé fontos működési adatokat, például a naplófájlok, teljesítmény nyomkövetési adatokat, és így tovább.</span><span class="sxs-lookup"><span data-stu-id="5645c-280">Other data might include less critical operational data, such as log files, performance traces, and so on.</span></span> <span data-ttu-id="5645c-281">Különböző típusú adatok azonosítása, után vegye figyelembe:</span><span class="sxs-lookup"><span data-stu-id="5645c-281">After identifying each type of data, consider:</span></span>
  * <span data-ttu-id="5645c-282">Kritikus fontosságú adatok tárolása egy megfelelő biztonsági mentési terv magas rendelkezésre állású partíciók.</span><span class="sxs-lookup"><span data-stu-id="5645c-282">Storing critical data in highly-available partitions with an appropriate backup plan.</span></span>
  * <span data-ttu-id="5645c-283">Létrehozó különálló felügyeleti és figyelési mechanizmusok vagy a különböző criticalities adatkészlet egyes eljárások.</span><span class="sxs-lookup"><span data-stu-id="5645c-283">Establishing separate management and monitoring mechanisms or procedures for the different criticalities of each dataset.</span></span> <span data-ttu-id="5645c-284">Helyezze olyan adatok, amelyek a partícióra kritikusságúként azonos szinten, hogy egy megfelelő gyakorisággal, biztonsági másolat együtt.</span><span class="sxs-lookup"><span data-stu-id="5645c-284">Place data that has the same level of criticality in the same partition so that it can be backed up together at an appropriate frequency.</span></span> <span data-ttu-id="5645c-285">Például kívánt banki tranzakciók adatainak tárolásához módosítania kell biztonsági mentését gyakrabban kívánt naplózás vagy a nyomkövetési adatok tárolására.</span><span class="sxs-lookup"><span data-stu-id="5645c-285">For example, partitions that hold data for bank transactions might need to be backed up more frequently than partitions that hold logging or trace information.</span></span>
* <span data-ttu-id="5645c-286">**Hogyan kezelheti az egyes partíciók**.</span><span class="sxs-lookup"><span data-stu-id="5645c-286">**How individual partitions can be managed**.</span></span> <span data-ttu-id="5645c-287">Partíciók támogatására független felügyeleti és karbantartási tervezése több előnyökkel jár.</span><span class="sxs-lookup"><span data-stu-id="5645c-287">Designing partitions to support independent management and maintenance provides several advantages.</span></span> <span data-ttu-id="5645c-288">Példa:</span><span class="sxs-lookup"><span data-stu-id="5645c-288">For example:</span></span>
  * <span data-ttu-id="5645c-289">A partíció nem sikerül, ha akkor állíthatók helyre egymástól függetlenül nem befolyásolja a többi partíció adatainak elérhető alkalmazásokat példányai.</span><span class="sxs-lookup"><span data-stu-id="5645c-289">If a partition fails, it can be recovered independently without affecting instances of applications that access data in other partitions.</span></span>
  * <span data-ttu-id="5645c-290">Particionálás adatokat földrajzi területenként lehetővé teszi, hogy minden hely csúcsidején elvégzi az ütemezett karbantartási feladatok.</span><span class="sxs-lookup"><span data-stu-id="5645c-290">Partitioning data by geographical area allows scheduled maintenance tasks to occur at off-peak hours for each location.</span></span> <span data-ttu-id="5645c-291">Győződjön meg arról, hogy partíciók nem túl nagy, ebben az időszakban nem lehet végrehajtani a tervezett karbantartások megelőzése érdekében.</span><span class="sxs-lookup"><span data-stu-id="5645c-291">Ensure that partitions are not too big to prevent any planned maintenance from being completed during this period.</span></span>
* <span data-ttu-id="5645c-292">**E kritikus fontosságú adatok partíciók közötti replikáció**.</span><span class="sxs-lookup"><span data-stu-id="5645c-292">**Whether to replicate critical data across partitions**.</span></span> <span data-ttu-id="5645c-293">Ezt a stratégiát javíthatja rendelkezésre állásáról és teljesítményéről, de azt is vezethet konzisztenciabeli problémákat.</span><span class="sxs-lookup"><span data-stu-id="5645c-293">This strategy can improve availability and performance, although it can also introduce consistency issues.</span></span> <span data-ttu-id="5645c-294">Egy partíció adatait szinkronizálni kell minden replika végzett módosítások időt vesz igénybe.</span><span class="sxs-lookup"><span data-stu-id="5645c-294">It takes time for changes made to data in a partition to be synchronized with every replica.</span></span> <span data-ttu-id="5645c-295">Ebben az időszakban a különböző partíciók különböző értékeket fogja tartalmazni.</span><span class="sxs-lookup"><span data-stu-id="5645c-295">During this period, different partitions will contain different data values.</span></span>

## <a name="understanding-how-partitioning-affects-design-and-development"></a><span data-ttu-id="5645c-296">Hogyan particionálás befolyásolja a tervezési és fejlesztési ismertetése</span><span class="sxs-lookup"><span data-stu-id="5645c-296">Understanding how partitioning affects design and development</span></span>
<span data-ttu-id="5645c-297">A tervezési és a rendszer fejlesztési particionálás használatával hozzáadja összetettségét.</span><span class="sxs-lookup"><span data-stu-id="5645c-297">Using partitioning adds complexity to the design and development of your system.</span></span> <span data-ttu-id="5645c-298">Fontolja meg a particionálás a alapvető részeként a rendszer kialakítása még akkor is, ha a rendszer először csak olyan egyetlen partícióra.</span><span class="sxs-lookup"><span data-stu-id="5645c-298">Consider partitioning as a fundamental part of system design even if the system initially only contains a single partition.</span></span> <span data-ttu-id="5645c-299">Meg oldani a particionálás utólag, mint amikor a rendszer megkezdi a teljesítmény- és méretezhetőségi problémákkal küzdenek, ha összetettségét növeli a rendszer, mivel már van egy működő rendszer fenntartásához.</span><span class="sxs-lookup"><span data-stu-id="5645c-299">If you address partitioning as an afterthought, when the system starts to suffer performance and scalability issues, the complexity increases because you already have a live system to maintain.</span></span>

<span data-ttu-id="5645c-300">Ha frissíti a rendszer átfogó particionálás ebben a környezetben, azt szükségessé teszi az adatok hozzáférési logikai módosítása.</span><span class="sxs-lookup"><span data-stu-id="5645c-300">If you update the system to incorporate partitioning in this environment, it necessitates modifying the data access logic.</span></span> <span data-ttu-id="5645c-301">Azt is magába foglaló áttelepítése szét, partíciók gyakran közben felhasználók kellene továbbra is használja a rendszer a meglévő adatok nagy mennyiségben.</span><span class="sxs-lookup"><span data-stu-id="5645c-301">It can also involve migrating large quantities of existing data to distribute it across partitions, often while users expect to be able to continue using the system.</span></span>

<span data-ttu-id="5645c-302">Bizonyos esetekben particionálás nem fontos, mert a kezdeti adatkészlet kicsi, és egy adott kiszolgáló könnyen kezelhető.</span><span class="sxs-lookup"><span data-stu-id="5645c-302">In some cases, partitioning is not considered important because the initial dataset is small and can be easily handled by a single server.</span></span> <span data-ttu-id="5645c-303">Erre akkor lehet igaz, a rendszer a kezdeti méretét felüli nem várt, de számos kereskedelmi rendszer kell bontsa ki a felhasználók növekszik számának.</span><span class="sxs-lookup"><span data-stu-id="5645c-303">This might be true in a system that is not expected to scale beyond its initial size, but many commercial systems need to expand as the number of users increases.</span></span> <span data-ttu-id="5645c-304">A bővítés általában csatolni egy növekedésének adatok mennyiségét.</span><span class="sxs-lookup"><span data-stu-id="5645c-304">This expansion is typically accompanied by a growth in the volume of data.</span></span>

<span data-ttu-id="5645c-305">Is fontos tisztában lenni azzal, hogy particionálás nem mindig nagy adattárolókhoz függvényében.</span><span class="sxs-lookup"><span data-stu-id="5645c-305">It's also important to understand that partitioning is not always a function of large data stores.</span></span> <span data-ttu-id="5645c-306">Például egy kis adattár fokozottan érheti el a több száz egyidejű ügyfelek.</span><span class="sxs-lookup"><span data-stu-id="5645c-306">For example, a small data store might be heavily accessed by hundreds of concurrent clients.</span></span> <span data-ttu-id="5645c-307">Ebben az esetben az adatok particionálása segíthet csökkentheti a versengés és javíthatja a teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="5645c-307">Partitioning the data in this situation can help to reduce contention and improve throughput.</span></span>

<span data-ttu-id="5645c-308">Adatok particionálási sémát tervezésekor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="5645c-308">Consider the following points when you design a data partitioning scheme:</span></span>

* <span data-ttu-id="5645c-309">**Ahol lehetséges, a leggyakrabban használt adatbázis-műveletek adatok együtt tartása a kereszt-partíció adatelérési műveletek minimalizálása érdekében minden partíció**.</span><span class="sxs-lookup"><span data-stu-id="5645c-309">**Where possible, keep data for the most common database operations together in each partition to minimize cross-partition data access operations**.</span></span> <span data-ttu-id="5645c-310">Több időt vesz igénybe, mint csak belül egyetlen partícióra lekérdezése közötti partíciók lekérdezése lehet, de a partíciókat a lekérdezések egyetlen halmazát optimalizálása kedvezőtlen hatással lehet más részhalmazához rendelésére lekérdezések.</span><span class="sxs-lookup"><span data-stu-id="5645c-310">Querying across partitions can be more time-consuming than querying only within a single partition, but optimizing partitions for one set of queries might adversely affect other sets of queries.</span></span> <span data-ttu-id="5645c-311">Partíciók között lekérdezése nem kerülheti el, ha minimálisra csökkenthető a lekérdezés idejét párhuzamos lekérdezések futtatásával, és az alkalmazáson belül az eredmények összesítése.</span><span class="sxs-lookup"><span data-stu-id="5645c-311">When you can't avoid querying across partitions, minimize query time by running parallel queries and aggregating the results within the application.</span></span> <span data-ttu-id="5645c-312">Előfordulhat, hogy ez a módszer nem egyes esetekben, amikor szükséges ahhoz, hogy egy lekérdezés eredményt beszerezni, használhatja a következő lekérdezés nem lehetséges.</span><span class="sxs-lookup"><span data-stu-id="5645c-312">This approach might not be possible in some cases, such as when it's necessary to obtain a result from one query and use it in the next query.</span></span>
* <span data-ttu-id="5645c-313">**Ha lekérdezések akkor viszonylag statikus referenciaadatok, például az irányítószámot táblák vagy termék listák használatát, javasoljuk, hogy ezeket az adatokat az összes különböző partíciók külön keresési művelet kapcsolatos követelmények csökkentése érdekében a partíciók replikálása**.</span><span class="sxs-lookup"><span data-stu-id="5645c-313">**If queries make use of relatively static reference data, such as postal code tables or product lists, consider replicating this data in all of the partitions to reduce the requirement for separate lookup operations in different partitions**.</span></span> <span data-ttu-id="5645c-314">Ez a megközelítés is csökkentheti a referenciaadatok válik, hogy a nagy forgalom között a teljes rendszer "Forró" dataset valószínűségét.</span><span class="sxs-lookup"><span data-stu-id="5645c-314">This approach can also reduce the likelihood of the reference data becoming a "hot" dataset that is subject to heavy traffic from across the entire system.</span></span> <span data-ttu-id="5645c-315">Van azonban a referenciaadatok előforduló módosítások szinkronizálása társított további költségek.</span><span class="sxs-lookup"><span data-stu-id="5645c-315">However,   there is an additional cost associated with synchronizing any changes that might occur to this reference data.</span></span>
* <span data-ttu-id="5645c-316">**Ahol lehetséges, minimálisra csökkenthető a hivatkozási integritás követelményei közötti függőleges és funkcionális partíciók**.</span><span class="sxs-lookup"><span data-stu-id="5645c-316">**Where possible, minimize requirements for referential integrity across vertical and functional partitions**.</span></span> <span data-ttu-id="5645c-317">Ezek a rendszerek a magának az alkalmazásnak karbantartásáért felelős a hivatkozási integritás partíciók között, amikor az adatok frissítése és felhasznált.</span><span class="sxs-lookup"><span data-stu-id="5645c-317">In these schemes, the application itself is responsible for maintaining referential integrity across partitions when data is updated and consumed.</span></span> <span data-ttu-id="5645c-318">Lekérdezés kell adatok között több partíció, amelyhez csatlakozni adatok csak a partíción belül, mert az alkalmazás általában egymást követő lekérdezések végrehajtásához, egy kulcs, és egy külső kulcs lekérdezések mint lassabban működik.</span><span class="sxs-lookup"><span data-stu-id="5645c-318">Queries that must join data across multiple partitions run more slowly than queries that join data only within the same partition because the application typically needs to perform consecutive queries based on a key and then on a foreign key.</span></span> <span data-ttu-id="5645c-319">Ehelyett érdemes végez replikálást vagy vonja normalizálása a vonatkozó adatokat.</span><span class="sxs-lookup"><span data-stu-id="5645c-319">Instead, consider replicating or de-normalizing the relevant data.</span></span> <span data-ttu-id="5645c-320">A lekérdezés idejét, amennyiben szükségesek a kereszt-partíció illesztések minimalizálása érdekében párhuzamos lekérdezések futtatása során a partíciók, és az adatokat az alkalmazásban.</span><span class="sxs-lookup"><span data-stu-id="5645c-320">To minimize the query time where cross-partition joins are necessary, run parallel queries over the partitions and join the data within the application.</span></span>
* <span data-ttu-id="5645c-321">**Vegye figyelembe, hogy milyen hatással a particionálási sémát előfordulhat, hogy az adatok konzisztenciájának a partíciók között.**</span><span class="sxs-lookup"><span data-stu-id="5645c-321">**Consider the effect that the partitioning scheme might have on the data consistency across partitions.**</span></span> <span data-ttu-id="5645c-322">Mérlegelje, hogy az erős konzisztencia feltétele ténylegesen.</span><span class="sxs-lookup"><span data-stu-id="5645c-322">Evaluate whether strong consistency is actually a requirement.</span></span> <span data-ttu-id="5645c-323">Ehelyett egy általánosan használt megközelítés a felhőben, hogy alkalmazza a végleges konzisztencia.</span><span class="sxs-lookup"><span data-stu-id="5645c-323">Instead, a common approach in the cloud is to implement eventual consistency.</span></span> <span data-ttu-id="5645c-324">Mindegyik partíció adatait a külön-külön frissül, és az alkalmazáslogikát biztosítja, hogy a frissítések összes sikeresen megadta.</span><span class="sxs-lookup"><span data-stu-id="5645c-324">The data in each partition is updated separately, and the application logic ensures that the updates are all completed successfully.</span></span> <span data-ttu-id="5645c-325">Az adatok lekérdezése egy idővel konzisztenssé művelet futtatása közben felmerülő inkonzisztenciák is kezeli.</span><span class="sxs-lookup"><span data-stu-id="5645c-325">It also handles the inconsistencies that can arise from querying data while an eventually consistent operation is running.</span></span> <span data-ttu-id="5645c-326">A végleges konzisztencia kapcsolatos további információkért lásd: a [adatok konzisztencia ismertetése].</span><span class="sxs-lookup"><span data-stu-id="5645c-326">For more information about implementing eventual consistency, see the [Data consistency primer].</span></span>
* <span data-ttu-id="5645c-327">**Vegye figyelembe, hogy lekérdezések hogyan keresse meg a megfelelő partíció**.</span><span class="sxs-lookup"><span data-stu-id="5645c-327">**Consider how queries locate the correct partition**.</span></span> <span data-ttu-id="5645c-328">Lekérdezés partíciók keresse meg a szükséges adatokat kell beolvasni, ha nincs jelentős hatással a teljesítményre, még akkor is, ha több párhuzamos lekérdezések szolgáltatások futnak.</span><span class="sxs-lookup"><span data-stu-id="5645c-328">If a query must scan all partitions to locate the required data, there is a significant impact on performance, even when multiple parallel queries are running.</span></span> <span data-ttu-id="5645c-329">A függőleges és funkcionális particionálási stratégiák használó lekérdezések természetes adhatja meg a partíciók.</span><span class="sxs-lookup"><span data-stu-id="5645c-329">Queries that are used with vertical and functional partitioning strategies can naturally specify the partitions.</span></span> <span data-ttu-id="5645c-330">Azonban vízszintes particionálás (horizontális) teheti nehéz elemének megkeresése, mert minden shard ugyanazon séma.</span><span class="sxs-lookup"><span data-stu-id="5645c-330">However, horizontal partitioning (sharding) can make locating an item difficult because every shard has the same schema.</span></span> <span data-ttu-id="5645c-331">Egy tipikus horizontális megoldás, hogy karbantartása, hogy segítségével megkeresheti az adatok elemeket shard helyét.</span><span class="sxs-lookup"><span data-stu-id="5645c-331">A typical solution for sharding is to maintain a map that can be used to look up the shard location for specific items of data.</span></span> <span data-ttu-id="5645c-332">Ez a térkép az alkalmazás horizontális logikája megvalósított, vagy ha támogatja az áttetsző horizontális tartja fenn a tárolót.</span><span class="sxs-lookup"><span data-stu-id="5645c-332">This map can be implemented in the sharding logic of the application, or maintained by the data store if it supports transparent sharding.</span></span>
* <span data-ttu-id="5645c-333">**Vízszintes jó particionálási stratégia használata esetén vegye figyelembe a szilánkok rendszeresen újraelosztás**.</span><span class="sxs-lookup"><span data-stu-id="5645c-333">**When using a horizontal partitioning strategy, consider periodically rebalancing the shards**.</span></span> <span data-ttu-id="5645c-334">Ezzel a megoldással mérete és a munkaterhelés minimalizálása érdekében a csatlakozási pontokhoz, lekérdezési teljesítmény maximalizálása és fizikai tárhelyet korlátozások kerülő egyenletes elosztása az adatokat.</span><span class="sxs-lookup"><span data-stu-id="5645c-334">This helps distribute the data evenly by size and by workload to minimize hotspots, maximize query performance, and work around physical storage limitations.</span></span> <span data-ttu-id="5645c-335">Ez azonban egy összetett feladat, amelyek gyakran egy egyéni eszköz vagy folyamat használatát igényli.</span><span class="sxs-lookup"><span data-stu-id="5645c-335">However, this is a complex task that often requires the use of a custom tool or process.</span></span>
* <span data-ttu-id="5645c-336">**Mindegyik partíció replikálja, ha meghibásodása elleni további védelmet nyújt**.</span><span class="sxs-lookup"><span data-stu-id="5645c-336">**If you replicate each partition, it provides additional protection against failure**.</span></span> <span data-ttu-id="5645c-337">Ha nem sikerül egy replikát, lekérdezések irányítható a működő példány felé.</span><span class="sxs-lookup"><span data-stu-id="5645c-337">If a single replica fails, queries can be directed towards a working copy.</span></span>
* <span data-ttu-id="5645c-338">**Ha eléri a jó particionálási stratégia fizikai korlátai, szükség lehet egy másik szintre méretezhetőségét kiterjeszteni**.</span><span class="sxs-lookup"><span data-stu-id="5645c-338">**If you reach the physical limits of a partitioning strategy, you might need to extend the scalability to a different level**.</span></span> <span data-ttu-id="5645c-339">Például ha az adatbázis szintjén a particionálás, szükség lehet keresse meg, vagy a partíciók több adatbázis replikálása.</span><span class="sxs-lookup"><span data-stu-id="5645c-339">For example, if partitioning is at the database level, you might need to locate or replicate partitions in multiple databases.</span></span> <span data-ttu-id="5645c-340">Particionálás már van az adatbázis szintjén, és fizikai korlátozások problémává, azt jelentheti, hogy szeretné-e keresse meg, vagy a partíciók több birtokosi fiókok replikálása.</span><span class="sxs-lookup"><span data-stu-id="5645c-340">If partitioning is already at the database level, and physical limitations are an issue, it might mean that you need to locate or replicate partitions in multiple hosting accounts.</span></span>
* <span data-ttu-id="5645c-341">**Több partíció adatait hozzáférő tranzakciók elkerülése**.</span><span class="sxs-lookup"><span data-stu-id="5645c-341">**Avoid transactions that access data in multiple partitions**.</span></span> <span data-ttu-id="5645c-342">Néhány tárolók megvalósítása tranzakciós adatkonzisztencia és műveletek integritását, amely adatokat, de csak abban az esetben, ha az adatok találhatók egyetlen partícióra módosítása.</span><span class="sxs-lookup"><span data-stu-id="5645c-342">Some data stores implement transactional consistency and integrity for operations that modify data, but only when the data is located in a single partition.</span></span> <span data-ttu-id="5645c-343">Ha több partíciót keresztül kell dokumentumos tranzakciótámogatást, valószínűleg akkor valósítható meg ez az alkalmazás logikája, mert a legtöbb particionálási rendszerek nem tartalmazzák a natív támogatást.</span><span class="sxs-lookup"><span data-stu-id="5645c-343">If you need transactional support across multiple partitions, you will probably need to implement this as part of your application logic because most partitioning systems do not provide native support.</span></span>

<span data-ttu-id="5645c-344">Minden adattárolókhoz szükséges néhány működési kezelése és figyelése.</span><span class="sxs-lookup"><span data-stu-id="5645c-344">All data stores require some operational management and monitoring activity.</span></span> <span data-ttu-id="5645c-345">A feladatok között lehet adatok betöltése, biztonsági mentése és adatok helyreállításához, adatok átrendezése és győződjön meg arról, hogy a rendszer megfelelően és hatékonyan működik-e.</span><span class="sxs-lookup"><span data-stu-id="5645c-345">The tasks can range from loading data, backing up and restoring data, reorganizing data, and ensuring that the system is performing correctly and efficiently.</span></span>

<span data-ttu-id="5645c-346">Vegye figyelembe a következő tényezőket, amelyek hatással vannak az operatív felügyeleti:</span><span class="sxs-lookup"><span data-stu-id="5645c-346">Consider the following factors that affect operational management:</span></span>

* <span data-ttu-id="5645c-347">**Megfelelő felügyeleti és működési feladatok megvalósításához, amikor az adatok particionálása**.</span><span class="sxs-lookup"><span data-stu-id="5645c-347">**How to implement appropriate management and operational tasks when the data is partitioned**.</span></span> <span data-ttu-id="5645c-348">Ezek a feladatok állhatnak biztonsági mentése és visszaállítása, adatok, a rendszer, és más felügyeleti feladatok figyelése archiválása.</span><span class="sxs-lookup"><span data-stu-id="5645c-348">These tasks might include backup and restore, archiving data, monitoring the system, and other administrative tasks.</span></span> <span data-ttu-id="5645c-349">Például a biztonsági mentési és visszaállítási műveletek során karbantartása logikai konzisztencia kihívást lehet.</span><span class="sxs-lookup"><span data-stu-id="5645c-349">For example, maintaining logical consistency during backup and restore operations can be a challenge.</span></span>
* <span data-ttu-id="5645c-350">**Az adatok betöltése az több partíciót és az új adatok, amelyek más forrásból érkező van**.</span><span class="sxs-lookup"><span data-stu-id="5645c-350">**How to load the data into multiple partitions and add new data that's arriving from other sources**.</span></span> <span data-ttu-id="5645c-351">Egyes eszközök és segédeszközök nem támogathatja horizontálisan skálázott adatok műveletek, például az adatok betöltését a megfelelő partíció.</span><span class="sxs-lookup"><span data-stu-id="5645c-351">Some tools and utilities might not support sharded data operations such as loading data into the correct partition.</span></span> <span data-ttu-id="5645c-352">Ez azt jelenti, hogy előfordulhat, hogy kell létrehozni, vagy szerezzen be új eszközök és segédprogramok.</span><span class="sxs-lookup"><span data-stu-id="5645c-352">This means that you might have to create or obtain new tools and utilities.</span></span>
* <span data-ttu-id="5645c-353">**Archivált, és törli az adatokat rendszeres időközönként**.</span><span class="sxs-lookup"><span data-stu-id="5645c-353">**How to archive and delete the data on a regular basis**.</span></span> <span data-ttu-id="5645c-354">Partíciók túlzott növekedést megelőzése érdekében szeretné archiválni, és törli az adatokat rendszeres időközönként (például havonta).</span><span class="sxs-lookup"><span data-stu-id="5645c-354">To prevent the excessive growth of partitions, you need to archive and delete data on a regular basis (perhaps monthly).</span></span> <span data-ttu-id="5645c-355">Egy másik archiválási séma megfelelő adatok átalakítására szükség lehet.</span><span class="sxs-lookup"><span data-stu-id="5645c-355">It might be necessary to transform the data to match a different archive schema.</span></span>
* <span data-ttu-id="5645c-356">**Hogyan keresse meg az adatok épségével kapcsolatos problémák**.</span><span class="sxs-lookup"><span data-stu-id="5645c-356">**How to locate data integrity issues**.</span></span> <span data-ttu-id="5645c-357">Fontolja meg egy olyan partíciót, egy másik objektuminformáció hivatkozó bármely adatok épségével kapcsolatos problémák, például az adatok kereséséhez rendszeres folyamatának futtatása.</span><span class="sxs-lookup"><span data-stu-id="5645c-357">Consider running a periodic process to locate any data integrity issues such as data in one partition that references missing information in another.</span></span> <span data-ttu-id="5645c-358">A folyamat vagy javítsa ki ezeket a problémákat automatikusan vagy manuálisan a problémák megoldására operátor riasztás tett kísérlet lehet.</span><span class="sxs-lookup"><span data-stu-id="5645c-358">The process can either attempt to fix these issues automatically or raise an alert to an operator to correct the problems manually.</span></span> <span data-ttu-id="5645c-359">Például egy e-kereskedelmi alkalmazás rendelésinformációkat tárolható előfordulhat, hogy egy partíció, de a sor elemek minden rendelés alkotó egy másik lehet tartani.</span><span class="sxs-lookup"><span data-stu-id="5645c-359">For example, in an e-commerce application, order information might be held in one partition but the line items that constitute each order might be held in another.</span></span> <span data-ttu-id="5645c-360">Adatok hozzáadása a többi partíció kell egy rendelés folyamatán.</span><span class="sxs-lookup"><span data-stu-id="5645c-360">The process of placing an order needs to add data to other partitions.</span></span> <span data-ttu-id="5645c-361">Ha ez a folyamat sikertelen, hiba előfordulhat, hogy lehet sor tárolt elemeket, amely nincs megfelelő rendelés.</span><span class="sxs-lookup"><span data-stu-id="5645c-361">If this process fails, there might be line items stored for which there is no corresponding order.</span></span>

<span data-ttu-id="5645c-362">Többféle tárolási technológiákat általában rendelkeznek a saját funkciók támogatják a particionálást.</span><span class="sxs-lookup"><span data-stu-id="5645c-362">Different data storage technologies typically provide their own features to support partitioning.</span></span> <span data-ttu-id="5645c-363">A következő szakaszok összegzik a beállításokat, amelyeket a rendszer által az Azure-alkalmazások gyakran használt adatok tárolókon.</span><span class="sxs-lookup"><span data-stu-id="5645c-363">The following sections summarize the options that are implemented by data stores commonly used by Azure applications.</span></span> <span data-ttu-id="5645c-364">Azt is leírják, alkalmazásokat, amelyek leginkább kihasználhatják ezeket a szolgáltatásokat tervezéséhez.</span><span class="sxs-lookup"><span data-stu-id="5645c-364">They also describe considerations for designing applications that can best take advantage of these features.</span></span>

## <a name="partitioning-strategies-for-azure-sql-database"></a><span data-ttu-id="5645c-365">Az Azure SQL Database particionálási stratégia</span><span class="sxs-lookup"><span data-stu-id="5645c-365">Partitioning strategies for Azure SQL Database</span></span>
<span data-ttu-id="5645c-366">Az Azure SQL-adatbázis egy relációs adatbázis-a-szolgáltatás, amely a felhőben.</span><span class="sxs-lookup"><span data-stu-id="5645c-366">Azure SQL Database is a relational database-as-a-service that runs in the cloud.</span></span> <span data-ttu-id="5645c-367">Microsoft SQL Server alapul.</span><span class="sxs-lookup"><span data-stu-id="5645c-367">It is based on Microsoft SQL Server.</span></span> <span data-ttu-id="5645c-368">A relációs osztja a táblázatok adatait, és minden tábla tartalmazza a sorokat sorozataként entitások kapcsolatos információkat.</span><span class="sxs-lookup"><span data-stu-id="5645c-368">A relational database divides information into tables, and each table holds information about entities as a series of rows.</span></span> <span data-ttu-id="5645c-369">Minden egyes sor tartalmazza az adatokat egy entitás egyedi mezők oszlopok.</span><span class="sxs-lookup"><span data-stu-id="5645c-369">Each row contains columns that hold the data for the individual fields of an entity.</span></span> <span data-ttu-id="5645c-370">A lap [Mi az Azure SQL Database?] a Microsoft webhely létrehozása és használata az SQL-adatbázisok vonatkozó részletes dokumentációt nyújt.</span><span class="sxs-lookup"><span data-stu-id="5645c-370">The page [What is Azure SQL Database?] on the Microsoft website provides detailed documentation about creating and using SQL databases.</span></span>

## <a name="horizontal-partitioning-with-elastic-database"></a><span data-ttu-id="5645c-371">Vízszintes particionálás rugalmas adatbáziskészlettel</span><span class="sxs-lookup"><span data-stu-id="5645c-371">Horizontal partitioning with Elastic Database</span></span>
<span data-ttu-id="5645c-372">Egy SQL-adatbázis a megadott korlát a kötet tartalmazhat adatot tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="5645c-372">A single SQL database has a limit to the volume of data that it can contain.</span></span> <span data-ttu-id="5645c-373">Átviteli sebesség architekturális tényezők és az azt támogató létesített egyidejű kapcsolatok számát korlátozza.</span><span class="sxs-lookup"><span data-stu-id="5645c-373">Throughput is constrained by architectural factors and the number of concurrent connections that it supports.</span></span> <span data-ttu-id="5645c-374">A rugalmas adatbázis-szolgáltatás SQL-adatbázis támogatja az SQL-adatbázis horizontális skálázást.</span><span class="sxs-lookup"><span data-stu-id="5645c-374">The Elastic Database feature of SQL Database supports horizontal scaling for a SQL database.</span></span> <span data-ttu-id="5645c-375">Rugalmas adatbázist használja, a szilánkok, amely több SQL-adatbázisok vannak elosztva az adatok is partícióazonosító.</span><span class="sxs-lookup"><span data-stu-id="5645c-375">Using Elastic Database, you can partition your data into shards that are spread across multiple SQL databases.</span></span> <span data-ttu-id="5645c-376">Hozzáadhat, vagy távolítsa el a szilánkok, kezelni kívánt adatok mennyisége növekszik és csökken.</span><span class="sxs-lookup"><span data-stu-id="5645c-376">You can also add or remove shards as the volume of data that you need to handle grows and shrinks.</span></span> <span data-ttu-id="5645c-377">Rugalmas adatbázis használatával is csökkenthető a versengés terhelését azáltal, hogy az adatbázisok közötti.</span><span class="sxs-lookup"><span data-stu-id="5645c-377">Using Elastic Database can also help reduce contention by distributing the load across databases.</span></span>

> [!NOTE]
> <span data-ttu-id="5645c-378">A rugalmas adatbázis megtalálható az összevonási szolgáltatás számára az Azure SQL adatbázis.</span><span class="sxs-lookup"><span data-stu-id="5645c-378">Elastic Database is a replacement for the Federations feature of Azure SQL Database.</span></span> <span data-ttu-id="5645c-379">Meglévő SQL-adatbázis összevonási telepítések áttelepíthetők rugalmas adatbázis áttelepítési összevonási segédprogram segítségével.</span><span class="sxs-lookup"><span data-stu-id="5645c-379">Existing SQL Database Federation installations can be migrated to Elastic Database by using the Federations migration utility.</span></span> <span data-ttu-id="5645c-380">Azt is megteheti Ha a forgatókönyv nem alkalmasnak természetesen a rugalmas adatbázis által nyújtott szolgáltatások saját horizontális mechanizmus is létrehozható.</span><span class="sxs-lookup"><span data-stu-id="5645c-380">Alternatively, you can implement your own sharding mechanism if your scenario does not lend itself naturally to the features that are provided by Elastic Database.</span></span>
>
>

<span data-ttu-id="5645c-381">Minden egyes shard, SQL-adatbázis lett megvalósítva.</span><span class="sxs-lookup"><span data-stu-id="5645c-381">Each shard is implemented as a SQL database.</span></span> <span data-ttu-id="5645c-382">A szilánkok tárolására képes több adatkészlet (a továbbiakban a *shardlet*).</span><span class="sxs-lookup"><span data-stu-id="5645c-382">A shard can hold more than one dataset (referred to as a *shardlet*).</span></span> <span data-ttu-id="5645c-383">Az egyes adatbázisok fenntartja a benne található shardlets leíró metaadatok.</span><span class="sxs-lookup"><span data-stu-id="5645c-383">Each database maintains metadata that describes the shardlets that it contains.</span></span> <span data-ttu-id="5645c-384">Egy shardlet lehet egyetlen adat, vagy egy csoport shardlet azonos kulccsal rendelkező elemek.</span><span class="sxs-lookup"><span data-stu-id="5645c-384">A shardlet can be a single data item, or it can be a group of items that share the same shardlet key.</span></span> <span data-ttu-id="5645c-385">Például ha egy több-bérlős alkalmazás horizontális adatokat, a shardlet kulcs lehet a bérlő azonosítója, és minden adat egy adott bérlő lehessen vonni a azonos shardlet részeként.</span><span class="sxs-lookup"><span data-stu-id="5645c-385">For example, if you are sharding data in a multitenant application, the shardlet key can be the tenant ID, and all data for a given tenant can be held as part of the same shardlet.</span></span> <span data-ttu-id="5645c-386">Más bérlők adatokat a különböző shardlets kell tartani.</span><span class="sxs-lookup"><span data-stu-id="5645c-386">Data for other tenants would be held in different shardlets.</span></span>

<span data-ttu-id="5645c-387">Feladata a programozói rendelje hozzá a dataset shardlet kulccsal.</span><span class="sxs-lookup"><span data-stu-id="5645c-387">It is the programmer's responsibility to associate a dataset with a shardlet key.</span></span> <span data-ttu-id="5645c-388">Egy másik SQL-adatbázist egy globális shard térkép manager funkcionál.</span><span class="sxs-lookup"><span data-stu-id="5645c-388">A separate SQL database acts as a global shard map manager.</span></span> <span data-ttu-id="5645c-389">Ezt az adatbázist a rendszer a szilánkok és shardlets listáját tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="5645c-389">This database contains a list of all the shards and shardlets in the system.</span></span> <span data-ttu-id="5645c-390">Egy ügyfélalkalmazás tárolt adatokkal először csatlakozik a globális shard térkép manager adatbázisát hozzájutni a shard térkép (szilánkok és shardlets felsoroló), amely, majd gyorsítótárba helyezi azt a helyileg.</span><span class="sxs-lookup"><span data-stu-id="5645c-390">A client application that accesses data connects first to the global shard map manager database to obtain a copy of the shard map (listing shards and shardlets), which it then caches locally.</span></span>

<span data-ttu-id="5645c-391">Az alkalmazás ezután a megfelelő shard útvonal kérelmek ezt az információt használja.</span><span class="sxs-lookup"><span data-stu-id="5645c-391">The application then uses this information to route data requests to the appropriate shard.</span></span> <span data-ttu-id="5645c-392">Ez a funkció egy API-k, amelyek szerepelnek az Azure SQL Database rugalmas adatbázis ügyféloldali kódtár, amely a NuGet-csomagként érhető sorozatát takarja.</span><span class="sxs-lookup"><span data-stu-id="5645c-392">This functionality is hidden behind a series of APIs that are contained in the Azure SQL Database Elastic Database Client Library, which is available as a NuGet package.</span></span> <span data-ttu-id="5645c-393">A lap [rugalmas adatbázis-szolgáltatások áttekintése] a Microsoft webhelyén biztosít a rugalmas adatbázis egy átfogóbb bemutatása.</span><span class="sxs-lookup"><span data-stu-id="5645c-393">The page [Elastic Database features overview] on the Microsoft website provides a more comprehensive introduction to Elastic Database.</span></span>

> [!NOTE]
> <span data-ttu-id="5645c-394">A globális shard manager adatbázist késés csökkentésére, valamint a rendelkezésre állás fejlesztése a replikálhatja.</span><span class="sxs-lookup"><span data-stu-id="5645c-394">You can replicate the global shard map manager database to reduce latency and improve availability.</span></span> <span data-ttu-id="5645c-395">Ha az adatbázis a Premium árképzési szinteket egyikének használatával valósítja meg, konfigurálhatja a aktív georeplikáció folyamatosan adatok különböző régiókban adatbázisok másolása.</span><span class="sxs-lookup"><span data-stu-id="5645c-395">If you implement the database by using one of the Premium pricing tiers, you can configure active geo-replication to continuously copy data to databases in different regions.</span></span> <span data-ttu-id="5645c-396">Az adatbázis másolatának létrehozása minden régióban, amelyben a felhasználók alapulnak.</span><span class="sxs-lookup"><span data-stu-id="5645c-396">Create a copy of the database in each region in which users are based.</span></span> <span data-ttu-id="5645c-397">Ezután konfigurálja az alkalmazás ezen példányának beszerzéséhez a szilánkok térkép való kapcsolódáshoz.</span><span class="sxs-lookup"><span data-stu-id="5645c-397">Then configure your application to connect to this copy to obtain the shard map.</span></span>
>
> <span data-ttu-id="5645c-398">Egy másik módszert is, hogy Azure SQL adatszinkronizálás vagy egy Azure Data Factory-folyamat használja a shard manager adatbázist régiók közötti replikáció.</span><span class="sxs-lookup"><span data-stu-id="5645c-398">An alternative approach is to use Azure SQL Data Sync or an Azure Data Factory pipeline to replicate the shard map manager database across regions.</span></span> <span data-ttu-id="5645c-399">Az űrlap replikációs rendszeres időközönként fut, és több megfelelő, ha a shard térkép ritkán módosul.</span><span class="sxs-lookup"><span data-stu-id="5645c-399">This form of replication runs periodically and is more suitable if the shard map changes infrequently.</span></span> <span data-ttu-id="5645c-400">Emellett a shard manager adatbázist nem kell a prémium tarifacsomag használatával hozható létre.</span><span class="sxs-lookup"><span data-stu-id="5645c-400">Additionally, the shard map manager database does not have to be created by using a Premium pricing tier.</span></span>
>
>

<span data-ttu-id="5645c-401">Rugalmas adatbázis biztosítja az adatok leképezése shardlets, és tárolja őket szilánkok két sémák:</span><span class="sxs-lookup"><span data-stu-id="5645c-401">Elastic Database provides two schemes for mapping data to shardlets and storing them in shards:</span></span>

* <span data-ttu-id="5645c-402">A **lista shard térkép** egy kulcs és egy shardlet közötti társítás ismerteti.</span><span class="sxs-lookup"><span data-stu-id="5645c-402">A **list shard map** describes an association between a single key and a shardlet.</span></span> <span data-ttu-id="5645c-403">Például egy több-bérlős rendszerben az egyes bérlők számára az adatok is kell tartozó egyedi kulcs és a saját shardlet tárolja.</span><span class="sxs-lookup"><span data-stu-id="5645c-403">For example, in a multitenant system, the data for each tenant can be associated with a unique key and stored in its own shardlet.</span></span> <span data-ttu-id="5645c-404">Garantálja az adatvédelmi és elkülönítési (Ez azt jelenti, hogy egy bérlő megakadályozása kimerítsék érhető el, hogy mások számára az adatok tárolási erőforrások), minden shardlet saját shard megtartható.</span><span class="sxs-lookup"><span data-stu-id="5645c-404">To guarantee privacy and isolation (that is, to prevent one tenant from exhausting the data storage resources available to others), each shardlet can be held within its own shard.</span></span>

![Egy lista shard térkép használatával bérlői adatokat külön szilánkok használatával](./images/data-partitioning/PointShardlet.png)

<span data-ttu-id="5645c-406">*4. ábra. Egy lista shard térkép használatával bérlői adatokat külön szilánkok használatával*</span><span class="sxs-lookup"><span data-stu-id="5645c-406">*Figure 4. Using a list shard map to store tenant data in separate shards*</span></span>

* <span data-ttu-id="5645c-407">A **tartomány shard térkép** összefüggő kulcs értékek és a shardlet közötti társítás ismerteti.</span><span class="sxs-lookup"><span data-stu-id="5645c-407">A **range shard map** describes an association between a set of contiguous key values and a shardlet.</span></span> <span data-ttu-id="5645c-408">A több-bérlős példa dedikált shardlets végrehajtási alternatívájaként korábban leírt csoportosíthatja az adatokat, azon belül az azonos shardlet (mindegyiket a saját kulcs) bérlők.</span><span class="sxs-lookup"><span data-stu-id="5645c-408">In the multitenant example described previously, as an alternative to implementing dedicated shardlets, you can group the data for a set of tenants (each with their own key) within the same shardlet.</span></span> <span data-ttu-id="5645c-409">Ez a séma olcsóbb az első (mivel a bérlők adatok tárolási erőforrások megosztása), de fennáll a kockázata, csökkentett adatvédelem és elkülönítési is létrehoz.</span><span class="sxs-lookup"><span data-stu-id="5645c-409">This scheme is less expensive than the first (because tenants share data storage resources), but it also creates a risk of reduced data privacy and isolation.</span></span>

![Egy tartomány shard térkép használatával adatok köre bérlők által a shard használatával](./images/data-partitioning/RangeShardlet.png)

<span data-ttu-id="5645c-411">*5. ábra. Egy tartomány shard térkép használatával adatok köre bérlők által a shard használatával*</span><span class="sxs-lookup"><span data-stu-id="5645c-411">*Figure 5. Using a range shard map to store data for a range of tenants in a shard*</span></span>

<span data-ttu-id="5645c-412">Vegye figyelembe, hogy egyetlen shard tartalmazhatnak több shardlets adatai.</span><span class="sxs-lookup"><span data-stu-id="5645c-412">Note that a single shard can contain the data for several shardlets.</span></span> <span data-ttu-id="5645c-413">Például használhatja lista shardlets ugyanazt a shard különböző nem összefüggő bérlők esetén az adatok tárolásához.</span><span class="sxs-lookup"><span data-stu-id="5645c-413">For example, you can use list shardlets to store data for different non-contiguous tenants in the same shard.</span></span> <span data-ttu-id="5645c-414">Bár ezek kiiktatása keresztül különböző maps a globális shard térkép manager adatbázisában tartomány shardlets és ugyanazt a shard, a lista shardlets is kombinálhatók.</span><span class="sxs-lookup"><span data-stu-id="5645c-414">You can also mix range shardlets and list shardlets in the same shard, although they will be addressed through different maps in the global shard map manager database.</span></span> <span data-ttu-id="5645c-415">(A globális shard manager adatbázist tartalmazhat több shard maps.) 6. ábra mutatja be ezt a módszert használja.</span><span class="sxs-lookup"><span data-stu-id="5645c-415">(The global shard map manager database can contain multiple shard maps.) Figure 6 depicts this approach.</span></span>

![Több shard végrehajtási leképezhető](./images/data-partitioning/MultipleShardMaps.png)

<span data-ttu-id="5645c-417">*6. ábra. Több shard végrehajtási leképezhető*</span><span class="sxs-lookup"><span data-stu-id="5645c-417">*Figure 6. Implementing multiple shard maps*</span></span>

<span data-ttu-id="5645c-418">A particionálási sémát, amely megvalósítása jelentős hatással lehet a rendszer teljesítményét.</span><span class="sxs-lookup"><span data-stu-id="5645c-418">The partitioning scheme that you implement can have a significant bearing on the performance of your system.</span></span> <span data-ttu-id="5645c-419">A sebesség, amellyel szilánkok kell hozzáadni vagy eltávolítani, vagy a sebesség, amellyel adatokat kell particionálni szilánkok között is érinti.</span><span class="sxs-lookup"><span data-stu-id="5645c-419">It can also affect the rate at which shards have to be added or removed, or the rate at which data must be repartitioned across shards.</span></span> <span data-ttu-id="5645c-420">A rugalmas adatbázis partíció adatokhoz való használatakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="5645c-420">Consider the following points when you use Elastic Database to partition data:</span></span>

* <span data-ttu-id="5645c-421">Adatok együtt használja ugyanazt a shard a csoportot, és használatban van a több szilánkok adatok elérését igénylő műveletek elkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="5645c-421">Group data that is used together in the same shard, and avoid operations that need to access data that's held in multiple shards.</span></span> <span data-ttu-id="5645c-422">Ne feledje, hogy rugalmas adatbáziskészlettel egy shard önálló SQL-adatbázis, valamint az Azure SQL Database nem támogatja az adatbázisok közötti illesztések (amelyeket hajtható végre az ügyféloldali).</span><span class="sxs-lookup"><span data-stu-id="5645c-422">Keep in mind that with Elastic Database, a shard is a SQL database in its own right, and Azure SQL Database does not support cross-database joins (which have to be performed on the client side).</span></span> <span data-ttu-id="5645c-423">Továbbá ne feledje, hogy az Azure SQL Database, a hivatkozási integritási megkötésekkel, eseményindítók és egy adatbázisban tárolt eljárások nem hivatkozhat egy másik objektum.</span><span class="sxs-lookup"><span data-stu-id="5645c-423">Remember also that in Azure SQL Database, referential integrity constraints, triggers, and stored procedures in one database cannot reference objects in another.</span></span> <span data-ttu-id="5645c-424">Ezért ne kialakítási függőségek között szilánkok olyan rendszerre.</span><span class="sxs-lookup"><span data-stu-id="5645c-424">Therefore, don't design a system that has dependencies between shards.</span></span> <span data-ttu-id="5645c-425">SQL-adatbázis azonban tartalmazhatnak gyakran használják a lekérdezések és egyéb műveletekhez referenciaadatok példányait táblákhoz.</span><span class="sxs-lookup"><span data-stu-id="5645c-425">A SQL database can, however, contain tables that hold copies of reference data frequently used by queries and other operations.</span></span> <span data-ttu-id="5645c-426">Ezek a táblázatok nem rendelkeznek minden megadott shardlet tartozik.</span><span class="sxs-lookup"><span data-stu-id="5645c-426">These tables do not have to belong to any specific shardlet.</span></span> <span data-ttu-id="5645c-427">Ezek az adatok replikálása szilánkok segítségével távolítsa el a szükséges adatbázisokat kiterjedő illesztési adatok.</span><span class="sxs-lookup"><span data-stu-id="5645c-427">Replicating this data across shards can help remove the need to join data that spans databases.</span></span> <span data-ttu-id="5645c-428">Ideális esetben az ilyen adatok lehetnek statikus, illetve lassan lecsökkentheti a replikációs beavatkozást, és csökkenti a veszélyét annak, hogy azt elévültek.</span><span class="sxs-lookup"><span data-stu-id="5645c-428">Ideally, such data should be static or slow-moving to minimize the replication effort and reduce the chances of it becoming stale.</span></span>

  > [!NOTE]
  > <span data-ttu-id="5645c-429">Bár az SQL-adatbázis nem támogatja az adatbázisok közötti csatlakozik, a kereszt-shard lekérdezések rugalmas adatbázis API-val végezheti el.</span><span class="sxs-lookup"><span data-stu-id="5645c-429">Although SQL Database does not support cross-database joins, you can perform cross-shard queries with the Elastic Database API.</span></span> <span data-ttu-id="5645c-430">Ezeket a lekérdezéseket is transzparens módon iterációt shard térképre által hivatkozott összes shardlets-ban tárolt adatok.</span><span class="sxs-lookup"><span data-stu-id="5645c-430">These queries can transparently iterate through the data held in all the shardlets that are referenced by a shard map.</span></span> <span data-ttu-id="5645c-431">A rugalmas adatbázis API oldaltörések kereszt-shard le egy sorozat (egy, az egyes adatbázisok) egyes lekérdezések lekérdezése, és majd egyesíti az eredményeket.</span><span class="sxs-lookup"><span data-stu-id="5645c-431">The Elastic Database API breaks cross-shard queries down into a series of individual queries (one for each database) and then merges the results.</span></span> <span data-ttu-id="5645c-432">További információkért lásd: a lap [több shard lekérdezése] a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="5645c-432">For more information, see the page [Multi-shard querying] on the Microsoft website.</span></span>
  >
  >
* <span data-ttu-id="5645c-433">A ugyanazt a shard térképhez tartozó shardlets tárolt adatok ugyanazon séma kell rendelkeznie.</span><span class="sxs-lookup"><span data-stu-id="5645c-433">The data stored in shardlets that belong to the same shard map should have the same schema.</span></span> <span data-ttu-id="5645c-434">Például nem mutat, néhány bérlői adatokat tartalmazó shardlets és egyéb shardlets termékinformációk tartalmazó lista shard térkép létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="5645c-434">For example, don't create a list shard map that points to some shardlets containing tenant data and other shardlets containing product information.</span></span> <span data-ttu-id="5645c-435">Ez a szabály nem kényszeríti ki a rugalmas adatbázis, de az adatok kezelése, és rendkívül bonyolult, ha minden shardlet másik sémát lekérdezése válik.</span><span class="sxs-lookup"><span data-stu-id="5645c-435">This rule is not enforced by Elastic Database, but data management and querying becomes very complex if each shardlet has a different schema.</span></span> <span data-ttu-id="5645c-436">Az imént említett példában jó megoldás, ha a két lista shard maps: egy bérlő adatokat, majd egy másikat, mutató termékinformációk hivatkozik.</span><span class="sxs-lookup"><span data-stu-id="5645c-436">In the example just cited, a good solution is to create two list shard maps: one that references tenant data and another that points to product information.</span></span> <span data-ttu-id="5645c-437">Ne feledje, hogy ugyanazt a shard különböző shardlets tartozó adatok tárolhatók.</span><span class="sxs-lookup"><span data-stu-id="5645c-437">Remember that the data belonging to different shardlets can be stored in the same shard.</span></span>

  > [!NOTE]
  > <span data-ttu-id="5645c-438">A rugalmas adatbázis API kereszt-shard lekérdezési funkcionalitás minden shardlet a shard leképezés ugyanazon séma tartalmazó függ.</span><span class="sxs-lookup"><span data-stu-id="5645c-438">The cross-shard query functionality of the Elastic Database API depends on each shardlet in the shard map containing the same schema.</span></span>
  >
  >
* <span data-ttu-id="5645c-439">Tranzakciós műveletek csak adatokat, amelyek ugyanazt a shard belül és között szilánkok nem tartják támogatottak.</span><span class="sxs-lookup"><span data-stu-id="5645c-439">Transactional operations are only supported for data that's held within the same shard, and not across shards.</span></span> <span data-ttu-id="5645c-440">Tranzakciók is kiterjedhet shardlets, mindaddig, amíg a ugyanazt a shard részét képezik.</span><span class="sxs-lookup"><span data-stu-id="5645c-440">Transactions can span shardlets as long as they are part of the same shard.</span></span> <span data-ttu-id="5645c-441">Ezért ha az üzleti logikát tranzakciók elvégzéséhez szüksége van, vagy az érintett adatok tárolása a ugyanazt a shard vagy valósítja meg a végleges konzisztencia.</span><span class="sxs-lookup"><span data-stu-id="5645c-441">Therefore, if your business logic needs to perform transactions, either store the affected data in the same shard or implement eventual consistency.</span></span> <span data-ttu-id="5645c-442">További információkért lásd: a [adatok konzisztencia ismertetése].</span><span class="sxs-lookup"><span data-stu-id="5645c-442">For more information, see the [Data consistency primer].</span></span>
* <span data-ttu-id="5645c-443">Helyezze a szilánkok megközelíti a felhasználókat, akik e szilánkok adatait (azaz földrajzi-keresse meg a szilánkok).</span><span class="sxs-lookup"><span data-stu-id="5645c-443">Place shards close to the users that access the data in those shards (in other words, geo-locate the shards).</span></span> <span data-ttu-id="5645c-444">Ezt a stratégiát csökkenthető a késleltetés.</span><span class="sxs-lookup"><span data-stu-id="5645c-444">This strategy helps reduce latency.</span></span>
* <span data-ttu-id="5645c-445">Ne használjon magas keverékével aktív (csatlakozási pontokhoz) és viszonylag inaktív szilánkok.</span><span class="sxs-lookup"><span data-stu-id="5645c-445">Avoid having a mixture of highly active (hotspots) and relatively inactive shards.</span></span> <span data-ttu-id="5645c-446">Próbálja meg a betöltési szilánkok egyenlően elosztva.</span><span class="sxs-lookup"><span data-stu-id="5645c-446">Try to spread the load evenly across shards.</span></span> <span data-ttu-id="5645c-447">Előfordulhat, hogy a shardlet kulcsok kivonatoláshoz.</span><span class="sxs-lookup"><span data-stu-id="5645c-447">This might require hashing the shardlet keys.</span></span>
* <span data-ttu-id="5645c-448">Ha szilánkok földrajzi megkeresése, győződjön meg arról, hogy a kivonatolt kulcsokat tárolja a felhasználói adatok közel szilánkok tárolt shardlets hozzárendelését.</span><span class="sxs-lookup"><span data-stu-id="5645c-448">If you are geo-locating shards, make sure that the hashed keys map to shardlets held in shards stored close to the users that access that data.</span></span>
* <span data-ttu-id="5645c-449">Jelenleg csak korlátozott készlete, típusok támogatottak shardlet kulcsként; SQL-adatok *int, bigint, varbinary,* és *uniqueidentifier*.</span><span class="sxs-lookup"><span data-stu-id="5645c-449">Currently, only a limited set of SQL data types are supported as shardlet keys; *int, bigint, varbinary,* and *uniqueidentifier*.</span></span> <span data-ttu-id="5645c-450">Az SQL *int* és *bigint* típusok vannak rendelve a *int* és *hosszú* adattípusok C# nyelven íródtak, és ugyanazt a tartományt.</span><span class="sxs-lookup"><span data-stu-id="5645c-450">The SQL *int* and *bigint* types correspond to the *int* and *long* data types in C#, and have the same ranges.</span></span> <span data-ttu-id="5645c-451">Az SQL *varbinary* típus használatával kezelhető egy *bájt* C#, és az SQL tömb *uniqueidentier* típus megfelel-e a *Guid* az osztály a .NET-keretrendszer.</span><span class="sxs-lookup"><span data-stu-id="5645c-451">The SQL *varbinary* type can be handled by using a *Byte* array in C#, and the SQL *uniqueidentier* type corresponds to the *Guid* class in the .NET Framework.</span></span>

<span data-ttu-id="5645c-452">Foglalja, rugalmas adatbázis lehetővé teszi a rendszer hozzáadása és eltávolítása a szilánkok, az adatok mennyisége zsugorítja és -növelés.</span><span class="sxs-lookup"><span data-stu-id="5645c-452">As the name implies, Elastic Database makes it possible for a system to add and remove shards as the volume of data shrinks and grows.</span></span> <span data-ttu-id="5645c-453">Az az Azure SQL Database Elastic Database ügyféloldali kódtár API-k lehetővé teszik, hogy az alkalmazások, és hozhat létre és szilánkok dinamikusan törlése (a shard térkép kezelőt frissíti, transzparens módon).</span><span class="sxs-lookup"><span data-stu-id="5645c-453">The APIs in the Azure SQL Database Elastic Database client library enable an application to create and delete shards dynamically (and transparently update the shard map manager).</span></span> <span data-ttu-id="5645c-454">A szilánkok eltávolítása azonban nem egy felülíró műveletet igénylő is, hogy a shard az összes adat törlése.</span><span class="sxs-lookup"><span data-stu-id="5645c-454">However, removing a shard is a destructive operation that also requires deleting all the data in that shard.</span></span>

<span data-ttu-id="5645c-455">Ha egy alkalmazás egy shard felosztása két külön szilánkok vagy szilánkok kombinálhatja, rugalmas külön vegyes egyesítéses szolgáltatást nyújt.</span><span class="sxs-lookup"><span data-stu-id="5645c-455">If an application needs to split a shard into two separate shards or combine shards, Elastic Database provides a separate split-merge service.</span></span> <span data-ttu-id="5645c-456">Ez a szolgáltatás a felhőben üzemeltetett szolgáltatás (amely léteznie kell a fejlesztő) fut, és biztonságosan szilánkok közötti áttelepítése.</span><span class="sxs-lookup"><span data-stu-id="5645c-456">This service runs in a cloud-hosted service (which must be created by the developer) and migrates data safely between shards.</span></span> <span data-ttu-id="5645c-457">További információkért lásd a témakör [méretezés, a rugalmas adatbázis vegyes egyesítéses eszközzel] a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="5645c-457">For more information, see the topic [Scaling using the Elastic Database split-merge tool] on the Microsoft website.</span></span>

## <a name="partitioning-strategies-for-azure-storage"></a><span data-ttu-id="5645c-458">Az Azure Storage particionálási stratégia</span><span class="sxs-lookup"><span data-stu-id="5645c-458">Partitioning strategies for Azure Storage</span></span>
<span data-ttu-id="5645c-459">Az Azure tárolási adatkezelésben négy absztrakt entitásokat biztosít:</span><span class="sxs-lookup"><span data-stu-id="5645c-459">Azure storage provides four abstractions for managing data:</span></span>

* <span data-ttu-id="5645c-460">A Blob Storage a strukturálatlan objektumadatokat tárolja.</span><span class="sxs-lookup"><span data-stu-id="5645c-460">Blob Storage stores unstructured object data.</span></span> <span data-ttu-id="5645c-461">Egy blob állhat bármilyen szövegből vagy bináris adatból, lehet például egy dokumentum, egy médiafájl vagy egy alkalmazástelepítő.</span><span class="sxs-lookup"><span data-stu-id="5645c-461">A blob can be any type of text or binary data, such as a document, media file, or application installer.</span></span> <span data-ttu-id="5645c-462">A Blob Storage más néven Objektumtárnak is hívható.</span><span class="sxs-lookup"><span data-stu-id="5645c-462">Blob storage is also referred to as Object storage.</span></span>
* <span data-ttu-id="5645c-463">A Table Storage a strukturált adatkészleteket tárolja.</span><span class="sxs-lookup"><span data-stu-id="5645c-463">Table Storage stores structured datasets.</span></span> <span data-ttu-id="5645c-464">A Table Storage a NoSQL-kulcsattribútumok adattára, amely gyors fejlesztési lehetőségeket és nagy adatmennyiségek gyors elérését biztosítja.</span><span class="sxs-lookup"><span data-stu-id="5645c-464">Table storage is a NoSQL key-attribute data store, which allows for rapid development and fast access to large quantities of data.</span></span>
* <span data-ttu-id="5645c-465">A Queue Storage megbízható üzenetküldést biztosít a munkafolyamat-feldolgozáshoz és a felhőszolgáltatás összetevői közötti kommunikációhoz.</span><span class="sxs-lookup"><span data-stu-id="5645c-465">Queue Storage provides reliable messaging for workflow processing and for communication between components of cloud services.</span></span>
* <span data-ttu-id="5645c-466">A File Storage közös tárterületet biztosít a szabványos SMB-protokollt használó örökölt alkalmazások számára.</span><span class="sxs-lookup"><span data-stu-id="5645c-466">File Storage offers shared storage for legacy applications using the standard SMB protocol.</span></span> <span data-ttu-id="5645c-467">Az Azure virtuális gépek és a felhőszolgáltatás csatlakoztatott megosztásokon keresztül adatokat oszthatnak meg az alkalmazások összetevői között, a helyszíni alkalmazások pedig a fájlszolgáltatás REST API-ján keresztül hozzáférhetnek a megosztott fájladatokhoz.</span><span class="sxs-lookup"><span data-stu-id="5645c-467">Azure virtual machines and cloud services can share file data across application components via mounted shares, and on-premises applications can access file data in a share via the File service REST API.</span></span>

<span data-ttu-id="5645c-468">A TABLE storage és a blob Storage tárolóban lényegében kulcs-érték tárolók, illetve strukturált és strukturálatlan adatok tárolásához optimalizált.</span><span class="sxs-lookup"><span data-stu-id="5645c-468">Table storage and blob storage are essentially key-value stores that are optimized to hold structured and unstructured data respectively.</span></span> <span data-ttu-id="5645c-469">Tárolási sorok lazán összekapcsolt, méretezhető alkalmazások létrehozásához egy olyan mechanizmus biztosítása.</span><span class="sxs-lookup"><span data-stu-id="5645c-469">Storage queues provide a mechanism for building loosely coupled, scalable applications.</span></span> <span data-ttu-id="5645c-470">A TABLE storage, a fájlok tárolására, a blob-tároló és a tárolási sorok Azure storage-fiók kontextusában jönnek létre.</span><span class="sxs-lookup"><span data-stu-id="5645c-470">Table storage, file storage, blob storage, and storage queues are created within the context of an Azure storage account.</span></span> <span data-ttu-id="5645c-471">Storage-fiókok redundancia három formáját támogatja:</span><span class="sxs-lookup"><span data-stu-id="5645c-471">Storage accounts support three forms of redundancy:</span></span>

* <span data-ttu-id="5645c-472">**Helyileg redundáns tárolás**, amely egyetlen adatközponton belül adatok három másolatot tart fenn.</span><span class="sxs-lookup"><span data-stu-id="5645c-472">**Locally redundant storage**, which maintains three copies of data within a single datacenter.</span></span> <span data-ttu-id="5645c-473">Ezt az űrlapot a redundancia hardverhiba szemben, de nem egy olyan vészhelyzet esetén, amely magában foglalja a teljes adatközpont elleni védelmet nyújt.</span><span class="sxs-lookup"><span data-stu-id="5645c-473">This form of redundancy protects against hardware failure but not against a disaster that encompasses the entire datacenter.</span></span>
* <span data-ttu-id="5645c-474">**Zónaredundáns tárolás**, ugyanabban a régióban belül különböző üzemeltetésében (vagy két földrajzilag Bezárás régióban) terjednek adatok három másolatot tart fenn, amelyek.</span><span class="sxs-lookup"><span data-stu-id="5645c-474">**Zone-redundant storage**, which maintains three copies of data spread across different datacenters within the same region (or across two geographically close regions).</span></span> <span data-ttu-id="5645c-475">Ezt az űrlapot a redundancia egyetlen adatközponton belül, de nem elleni vészhelyzetek ellen lehet védekezni nagy méretű hálózati bontja a kapcsolatot, amelyek hatással vannak az egész régió.</span><span class="sxs-lookup"><span data-stu-id="5645c-475">This form of redundancy can protect against disasters that occur within a single datacenter, but cannot protect against large-scale network disconnects that affect an entire region.</span></span> <span data-ttu-id="5645c-476">Vegye figyelembe, hogy zónaredundáns tárolás jelenleg csak a blokkblobokhoz érhető el.</span><span class="sxs-lookup"><span data-stu-id="5645c-476">Note that zone-redundant storage is currently only available for block blobs.</span></span>
* <span data-ttu-id="5645c-477">**Georedundáns tárolás**, amely az adatok hat másolatot tart fenn: egy régió tartozik (a helyi régió) három példányban, és egy másik három példányban egy távoli régióban.</span><span class="sxs-lookup"><span data-stu-id="5645c-477">**Geo-redundant storage**, which maintains six copies of data: three copies in one region (your local region), and another three copies in a remote region.</span></span> <span data-ttu-id="5645c-478">Ezt az űrlapot a redundancia a legmagasabb szintű vész-helyreállítási védelmet nyújt.</span><span class="sxs-lookup"><span data-stu-id="5645c-478">This form of redundancy provides the highest level of disaster protection.</span></span>

<span data-ttu-id="5645c-479">Microsoft Azure Storage méretezhetőségi célok van közzétéve.</span><span class="sxs-lookup"><span data-stu-id="5645c-479">Microsoft has published scalability targets for Azure Storage.</span></span> <span data-ttu-id="5645c-480">További információkért lásd: a lap [Azure Storage méretezhetőségi és Teljesítménycélok] a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="5645c-480">For more information, see the page [Azure Storage scalability and performance targets] on the Microsoft website.</span></span> <span data-ttu-id="5645c-481">A teljes tárfiókok kapacitásával jelenleg legfeljebb 500 TB lehet.</span><span class="sxs-lookup"><span data-stu-id="5645c-481">Currently, the total storage account capacity cannot exceed 500 TB.</span></span> <span data-ttu-id="5645c-482">(Ez magában foglalja a tárolókészletben levő adatok tartott a table storage, a file storage blob-tároló, valamint a tároló várólista a tranzakció kimenetelére várva függőben lévő üzenetek).</span><span class="sxs-lookup"><span data-stu-id="5645c-482">(This includes the size of data that's held in table storage, file storage and blob storage, as well as outstanding messages that are held in storage queue).</span></span>

<span data-ttu-id="5645c-483">A kérelem maximális (feltéve, hogy egy 1 KB-os entitás, blob vagy üzenet mérete) tárfiókok esetén ez 20 000 kérelmek / másodperc.</span><span class="sxs-lookup"><span data-stu-id="5645c-483">The maximum request rate for a storage account (assuming a 1-KB entity, blob, or message size) is 20,000 requests per second.</span></span> <span data-ttu-id="5645c-484">A tárfiók legfeljebb 1000 iops-értéket (8 KB-nál) fájlmegosztás rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="5645c-484">A storage account has a maximum of 1000 IOPS (8 KB in size) per file share.</span></span> <span data-ttu-id="5645c-485">Ha a rendszer várhatóan meghaladja ezt a korlátot, fontolja meg a betöltési particionálás több tárfiókok között.</span><span class="sxs-lookup"><span data-stu-id="5645c-485">If your system is likely to exceed these limits, consider partitioning the load across multiple storage accounts.</span></span> <span data-ttu-id="5645c-486">Egy Azure-előfizetéssel 200 storage-fiókokat hozhat létre.</span><span class="sxs-lookup"><span data-stu-id="5645c-486">A single Azure subscription can create up to 200 storage accounts.</span></span> <span data-ttu-id="5645c-487">Vegye figyelembe azonban, hogy ezek a korlátozások idővel változhatnak.</span><span class="sxs-lookup"><span data-stu-id="5645c-487">However, note that these limits might change over time.</span></span>

## <a name="partitioning-azure-table-storage"></a><span data-ttu-id="5645c-488">Az Azure table storage particionálás</span><span class="sxs-lookup"><span data-stu-id="5645c-488">Partitioning Azure table storage</span></span>
<span data-ttu-id="5645c-489">Az Azure table storage egy kulcs-érték tárolóban, a particionálás ellátására van kialakítva.</span><span class="sxs-lookup"><span data-stu-id="5645c-489">Azure table storage is a key-value store that's designed around partitioning.</span></span> <span data-ttu-id="5645c-490">Egy partíció összes entitásának tárolja, és a partíciók belsőleg kezeli az Azure table storage.</span><span class="sxs-lookup"><span data-stu-id="5645c-490">All entities are stored in a partition, and partitions are managed internally by Azure table storage.</span></span> <span data-ttu-id="5645c-491">Minden entitás, amely a táblában tárolt meg kell adnia egy kétlépéses kulcsot, amely tartalmazza:</span><span class="sxs-lookup"><span data-stu-id="5645c-491">Each entity that's stored in a table must provide a two-part key that includes:</span></span>

* <span data-ttu-id="5645c-492">**A partíciós kulcs**.</span><span class="sxs-lookup"><span data-stu-id="5645c-492">**The partition key**.</span></span> <span data-ttu-id="5645c-493">Ez az egy karakterláncértéket, amely meghatározza, melyik partíció Azure table storage helyezi el az entitás.</span><span class="sxs-lookup"><span data-stu-id="5645c-493">This is a string value that determines in which partition Azure table storage will place the entity.</span></span> <span data-ttu-id="5645c-494">Az azonos partíciókulcsú valamennyi entitást tartalmazó partícióra tárolódnak.</span><span class="sxs-lookup"><span data-stu-id="5645c-494">All entities with the same partition key will be stored in the same partition.</span></span>
* <span data-ttu-id="5645c-495">**A sorkulcs**.</span><span class="sxs-lookup"><span data-stu-id="5645c-495">**The row key**.</span></span> <span data-ttu-id="5645c-496">Ez az egy másik karakterlánc-érték, amely azonosítja az entitást a partíción belül.</span><span class="sxs-lookup"><span data-stu-id="5645c-496">This is another string value that identifies the entity within the partition.</span></span> <span data-ttu-id="5645c-497">Egy partíció összes entitásának alapján rendezi a lexically, növekvő sorrendben, ezt a kulcsot.</span><span class="sxs-lookup"><span data-stu-id="5645c-497">All entities within a partition are sorted lexically, in ascending order, by this key.</span></span> <span data-ttu-id="5645c-498">A partíciós kulcs/sor billentyűkombinációt minden egyes entitásnál egyedinek kell lennie, és a hossza legfeljebb 1 KB lehet.</span><span class="sxs-lookup"><span data-stu-id="5645c-498">The partition key/row key combination must be unique for each entity and cannot exceed 1 KB in length.</span></span>

<span data-ttu-id="5645c-499">Az adatokat, hogy egy entitás többi alkalmazás által meghatározott mezőből áll.</span><span class="sxs-lookup"><span data-stu-id="5645c-499">The remainder of the data for an entity consists of application-defined fields.</span></span> <span data-ttu-id="5645c-500">Nem adott sémák lépnek érvénybe, és minden egyes sorára tartalmazhat egy másik alkalmazás által definiált mezők csoportját.</span><span class="sxs-lookup"><span data-stu-id="5645c-500">No particular schemas are enforced, and each row can contain a different set of application-defined fields.</span></span> <span data-ttu-id="5645c-501">A csak korlátozása, hogy egy entitás (beleértve a partíció- és sorfejlécek kulcsok) maximális méretének jelenleg 1 MB.</span><span class="sxs-lookup"><span data-stu-id="5645c-501">The only limitation is that the maximum size of an entity (including the partition and row keys) is currently 1 MB.</span></span> <span data-ttu-id="5645c-502">A maximális tábla mérete 200 TB, bár ezeket az adatokat a későbbiekben változhat.</span><span class="sxs-lookup"><span data-stu-id="5645c-502">The maximum size of a table is 200 TB, although these figures might change in the future.</span></span> <span data-ttu-id="5645c-503">(Ellenőrizze a lap [Azure Storage méretezhetőségi és Teljesítménycélok] kapcsolatos legfrissebb adatokat a Microsoft webhelyén.)</span><span class="sxs-lookup"><span data-stu-id="5645c-503">(Check the page [Azure Storage scalability and performance targets] on the Microsoft website for the most recent information about these limits.)</span></span>

<span data-ttu-id="5645c-504">Ha tárolására, amelyek mérete meghaladja a kapacitását entitásokat próbál, fontolja meg több táblákba felosztásával őket.</span><span class="sxs-lookup"><span data-stu-id="5645c-504">If you are attempting to store entities that exceed this capacity, then consider splitting them into multiple tables.</span></span> <span data-ttu-id="5645c-505">A mezők felosztani a csoportokat, amelyek a legnagyobb valószínűség együttesen érhető el a vertikális particionálást használnak.</span><span class="sxs-lookup"><span data-stu-id="5645c-505">Use vertical partitioning to divide the fields into the groups that are most likely to be accessed together.</span></span>

<span data-ttu-id="5645c-506">A 7. ábrán egy példa storage-fiók (a Contoso adatok) logikai szerkezetének egy fiktív e-kereskedelmi alkalmazás jelennek meg.</span><span class="sxs-lookup"><span data-stu-id="5645c-506">Figure 7 shows the logical structure of an example storage account (Contoso Data) for a fictitious e-commerce application.</span></span> <span data-ttu-id="5645c-507">A tárfiók három táblát tartalmaz: ügyféladatok, termékinformációk és rendelés adatai.</span><span class="sxs-lookup"><span data-stu-id="5645c-507">The storage account contains three tables: Customer Info, Product Info, and Order Info.</span></span> <span data-ttu-id="5645c-508">Minden tábla több partíciót tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="5645c-508">Each table has multiple partitions.</span></span>

<span data-ttu-id="5645c-509">Az ügyféladatok táblázatban az adatok particionálása megfelelően a város, amikor az ügyfél található, és a sorkulcs az ügyfél-azonosítót tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="5645c-509">In the Customer Info table, the data is partitioned according to the city in which the customer is located, and the row key contains the customer ID.</span></span> <span data-ttu-id="5645c-510">A termékinformációk tábla termékkategóriák és a termékek particionáltak, és a sorkulcs a termék számát tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="5645c-510">In the Product Info table, the products are partitioned by product category, and the row key contains the product number.</span></span> <span data-ttu-id="5645c-511">A sorrend Info tábla rendelések particionáltak a dátum, amelyen helyezték, és a sorkulcs Megadja azt az időtartamot, a sorrendben érkezett.</span><span class="sxs-lookup"><span data-stu-id="5645c-511">In the Order Info table, the orders are partitioned by the date on which they were placed, and the row key specifies the time the order was received.</span></span> <span data-ttu-id="5645c-512">Vegye figyelembe, hogy minden adatot a sorkulcs minden partíció van rendezve.</span><span class="sxs-lookup"><span data-stu-id="5645c-512">Note that all data is ordered by the row key in each partition.</span></span>

![A táblák és a partíciók egy példa storage-fiók](./images/data-partitioning/TableStorage.png)

<span data-ttu-id="5645c-514">*7. ábra. A táblák és a partíciók egy példa storage-fiók*</span><span class="sxs-lookup"><span data-stu-id="5645c-514">*Figure 7. The tables and partitions in an example storage account*</span></span>

> [!NOTE]
> <span data-ttu-id="5645c-515">Az Azure table storage időbélyegmezővel is hozzáadja minden entitáshoz.</span><span class="sxs-lookup"><span data-stu-id="5645c-515">Azure table storage also adds a timestamp field to each entity.</span></span> <span data-ttu-id="5645c-516">A Timestamp típusú mező a table storage tartja fenn, és minden alkalommal, amikor az entitást módosító és visszaírását a partíció frissül.</span><span class="sxs-lookup"><span data-stu-id="5645c-516">The timestamp field is maintained by table storage and is updated each time the entity is modified and written back to a partition.</span></span> <span data-ttu-id="5645c-517">A table storage szolgáltatás ezt a mezőt egyidejű hozzáférések optimista végrehajtásához használja.</span><span class="sxs-lookup"><span data-stu-id="5645c-517">The table storage service uses this field to implement optimistic concurrency.</span></span> <span data-ttu-id="5645c-518">(Minden alkalommal, amikor egy alkalmazás ír egy entitás vissza a table storage a table storage szolgáltatás összehasonlítja az értéket az entitásban jelenleg írt Timestamp az értéket, amelyet a table storage használatban van.</span><span class="sxs-lookup"><span data-stu-id="5645c-518">(Each time an application writes an entity back to table storage, the table storage service compares the value of the timestamp in the entity that's being written with the value that's held in table storage.</span></span> <span data-ttu-id="5645c-519">Ha az érték nem egyezik, az azt jelenti, hogy egy másik alkalmazás kell rendelkeznie az entitás óta módosított legutóbb beolvasott, és az írási művelet sikertelen lesz.</span><span class="sxs-lookup"><span data-stu-id="5645c-519">If the values are different, it means that another application must have modified the entity since it was last retrieved, and the write operation fails.</span></span> <span data-ttu-id="5645c-520">Az Ön saját kódját a mező nem módosítható, és ez a mező értékét nem adja meg, amikor létrehoz egy új entitást.</span><span class="sxs-lookup"><span data-stu-id="5645c-520">Don't modify this field in your own code, and don't specify a value for this field when you create a new entity.</span></span>
>
>

<span data-ttu-id="5645c-521">Az Azure table storage a partíciós kulcs használ az adatok tárolásához, hogyan lehet.</span><span class="sxs-lookup"><span data-stu-id="5645c-521">Azure table storage uses the partition key to determine how to store the data.</span></span> <span data-ttu-id="5645c-522">Egy entitás egy táblát ad hozzá egy korábban nem használt partíciós kulccsal, ha az Azure table storage új partíciót hoz létre ehhez az entitáshoz.</span><span class="sxs-lookup"><span data-stu-id="5645c-522">If an entity is added to a table with a previously unused partition key, Azure table storage creates a new partition for this entity.</span></span> <span data-ttu-id="5645c-523">Egyéb az azonos partíciókulcsú entitások partícióra tárolódnak.</span><span class="sxs-lookup"><span data-stu-id="5645c-523">Other entities with the same partition key will be stored in the same partition.</span></span>

<span data-ttu-id="5645c-524">Ez az eljárás egy automatikus kibővített stratégia ténylegesen alkalmazza.</span><span class="sxs-lookup"><span data-stu-id="5645c-524">This mechanism effectively implements an automatic scale-out strategy.</span></span> <span data-ttu-id="5645c-525">Mindegyik partíció egy Azure-adatközpontban annak biztosítására, hogy a lekérdezéseiben, amelyeket egyetlen partíció adatainak lekérése gyorsan futtassa a egy kiszolgálón tárolja.</span><span class="sxs-lookup"><span data-stu-id="5645c-525">Each partition is stored on a single server in an Azure datacenter to help ensure that queries that retrieve data from a single partition run quickly.</span></span> <span data-ttu-id="5645c-526">A különböző partíciók azonban több kiszolgálón is terjeszthetők.</span><span class="sxs-lookup"><span data-stu-id="5645c-526">However, different partitions can be distributed across multiple servers.</span></span> <span data-ttu-id="5645c-527">Emellett egyetlen kiszolgáló üzemeltethet több partíciót, ha ezek a partíciók korlátozott mérete.</span><span class="sxs-lookup"><span data-stu-id="5645c-527">Additionally, a single server can host multiple partitions if these partitions are limited in size.</span></span>

<span data-ttu-id="5645c-528">Az entitások az Azure table storage tervezésekor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="5645c-528">Consider the following points when you design your entities for Azure table storage:</span></span>

* <span data-ttu-id="5645c-529">A partíciós kulcs és a sor kulcsértékei kiválasztott kell áll az adatok elérése a.</span><span class="sxs-lookup"><span data-stu-id="5645c-529">The selection of partition key and row key values should be driven by the way in which the data is accessed.</span></span> <span data-ttu-id="5645c-530">Válassza ki a partíciós kulcs/sor billentyűkombinációt, amely támogatja a legtöbb, a lekérdezések.</span><span class="sxs-lookup"><span data-stu-id="5645c-530">Choose a partition key/row key combination that supports the majority of your queries.</span></span> <span data-ttu-id="5645c-531">A leghatékonyabb lekérdezések le adatokat a partíciós kulcs és a sorkulcs megadásával.</span><span class="sxs-lookup"><span data-stu-id="5645c-531">The most efficient queries retrieve data by specifying the partition key and the row key.</span></span> <span data-ttu-id="5645c-532">Adja meg a partíciós kulcs és a sor kulcsok számos lekérdezések végezheti el egy olyan partíciót vizsgálatát.</span><span class="sxs-lookup"><span data-stu-id="5645c-532">Queries that specify a partition key and a range of row keys can be completed by scanning a single partition.</span></span> <span data-ttu-id="5645c-533">Ez a viszonylag gyors, mert az adatok sorok kulcs sorrendjének használatban van.</span><span class="sxs-lookup"><span data-stu-id="5645c-533">This is relatively fast because the data is held in row key order.</span></span> <span data-ttu-id="5645c-534">Lekérdezések mely partíció vizsgálata nem ad meg, ha a partíciós kulcs Azure table storage megvizsgálja az adatok minden partíció lehet szükség.</span><span class="sxs-lookup"><span data-stu-id="5645c-534">If queries don't specify which partition to scan, the partition key might require Azure table storage to scan every partition for your data.</span></span>

  > [!TIP]
  > <span data-ttu-id="5645c-535">Egy entitás egy természetes kulccsal rendelkezik, ha használható a partíciós kulcs, és adja meg a sorkulcs egy üres karakterlánc.</span><span class="sxs-lookup"><span data-stu-id="5645c-535">If an entity has one natural key, then use it as the partition key and specify an empty string as the row key.</span></span> <span data-ttu-id="5645c-536">Ha egy entitás két tulajdonságait tartalmazó összetett kulccsal rendelkezik, jelölje ki a slowest változó tulajdonságot a partíciós kulcs, míg a másik a sorkulcs.</span><span class="sxs-lookup"><span data-stu-id="5645c-536">If an entity has a composite key comprising two properties, select the slowest changing property as the partition key and the other as the row key.</span></span> <span data-ttu-id="5645c-537">Ha egy entitás legfeljebb két fő tulajdonságokkal rendelkezik, a Tulajdonságok összefűzése segítségével a partíció- és sorfejlécek kulcsait biztosítja.</span><span class="sxs-lookup"><span data-stu-id="5645c-537">If an entity has more than two key properties, use a concatenation of properties to provide the partition and row keys.</span></span>
  >
  >
* <span data-ttu-id="5645c-538">Ha rendszeresen végre lekérdezések, amelyek adatokat kereshet a partíció- és sorfejlécek kulcsok eltérő mezőkkel, vegye fontolóra a [index táblázat mintát].</span><span class="sxs-lookup"><span data-stu-id="5645c-538">If you regularly perform queries that look up data by using fields other than the partition and row keys, consider implementing the [index table pattern].</span></span>
* <span data-ttu-id="5645c-539">Ha készítése a partíciókulcsok használatával a monoton növekvő vagy csökkenő sorrendben (például "0001", "0002", "0003", és így tovább) minden partíció csak korlátozott mennyiségű adat tartalmazza, majd az Azure table storage is fizikailag ezek a partíciók egy csoportba a a ugyanazon a kiszolgálón.</span><span class="sxs-lookup"><span data-stu-id="5645c-539">If you generate partition keys by using a monotonic increasing or decreasing sequence (such as "0001", "0002", "0003", and so on) and each partition only contains a limited amount of data, then Azure table storage can physically group these partitions together on the same server.</span></span> <span data-ttu-id="5645c-540">Ez az eljárás feltételezi, hogy az alkalmazás valószínűleg partíciók (lekérdezések) összefüggő számos különböző lekérdezések végrehajtásához, és ebben az esetben van optimalizálva.</span><span class="sxs-lookup"><span data-stu-id="5645c-540">This mechanism assumes that the application is most likely to perform queries across a contiguous range of partitions (range queries) and is optimized for this case.</span></span> <span data-ttu-id="5645c-541">Ezt a módszert azonban egy kiszolgálón arra irányul, mert az új entitások minden Beszúrások valószínűleg több olyan end vagy egyéb összefüggő tartományt koncentrált elérési pontokhoz való vezethet.</span><span class="sxs-lookup"><span data-stu-id="5645c-541">However, this approach can lead to hotspots focused on a single server because all insertions of new entities are likely to be concentrated at one end or the other of the contiguous ranges.</span></span> <span data-ttu-id="5645c-542">Méretezhetőség is csökkentheti.</span><span class="sxs-lookup"><span data-stu-id="5645c-542">It can also reduce scalability.</span></span> <span data-ttu-id="5645c-543">Egyenletesen a terhelés több kiszolgáló között, fontolja meg a partíciós kulcs, hogy a feladatütemezési több véletlenszerű kivonatoláshoz.</span><span class="sxs-lookup"><span data-stu-id="5645c-543">To spread the load more evenly across servers, consider hashing the partition key to make the sequence more random.</span></span>
* <span data-ttu-id="5645c-544">Azure table storage támogatja a tranzakciós műveletek ugyanahhoz a partícióhoz tartozó entitások is szerepelnek.</span><span class="sxs-lookup"><span data-stu-id="5645c-544">Azure table storage supports transactional operations for entities that belong to the same partition.</span></span> <span data-ttu-id="5645c-545">Ez azt jelenti, hogy egy alkalmazás végezheti több insert, update, delete, csere vagy egyesítési műveletek atomi egységként (feltéve, hogy a tranzakció nem tartalmazza a 100-nál több entitásokat és a kérelem hasznos nem haladhatja meg a 4 MB).</span><span class="sxs-lookup"><span data-stu-id="5645c-545">This means that an application can perform multiple insert, update, delete, replace, or merge operations as an atomic unit (as long as the transaction doesn't include more than 100 entities and the payload of the request doesn't exceed 4 MB).</span></span> <span data-ttu-id="5645c-546">Több partíción átnyúló műveletek nem tranzakciós, és előfordulhat, hogy meg kell valósítania a végleges konzisztencia szerint a [adatok konzisztencia ismertetése].</span><span class="sxs-lookup"><span data-stu-id="5645c-546">Operations that span multiple partitions are not transactional, and might require you to implement eventual consistency as described by the [Data consistency primer].</span></span> <span data-ttu-id="5645c-547">A table storage és a tranzakciók kapcsolatos további információkért lépjen a lapra [entitás csoport tranzakciók végrehajtása] a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="5645c-547">For more information about table storage and transactions, go to the page [Performing entity group transactions] on the Microsoft website.</span></span>
* <span data-ttu-id="5645c-548">Adja meg a lépésköz legyen a partíciós kulcs alapos figyelmet a következő okok miatt:</span><span class="sxs-lookup"><span data-stu-id="5645c-548">Give careful attention to the granularity of the partition key because of the following reasons:</span></span>
  * <span data-ttu-id="5645c-549">Minden entitás ugyanazzal a partíciókulccsal használata azt eredményezi, a table storage szolgáltatás egy kiszolgálón tartott egy nagy partíció létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="5645c-549">Using the same partition key for every entity causes the table storage service to create a single large partition that's held on one server.</span></span> <span data-ttu-id="5645c-550">Ez megakadályozza, hogy kiterjesztése, és a terhelés dokumentum egy kiszolgálón.</span><span class="sxs-lookup"><span data-stu-id="5645c-550">This prevents it from scaling out and instead focuses the load on a single server.</span></span> <span data-ttu-id="5645c-551">Ennek köszönhetően ez a megközelítés alkalmas csak rendszerek által kezelt entitások kis számú.</span><span class="sxs-lookup"><span data-stu-id="5645c-551">As a result, this approach is only suitable for systems that manage a small number of entities.</span></span> <span data-ttu-id="5645c-552">Azonban ez a megközelítés győződjön meg arról, hogy valamennyi entitást részt vehetnek-e entitás csoport tranzakciók.</span><span class="sxs-lookup"><span data-stu-id="5645c-552">However, this approach does ensure that all entities can participate in entity group transactions.</span></span>
  * <span data-ttu-id="5645c-553">Minden entitás egyedi partíciós kulcs használata azt eredményezi, a table storage szolgáltatás minden egyes entitásnál, valószínűleg eredményezve kis partíciók (attól függően, hogy az entitások méretét) számos különböző partíció létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="5645c-553">Using a unique partition key for every entity causes the table storage service to create a separate partition for each entity, possibly resulting in a large number of small partitions (depending on the size of the entities).</span></span> <span data-ttu-id="5645c-554">Ez a megközelítés több méretezhető, mint a egyetlen partíciókulcsok használatával, de entitás csoport tranzakciók nem lehetséges.</span><span class="sxs-lookup"><span data-stu-id="5645c-554">This approach is more scalable than using a single partition key, but entity group transactions are not possible.</span></span> <span data-ttu-id="5645c-555">Emellett beolvasása egynél több entitáskészlet lekérdezések előfordulhat, hogy tartalmaz, amely egynél több kiszolgálón történő olvasás.</span><span class="sxs-lookup"><span data-stu-id="5645c-555">Also, queries that fetch more than one entity might involve reading from more than one server.</span></span> <span data-ttu-id="5645c-556">Azonban ha az alkalmazás hajt végre a lekérdezések, monoton feladatütemezési segítségével a partíciós kulcsok létrehozása segíthet optimalizálni a lekérdezéseket.</span><span class="sxs-lookup"><span data-stu-id="5645c-556">However, if the application performs range queries, then using a monotonic sequence to generate the partition keys might help to optimize these queries.</span></span>
  * <span data-ttu-id="5645c-557">A partíciós kulcs egy részhalmazát entitások közötti megosztás lehetővé teszi, hogy a csoport kapcsolódó bejegyzései szerepelnek a partícióra.</span><span class="sxs-lookup"><span data-stu-id="5645c-557">Sharing the partition key across a subset of entities makes it possible for you to group related entities in the same partition.</span></span> <span data-ttu-id="5645c-558">Entitás csoport tranzakciók segítségével végrehajtható műveletek, például a kapcsolódó entitásokból, és a kapcsolódó entitásokból készlete fetch lekérdezések egyetlen kiszolgáló elérésével lehet teljesíteni.</span><span class="sxs-lookup"><span data-stu-id="5645c-558">Operations that involve related entities can be performed by using entity group transactions, and queries that fetch a set of related entities can be satisfied by accessing a single server.</span></span>

<span data-ttu-id="5645c-559">Adatok az Azure table storage-ban partícionálásra vonatkozó további információkért lásd: a cikk [az Azure storage táblázat kialakítási útmutató] a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="5645c-559">For additional information about partitioning data in Azure table storage, see the article [Azure storage table design guide] on the Microsoft website.</span></span>

## <a name="partitioning-azure-blob-storage"></a><span data-ttu-id="5645c-560">Az Azure blob storage particionálás</span><span class="sxs-lookup"><span data-stu-id="5645c-560">Partitioning Azure blob storage</span></span>
<span data-ttu-id="5645c-561">Az Azure blob-tároló lehetővé teszi az nagyméretű bináris objektumok – jelenleg legfeljebb 5 TB-nál a blokkblobokhoz vagy lapblobokra 1 TB.</span><span class="sxs-lookup"><span data-stu-id="5645c-561">Azure blob storage makes it possible to hold large binary objects--currently up to 5 TB in size for block blobs or 1 TB for page blobs.</span></span> <span data-ttu-id="5645c-562">(A legfrissebb információkért nyissa meg a lap [Azure Storage méretezhetőségi és Teljesítménycélok] a Microsoft webhelyén.) A forgatókönyvek használhatók, mint ahol kell streaming blokkblobokat segítségével feltölteni, vagy töltse le a nagy adatmennyiségek gyors.</span><span class="sxs-lookup"><span data-stu-id="5645c-562">(For the most recent information, go to the page [Azure Storage scalability and performance targets] on the Microsoft website.) Use block blobs in scenarios such as streaming where you need to upload or download large volumes of data quickly.</span></span> <span data-ttu-id="5645c-563">Ahelyett, hogy a soros hozzáféréshez, az adatokat a különböző részeinek véletlenszerű igénylő alkalmazások lapblobokat használnak.</span><span class="sxs-lookup"><span data-stu-id="5645c-563">Use page blobs for applications that require random rather than serial access to parts of the data.</span></span>

<span data-ttu-id="5645c-564">Minden egyes blob (blokk vagy oldal) egy tároló az Azure-tárfiók használatban van.</span><span class="sxs-lookup"><span data-stu-id="5645c-564">Each blob (either block or page) is held in a container in an Azure storage account.</span></span> <span data-ttu-id="5645c-565">Tárolók használatával kapcsolódó blobok, amelyek az ugyanazon biztonsági követelmények csoportban.</span><span class="sxs-lookup"><span data-stu-id="5645c-565">You can use containers to group related blobs that have the same security requirements.</span></span> <span data-ttu-id="5645c-566">Ez a csoportosítás akkor logikai, hanem fizikai.</span><span class="sxs-lookup"><span data-stu-id="5645c-566">This grouping is logical rather than physical.</span></span> <span data-ttu-id="5645c-567">Egy tároló belül minden egyes blob egyedi névvel rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="5645c-567">Inside a container, each blob has a unique name.</span></span>

<span data-ttu-id="5645c-568">A partíció egy blob kulcsa fiók nevét, a tároló neve + a blob neve.</span><span class="sxs-lookup"><span data-stu-id="5645c-568">The partition key for a blob is account name + container name + blob name.</span></span> <span data-ttu-id="5645c-569">Ez azt jelenti, hogy minden egyes blob saját partícióval rendelkezhet, ha a blob terhelése megköveteli azt.</span><span class="sxs-lookup"><span data-stu-id="5645c-569">This means each blob can have its own partition if load on the blob demands it.</span></span> <span data-ttu-id="5645c-570">Blobok terjeszthető környezetekben, sok kiszolgálón ahhoz, hogy terjessze ki őket a hozzáférést, de egyetlen blob csak egyetlen kiszolgáló szolgálhatók ki.</span><span class="sxs-lookup"><span data-stu-id="5645c-570">Blobs can be distributed across many servers in order to scale out access to them, but a single blob can only be served by a single server.</span></span> 

<span data-ttu-id="5645c-571">Egy egyetlen blokkot (blokkblob) vagy a lap (az oldalakra vonatkozó blob) írása műveleteit atomi, de műveletek, amelyek több blokkolja, a lapok vagy a BLOB nem.</span><span class="sxs-lookup"><span data-stu-id="5645c-571">The actions of writing a single block (block blob) or page (page blob) are atomic, but operations that span blocks, pages, or blobs are not.</span></span> <span data-ttu-id="5645c-572">Ha blokkolja, a lapokat és a blobok keresztül az írási műveletek végrehajtása során, győződjön meg arról, hogy konzisztencia van szüksége, vegye ki egy írási zárolás a blob címbérlet használatával.</span><span class="sxs-lookup"><span data-stu-id="5645c-572">If you need to ensure consistency when performing write operations across blocks, pages, and blobs, take out a write lock by using a blob lease.</span></span>

<span data-ttu-id="5645c-573">Az Azure blob storage tárolók átviteli sebességre legfeljebb 60 MB második vagy 500 kérelmek minden egyes blob másodpercenkénti száma.</span><span class="sxs-lookup"><span data-stu-id="5645c-573">Azure blob storage targets transfer rates of up to 60 MB per second or 500 requests per second for each blob.</span></span> <span data-ttu-id="5645c-574">Ha ezek a korlátozások határértékek túllépését várhatóan, és a blobadatokat viszonylag statikus, fontolja meg bináris objektumok replikálása az Azure Content Delivery Network használatával.</span><span class="sxs-lookup"><span data-stu-id="5645c-574">If you anticipate surpassing these limits, and the blob data is relatively static, then consider replicating blobs by using the Azure Content Delivery Network.</span></span> <span data-ttu-id="5645c-575">További információkért lásd: a lap [Azure Content Delivery Network] a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="5645c-575">For more information, see the page [Azure Content Delivery Network] on the Microsoft website.</span></span> <span data-ttu-id="5645c-576">További útmutatás és szempontokat, [használata Azure Content Delivery Network].</span><span class="sxs-lookup"><span data-stu-id="5645c-576">For additional guidance and considerations, see [Using Azure Content Delivery Network].</span></span>

## <a name="partitioning-azure-storage-queues"></a><span data-ttu-id="5645c-577">Az Azure storage várólisták particionálás</span><span class="sxs-lookup"><span data-stu-id="5645c-577">Partitioning Azure storage queues</span></span>
<span data-ttu-id="5645c-578">Az Azure storage-üzenetsorok lehetővé teszik-folyamatai közötti aszinkron üzenetkezelési végrehajtásához.</span><span class="sxs-lookup"><span data-stu-id="5645c-578">Azure storage queues enable you to implement asynchronous messaging between processes.</span></span> <span data-ttu-id="5645c-579">Azure-tárfiók várólisták tetszőleges számú tartalmazhat, és egyes várólisták korlátlan számú üzenetet tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="5645c-579">An Azure storage account can contain any number of queues, and each queue can contain any number of messages.</span></span> <span data-ttu-id="5645c-580">Egyetlen korlátozás a hely, amely a tárfiókban lévő érhető el.</span><span class="sxs-lookup"><span data-stu-id="5645c-580">The only limitation is the space that's available in the storage account.</span></span> <span data-ttu-id="5645c-581">Egy egyszeri üzenetek maximális mérete 64 KB.</span><span class="sxs-lookup"><span data-stu-id="5645c-581">The maximum size of an individual message is 64 KB.</span></span> <span data-ttu-id="5645c-582">Ha nagyobb, mint ez üzenetek van szüksége, fontolja meg helyette az Azure Service Bus-üzenetsorok.</span><span class="sxs-lookup"><span data-stu-id="5645c-582">If you require messages bigger than this, then consider using Azure Service Bus queues instead.</span></span>

<span data-ttu-id="5645c-583">Minden egyes tárolási várólista, amely tartalmazza azt a tárfiókon belül egyedi névvel rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="5645c-583">Each storage queue has a unique name within the storage account that contains it.</span></span> <span data-ttu-id="5645c-584">Azure particionálja a várólisták neve alapján.</span><span class="sxs-lookup"><span data-stu-id="5645c-584">Azure partitions queues based on the name.</span></span> <span data-ttu-id="5645c-585">Ugyanazon a várólistán üzenetek egy adott kiszolgáló vezérli partícióra vannak tárolva.</span><span class="sxs-lookup"><span data-stu-id="5645c-585">All messages for the same queue are stored in the same partition, which is controlled by a single server.</span></span> <span data-ttu-id="5645c-586">Különböző várólisták kezelhető a terhelés elosztása érdekében különböző kiszolgálókon.</span><span class="sxs-lookup"><span data-stu-id="5645c-586">Different queues can be managed by different servers to help balance the load.</span></span> <span data-ttu-id="5645c-587">Lefoglalása a várólisták kiválasztásával kiszolgálók az alkalmazások és a felhasználók számára transzparens.</span><span class="sxs-lookup"><span data-stu-id="5645c-587">The allocation of queues to servers is transparent to applications and users.</span></span>

 <span data-ttu-id="5645c-588">Egy nagy méretű alkalmazásban ne használjon ugyanazon a várólistán tárolási az alkalmazás összes példányát, mert ez a megközelítés előfordulhat, hogy a kiszolgáló, amelyen az interaktív terület lesz a várólista.</span><span class="sxs-lookup"><span data-stu-id="5645c-588">In a large-scale application, don't use the same storage queue for all instances of the application because this approach might cause the server that's hosting the queue to become a hotspot.</span></span> <span data-ttu-id="5645c-589">Ehelyett használjon különböző sorok különböző funkcionális területek az alkalmazás.</span><span class="sxs-lookup"><span data-stu-id="5645c-589">Instead, use different queues for different functional areas of the application.</span></span> <span data-ttu-id="5645c-590">Az Azure storage várólisták támogatja a tranzakciókat, így arra utasíthatja a különböző üzenetsorok üzenetek kell jelentősek üzenetküldéssel konzisztencia.</span><span class="sxs-lookup"><span data-stu-id="5645c-590">Azure storage queues do not support transactions, so directing messages to different queues should have little impact on messaging consistency.</span></span>

<span data-ttu-id="5645c-591">Egy Azure storage üzenetsorába kezelni tud a legfeljebb 2000 üzenetek száma másodpercenként.</span><span class="sxs-lookup"><span data-stu-id="5645c-591">An Azure storage queue can handle up to 2,000 messages per second.</span></span>  <span data-ttu-id="5645c-592">Ennél nagyobb arányban üzenetek feldolgozásához, javasolt több várólisták létrehozására.</span><span class="sxs-lookup"><span data-stu-id="5645c-592">If you need to process messages at a greater rate than this, consider creating multiple queues.</span></span> <span data-ttu-id="5645c-593">Például egy globális alkalmazásban hozzon létre külön tárüzenetsort külön tárfiókokban minden régióban futtató alkalmazáspéldányok kezelésére.</span><span class="sxs-lookup"><span data-stu-id="5645c-593">For example, in a global application, create separate storage queues in separate storage accounts to handle application instances that are running in each region.</span></span>

## <a name="partitioning-strategies-for-azure-service-bus"></a><span data-ttu-id="5645c-594">Azure Service Bus particionálási stratégia</span><span class="sxs-lookup"><span data-stu-id="5645c-594">Partitioning strategies for Azure Service Bus</span></span>
<span data-ttu-id="5645c-595">Azure Service Bus egy üzenet broker használatával a Service Bus-üzenetsor vagy témakör küldött üzenetek kezeléséhez.</span><span class="sxs-lookup"><span data-stu-id="5645c-595">Azure Service Bus uses a message broker to handle messages that are sent to a Service Bus queue or topic.</span></span> <span data-ttu-id="5645c-596">Alapértelmezés szerint üzenetsor vagy témakör küldött összes üzenet kezeli a ugyanazon üzenet broker folyamat.</span><span class="sxs-lookup"><span data-stu-id="5645c-596">By default, all messages that are sent to a queue or topic are handled by the same message broker process.</span></span> <span data-ttu-id="5645c-597">Ez az architektúra korlátozása állíthat be a teljes átviteli képessége – az üzenet-várólista.</span><span class="sxs-lookup"><span data-stu-id="5645c-597">This architecture can place a limitation on the overall throughput of the message queue.</span></span> <span data-ttu-id="5645c-598">Azonban Ön is is partícióazonosító üzenetsor vagy témakör létrehozásakor.</span><span class="sxs-lookup"><span data-stu-id="5645c-598">However, you can also partition a queue or topic when it is created.</span></span> <span data-ttu-id="5645c-599">Úgy, hogy ehhez a *EnablePartitioning* az üzenetsor vagy témakör leírást tulajdonságának *igaz*.</span><span class="sxs-lookup"><span data-stu-id="5645c-599">You do this by setting the *EnablePartitioning* property of the queue or topic description to *true*.</span></span>

<span data-ttu-id="5645c-600">A particionált üzenetsor vagy témakör több töredék biztonsági, amelyek mindegyike egy külön üzenettároló, valamint az üzenet broker van felosztva.</span><span class="sxs-lookup"><span data-stu-id="5645c-600">A partitioned queue or topic is divided into multiple fragments, each of which is backed by a separate message store and message broker.</span></span> <span data-ttu-id="5645c-601">A Service Bus létrehozását és kezelését, ez a töredék felelősséget.</span><span class="sxs-lookup"><span data-stu-id="5645c-601">Service Bus takes responsibility for creating and managing these fragments.</span></span> <span data-ttu-id="5645c-602">Egy alkalmazás particionált üzenetsor vagy témakör üzenetet küldi, a Service Bus egy kódrészletet az adott üzenetsor vagy témakör az üzenet rendel.</span><span class="sxs-lookup"><span data-stu-id="5645c-602">When an application posts a message to a partitioned queue or topic, Service Bus assigns the message to a fragment for that queue or topic.</span></span> <span data-ttu-id="5645c-603">Amikor egy alkalmazás egy üzenetsorból vagy előfizetés üzenetet kap, a Service Bus ellenőrzi a következő elérhető üzenetet minden egyes töredék, és átadja az alkalmazás feldolgozásra.</span><span class="sxs-lookup"><span data-stu-id="5645c-603">When an application receives a message from a queue or subscription, Service Bus checks each fragment for the next available message and then passes it to the application for processing.</span></span>

<span data-ttu-id="5645c-604">Ez a struktúra segít a terhelés szétosztását üzenet brókerek és üzenettároló, hatékonyabb méretezhetőséget és rendelkezésre állás javítása.</span><span class="sxs-lookup"><span data-stu-id="5645c-604">This structure helps distribute the load across message brokers and message stores, increasing scalability and improving availability.</span></span> <span data-ttu-id="5645c-605">Ha egy üzenet broker vagy az üzenet tároló átmenetileg nem érhető el, a Service Bus lehet üzeneteket beolvasni a fennmaradó rendelkezésre álló töredék egyikéhez.</span><span class="sxs-lookup"><span data-stu-id="5645c-605">If the message broker or message store for one fragment is temporarily unavailable, Service Bus can retrieve messages from one of the remaining available fragments.</span></span>

<span data-ttu-id="5645c-606">A Service Bus rendel hozzá egy üzenet egy kódrészletet az alábbiak szerint:</span><span class="sxs-lookup"><span data-stu-id="5645c-606">Service Bus assigns a message to a fragment as follows:</span></span>

* <span data-ttu-id="5645c-607">Ha az üzenet egy munkamenet tartozik, az összes üzenetek ugyanazt az értéket a * ugyanazon töredék küldött munkamenet-azonosító * tulajdonság.</span><span class="sxs-lookup"><span data-stu-id="5645c-607">If the message belongs to a session, all messages with the same value for the * SessionId*  property are sent to the same fragment.</span></span>
* <span data-ttu-id="5645c-608">Ha az üzenet nem tartozik egy munkamenetet, de a küldő rendelkezik a megadott értéket a *PartitionKey* tulajdonság, majd ugyanazzal a összes üzenet *PartitionKey* értéket küldött ugyanazon töredék.</span><span class="sxs-lookup"><span data-stu-id="5645c-608">If the message does not belong to a session, but the sender has specified a value for the *PartitionKey* property, then all messages with the same *PartitionKey* value are sent to the same fragment.</span></span>

  > [!NOTE]
  > <span data-ttu-id="5645c-609">Ha a *SessionId* és *PartitionKey* mindkét megadva a tulajdonságai, akkor ugyanazt az értéket be kell állítani, vagy az üzenet vissza lesznek utasítva.</span><span class="sxs-lookup"><span data-stu-id="5645c-609">If the *SessionId* and *PartitionKey* properties are both specified, then they must be set to the same value or the message will be rejected.</span></span>
  >
  >
* <span data-ttu-id="5645c-610">Ha a *SessionId* és *PartitionKey* üzenet tulajdonságai nincsenek megadva, de ismétlődő érzékelés engedélyezve van, a *MessageId* tulajdonság használható.</span><span class="sxs-lookup"><span data-stu-id="5645c-610">If the *SessionId* and *PartitionKey* properties for a message are not specified, but duplicate detection is enabled, the *MessageId* property will be used.</span></span> <span data-ttu-id="5645c-611">Összes üzenet azonos *MessageId* ugyanazon töredék a rendszer kéri.</span><span class="sxs-lookup"><span data-stu-id="5645c-611">All messages with the same *MessageId* will be directed to the same fragment.</span></span>
* <span data-ttu-id="5645c-612">Ha az üzenetek nem tartalmaznak egy *munkamenet-azonosító, PartitionKey,* vagy *MessageId* tulajdonság, akkor a Service Bus rendel üzenetek töredék egymás után.</span><span class="sxs-lookup"><span data-stu-id="5645c-612">If messages do not include a *SessionId, PartitionKey,* or *MessageId* property, then Service Bus assigns messages to fragments sequentially.</span></span> <span data-ttu-id="5645c-613">Töredékkel nem érhető el, ha a Service Bus helyezi át a Tovább gombra.</span><span class="sxs-lookup"><span data-stu-id="5645c-613">If a fragment is unavailable, Service Bus will move on to the next.</span></span> <span data-ttu-id="5645c-614">Ez azt jelenti, hogy az üzenetkezelési infrastruktúrára egy ideiglenes hiba nem okoz az üzenet-küldési művelet sikertelen lesz.</span><span class="sxs-lookup"><span data-stu-id="5645c-614">This means that a temporary fault in the messaging infrastructure does not cause the message-send operation to fail.</span></span>

<span data-ttu-id="5645c-615">Vegye figyelembe az alábbiakat, ha meghatározásakor vagy a Service Bus-üzenetsor vagy témakör particionálásáról:</span><span class="sxs-lookup"><span data-stu-id="5645c-615">Consider the following points when deciding if or how to partition a Service Bus message queue or topic:</span></span>

* <span data-ttu-id="5645c-616">Service Bus-üzenetsorok és témakörök jönnek létre a Service Bus-névtér hatókörén belül.</span><span class="sxs-lookup"><span data-stu-id="5645c-616">Service Bus queues and topics are created within the scope of a Service Bus namespace.</span></span> <span data-ttu-id="5645c-617">A Service Bus jelenleg lehetővé teszi, hogy legfeljebb 100 particionált várólisták vagy olyan témakörök / névtér.</span><span class="sxs-lookup"><span data-stu-id="5645c-617">Service Bus currently allows up to 100 partitioned queues or topics per namespace.</span></span>
* <span data-ttu-id="5645c-618">Minden egyes Service Bus-névtér írja elő a rendelkezésre álló erőforrások, például előfizetésszám száma párhuzamos küldés számát, a témakör az kvótái, és részesüljön kérelmek / másodperc, és a létrehozható egyidejű kapcsolatok maximális száma.</span><span class="sxs-lookup"><span data-stu-id="5645c-618">Each Service Bus namespace imposes quotas on the available resources, such as the number of subscriptions per topic, the number of concurrent send and receive requests per second, and the maximum number of concurrent connections that can be established.</span></span> <span data-ttu-id="5645c-619">Ezek mely százalékértékénél kéri a Microsoft webhelyén, a lapon szerepelnek [Service Bus kvóták].</span><span class="sxs-lookup"><span data-stu-id="5645c-619">These quotas are documented on the Microsoft website on the page [Service Bus quotas].</span></span> <span data-ttu-id="5645c-620">Ha várhatóan a következő korlátozásokkal ezeket az értékeket, a saját üzenetsorok és témakörök további névteret létrehozása, és a munka elosztva a névterek.</span><span class="sxs-lookup"><span data-stu-id="5645c-620">If you expect to exceed these values, then create additional namespaces with their own queues and topics, and spread the work across these namespaces.</span></span> <span data-ttu-id="5645c-621">Globális alkalmazásokban, például különálló névterek létrehozása minden régióban, és a alkalmazáspéldányok az üzenetsorok és témakörök a legközelebbi névtér használatára konfigurálja.</span><span class="sxs-lookup"><span data-stu-id="5645c-621">For example, in a global application, create separate namespaces in each region and configure application instances to use the queues and topics in the nearest namespace.</span></span>
* <span data-ttu-id="5645c-622">Egy tranzakció részeként küldött üzenetek meg kell adnia egy partíciókulcsot.</span><span class="sxs-lookup"><span data-stu-id="5645c-622">Messages that are sent as part of a transaction must specify a partition key.</span></span> <span data-ttu-id="5645c-623">Ez lehet egy *SessionId*, *PartitionKey*, vagy *MessageId* tulajdonság.</span><span class="sxs-lookup"><span data-stu-id="5645c-623">This can be a *SessionId*, *PartitionKey*, or *MessageId* property.</span></span> <span data-ttu-id="5645c-624">Ugyanabban a tranzakcióban részeként küldött összes üzenet kell megadni ugyanazzal a partíciókulccsal, mert azok a ugyanazon üzenet broker folyamat kell kezelnie.</span><span class="sxs-lookup"><span data-stu-id="5645c-624">All messages that are sent as part of the same transaction must specify the same partition key because they must be handled by the same message broker process.</span></span> <span data-ttu-id="5645c-625">Üzenetek küldése nem különböző várólisták vagy olyan témakörök ugyanazon a tranzakción belül.</span><span class="sxs-lookup"><span data-stu-id="5645c-625">You cannot send messages to different queues or topics within the same transaction.</span></span>
* <span data-ttu-id="5645c-626">A particionált üzenetsorok és témakörök automatikusan törlésekor üresjárati válnának nem konfigurálható.</span><span class="sxs-lookup"><span data-stu-id="5645c-626">Partitioned queues and topics can't be configured to be automatically deleted when they become idle.</span></span>
* <span data-ttu-id="5645c-627">A particionált üzenetsorok és témakörök jelenleg használható a speciális Message Queuing protokoll (AMQP) platformfüggetlen vagy hibrid megoldások készítésekor.</span><span class="sxs-lookup"><span data-stu-id="5645c-627">Partitioned queues and topics can't currently be used with the Advanced Message Queuing Protocol (AMQP) if you are building cross-platform or hybrid solutions.</span></span>

## <a name="partitioning-strategies-for-cosmos-db"></a><span data-ttu-id="5645c-628">A Cosmos DB particionálási stratégia</span><span class="sxs-lookup"><span data-stu-id="5645c-628">Partitioning strategies for Cosmos DB</span></span>

<span data-ttu-id="5645c-629">Azure Cosmos DB egy NoSQL-adatbázis, amely segítségével JSON-dokumentumokat tárolhat a [Azure Cosmos DB SQL API][cosmosdb-sql-api].</span><span class="sxs-lookup"><span data-stu-id="5645c-629">Azure Cosmos DB is a NoSQL database that can store JSON documents using the [Azure Cosmos DB SQL API][cosmosdb-sql-api].</span></span> <span data-ttu-id="5645c-630">A dokumentum egy Cosmos DB adatbázisban egy objektum vagy egyéb adatok JSON-szerializált ábrázolását.</span><span class="sxs-lookup"><span data-stu-id="5645c-630">A document in a Cosmos DB database is a JSON-serialized representation of an object or other piece of data.</span></span> <span data-ttu-id="5645c-631">Nincsenek rögzített sémák kerül minden alkalom, azzal a különbséggel, hogy minden dokumentumnak tartalmaznia kell egy egyedi azonosítót.</span><span class="sxs-lookup"><span data-stu-id="5645c-631">No fixed schemas are enforced except that every document must contain a unique ID.</span></span>

<span data-ttu-id="5645c-632">Dokumentumok gyűjteményekbe vannak rendezve.</span><span class="sxs-lookup"><span data-stu-id="5645c-632">Documents are organized into collections.</span></span> <span data-ttu-id="5645c-633">Kapcsolódó dokumentumok együtt egy gyűjteményen belül csoportosíthatja.</span><span class="sxs-lookup"><span data-stu-id="5645c-633">You can group related documents together in a collection.</span></span> <span data-ttu-id="5645c-634">Például az állapotinformációkat bejegyzéseket, tárolhatja minden blogbejegyzés tartalmát a gyűjtemény-dokumentumként.</span><span class="sxs-lookup"><span data-stu-id="5645c-634">For example, in a system that maintains blog postings, you can store the contents of each blog post as a document in a collection.</span></span> <span data-ttu-id="5645c-635">Az egyes tulajdonos gyűjteményeket is létrehozhat.</span><span class="sxs-lookup"><span data-stu-id="5645c-635">You can also create collections for each subject type.</span></span> <span data-ttu-id="5645c-636">Azt is megteheti több-bérlős alkalmazásokban, például a rendszer, ahol a különböző szerzők szabályozza, és kezelheti a saját blogbejegyzések is Szerző blogok partícióazonosító és minden egyes Szerző külön gyűjtemények létrehozása.</span><span class="sxs-lookup"><span data-stu-id="5645c-636">Alternatively, in a multitenant application, such as a system where different authors control and manage their own blog posts, you can partition blogs by author and create separate collections for each author.</span></span> <span data-ttu-id="5645c-637">A gyűjtemények lefoglalt tárhely rugalmas és zsugorításával vagy igény szerinti.</span><span class="sxs-lookup"><span data-stu-id="5645c-637">The storage space that's allocated to collections is elastic and can shrink or grow as needed.</span></span>

<span data-ttu-id="5645c-638">Cosmos DB támogatja az adatokat az alkalmazás által meghatározott partíciós kulcs alapján automatikus particionálási.</span><span class="sxs-lookup"><span data-stu-id="5645c-638">Cosmos DB supports automatic partitioning of data based on an application-defined partition key.</span></span> <span data-ttu-id="5645c-639">A *logikai partíciót* javasoljuk, hogy az összes adatot tárolja az egypartíciós kulcs értéke van.</span><span class="sxs-lookup"><span data-stu-id="5645c-639">A *logical partition* is a partition that stores all the data for a single partition key value.</span></span> <span data-ttu-id="5645c-640">Összes dokumentumot, amely ugyanazt az értéket a partíciós kulcs belül az azonos logikai partíció el őket.</span><span class="sxs-lookup"><span data-stu-id="5645c-640">All documents that share the same value for the partition key are placed within the same logical partition.</span></span> <span data-ttu-id="5645c-641">Cosmos DB osztja el a kivonat a partíciókulcs szerint értékeket.</span><span class="sxs-lookup"><span data-stu-id="5645c-641">Cosmos DB distributes values according to hash of the partition key.</span></span> <span data-ttu-id="5645c-642">Egy logikai partíciónak mérete 10 GB-os.</span><span class="sxs-lookup"><span data-stu-id="5645c-642">A logical partition has a maximum size of 10 GB.</span></span> <span data-ttu-id="5645c-643">Ezért a választott a partíciós kulcs, egy fontos döntés tervezési időben.</span><span class="sxs-lookup"><span data-stu-id="5645c-643">Therefore, the choice of the partition key is an important decision at design time.</span></span> <span data-ttu-id="5645c-644">Válassza ki az értékeket, és még akkor is, hozzáférési minták számos tulajdonságot.</span><span class="sxs-lookup"><span data-stu-id="5645c-644">Choose a property with a wide range of values and even access patterns.</span></span> <span data-ttu-id="5645c-645">További információkért lásd: [partíció és a skála Azure Cosmos DB](/azure/cosmos-db/partition-data).</span><span class="sxs-lookup"><span data-stu-id="5645c-645">For more information, see [Partition and scale in Azure Cosmos DB](/azure/cosmos-db/partition-data).</span></span>

> [!NOTE]
> <span data-ttu-id="5645c-646">Minden egyes Cosmos DB-adatbázis egy *teljesítményszintet* , amely meghatározza, hogy lekéri a mérete.</span><span class="sxs-lookup"><span data-stu-id="5645c-646">Each Cosmos DB database has a *performance level* that determines the amount of resources it gets.</span></span> <span data-ttu-id="5645c-647">A teljesítményszintet társítva van egy *kérelem egység* sávszélesség-korlátjának (RU).</span><span class="sxs-lookup"><span data-stu-id="5645c-647">A performance level is associated with a *request unit* (RU) rate limit.</span></span> <span data-ttu-id="5645c-648">A sávszélesség-korlátjának RU meg fenntartott és a rendelkezésre álló kizárólagos adott gyűjtemény által használt erőforrások mennyisége határozza meg.</span><span class="sxs-lookup"><span data-stu-id="5645c-648">The RU rate limit specifies the volume of resources that's reserved and available for exclusive use by that collection.</span></span> <span data-ttu-id="5645c-649">A gyűjtemény költségét attól függ, hogy az adott gyűjtemény kiválasztott teljesítményszint szükséges.</span><span class="sxs-lookup"><span data-stu-id="5645c-649">The cost of a collection depends on the performance level that's selected for that collection.</span></span> <span data-ttu-id="5645c-650">Minél nagyobb teljesítményt szint (és a sávszélesség-korlátjának RU) minél nagyobb a kell fizetni.</span><span class="sxs-lookup"><span data-stu-id="5645c-650">The higher the performance level (and RU rate limit) the higher the charge.</span></span> <span data-ttu-id="5645c-651">Az Azure portál használatával módosíthatja a gyűjtemény teljesítményszintjét.</span><span class="sxs-lookup"><span data-stu-id="5645c-651">You can adjust the performance level of a collection by using the Azure portal.</span></span> <span data-ttu-id="5645c-652">További információkért lásd: [Azure Cosmos DB egység kérelem][cosmos-db-ru].</span><span class="sxs-lookup"><span data-stu-id="5645c-652">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span>
>
>

<span data-ttu-id="5645c-653">Ha nincs elegendő Cosmos DB biztosít paritioning mechanizmust, esetleg shard az adatokat az alkalmazás szintjén.</span><span class="sxs-lookup"><span data-stu-id="5645c-653">If the paritioning mechanism that Cosmos DB provides is not sufficient, you may need to shard the data at the application level.</span></span> <span data-ttu-id="5645c-654">A dokumentum gyűjtemények lehetővé természetes egyetlen adatbázisban lévő adatok particionálása.</span><span class="sxs-lookup"><span data-stu-id="5645c-654">Document collections provide a natural mechanism for partitioning data within a single database.</span></span> <span data-ttu-id="5645c-655">A legegyszerűbben horizontális megvalósítása után minden shard a gyűjtemény létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="5645c-655">The simplest way to implement sharding is to create a collection for each shard.</span></span> <span data-ttu-id="5645c-656">Tárolók logikai erőforrásokat, és egy vagy több kiszolgálóra is kiterjedhetnek.</span><span class="sxs-lookup"><span data-stu-id="5645c-656">Containers are logical resources and can span one or more servers.</span></span> <span data-ttu-id="5645c-657">Rögzített méretű tárolók rendelkezik egy legfeljebb 10 GB és 10000 RU/s átviteli sebesség.</span><span class="sxs-lookup"><span data-stu-id="5645c-657">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="5645c-658">Korlátlan tárolók nem rendelkezik a sotrage maximális méretét, de kell adnia egy partíciókulcsot.</span><span class="sxs-lookup"><span data-stu-id="5645c-658">Unlimited containers do not have a maximum sotrage size, but must specify a partition key.</span></span> <span data-ttu-id="5645c-659">Az alkalmazás horizontális az ügyfélalkalmazás kell közvetlen kéréseket a megfelelő shard általában alkalmazásával segítse a saját leképezés mechanizmus az adatokat, amelyek meghatározzák a shard kulcs bizonyos attribútumai alapján.</span><span class="sxs-lookup"><span data-stu-id="5645c-659">With application sharding, the client application must direct requests to the appropriate shard, usually by implementing its own mapping mechanism based on some attributes of the data that define the shard key.</span></span> 

<span data-ttu-id="5645c-660">Összes adatbázis egy Cosmos-adatbázis adatbázis-fiók környezetében jönnek létre.</span><span class="sxs-lookup"><span data-stu-id="5645c-660">All databases are created in the context of a Cosmos DB database account.</span></span> <span data-ttu-id="5645c-661">Egy olyan fiók több adatbázisok tartalmazhat, és meghatározza azokat a területeket az adatbázisok jön létre.</span><span class="sxs-lookup"><span data-stu-id="5645c-661">A single account can contain several databases, and it specifies in which regions the databases are created.</span></span> <span data-ttu-id="5645c-662">Minden felhasználói fiókhoz is érvényesíti a saját hozzáférés-vezérlést.</span><span class="sxs-lookup"><span data-stu-id="5645c-662">Each account also enforces its own access control.</span></span> <span data-ttu-id="5645c-663">Használhatja a földrajzi Cosmos DB fiókokat-keresse meg a szilánkok (gyűjtemények adatbázisok belül) megközelíti a felhasználók, akik azok eléréséhez, és a korlátozások érvényesítése, hogy csak azokat a felhasználók kapcsolódhatnak őket.</span><span class="sxs-lookup"><span data-stu-id="5645c-663">You can use Cosmos DB accounts to geo-locate shards (collections within databases) close to the users who need to access them, and enforce restrictions so that only those users can connect to them.</span></span>

<span data-ttu-id="5645c-664">Adatok Cosmos DB SQL API-val particionálásáról meghatározásakor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="5645c-664">Consider the following points when deciding how to partition data with the Cosmos DB SQL API:</span></span>

* <span data-ttu-id="5645c-665">**A fiók sablonkérelem lépnek egy Cosmos DB adatbázis számára elérhető erőforrások**.</span><span class="sxs-lookup"><span data-stu-id="5645c-665">**The resources available to a Cosmos DB database are subject to the quota limitations of the account**.</span></span> <span data-ttu-id="5645c-666">Az egyes adatbázisok tárolására képes a gyűjtemények számos, és minden gyűjtemény egy teljesítményszint szükséges, amely szabályozza a RU sávszélesség-korlátjának (fenntartott átviteli sebességet), hogy a gyűjtemény társítva.</span><span class="sxs-lookup"><span data-stu-id="5645c-666">Each database can hold a number of collections, and each collection is associated with a performance level that governs the RU rate limit (reserved throughput) for that collection.</span></span> <span data-ttu-id="5645c-667">További információkért lásd: [Azure-előfizetés és szolgáltatási korlátok, kvóták és megkötések][azure-limits].</span><span class="sxs-lookup"><span data-stu-id="5645c-667">For more information, see [Azure subscription and service limits, quotas, and constraints][azure-limits].</span></span>
* <span data-ttu-id="5645c-668">**Ügyeljen rá, hogy a dokumentum a gyűjteményt, amelyben tárolt belül egyedi azonosítására használható egy attribútummal kell rendelkeznie,**.</span><span class="sxs-lookup"><span data-stu-id="5645c-668">**Each document must have an attribute that can be used to uniquely identify that document within the collection in which it is held**.</span></span> <span data-ttu-id="5645c-669">Ez az attribútum található a szilánkcímtárban kulcs, amely meghatározza, mely a gyűjtemény kérelemfejléceket tárol, a dokumentum eltér.</span><span class="sxs-lookup"><span data-stu-id="5645c-669">This attribute is different from the shard key, which defines which collection holds the document.</span></span> <span data-ttu-id="5645c-670">Egy gyűjtemény tartalmazhat nagyszámú dokumentumok.</span><span class="sxs-lookup"><span data-stu-id="5645c-670">A collection can contain a large number of documents.</span></span> <span data-ttu-id="5645c-671">Elméletileg azt csak korlátozza a maximális időtartamot, a dokumentum azonosítóját.</span><span class="sxs-lookup"><span data-stu-id="5645c-671">In theory, it's limited only by the maximum length of the document ID.</span></span> <span data-ttu-id="5645c-672">A dokumentum azonosító legfeljebb 255 karakterből állhat.</span><span class="sxs-lookup"><span data-stu-id="5645c-672">The document ID can be up to 255 characters.</span></span>
* <span data-ttu-id="5645c-673">**Az összes dokumentum elleni műveleteket egy tranzakció keretén belül. Tranzakciók hatóköre a gyűjteményt, amelyben a dokumentum tartalmazza.**</span><span class="sxs-lookup"><span data-stu-id="5645c-673">**All operations against a document are performed within the context of a transaction. Transactions are scoped to the collection in which the document is contained.**</span></span> <span data-ttu-id="5645c-674">Egy művelet meghiúsul, ha a munka még hajtott végre vissza lesz állítva.</span><span class="sxs-lookup"><span data-stu-id="5645c-674">If an operation fails, the work that it has performed is rolled back.</span></span> <span data-ttu-id="5645c-675">Míg egy dokumentumot egy művelet függvényében, minden egyes helyadatbázisokban végrehajtott módosításokat a pillanatkép szintű elkülönítés vonatkoznak.</span><span class="sxs-lookup"><span data-stu-id="5645c-675">While a document is subject to an operation, any changes that are made are subject to snapshot-level isolation.</span></span> <span data-ttu-id="5645c-676">Ez a módszer biztosítja azt, hogy ha például egy új dokumentum létrehozása sikertelen, akik egy időben kérdezi le az adatbázis egy másik felhasználó kérést nem jelenik meg egy részleges dokumentumot, majd eltávolítani.</span><span class="sxs-lookup"><span data-stu-id="5645c-676">This mechanism guarantees that if, for example, a request to create a new document fails, another user who's querying the database simultaneously will not see a partial document that is then removed.</span></span>
* <span data-ttu-id="5645c-677">**A gyűjtemény szintjén is hatóköre az adatbázis-lekérdezések**.</span><span class="sxs-lookup"><span data-stu-id="5645c-677">**Database queries are also scoped to the collection level**.</span></span> <span data-ttu-id="5645c-678">Egyetlen lekérdezés adatainak lekérése is csak egy gyűjtemény.</span><span class="sxs-lookup"><span data-stu-id="5645c-678">A single query can retrieve data from only one collection.</span></span> <span data-ttu-id="5645c-679">Ha adatainak lekérése több gyűjteményre van szüksége, kell egyes gyűjtemények külön-külön és -lekérdezés egyesítése az eredményeket az alkalmazás kódjában.</span><span class="sxs-lookup"><span data-stu-id="5645c-679">If you need to retrieve data from multiple collections, you must query each collection individually and merge the results in your application code.</span></span>
* <span data-ttu-id="5645c-680">**Cosmos DB programozható elemek összes tárolható egy gyűjtemény dokumentumok mellett támogatja**.</span><span class="sxs-lookup"><span data-stu-id="5645c-680">**Cosmos DB supports programmable items that can all be stored in a collection alongside documents**.</span></span> <span data-ttu-id="5645c-681">Ezek közé tartozik a tárolt eljárások, felhasználó által definiált függvények és eseményindítók (JavaScript nyelven írt).</span><span class="sxs-lookup"><span data-stu-id="5645c-681">These include stored procedures, user-defined functions, and triggers (written in JavaScript).</span></span> <span data-ttu-id="5645c-682">Ezek az elemek összes dokumentumának belül ugyanaz a gyűjtemény.</span><span class="sxs-lookup"><span data-stu-id="5645c-682">These items can access any document within the same collection.</span></span> <span data-ttu-id="5645c-683">Ezenkívül ezek az elemek futtatása (esetén egy eseményindítót, amely akkor következik be, mert eredménye egy létrehozása, törlése, vagy műveletet hajt végre a dokumentum cseréje), a környezeti tranzakció hatókörén belül, vagy (esetén tárolt eljárás új tranzakció elindítása futtatott az explicit ügyfélkérés miatt).</span><span class="sxs-lookup"><span data-stu-id="5645c-683">Furthermore, these items run either inside the scope of the ambient transaction (in the case of a trigger that fires as the result of a create, delete, or replace operation performed against a document), or by starting a new transaction (in the case of a stored procedure that is run as the result of an explicit client request).</span></span> <span data-ttu-id="5645c-684">A kód egy programozható elemben kivételt jelez, ha a tranzakció vissza lesz állítva.</span><span class="sxs-lookup"><span data-stu-id="5645c-684">If the code in a programmable item throws an exception, the transaction is rolled back.</span></span> <span data-ttu-id="5645c-685">Tárolt eljárások és eseményindítók használhatja az integritásra és a dokumentumok között konzisztencia fenntartása, de ezeket a dokumentumokat ugyanaz a gyűjtemény részének kell lennie.</span><span class="sxs-lookup"><span data-stu-id="5645c-685">You can use stored procedures and triggers to maintain integrity and consistency between documents, but these documents must all be part of the same collection.</span></span>
* <span data-ttu-id="5645c-686">**A gyűjtemények, melyet a adatbázisokban tárolásához valószínűleg nem haladja meg a teljesítményszintet gyűjtemények által megadott átviteli sebességének korlátai kell**.</span><span class="sxs-lookup"><span data-stu-id="5645c-686">**The collections that you intend to hold in the databases should be unlikely to exceed the throughput limits defined by the performance levels of the collections**.</span></span> <span data-ttu-id="5645c-687">További információkért lásd: [Azure Cosmos DB egység kérelem][cosmos-db-ru].</span><span class="sxs-lookup"><span data-stu-id="5645c-687">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span> <span data-ttu-id="5645c-688">Ha várhatóan a működés felső korlátjának elérése, fontolja meg a gyűjtemények gyűjteményenként a terhelés csökkentése érdekében különböző fiókok az adatbázisok közötti felosztásával.</span><span class="sxs-lookup"><span data-stu-id="5645c-688">If you anticipate reaching these limits, consider splitting collections across databases in different accounts to reduce the load per collection.</span></span>

## <a name="partitioning-strategies-for-azure-search"></a><span data-ttu-id="5645c-689">Az Azure Search particionálási stratégia</span><span class="sxs-lookup"><span data-stu-id="5645c-689">Partitioning strategies for Azure Search</span></span>
<span data-ttu-id="5645c-690">Adatok keresése a gyakran és sok webes alkalmazások által biztosított feltárása az elsődleges módszer.</span><span class="sxs-lookup"><span data-stu-id="5645c-690">The ability to search for data is often the primary method of navigation and exploration that's provided by many web applications.</span></span> <span data-ttu-id="5645c-691">Ennek segítségével a felhasználók, erőforrások gyorsan (például az e-kereskedelmi alkalmazás-termékek) kombinációit keresési feltételek alapján található.</span><span class="sxs-lookup"><span data-stu-id="5645c-691">It helps users find resources quickly (for example, products in an e-commerce application) based on combinations of search criteria.</span></span> <span data-ttu-id="5645c-692">Az Azure Search szolgáltatás teljes szöveges keresési lehetőségeket biztosítanak a webes tartalom, és a szolgáltatások, mint a találatok és a jellemzőalapú navigáció közelében alapuló begépelt, javasolt lekérdezések tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="5645c-692">The Azure Search service provides full-text search capabilities over web content, and includes features such as type-ahead, suggested queries based on near matches, and faceted navigation.</span></span> <span data-ttu-id="5645c-693">Ezek a képességek teljes leírását az oldalon érhető el [Azure Search újdonságai?] a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="5645c-693">A full description of these capabilities is available on the page [What is Azure Search?] on the Microsoft website.</span></span>

<span data-ttu-id="5645c-694">Az Azure Search kereshető tartalom adatbázis a JSON-dokumentumokként tárolja.</span><span class="sxs-lookup"><span data-stu-id="5645c-694">Azure Search stores searchable content as JSON documents in a database.</span></span> <span data-ttu-id="5645c-695">Megadhatja, hogy a kereshető mezők meg ezeket a dokumentumokat és e definíciókat meg az Azure Search index.</span><span class="sxs-lookup"><span data-stu-id="5645c-695">You define indexes that specify the searchable fields in these documents and provide these definitions to Azure Search.</span></span> <span data-ttu-id="5645c-696">Ha a keresési kérelem elküldése, Azure Search használja a megfelelő indexek egyező elemek.</span><span class="sxs-lookup"><span data-stu-id="5645c-696">When a user submits a search request, Azure Search uses the appropriate indexes to find matching items.</span></span>

<span data-ttu-id="5645c-697">A versengés csökkentése érdekében az Azure Search által használt tárolási 1, 2, 3, 4, 6 vagy 12 partíciók oszthatók, és mindegyik partíció legfeljebb 6 alkalommal replikálható.</span><span class="sxs-lookup"><span data-stu-id="5645c-697">To reduce contention, the storage that's used by Azure Search can be divided into 1, 2, 3, 4, 6, or 12 partitions, and each partition can be replicated up to 6 times.</span></span> <span data-ttu-id="5645c-698">A replikák számának szorzata partíciók számának a termék neve a *keresési egység* (SU).</span><span class="sxs-lookup"><span data-stu-id="5645c-698">The product of the number of partitions multiplied by the number of replicas is called the *search unit* (SU).</span></span> <span data-ttu-id="5645c-699">Azure Search egyetlen példányát maximum 36 SUS-t (12 partíciókkal rendelkező adatbázis csak legfeljebb 3 replikák) tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="5645c-699">A single instance of Azure Search can contain a maximum of 36 SUs (a database with 12 partitions only supports a maximum of 3 replicas).</span></span>

<span data-ttu-id="5645c-700">A szolgáltatás az összes lefoglalt SU számlázása.</span><span class="sxs-lookup"><span data-stu-id="5645c-700">You are billed for each SU that is allocated to your service.</span></span> <span data-ttu-id="5645c-701">Növekedésével a kötet kereshető tartalom nő vagy keresési kérelmek számát, SUS-t is hozzáadhat az Azure Search a megnövekedett terhelés kezelésére egy meglévő példányát.</span><span class="sxs-lookup"><span data-stu-id="5645c-701">As the volume of searchable content increases or the rate of search requests grows, you can add SUs to an existing instance of Azure Search to handle the extra load.</span></span> <span data-ttu-id="5645c-702">Az Azure Search magát a dokumentumok egyenletesen elosztja a partíciók.</span><span class="sxs-lookup"><span data-stu-id="5645c-702">Azure Search itself distributes the documents evenly across the partitions.</span></span> <span data-ttu-id="5645c-703">Nincs manuális particionálási stratégia jelenleg támogatott.</span><span class="sxs-lookup"><span data-stu-id="5645c-703">No manual partitioning strategies are currently supported.</span></span>

<span data-ttu-id="5645c-704">Mindegyik partíció tartalmazhatnak legfeljebb 15 millió dokumentumnál vagy 300 GB tárterületet (amelyik érték kisebb) foglalnak.</span><span class="sxs-lookup"><span data-stu-id="5645c-704">Each partition can contain a maximum of 15 million documents or occupy 300 GB of storage space (whichever is smaller).</span></span> <span data-ttu-id="5645c-705">Legfeljebb 50 indexek hozhat létre.</span><span class="sxs-lookup"><span data-stu-id="5645c-705">You can create up to 50 indexes.</span></span> <span data-ttu-id="5645c-706">A szolgáltatás teljesítményének változik, és a dokumentumok, a rendelkezésre álló indexek és a hálózati késés hatásait bonyolultságától függ.</span><span class="sxs-lookup"><span data-stu-id="5645c-706">The performance of the service varies and depends on the complexity of the documents, the available indexes, and the effects of network latency.</span></span> <span data-ttu-id="5645c-707">Átlagosan egy replikához (1 SU) kell tudni kezelni 15 lekérdezések / másodperc (QPS), bár javasolt végrehajtását átviteli pontosabb mérték beszerzése a saját adataival teljesítménymérésre.</span><span class="sxs-lookup"><span data-stu-id="5645c-707">On average, a single replica (1 SU) should be able to handle 15 queries per second (QPS), although we recommend performing benchmarking with your own data to obtain a more precise measure of throughput.</span></span> <span data-ttu-id="5645c-708">További információkért lásd: a lap [szolgáltatási korlátait, az Azure Search] a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="5645c-708">For more information, see the page [Service limits in Azure Search] on the Microsoft website.</span></span>

> [!NOTE]
> <span data-ttu-id="5645c-709">Adattípusok korlátozott számú kereshető dokumentumok, karakterláncok, a logikai, numerikus, dátum és idő data, és egyes földrajzi adatokat tárolhatja.</span><span class="sxs-lookup"><span data-stu-id="5645c-709">You can store a limited set of data types in searchable documents, including strings, Booleans, numeric data, datetime data, and some geographical data.</span></span> <span data-ttu-id="5645c-710">További részletekért lásd: a lap [a támogatott adattípusokat (Azure Search)] a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="5645c-710">For more details, see the page [Supported data types (Azure Search)] on the Microsoft website.</span></span>
>
>

<span data-ttu-id="5645c-711">Korlátozott számú szabályozhatják, hogyan Azure Search particionálja a szolgáltatás minden példányának adatait.</span><span class="sxs-lookup"><span data-stu-id="5645c-711">You have limited control over how Azure Search partitions data for each instance of the service.</span></span> <span data-ttu-id="5645c-712">Azonban a globális környezetben valószínűleg jobb teljesítmény és csökkenteni a késleltetés és a további versengés particionálás a szolgáltatás a következő stratégiák egyikét követve:</span><span class="sxs-lookup"><span data-stu-id="5645c-712">However, in a global environment you might be able to improve performance and reduce latency and contention further by partitioning the service itself using either of the following strategies:</span></span>

* <span data-ttu-id="5645c-713">Hozzon létre egy Azure Search példányát minden egyes földrajzi régióban, és győződjön meg arról, hogy az ügyfélalkalmazások irányul a legközelebbi elérhető példányhoz.</span><span class="sxs-lookup"><span data-stu-id="5645c-713">Create an instance of Azure Search in each geographic region, and ensure that client applications are directed towards the nearest available instance.</span></span> <span data-ttu-id="5645c-714">Ezt a stratégiát szükséges kereshető tartalom frissítéseit időben replikálódnak a szolgáltatás minden példányának.</span><span class="sxs-lookup"><span data-stu-id="5645c-714">This strategy requires that any updates to searchable content are replicated in a timely manner across all instances of the service.</span></span>
* <span data-ttu-id="5645c-715">Hozzon létre két rétegből álló Azure Search:</span><span class="sxs-lookup"><span data-stu-id="5645c-715">Create two tiers of Azure Search:</span></span>

  * <span data-ttu-id="5645c-716">Minden egyes régió, amely tartalmazza az adatokat, amelyek a leggyakrabban az adott régióban felhasználók férhetnek hozzá a helyi szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="5645c-716">A local service in each region that contains the data that's most frequently accessed by users in that region.</span></span> <span data-ttu-id="5645c-717">Felhasználók is közvetlen kérelmeket Itt a gyors, de korlátozott eredmények elérése érdekében.</span><span class="sxs-lookup"><span data-stu-id="5645c-717">Users can direct requests here for fast but limited results.</span></span>
  * <span data-ttu-id="5645c-718">A globális szolgáltatás, amely magában foglalja az összes adatot.</span><span class="sxs-lookup"><span data-stu-id="5645c-718">A global service that encompasses all the data.</span></span> <span data-ttu-id="5645c-719">Felhasználók utasíthatja a lassabb, de több teljes eredmény itt kérelmek.</span><span class="sxs-lookup"><span data-stu-id="5645c-719">Users can direct requests here for slower but more complete results.</span></span>

<span data-ttu-id="5645c-720">Ezt a módszert akkor legmegfelelőbb, ha az adatokat, amelyben keres regionális jelentős eltérés van.</span><span class="sxs-lookup"><span data-stu-id="5645c-720">This approach is most suitable when there is a significant regional variation in the data that's being searched.</span></span>

## <a name="partitioning-strategies-for-azure-redis-cache"></a><span data-ttu-id="5645c-721">Az Azure Redis Cache particionálási stratégia</span><span class="sxs-lookup"><span data-stu-id="5645c-721">Partitioning strategies for Azure Redis Cache</span></span>
<span data-ttu-id="5645c-722">Azure Redis Cache a felhőben, amelyek a Redis-kulcs-érték tároló alapján egy megosztott gyorsítótárazási szolgáltatást biztosít.</span><span class="sxs-lookup"><span data-stu-id="5645c-722">Azure Redis Cache provides a shared caching service in the cloud that's based on the Redis key-value data store.</span></span> <span data-ttu-id="5645c-723">Mivel a név azt jelenti, Azure Redis Cache szándék szerint gyorsítótárazási megoldását.</span><span class="sxs-lookup"><span data-stu-id="5645c-723">As its name implies, Azure Redis Cache is intended as a caching solution.</span></span> <span data-ttu-id="5645c-724">Használja azt, csak az átmeneti adatokat, és nem állandó adattárat.</span><span class="sxs-lookup"><span data-stu-id="5645c-724">Use it only for holding transient data and not as a permanent data store.</span></span> <span data-ttu-id="5645c-725">Alkalmazások, amelyek ténylegesen használják az Azure Redis Cache tudják is működjenek, ha a gyorsítótár nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="5645c-725">Applications that utilize Azure Redis Cache should be able to continue functioning if the cache is unavailable.</span></span> <span data-ttu-id="5645c-726">Azure Redis Cache elsődleges és másodlagos támogatja magas rendelkezésre állás biztosításához, de jelenleg korlátozza az 53 GB a gyorsítótár maximális méretét.</span><span class="sxs-lookup"><span data-stu-id="5645c-726">Azure Redis Cache supports primary/secondary replication to provide high availability, but currently limits the maximum cache size to 53 GB.</span></span> <span data-ttu-id="5645c-727">Ha ennél több helyre van szüksége, létre kell hoznia további gyorsítótárak.</span><span class="sxs-lookup"><span data-stu-id="5645c-727">If you need more space than this, you must create additional caches.</span></span> <span data-ttu-id="5645c-728">További információkért lépjen a lapra [Azure Redis Cache] a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="5645c-728">For more information, go to the page [Azure Redis Cache] on the Microsoft website.</span></span>

<span data-ttu-id="5645c-729">A Redis-tárolóban particionálás magában foglalja az adatok felosztása a Redis szolgáltatás példánya között.</span><span class="sxs-lookup"><span data-stu-id="5645c-729">Partitioning a Redis data store involves splitting the data across instances of the Redis service.</span></span> <span data-ttu-id="5645c-730">Minden példány egyetlen partícióra számít.</span><span class="sxs-lookup"><span data-stu-id="5645c-730">Each instance constitutes a single partition.</span></span> <span data-ttu-id="5645c-731">Azure Redis Cache kivonatolja a Redis-szolgáltatások egy homlokzati mögött, és nem teszi közzé őket közvetlenül.</span><span class="sxs-lookup"><span data-stu-id="5645c-731">Azure Redis Cache abstracts the Redis services behind a façade and does not expose them directly.</span></span> <span data-ttu-id="5645c-732">A legegyszerűbben úgy particionálás végrehajtására több Azure Redis Cache példány létrehozásához, és az adatok elosztva.</span><span class="sxs-lookup"><span data-stu-id="5645c-732">The simplest way to implement partitioning is to create multiple Azure Redis Cache instances and spread the data across them.</span></span>

<span data-ttu-id="5645c-733">Egy azonosító (a partíciós kulcs), amely meghatározza, hogy melyik gyorsítótár tárolja az elem minden adatelemet társíthatja.</span><span class="sxs-lookup"><span data-stu-id="5645c-733">You can associate each data item with an identifier (a partition key) that specifies which cache stores the data item.</span></span> <span data-ttu-id="5645c-734">Az ügyfél úgy az alkalmazáslogikát ezután használhatja ezt az azonosítót kérelmek átirányítása a megfelelő partíció.</span><span class="sxs-lookup"><span data-stu-id="5645c-734">The client application logic can then use this identifier to route requests to the appropriate partition.</span></span> <span data-ttu-id="5645c-735">Ez a séma nagyon egyszerű, de a particionálási sémát változik (például, ha több Azure Redis Cache példányt jönnek létre), ha ügyfélalkalmazások módosítania kell újra kell konfigurálni.</span><span class="sxs-lookup"><span data-stu-id="5645c-735">This scheme is very simple, but if the partitioning scheme changes (for example, if additional Azure Redis Cache instances are created), client applications might need to be reconfigured.</span></span>

<span data-ttu-id="5645c-736">Natív Redis (Azure Redis Cache nem) támogatja a kiszolgálóoldali particionálás Redis fürtszolgáltatás alapján.</span><span class="sxs-lookup"><span data-stu-id="5645c-736">Native Redis (not Azure Redis Cache) supports server-side partitioning based on Redis clustering.</span></span> <span data-ttu-id="5645c-737">Ez a megközelítés a oszthatja az adatokat egyenletesen kiszolgáló között kivonatoló mechanizmus használatával.</span><span class="sxs-lookup"><span data-stu-id="5645c-737">In this approach, you can divide the data evenly across servers by using a hashing mechanism.</span></span> <span data-ttu-id="5645c-738">Minden egyes Redis-kiszolgáló tárolja a tartomány, amely tárolja a partíció, kivonatoló kulcsok leíró metaadatok és mely kivonatoló kapcsolatos kulcsok más kiszolgálókon a partíciók található információkat is tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="5645c-738">Each Redis server stores metadata that describes the range of hash keys that the partition holds, and also contains information about which hash keys are located in the partitions on other servers.</span></span>

<span data-ttu-id="5645c-739">Ügyfél-alkalmazások egyszerűen kérelmet küldeni a programban részt vevő Redis-kiszolgáló (valószínűleg a legközelebbi egy).</span><span class="sxs-lookup"><span data-stu-id="5645c-739">Client applications simply send requests to any of the participating Redis servers (probably the closest one).</span></span> <span data-ttu-id="5645c-740">A Redis-kiszolgáló megvizsgálja az ügyfélkérés.</span><span class="sxs-lookup"><span data-stu-id="5645c-740">The Redis server examines the client request.</span></span> <span data-ttu-id="5645c-741">Ha helyileg feloldható, a kért műveletet hajt végre.</span><span class="sxs-lookup"><span data-stu-id="5645c-741">If it can be resolved locally, it performs the requested operation.</span></span> <span data-ttu-id="5645c-742">Ellenkező esetben továbbítja, a kérelem továbbítása az a megfelelő kiszolgálót.</span><span class="sxs-lookup"><span data-stu-id="5645c-742">Otherwise it forwards the request on to the appropriate server.</span></span>

<span data-ttu-id="5645c-743">Ez a modell Redis Fürtszolgáltatás segítségével történik, és további részletes leírását lásd a a [Redis-fürt oktatóanyag] lap a Redis-webhelyen.</span><span class="sxs-lookup"><span data-stu-id="5645c-743">This model is implemented by using Redis clustering, and is described in more detail on the [Redis cluster tutorial] page on the Redis website.</span></span> <span data-ttu-id="5645c-744">A redis-fürtszolgáltatás az ügyfélalkalmazások számára transzparens.</span><span class="sxs-lookup"><span data-stu-id="5645c-744">Redis clustering is transparent to client applications.</span></span> <span data-ttu-id="5645c-745">További Redis-kiszolgálók adhatók hozzá a fürtöt (és az adatok újra lehet particionálni) anélkül, hogy be újra az ügyfeleket.</span><span class="sxs-lookup"><span data-stu-id="5645c-745">Additional Redis servers can be added to the cluster (and the data can be re-partitioned) without requiring that you reconfigure the clients.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="5645c-746">Azure Redis Cache jelenleg nem támogatja a Redis-fürtszolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="5645c-746">Azure Redis Cache does not currently support Redis clustering.</span></span> <span data-ttu-id="5645c-747">Ha szeretné végrehajtani ezt a módszert, az Azure-ral, majd meg kell valósítani a saját Redis kiszolgálók Redis telepítése Azure virtuális gépek egy csoportján és konfigurálásuk manuálisan.</span><span class="sxs-lookup"><span data-stu-id="5645c-747">If you want to implement this approach with Azure, then you must implement your own Redis servers by installing Redis on a set of Azure virtual machines and configuring them manually.</span></span> <span data-ttu-id="5645c-748">A lap [a CentOS Linux virtuális gép az Azure-ban futó Redis] a Microsoft webhelyén végigvezeti egy példa, amely azt ismerteti, hogyan hozza létre és konfigurálja az Azure virtuális gépként futó Redis csomópont.</span><span class="sxs-lookup"><span data-stu-id="5645c-748">The page [Running Redis on a CentOS Linux VM in Azure] on the Microsoft website walks through an example that shows you how to build and configure a Redis node running as an Azure VM.</span></span>
>
>

<span data-ttu-id="5645c-749">A lap [particionálására: hogyan adatok több Redis-példány között] a Redis webhelyet biztosít a redis gyorsítótárral particionálás alkalmazásával kapcsolatos további információkat.</span><span class="sxs-lookup"><span data-stu-id="5645c-749">The page [Partitioning: how to split data among multiple Redis instances] on the Redis website provides more information about implementing partitioning with Redis.</span></span> <span data-ttu-id="5645c-750">Ez a szakasz többi feltételezi, hogy az ügyféloldali vagy a proxy támogatású particionálás webkiszolgálókból.</span><span class="sxs-lookup"><span data-stu-id="5645c-750">The remainder of this section assumes that you are implementing client-side or proxy-assisted partitioning.</span></span>

<span data-ttu-id="5645c-751">Azure Redis Cache adatok particionálása módjának, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="5645c-751">Consider the following points when deciding how to partition data with Azure Redis Cache:</span></span>

* <span data-ttu-id="5645c-752">Azure Redis Cache nem célja, hogy működjön, és a végleges tárolóban, ezért bármilyen particionálási sémát alkalmazza, az alkalmazás kódjában képesnek kell lennie lekérdezni az adatok egy helyre a rendszer a gyorsítótárban.</span><span class="sxs-lookup"><span data-stu-id="5645c-752">Azure Redis Cache is not intended to act as a permanent data store, so whatever partitioning scheme you implement, your application code must be able to retrieve data from a location that's not the cache.</span></span>
* <span data-ttu-id="5645c-753">Együtt a gyakran használt adatok ugyanazon partíció kell tartani.</span><span class="sxs-lookup"><span data-stu-id="5645c-753">Data that is frequently accessed together should be kept in the same partition.</span></span> <span data-ttu-id="5645c-754">A redis egy hatékony kulcs-érték tároló, amely több magas szinten optimalizált mechanizmusok adatok rendszerezésére szolgál.</span><span class="sxs-lookup"><span data-stu-id="5645c-754">Redis is a powerful key-value store that provides several highly optimized mechanisms for structuring data.</span></span> <span data-ttu-id="5645c-755">Ezek a mechanizmusok az alábbiak egyike lehet:</span><span class="sxs-lookup"><span data-stu-id="5645c-755">These mechanisms can be one of the following:</span></span>

  * <span data-ttu-id="5645c-756">Egyszerű karakterláncok (bináris adatok hossza legfeljebb 512 MB)</span><span class="sxs-lookup"><span data-stu-id="5645c-756">Simple strings (binary data up to 512 MB in length)</span></span>
  * <span data-ttu-id="5645c-757">Összesített típuson például listák (amely működhet várólisták és a verem)</span><span class="sxs-lookup"><span data-stu-id="5645c-757">Aggregate types such as lists (which can act as queues and stacks)</span></span>
  * <span data-ttu-id="5645c-758">Beállítja a (rendezett és rendezetlen)</span><span class="sxs-lookup"><span data-stu-id="5645c-758">Sets (ordered and unordered)</span></span>
  * <span data-ttu-id="5645c-759">A kivonatok (amely is kapcsolódó mezők egy csoportba, például a elemek, amelyek megfelelnek a mezők objektum)</span><span class="sxs-lookup"><span data-stu-id="5645c-759">Hashes (which can group related fields together, such as the items that represent the fields in an object)</span></span>
* <span data-ttu-id="5645c-760">Az összesített típusok lehetővé teszik a ugyanazzal a kulccsal sok kapcsolódó értéket hozzárendelni.</span><span class="sxs-lookup"><span data-stu-id="5645c-760">The aggregate types enable you to associate many related values with the same key.</span></span> <span data-ttu-id="5645c-761">Egy Redis-key listáját, be van állítva, vagy kivonatoló helyett a benne tárolt adatelemek azonosítja.</span><span class="sxs-lookup"><span data-stu-id="5645c-761">A Redis key identifies a list, set, or hash rather than the data items that it contains.</span></span> <span data-ttu-id="5645c-762">Ezek a típusok Azure Redis Cache segítségével elérhetők, és ismerteti a által a [adattípusok] lap a Redis-webhelyen.</span><span class="sxs-lookup"><span data-stu-id="5645c-762">These types are all available with Azure Redis Cache and are described by the [Data types] page on the Redis website.</span></span> <span data-ttu-id="5645c-763">Például részben az elektronikus kereskedelmi rendszer, amely nyomon követi az ügyfelek általi rendeléseket, mindegyik ügyfél részletes adatait tárolhatja a Redis-kivonat, amely a felhasználói azonosítóját. a kulccsal van</span><span class="sxs-lookup"><span data-stu-id="5645c-763">For example, in part of an e-commerce system that tracks the orders that are placed by customers, the details of each customer can be stored in a Redis hash that is keyed by using the customer ID.</span></span> <span data-ttu-id="5645c-764">Minden Kivonatoló azonosítók rendelés gyűjteménye tárolható az ügyfél.</span><span class="sxs-lookup"><span data-stu-id="5645c-764">Each hash can hold a collection of order IDs for the customer.</span></span> <span data-ttu-id="5645c-765">Egy külön Redis-készlet tárolására képes újra, a kivonatok strukturált, és az azonosító. a kulccsal definiált rendelések</span><span class="sxs-lookup"><span data-stu-id="5645c-765">A separate Redis set can hold the orders, again structured as hashes, and keyed by using the order ID.</span></span> <span data-ttu-id="5645c-766">8. ábrán látható, ez a struktúra.</span><span class="sxs-lookup"><span data-stu-id="5645c-766">Figure 8 shows this structure.</span></span> <span data-ttu-id="5645c-767">Vegye figyelembe, hogy Redis nem valósítja meg a hivatkozási integritás bármilyen, a fejlesztő felelőssége, hogy az ügyfelek és a rendeléseket kapcsolatának fenntartásához.</span><span class="sxs-lookup"><span data-stu-id="5645c-767">Note that Redis does not implement any form of referential integrity, so it is the developer's responsibility to maintain the relationships between customers and orders.</span></span>

![A Redis-tároló megrendelések és azok adatai rögzítése javasolt struktúra](./images/data-partitioning/RedisCustomersandOrders.png)

<span data-ttu-id="5645c-769">*8. ábra. A Redis-tároló megrendelések és azok adatai rögzítése javasolt struktúra*</span><span class="sxs-lookup"><span data-stu-id="5645c-769">*Figure 8. Suggested structure in Redis storage for recording customer orders and their details*</span></span>

> [!NOTE]
> <span data-ttu-id="5645c-770">A Redis minden kulcs bináris adatok értékek (például a Redis-karakterláncok), és legfeljebb 512 MB adatokat is tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="5645c-770">In Redis, all keys are binary data values (like Redis strings) and can contain up to 512 MB of data.</span></span> <span data-ttu-id="5645c-771">Elméletileg kulcs szinte bármilyen információkat is tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="5645c-771">In theory, a key can contain almost any information.</span></span> <span data-ttu-id="5645c-772">Azt javasoljuk azonban bevezetése egységes elnevezési kulcsok leíró, milyen típusú adatok, amelyek, amely azonosítja az entitást, de nem túl hosszú.</span><span class="sxs-lookup"><span data-stu-id="5645c-772">However, we recommend adopting a consistent naming convention for keys that is descriptive of the type of data and that identifies the entity, but is not excessively long.</span></span> <span data-ttu-id="5645c-773">Általános gyakorlatként javasolt, hogy az űrlap "entity_type:ID" kulcsok használja.</span><span class="sxs-lookup"><span data-stu-id="5645c-773">A common approach is to use keys of the form "entity_type:ID".</span></span> <span data-ttu-id="5645c-774">Például az "felhasználói: 99" segítségével jelzik az azonosító 99 az ügyfél a kulcsot.</span><span class="sxs-lookup"><span data-stu-id="5645c-774">For example, you can use "customer:99" to indicate the key for a customer with the ID 99.</span></span>
>
>

* <span data-ttu-id="5645c-775">A vertikális particionálás kapcsolódó információk tárolása különböző összesítések egy adatbázisban is létrehozható.</span><span class="sxs-lookup"><span data-stu-id="5645c-775">You can implement vertical partitioning by storing related information in different aggregations in the same database.</span></span> <span data-ttu-id="5645c-776">Például egy e-kereskedelmi alkalmazás tárolhatja termékek egy Redis-kivonatot, és kevesebb mint egy másik gyakran használt részletes információk általánosan használt információ.</span><span class="sxs-lookup"><span data-stu-id="5645c-776">For example, in an e-commerce application, you can store commonly accessed information about products in one Redis hash and less frequently used detailed information in another.</span></span>
  <span data-ttu-id="5645c-777">Mindkét kivonatokat a azonos termékazonosító használható a kulcs részét.</span><span class="sxs-lookup"><span data-stu-id="5645c-777">Both hashes can use the same product ID as part of the key.</span></span> <span data-ttu-id="5645c-778">Használhat például "termék:  *nn* " (ahol  *nn*  termék azonosítója) az információkat és "product_details:  *nn*  "a részletes adatokat.</span><span class="sxs-lookup"><span data-stu-id="5645c-778">For example, you can use "product: *nn*" (where *nn* is the product ID) for the product information and "product_details: *nn*" for the detailed data.</span></span> <span data-ttu-id="5645c-779">Ezt a stratégiát, amely a legtöbb lekérdezésnél valószínűleg beolvasása adatok mennyisége csökkenthető.</span><span class="sxs-lookup"><span data-stu-id="5645c-779">This strategy can help reduce the volume of data that most queries are likely to retrieve.</span></span>
* <span data-ttu-id="5645c-780">Egy Redis adatok tárolására, de vegye figyelembe, hogy a rendszer egy összetett és időigényes feladat particionálhatja.</span><span class="sxs-lookup"><span data-stu-id="5645c-780">You can repartition a Redis data store, but keep in mind that it's a complex and time-consuming task.</span></span> <span data-ttu-id="5645c-781">A redis-fürtszolgáltatás automatikusan adatok particionálhatja, de ez a funkció nem érhető el az Azure Redis Cache.</span><span class="sxs-lookup"><span data-stu-id="5645c-781">Redis clustering can repartition data automatically, but this capability is not available with Azure Redis Cache.</span></span> <span data-ttu-id="5645c-782">Ezért amikor a particionálási sémát, próbálja hagyjon elegendő szabad hely a partíciókat úgy, hogy lehetővé teszik a várt adatnál növekedési adott idő alatt.</span><span class="sxs-lookup"><span data-stu-id="5645c-782">Therefore, when you design your partitioning scheme, try to leave sufficient free space in each partition to allow for expected data growth over time.</span></span> <span data-ttu-id="5645c-783">Ne feledje azonban, hogy Azure Redis Cache célja, hogy adatok gyorsítótárazása ideiglenesen, illetve, hogy a gyorsítótárban tárolt adatok, hogy egy korlátozott élettartamáról, megadott idő-live (TTL) értéket.</span><span class="sxs-lookup"><span data-stu-id="5645c-783">However, remember that Azure Redis Cache is intended to cache data temporarily, and that data held in the cache can have a limited lifetime specified as a time-to-live (TTL) value.</span></span> <span data-ttu-id="5645c-784">Viszonylag "volatile" adatok lehet, hogy az élettartam rövid, de a statikus adatok az élettartam sokkal hosszabb lehet.</span><span class="sxs-lookup"><span data-stu-id="5645c-784">For relatively volatile data, the TTL can be short, but for static data the TTL can be a lot longer.</span></span> <span data-ttu-id="5645c-785">Kerülje a nagy mennyiségű hosszú élettartamú adatok tárolása a gyorsítótár, ha ezek az adatok mennyisége várhatóan töltse ki a gyorsítótárból.</span><span class="sxs-lookup"><span data-stu-id="5645c-785">Avoid storing large amounts of long-lived data in the cache if the volume of this data is likely to fill the cache.</span></span> <span data-ttu-id="5645c-786">Megadhat egy kiürítés szabályzattal, amely eltávolítja az adatokat, ha a hely jelenleg egy prémium szintű Azure Redis Cache okoz.</span><span class="sxs-lookup"><span data-stu-id="5645c-786">You can specify an eviction policy that causes Azure Redis Cache to remove data if space is at a premium.</span></span>

  > [!NOTE]
  > <span data-ttu-id="5645c-787">Azure Redis Cache-gyorsítótár használata esetén az a megfelelő árképzési szint kiválasztásával adja meg (az 53 GB 250 MB) a gyorsítótár maximális méretét.</span><span class="sxs-lookup"><span data-stu-id="5645c-787">When you use Azure Redis cache, you specify the maximum size of the cache (from 250 MB to 53 GB) by selecting the appropriate pricing tier.</span></span> <span data-ttu-id="5645c-788">Azonban az Azure Redis Cache-gyorsítótár létrehozása után nem növelése (vagy csökkentése) mérete.</span><span class="sxs-lookup"><span data-stu-id="5645c-788">However, after an Azure Redis Cache has been created, you cannot increase (or decrease) its size.</span></span>
  >
  >
* <span data-ttu-id="5645c-789">Redis kötegek és a tranzakciók nem terjedhetnek ki több kapcsolatot, a köteg vagy a tranzakció által érintett összes adatot kell maradnia ugyanabban az adatbázisban (szilánkok) így.</span><span class="sxs-lookup"><span data-stu-id="5645c-789">Redis batches and transactions cannot span multiple connections, so all data that is affected by a batch or transaction should be held in the same database (shard).</span></span>

  > [!NOTE]
  > <span data-ttu-id="5645c-790">A Redis-tranzakció műveletei sorozatát nincs feltétlenül atomi.</span><span class="sxs-lookup"><span data-stu-id="5645c-790">A sequence of operations in a Redis transaction is not necessarily atomic.</span></span> <span data-ttu-id="5645c-791">A tranzakció alkotó parancsok ellenőrzése és a sorba állított még futtatása előtt.</span><span class="sxs-lookup"><span data-stu-id="5645c-791">The commands that compose a transaction are verified and queued before they run.</span></span> <span data-ttu-id="5645c-792">Ha a hiba akkor fordul elő, ebben a fázisban, a rendszer törli a teljes sor.</span><span class="sxs-lookup"><span data-stu-id="5645c-792">If an error occurs during this phase, the entire queue is discarded.</span></span> <span data-ttu-id="5645c-793">Azonban után a tranzakció küldése sikeres volt, a várólistán lévő parancsokat futtassa sorrendben.</span><span class="sxs-lookup"><span data-stu-id="5645c-793">However, after the transaction has been successfully submitted, the queued commands run in sequence.</span></span> <span data-ttu-id="5645c-794">Ha a parancs sikertelen, a parancsnak csak leáll.</span><span class="sxs-lookup"><span data-stu-id="5645c-794">If any command fails, only that command stops running.</span></span> <span data-ttu-id="5645c-795">A várólistában lévő összes előző és a következő parancsok megy végbe.</span><span class="sxs-lookup"><span data-stu-id="5645c-795">All previous and subsequent commands in the queue are performed.</span></span> <span data-ttu-id="5645c-796">További információkért látogasson el a [tranzakciók] lap a Redis-webhelyen.</span><span class="sxs-lookup"><span data-stu-id="5645c-796">For more information, go to the [Transactions] page on the Redis website.</span></span>
  >
  >
* <span data-ttu-id="5645c-797">A redis támogatja egy atomi műveletek száma korlátozott.</span><span class="sxs-lookup"><span data-stu-id="5645c-797">Redis supports a limited number of atomic operations.</span></span> <span data-ttu-id="5645c-798">Csak ilyen típusú, amely támogatja a több kulcsok és értékek olyan MGET és MSET műveleteket.</span><span class="sxs-lookup"><span data-stu-id="5645c-798">The only operations of this type that support multiple keys and values are MGET and MSET operations.</span></span> <span data-ttu-id="5645c-799">Kell visszaadnia MGET műveletek a megadott listán szereplő kulcsokra értékeit, és MSET műveletek kulcsok megadott listája értékek gyűjteménye tárolja.</span><span class="sxs-lookup"><span data-stu-id="5645c-799">MGET operations return a collection of values for a specified list of keys, and MSET operations store a collection of values for a specified list of keys.</span></span> <span data-ttu-id="5645c-800">Ha szeretné használni ezeket a műveleteket, a MSET és MGET parancsok által hivatkozott kulcs-érték párok belül az azonos adatbázist kell tárolni.</span><span class="sxs-lookup"><span data-stu-id="5645c-800">If you need to use these operations, the key-value pairs that are referenced by the MSET and MGET commands must be stored within the same database.</span></span>

## <a name="partitioning-strategies-for-azure-service-fabric"></a><span data-ttu-id="5645c-801">Az Azure Service Fabric particionálási stratégia</span><span class="sxs-lookup"><span data-stu-id="5645c-801">Partitioning Strategies for Azure Service Fabric</span></span>
<span data-ttu-id="5645c-802">Az Azure Service Fabric egy mikroszolgáltatások platform, amely egy futásidejű biztosít elosztott alkalmazások számára a felhőben.</span><span class="sxs-lookup"><span data-stu-id="5645c-802">Azure Service Fabric is a microservices platform that provides a runtime for distributed applications in the cloud.</span></span> <span data-ttu-id="5645c-803">A Service Fabric támogatja a .net Vendég végrehajtható fájlok, az állapot nélküli és állapotalapú alkalmazások és szolgáltatások és tárolók.</span><span class="sxs-lookup"><span data-stu-id="5645c-803">Service Fabric supports .Net guest executables, stateful and stateless services, and containers.</span></span> <span data-ttu-id="5645c-804">Állapotalapú szolgáltatások biztosítják a [megbízható gyűjtemény] [ service-fabric-reliable-collections] tartósan adatok egy kulcs-érték gyűjtemény belül a Service Fabric-fürt tárolására.</span><span class="sxs-lookup"><span data-stu-id="5645c-804">Stateful services provide a [reliable collection][service-fabric-reliable-collections] to persistently store data in a key-value collection within the Service Fabric cluster.</span></span> <span data-ttu-id="5645c-805">Egy megbízható gyűjtemény partioning kulcsok kapcsolatos olyan stratégiák kapcsolatos további információkért lásd: [irányelvek és javaslatok az Azure Service Fabric megbízható gyűjtemények].</span><span class="sxs-lookup"><span data-stu-id="5645c-805">For more information about strategies for partioning keys in a reliable collection, see [guidelines and recommendations for reliable collections in Azure Service Fabric].</span></span>

### <a name="more-information"></a><span data-ttu-id="5645c-806">További információ</span><span class="sxs-lookup"><span data-stu-id="5645c-806">More information</span></span>
* <span data-ttu-id="5645c-807">[Azure Service Fabric áttekintése] bemutatja az Azure Service Fabric.</span><span class="sxs-lookup"><span data-stu-id="5645c-807">[Overview of Azure Service Fabric] is an introduction to Azure Service Fabric.</span></span>
* <span data-ttu-id="5645c-808">[A Service Fabric megbízható szolgáltatások partícióazonosító] további információt az Azure Service Fabric megbízható szolgáltatásokat nyújt.</span><span class="sxs-lookup"><span data-stu-id="5645c-808">[Partition Service Fabric reliable services] provides more information about reliable services in Azure Service Fabric.</span></span>

## <a name="partitioning-strategies-for-azure-event-hubs"></a><span data-ttu-id="5645c-809">Az Azure Event Hubs particionálási stratégia</span><span class="sxs-lookup"><span data-stu-id="5645c-809">Partitioning strategies for Azure Event Hubs</span></span>

<span data-ttu-id="5645c-810">[Az Azure Event Hubs] [ event-hubs] olyan fürtrendszergazdáknak készült, nagy léptékű streaming és particionálás horizontális skálázás engedélyezése a szolgáltatás be van építve.</span><span class="sxs-lookup"><span data-stu-id="5645c-810">[Azure Event Hubs][event-hubs] is designed for data streaming at massive scale, and partitioning is built into the service to enable horizontal scaling.</span></span> <span data-ttu-id="5645c-811">Mindegyik felhasználó csak egy adott partícióra az üzenet-adatfolyam olvassa be.</span><span class="sxs-lookup"><span data-stu-id="5645c-811">Each consumer only reads a specific partition of the message stream.</span></span> 

<span data-ttu-id="5645c-812">Az esemény-közzétevő csak a partíciókulcsot ismeri, azt a partíciót nem, amelyre az esemény közzé lesz téve.</span><span class="sxs-lookup"><span data-stu-id="5645c-812">The event publisher is only aware of its partition key, not the partition to which the events are published.</span></span> <span data-ttu-id="5645c-813">A kulcs és a partíció szétválasztása révén a küldőnek nem szükséges behatóan ismernie az alárendelt feldolgozási folyamatokat.</span><span class="sxs-lookup"><span data-stu-id="5645c-813">This decoupling of key and partition insulates the sender from needing to know too much about the downstream processing.</span></span> <span data-ttu-id="5645c-814">(Egyben események lehetséges küldése közvetlenül egy adott partíció, de általában nem ajánlott.)</span><span class="sxs-lookup"><span data-stu-id="5645c-814">(It's also possible send events directly to a given partition, but generally that's not recommended.)</span></span>  

<span data-ttu-id="5645c-815">Hosszú távú skálázási megfontolandó választja, a partíciók száma.</span><span class="sxs-lookup"><span data-stu-id="5645c-815">Consider long-term scale when you select the partition count.</span></span> <span data-ttu-id="5645c-816">Az eseményközpontok létrehozását követően nem módosíthatja a partíciók számát.</span><span class="sxs-lookup"><span data-stu-id="5645c-816">After an event hub is created, you can't change the number of partitions.</span></span> 

<span data-ttu-id="5645c-817">Az Event Hubs partíciók használatával kapcsolatos további információkért lásd: [Mi az az Event Hubs?].</span><span class="sxs-lookup"><span data-stu-id="5645c-817">For more information about using partitions in Event Hubs, see [What is Event Hubs?].</span></span>

<span data-ttu-id="5645c-818">Rendelkezésre állás és a konzisztencia közötti kompromisszumot kapcsolatos problémák, lásd: [rendelkezésre állását és az Event Hubs következetes].</span><span class="sxs-lookup"><span data-stu-id="5645c-818">For considerations about trade-offs between availability and consistency, see [Availability and consistency in Event Hubs].</span></span>

## <a name="rebalancing-partitions"></a><span data-ttu-id="5645c-819">Partíciók újraelosztás</span><span class="sxs-lookup"><span data-stu-id="5645c-819">Rebalancing partitions</span></span>
<span data-ttu-id="5645c-820">Miután a rendszer kiforrottá válik, és a használati minták jobban megismerte, lehetséges, hogy úgy, hogy a particionálási sémát.</span><span class="sxs-lookup"><span data-stu-id="5645c-820">As a system matures and you understand the usage patterns better, you might have to adjust the partitioning scheme.</span></span> <span data-ttu-id="5645c-821">Például az egyes partíciók előfordulhat, hogy start, valamint a forgalom le aránytalanul nagy mennyiségű és forró, ami túl sok versengés válnak.</span><span class="sxs-lookup"><span data-stu-id="5645c-821">For example, individual partitions might start attracting a disproportionate volume of traffic and become hot, leading to excessive contention.</span></span> <span data-ttu-id="5645c-822">Emellett, előfordulhat, hogy rendelkezik kellőképpen adatokat az egyes partíciók okozza, hogy megközelíti a tárolási kapacitás, ezek a partíciók a határain.</span><span class="sxs-lookup"><span data-stu-id="5645c-822">Additionally, you might have underestimated the volume of data in some partitions, causing you to approach the limits of the storage capacity in these partitions.</span></span> <span data-ttu-id="5645c-823">A valamilyen okból, fontos néha egyensúlyba partíciók több egyenletesen a terhelést.</span><span class="sxs-lookup"><span data-stu-id="5645c-823">Whatever the cause, it is sometimes necessary to rebalance partitions to spread the load more evenly.</span></span>

<span data-ttu-id="5645c-824">Bizonyos esetekben a adattároló rendszerek, amelyek nem nyilvánosan láthatóvá adatok kiszolgálókon elosztását vezérli automatikusan egyensúlyba partíciók rendelkezésre álló erőforrások keretein belül.</span><span class="sxs-lookup"><span data-stu-id="5645c-824">In some cases, data storage systems that don't publicly expose how data is allocated to servers can automatically rebalance partitions within the limits of the resources available.</span></span> <span data-ttu-id="5645c-825">Más helyzetekben újraelosztás felügyeleti feladatot, amely két szakaszból áll:</span><span class="sxs-lookup"><span data-stu-id="5645c-825">In other situations, rebalancing is an administrative task that consists of two stages:</span></span>

1. <span data-ttu-id="5645c-826">Annak megállapítása, az új particionálási stratégia meghatározása:</span><span class="sxs-lookup"><span data-stu-id="5645c-826">Determining the new partitioning strategy to ascertain:</span></span>
   * <span data-ttu-id="5645c-827">Előfordulhat, hogy partíciók kell vágási (vagy esetlegesen).</span><span class="sxs-lookup"><span data-stu-id="5645c-827">Which partitions might need to be split (or possibly combined).</span></span>
   * <span data-ttu-id="5645c-828">Ezek a partíciók adatok új partíciós kulcsok megtervezésével lefoglalni módját.</span><span class="sxs-lookup"><span data-stu-id="5645c-828">How to allocate data to these new partitions by designing new partition keys.</span></span>
2. <span data-ttu-id="5645c-829">Az érintett adatok áttelepítése a régi particionálási sémát az újonnan létrehozott partíciók.</span><span class="sxs-lookup"><span data-stu-id="5645c-829">Migrating the affected data from the old partitioning scheme to the new set of partitions.</span></span>

> [!NOTE]
> <span data-ttu-id="5645c-830">Kiszolgálók adatbázis gyűjtemények leképezése nem átlátszó, de továbbra is érhető el a tárolási kapacitás és átviteli sebességének korlátai Cosmos DB fiók.</span><span class="sxs-lookup"><span data-stu-id="5645c-830">The mapping of database collections to servers is transparent, but you can still reach the storage capacity and throughput limits of a Cosmos DB account.</span></span> <span data-ttu-id="5645c-831">Ha ez történik, előfordulhat, hogy kell terveznie a particionálási sémát, és az adatok áttelepítéséhez.</span><span class="sxs-lookup"><span data-stu-id="5645c-831">If this happens, you might need to redesign your partitioning scheme and migrate the data.</span></span>
>
>

<span data-ttu-id="5645c-832">Attól függően, hogy az adatok tárolási technológia, és az adatok tárolási rendszer kialakítása valószínűleg tudni át adatokat, amíg azok használja (online áttelepítés) partíciók között.</span><span class="sxs-lookup"><span data-stu-id="5645c-832">Depending on the data storage technology and the design of your data storage system, you might be able to migrate data between partitions while they are in use (online migration).</span></span> <span data-ttu-id="5645c-833">Ha ez nem lehetséges, szükség lehet annak az érintett partíciók átmenetileg nem érhető el, amíg az adatok áthelyezett (kapcsolat nélküli áttelepítés).</span><span class="sxs-lookup"><span data-stu-id="5645c-833">If this isn't possible, you might need to make the affected partitions temporarily unavailable while the data is relocated (offline migration).</span></span>

## <a name="offline-migration"></a><span data-ttu-id="5645c-834">Offline áttelepítés</span><span class="sxs-lookup"><span data-stu-id="5645c-834">Offline migration</span></span>
<span data-ttu-id="5645c-835">Offline áttelepítés késései a legegyszerűbb módszere mivel csökkenti a veszélyét annak, hogy a versengés lépett fel.</span><span class="sxs-lookup"><span data-stu-id="5645c-835">Offline migration is arguably the simplest approach because it reduces the chances of contention occurring.</span></span> <span data-ttu-id="5645c-836">Nem módosítja az adatokat, amíg folyamatban van áthelyezése és szerkezetátalakítás.</span><span class="sxs-lookup"><span data-stu-id="5645c-836">Don't make any changes to the data while it is being moved and restructured.</span></span>

<span data-ttu-id="5645c-837">Ez a folyamat elméleti szinten, a következő lépéseket tartalmazza:</span><span class="sxs-lookup"><span data-stu-id="5645c-837">Conceptually, this process includes the following steps:</span></span>

1. <span data-ttu-id="5645c-838">A szilánkok offline megjelölni.</span><span class="sxs-lookup"><span data-stu-id="5645c-838">Mark the shard offline.</span></span>
2. <span data-ttu-id="5645c-839">Vegyes egyesítéses és az adatok helyezze át az új szilánkok.</span><span class="sxs-lookup"><span data-stu-id="5645c-839">Split-merge and move the data to the new shards.</span></span>
3. <span data-ttu-id="5645c-840">Ellenőrizze az adatokat.</span><span class="sxs-lookup"><span data-stu-id="5645c-840">Verify the data.</span></span>
4. <span data-ttu-id="5645c-841">Kapcsolja a hálózatra az új szilánkok.</span><span class="sxs-lookup"><span data-stu-id="5645c-841">Bring the new shards online.</span></span>
5. <span data-ttu-id="5645c-842">Távolítsa el a régi szilánkcímtárban.</span><span class="sxs-lookup"><span data-stu-id="5645c-842">Remove the old shard.</span></span>

<span data-ttu-id="5645c-843">Egyes rendelkezésre állási megőrzéséhez jelölheti meg az 1. lépésben írásvédett eredeti shard ahelyett, így nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="5645c-843">To retain some availability, you can mark the original shard as read-only in step 1 rather than making it unavailable.</span></span> <span data-ttu-id="5645c-844">Ez lehetővé teszi az alkalmazások, az adatok olvasása áthelyezés alatt, de nem módosíthatja.</span><span class="sxs-lookup"><span data-stu-id="5645c-844">This allows applications to read the data while it is being moved but not to change it.</span></span>

## <a name="online-migration"></a><span data-ttu-id="5645c-845">Online áttelepítése</span><span class="sxs-lookup"><span data-stu-id="5645c-845">Online migration</span></span>
<span data-ttu-id="5645c-846">Online az áttelepítés akkor összetettebb, de kevésbé zavaró, a felhasználók számára végezhető el, mert az adatok továbbra is elérhető a teljes folyamat során.</span><span class="sxs-lookup"><span data-stu-id="5645c-846">Online migration is more complex to perform but less disruptive to users because data remains available during the entire procedure.</span></span> <span data-ttu-id="5645c-847">A folyamat hasonlít a, az offline áttelepítés használatával, azzal a különbséggel, hogy az eredeti shard nincs megjelölve offline (1. lépés).</span><span class="sxs-lookup"><span data-stu-id="5645c-847">The process is similar to that used by offline migration, except that the original shard is not marked offline (step 1).</span></span> <span data-ttu-id="5645c-848">Attól függően, hogy a lépésköz legyen az áttelepítési folyamat (például, hogy elkészült elem vagy shard által shard), az ügyfélalkalmazások számára az adatok hozzáférési kód lehet kezelni a olvasását és írását, amely két helyen használatban van (az eredeti shard és a új shard).</span><span class="sxs-lookup"><span data-stu-id="5645c-848">Depending on the granularity of the migration process (for example, whether it's done item by item or shard by shard), the data access code in the client applications might have to handle reading and writing data that's held in two locations (the original shard and the new shard).</span></span>

<span data-ttu-id="5645c-849">Például egy olyan megoldás, amely támogatja az online áttelepítést, tekintse meg a cikket [méretezés, a rugalmas adatbázis vegyes egyesítéses eszközzel] a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="5645c-849">For an example of a solution that supports online migration, see the article [Scaling using the Elastic Database split-merge tool] on the Microsoft website.</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="5645c-850">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="5645c-850">Related patterns and guidance</span></span>
<span data-ttu-id="5645c-851">Amikor kiválasztja az adatok konzisztenciájának bevezetése, a következő minták is lehet a forgatókönyvhöz kapcsolódó:</span><span class="sxs-lookup"><span data-stu-id="5645c-851">When considering strategies for implementing data consistency, the following patterns might also be relevant to your scenario:</span></span>

* <span data-ttu-id="5645c-852">A [adatok konzisztencia ismertetése] a Microsoft webhelyén a lap egy elosztott környezetben, például a felhő konzisztencia fenntartása kapcsolatos olyan stratégiák ismerteti.</span><span class="sxs-lookup"><span data-stu-id="5645c-852">The [Data consistency primer] page on the Microsoft website describes strategies for maintaining consistency in a distributed environment such as the cloud.</span></span>
* <span data-ttu-id="5645c-853">A [útmutatást particionálás adatok] oldalon, a Microsoft webhelyén általános áttekintést nyújt a különféle feltételeknek megfelelő elosztott megoldásban partíciók megtervezésére.</span><span class="sxs-lookup"><span data-stu-id="5645c-853">The [Data partitioning guidance] page on the Microsoft website provides a general overview of how to design partitions to meet various criteria in a distributed solution.</span></span>
* <span data-ttu-id="5645c-854">A [horizontális mintát] erről a Microsoft webhelyén foglalja össze a horizontális adatokat néhány gyakori stratégiát.</span><span class="sxs-lookup"><span data-stu-id="5645c-854">The [sharding pattern] as described on the Microsoft website summarizes some common strategies for sharding data.</span></span>
* <span data-ttu-id="5645c-855">A [index táblázat mintát] erről a Microsoft webhelyén azt ábrázolja, hogyan hozhat létre másodlagos indexek adatokat.</span><span class="sxs-lookup"><span data-stu-id="5645c-855">The [index table pattern] as described on the Microsoft website illustrates how to create secondary indexes over data.</span></span> <span data-ttu-id="5645c-856">Egy alkalmazás egy gyűjtemény elsődleges kulcsa nem hivatkozó lekérdezések használatával gyorsan lekérhető adatok ezt a módszert.</span><span class="sxs-lookup"><span data-stu-id="5645c-856">An application can quickly retrieve data with this approach, by using queries that do not reference the primary key of a collection.</span></span>
* <span data-ttu-id="5645c-857">A [materializált nézet mintát] erről a Microsoft webhelyén ismerteti, hogyan lehet adatokat gyors lekérdezési műveletek támogatásához előre megadott nézetek létrehozása céljából.</span><span class="sxs-lookup"><span data-stu-id="5645c-857">The [materialized view pattern] as described on the Microsoft website describes how to generate pre-populated views that summarize data to support fast query operations.</span></span> <span data-ttu-id="5645c-858">Ez a módszer hasznos lehet a particionált tárolóban Ha összegzett adatok a partíciók több hely különböző pontjain.</span><span class="sxs-lookup"><span data-stu-id="5645c-858">This approach can be useful in a partitioned data store if the partitions that contain the data being summarized are distributed across multiple sites.</span></span>
* <span data-ttu-id="5645c-859">A [használata Azure Content Delivery Network] cikk a Microsoft webhelyén konfigurálásával és az Azure Content Delivery Network használatával további útmutatást nyújt.</span><span class="sxs-lookup"><span data-stu-id="5645c-859">The [Using Azure Content Delivery Network] article on the Microsoft website provides additional guidance on configuring and using Content Delivery Network with Azure.</span></span>

## <a name="more-information"></a><span data-ttu-id="5645c-860">További információ</span><span class="sxs-lookup"><span data-stu-id="5645c-860">More information</span></span>
* <span data-ttu-id="5645c-861">A lap [Mi az Azure SQL Database?] a Microsoft webhelyén biztosít, amely azt ismerteti, hogyan történő létrehozásáról és használatáról az SQL-adatbázisok részletes dokumentációt.</span><span class="sxs-lookup"><span data-stu-id="5645c-861">The page [What is Azure SQL Database?] on the Microsoft website provides detailed documentation that describes how to create and use SQL databases.</span></span>
* <span data-ttu-id="5645c-862">A lap [rugalmas adatbázis-szolgáltatások áttekintése] a Microsoft webhelyén egy átfogó bevezetést tartalmaz ahhoz a rugalmas adatbázis.</span><span class="sxs-lookup"><span data-stu-id="5645c-862">The page [Elastic Database features overview] on the Microsoft website provides a comprehensive introduction to Elastic Database.</span></span>
* <span data-ttu-id="5645c-863">A lap [méretezés, a rugalmas adatbázis vegyes egyesítéses eszközzel] a Microsoft webhelyén a vegyes egyesítéses szolgáltatással kezelheti a rugalmas adatbázis szilánkok adatait tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="5645c-863">The page [Scaling using the Elastic Database split-merge tool] on the Microsoft website contains information about using the split-merge service to manage Elastic Database shards.</span></span>
* <span data-ttu-id="5645c-864">A lap [az Azure storage méretezhetőségi és Teljesítménycélok](https://msdn.microsoft.com/library/azure/dn249410.aspx) a Microsoft-webhely az aktuális méretezési és az átviteli Sebességkorlát az Azure Storage dokumentumokat.</span><span class="sxs-lookup"><span data-stu-id="5645c-864">The page [Azure storage scalability and performance targets](https://msdn.microsoft.com/library/azure/dn249410.aspx) on the Microsoft website documents the current sizing and throughput limits of Azure Storage.</span></span>
* <span data-ttu-id="5645c-865">A lap [entitás csoport tranzakciók végrehajtása] a Microsoft webhelyén részletes információkat nyújt azokról tranzakciós műveletek végrehajtása az Azure table storage-ban tárolt entitásokat keresztül.</span><span class="sxs-lookup"><span data-stu-id="5645c-865">The page [Performing entity group transactions] on the Microsoft website provides detailed information about implementing transactional operations over entities that are stored in Azure table storage.</span></span>
* <span data-ttu-id="5645c-866">A cikk [Azure Storage táblázat kialakítási útmutató] a Microsoft webhely adatokat az Azure table storage-ban partícionálásra vonatkozó részletes információkat tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="5645c-866">The article [Azure Storage table design guide] on the Microsoft website contains detailed information about partitioning data in Azure table storage.</span></span>
* <span data-ttu-id="5645c-867">A lap [használata Azure Content Delivery Network] a Microsoft webhelyén ismerteti, hogyan lehet replikálja az adatokat, amely használatban van az Azure blob Storage tárolóban az Azure Content Delivery Network használatával.</span><span class="sxs-lookup"><span data-stu-id="5645c-867">The page [Using Azure Content Delivery Network] on the Microsoft website describes how to replicate data that's held in Azure blob storage by using the Azure Content Delivery Network.</span></span>
* <span data-ttu-id="5645c-868">A lap [Azure Search újdonságai?] a Microsoft webhelyén elérhető lehetőségek érhetők el az Azure Search teljes leírását tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="5645c-868">The page [What is Azure Search?] on the Microsoft website provides a full description of the capabilities that are available in Azure Search.</span></span>
* <span data-ttu-id="5645c-869">A lap [szolgáltatási korlátait, az Azure Search] a Microsoft webhelyén a kapacitás az összes Azure Search-példány adatait tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="5645c-869">The page [Service limits in Azure Search] on the Microsoft website contains information about the capacity of each instance of Azure Search.</span></span>
* <span data-ttu-id="5645c-870">A lap [a támogatott adattípusokat (Azure Search)] a Microsoft webhely segítségével is kereshető dokumentumok és indexek adattípusokat foglalja össze.</span><span class="sxs-lookup"><span data-stu-id="5645c-870">The page [Supported data types (Azure Search)] on the Microsoft website summarizes the data types that you can use in searchable documents and indexes.</span></span>
* <span data-ttu-id="5645c-871">A lap [Azure Redis Cache] a Microsoft webhelyén Azure Redis Cache bevezetést nyújt.</span><span class="sxs-lookup"><span data-stu-id="5645c-871">The page [Azure Redis Cache] on the Microsoft website provides an introduction to Azure Redis Cache.</span></span>
* <span data-ttu-id="5645c-872">A [particionálására: hogyan adatok több Redis-példány között] a Redis-webhelyen lap megvalósításához a particionálás a redis gyorsítótárral kapcsolatos információkat biztosít.</span><span class="sxs-lookup"><span data-stu-id="5645c-872">The [Partitioning: how to split data among multiple Redis instances] page on the Redis website provides information about how to implement partitioning with Redis.</span></span>
* <span data-ttu-id="5645c-873">A lap [a CentOS Linux virtuális gép az Azure-ban futó Redis] a Microsoft webhelyén végigvezeti egy példa, amely azt ismerteti, hogyan hozza létre és konfigurálja az Azure virtuális gépként futó Redis csomópont.</span><span class="sxs-lookup"><span data-stu-id="5645c-873">The page [Running Redis on a CentOS Linux VM in Azure] on the Microsoft website walks through an example that shows you how to build and configure a Redis node running as an Azure VM.</span></span>
* <span data-ttu-id="5645c-874">A [adattípusok] a Redis-webhelyen lap ismerteti, hogy a Redis és az Azure Redis Cache adatok típusát.</span><span class="sxs-lookup"><span data-stu-id="5645c-874">The [Data types] page on the Redis website describes the data types that are available with Redis and Azure Redis Cache.</span></span>

[rendelkezésre állását és az Event Hubs következetes]: /azure/event-hubs/event-hubs-availability-and-consistency
[Availability and consistency in Event Hubs]: /azure/event-hubs/event-hubs-availability-and-consistency
[azure-limits]: /azure/azure-subscription-service-limits
[Azure Content Delivery Network]: /azure/cdn/cdn-overview
[Azure Redis Cache]: http://azure.microsoft.com/services/cache/
[Az Azure Storage méretezhetőségi és teljesítménycéloknak]: /azure/storage/storage-scalability-targets
[Azure Storage Scalability and Performance Targets]: /azure/storage/storage-scalability-targets
[Az Azure Storage táblázat kialakítási útmutató]: /azure/storage/storage-table-design-guide
[Azure Storage Table Design Guide]: /azure/storage/storage-table-design-guide
[A Polyglot megoldás létrehozása]: https://msdn.microsoft.com/library/dn313279.aspx
[Building a Polyglot Solution]: https://msdn.microsoft.com/library/dn313279.aspx
[cosmos-db-ru]: /azure/cosmos-db/request-units
[A magas szinten méretezhető megoldások adatelérési: SQL, nosql-alapú és Polyglot adatmegőrzési használatával]: https://msdn.microsoft.com/library/dn271399.aspx
[Data Access for Highly-Scalable Solutions: Using SQL, NoSQL, and Polyglot Persistence]: https://msdn.microsoft.com/library/dn271399.aspx
[adatok konzisztencia ismertetése]: http://aka.ms/Data-Consistency-Primer
[Data consistency primer]: http://aka.ms/Data-Consistency-Primer
[Adatok particionálási útmutató]: https://msdn.microsoft.com/library/dn589795.aspx
[Data Partitioning Guidance]: https://msdn.microsoft.com/library/dn589795.aspx
[Adattípusok]: http://redis.io/topics/data-types
[Data Types]: http://redis.io/topics/data-types
[cosmosdb-sql-api]: /azure/cosmos-db/sql-api-introduction
[rugalmas adatbázis-szolgáltatások áttekintése]: /azure/sql-database/sql-database-elastic-scale-introduction
[Elastic Database features overview]: /azure/sql-database/sql-database-elastic-scale-introduction
[event-hubs]: /azure/event-hubs
[Federations Migration Utility]: https://code.msdn.microsoft.com/vstudio/Federations-Migration-ce61e9c1
[irányelvek és javaslatok az Azure Service Fabric megbízható gyűjtemények]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[guidelines and recommendations for reliable collections in Azure Service Fabric]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[Index táblázat minta]: http://aka.ms/Index-Table-Pattern
[Index Table Pattern]: http://aka.ms/Index-Table-Pattern
[Materializált nézet minta]: http://aka.ms/Materialized-View-Pattern
[Materialized View Pattern]: http://aka.ms/Materialized-View-Pattern
[több shard lekérdezése]: /azure/sql-database/sql-database-elastic-scale-multishard-querying
[Multi-shard querying]: /azure/sql-database/sql-database-elastic-scale-multishard-querying
[Azure Service Fabric áttekintése]: /azure/service-fabric/service-fabric-overview
[Overview of Azure Service Fabric]: /azure/service-fabric/service-fabric-overview
[A Service Fabric megbízható szolgáltatások partícióazonosító]: /azure/service-fabric/service-fabric-concepts-partitioning
[Partition Service Fabric reliable services]: /azure/service-fabric/service-fabric-concepts-partitioning
[particionálására: hogyan adatok több Redis-példány között]: http://redis.io/topics/partitioning
[Partitioning: how to split data among multiple Redis instances]: http://redis.io/topics/partitioning
[Entitás csoport tranzakciók végrehajtása]: https://msdn.microsoft.com/library/azure/dd894038.aspx
[Performing Entity Group Transactions]: https://msdn.microsoft.com/library/azure/dd894038.aspx
[Redis-fürt oktatóanyag]: http://redis.io/topics/cluster-tutorial
[Redis cluster tutorial]: http://redis.io/topics/cluster-tutorial
[a CentOS Linux virtuális gép az Azure-ban futó Redis]: http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx
[Running Redis on a CentOS Linux VM in Azure]: http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx
[méretezés, a rugalmas adatbázis vegyes egyesítéses eszközzel]: /azure/sql-database/sql-database-elastic-scale-overview-split-and-merge
[Scaling using the Elastic Database split-merge tool]: /azure/sql-database/sql-database-elastic-scale-overview-split-and-merge
[használata Azure Content Delivery Network]: /azure/cdn/cdn-create-new-endpoint
[Using Azure Content Delivery Network]: /azure/cdn/cdn-create-new-endpoint
[Service Bus kvóták]: /azure/service-bus-messaging/service-bus-quotas
[Service Bus quotas]: /azure/service-bus-messaging/service-bus-quotas
[service-fabric-reliable-collections]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections
[szolgáltatási korlátait, az Azure Search]:  /azure/search/search-limits-quotas-capacity
[Service limits in Azure Search]:  /azure/search/search-limits-quotas-capacity
[horizontális mintát]: http://aka.ms/Sharding-Pattern
[Sharding pattern]: http://aka.ms/Sharding-Pattern
[Támogatott adattípusokat (az Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Supported Data Types (Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[tranzakciók]: http://redis.io/topics/transactions
[Transactions]: http://redis.io/topics/transactions
[Mi az az Event Hubs?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[What is Event Hubs?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[Azure Search újdonságai?]: /azure/search/search-what-is-azure-search
[What is Azure Search?]: /azure/search/search-what-is-azure-search
[Mi az Azure SQL Database?]: /azure/sql-database/sql-database-technical-overview
[What is Azure SQL Database?]: /azure/sql-database/sql-database-technical-overview
