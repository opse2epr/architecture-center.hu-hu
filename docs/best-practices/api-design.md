---
title: "API-tervezési segédlet"
description: "Útmutatás jól létrehozása után API tervezték."
author: dragon119
ms.date: 07/13/2016
pnp.series.title: Best Practices
ms.openlocfilehash: 3ffadce1b0c4a4da808e52d61cff0b7f0b27de11
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 11/14/2017
---
# <a name="api-design"></a><span data-ttu-id="7c98e-103">API-Tervező</span><span class="sxs-lookup"><span data-stu-id="7c98e-103">API design</span></span>
[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="7c98e-104">Számos modern webes megoldás ellenőrizze webszolgáltatások webkiszolgálókon, funkcionalitással távoli ügyfél alkalmazások használatát.</span><span class="sxs-lookup"><span data-stu-id="7c98e-104">Many modern web-based solutions make the use of web services, hosted by web servers, to provide functionality for remote client applications.</span></span> <span data-ttu-id="7c98e-105">A művelet, amely egy webszolgáltatás-bővítmény elérhetővé teszi a webes API jelent.</span><span class="sxs-lookup"><span data-stu-id="7c98e-105">The operations that a web service exposes constitute a web API.</span></span> <span data-ttu-id="7c98e-106">Tetszetős webes API-k támogatása érhető el:</span><span class="sxs-lookup"><span data-stu-id="7c98e-106">A well-designed web API should aim to support:</span></span>

* <span data-ttu-id="7c98e-107">**Platform függetlenség**.</span><span class="sxs-lookup"><span data-stu-id="7c98e-107">**Platform independence**.</span></span> <span data-ttu-id="7c98e-108">Kell, hogy az API-t, hogy a webszolgáltatás biztosít anélkül, hogy az adatok vagy a műveletek API elérhetővé tévő fizikailag valósíthatók meg használatára képesek az ügyfélalkalmazások számára.</span><span class="sxs-lookup"><span data-stu-id="7c98e-108">Client applications should be able to utilize the API that the web service provides without requiring how the data or operations that API exposes are physically implemented.</span></span> <span data-ttu-id="7c98e-109">Ehhez szükséges, hogy az API-t, amelyek lehetővé teszik egy ügyfél alkalmazás és szolgáltatás mely adatok formátumok használatát, és az ügyfél és a webszolgáltatás keresztül megosztott adatokat szerkezete megállapodni közös szabványokkal megfelel-e.</span><span class="sxs-lookup"><span data-stu-id="7c98e-109">This requires that the API abides by common standards that enable a client application and web service to agree on which data formats to use, and the structure of the data that is exchanged between client applications and the web service.</span></span>
* <span data-ttu-id="7c98e-110">**Szolgáltatás alakulása**.</span><span class="sxs-lookup"><span data-stu-id="7c98e-110">**Service evolution**.</span></span> <span data-ttu-id="7c98e-111">A webszolgáltatás fejlődnek és hozzáadása (vagy eltávolítása) funkció ügyfélalkalmazásokat től függetlenül képesnek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="7c98e-111">The web service should be able to evolve and add (or remove) functionality independently from client applications.</span></span> <span data-ttu-id="7c98e-112">Meglévő ügyfélalkalmazások továbbra is működik, a webes szolgáltatás változás által nyújtott szolgáltatásokat változatlan kell lennie.</span><span class="sxs-lookup"><span data-stu-id="7c98e-112">Existing client applications should be able to continue to operate unmodified as the features provided by the web service change.</span></span> <span data-ttu-id="7c98e-113">Összes funkciót is kell felderíthető, úgy, hogy az ügyfélalkalmazások teljesen használhatják azt.</span><span class="sxs-lookup"><span data-stu-id="7c98e-113">All functionality should also be discoverable, so that client applications can fully utilize it.</span></span>

<span data-ttu-id="7c98e-114">Ez az útmutató célja a webes API-k tervezésekor érdemes problémákat ismertetik.</span><span class="sxs-lookup"><span data-stu-id="7c98e-114">The purpose of this guidance is to describe the issues that you should consider when designing a web API.</span></span>

## <a name="introduction-to-representational-state-transfer-rest"></a><span data-ttu-id="7c98e-115">Bevezetés a Representational State Transfer (REST)</span><span class="sxs-lookup"><span data-stu-id="7c98e-115">Introduction to Representational State Transfer (REST)</span></span>
<span data-ttu-id="7c98e-116">A saját disszertáció zárja 2000 Roy Fielding javasolt egy másik architekturális módjáról a webszolgáltatások; által elérhetővé tett műveletek szerkezetének kialakítása REST.</span><span class="sxs-lookup"><span data-stu-id="7c98e-116">In his dissertation in 2000, Roy Fielding proposed an alternative architectural approach to structuring the operations exposed by web services; REST.</span></span> <span data-ttu-id="7c98e-117">REST egy architekturális stílus hipermédia alapján elosztott rendszerek készítéséhez.</span><span class="sxs-lookup"><span data-stu-id="7c98e-117">REST is an architectural style for building distributed systems based on hypermedia.</span></span> <span data-ttu-id="7c98e-118">Egy elsődleges a többi modell előnye, hogy nyitva szabványok alapul, és nem köthető. a modell vagy az ügyfélalkalmazások számára bármely adott megvalósításához elérő végrehajtása.</span><span class="sxs-lookup"><span data-stu-id="7c98e-118">A primary advantage of the REST model is that it is based on open standards and does not bind the implementation of the model or the client applications that access it to any specific implementation.</span></span> <span data-ttu-id="7c98e-119">Például egy REST webszolgáltatás-bővítmény a Microsoft ASP.NET Web API használatával találhatja, és az ügyfélalkalmazások bármely nyelvet és a HTTP-kérelmek előállítására és elemezni a HTTP-válaszok eszközkészlet használatával lehet kialakítani.</span><span class="sxs-lookup"><span data-stu-id="7c98e-119">For example, a REST web service could be implemented by using the Microsoft ASP.NET Web API, and client applications could be developed by using any language and toolset that can generate HTTP requests and parse HTTP responses.</span></span>

> [!NOTE]
> <span data-ttu-id="7c98e-120">REST ténylegesen független a mögöttes protokollt, és nem feltétlenül kötődik HTTP.</span><span class="sxs-lookup"><span data-stu-id="7c98e-120">REST is actually independent of any underlying protocol and is not necessarily tied to HTTP.</span></span> <span data-ttu-id="7c98e-121">Azonban a többi alapuló rendszerek leggyakoribb alkalmazása HTTP küldését és fogadását kérelmek alkalmazás protokollt használja.</span><span class="sxs-lookup"><span data-stu-id="7c98e-121">However, most common implementations of systems that are based on REST utilize HTTP as the application protocol for sending and receiving requests.</span></span> <span data-ttu-id="7c98e-122">Ez a dokumentum elsősorban REST alapelvek leképezése rendszert úgy tervezték, hogy működik a HTTP-n keresztül.</span><span class="sxs-lookup"><span data-stu-id="7c98e-122">This document focuses on mapping REST principles to systems designed to operate using HTTP.</span></span>
>
>

<span data-ttu-id="7c98e-123">A többi modellje egy navigációs séma képviselő objektum és a szolgáltatások a hálózaton keresztül (néven *erőforrások*).</span><span class="sxs-lookup"><span data-stu-id="7c98e-123">The REST model uses a navigational scheme to represent objects and services over a network (referred to as *resources*).</span></span> <span data-ttu-id="7c98e-124">Sok rendszerek REST általában a HTTP protokoll használatával továbbítja ezeket az erőforrásokat hozzáférés kérése.</span><span class="sxs-lookup"><span data-stu-id="7c98e-124">Many systems that implement REST typically use the HTTP protocol to transmit requests to access these resources.</span></span> <span data-ttu-id="7c98e-125">Az ezekben a rendszerekben ügyfélalkalmazás kérést formája, amely azonosítja az erőforrás URI és egy (a leggyakrabban használt alatt GET, POST, PUT vagy DELETE) HTTP-metódus, amely jelzi az adott erőforrás kell elvégezni a műveletet.</span><span class="sxs-lookup"><span data-stu-id="7c98e-125">In these systems, a client application submits a request in the form of a URI that identifies a resource, and an HTTP method (the most common being GET, POST, PUT, or DELETE) that indicates the operation to be performed on that resource.</span></span>  <span data-ttu-id="7c98e-126">A HTTP-kérelem törzsében a művelet végrehajtásához szükséges adatokat.</span><span class="sxs-lookup"><span data-stu-id="7c98e-126">The body of the HTTP request contains the data required to perform the operation.</span></span> <span data-ttu-id="7c98e-127">Megértéséhez lényege, hogy a többi állapot nélküli kérelem modell határozza meg.</span><span class="sxs-lookup"><span data-stu-id="7c98e-127">The important point to understand is that REST defines a stateless request model.</span></span> <span data-ttu-id="7c98e-128">HTTP-kérelmek függetlennek kell lenniük, és bármilyen sorrendben fordulhat elő, tartsa meg az átmeneti állapotadatokat kérelmek között kísérlet esetén nem valósítható meg.</span><span class="sxs-lookup"><span data-stu-id="7c98e-128">HTTP requests should be independent and may occur in any order, so attempting to retain transient state information between requests is not feasible.</span></span>  <span data-ttu-id="7c98e-129">Az egyetlen hely adatokat tároló magukat az erőforrások, és minden kérelmet egy atomi művelet kell lennie.</span><span class="sxs-lookup"><span data-stu-id="7c98e-129">The only place where information is stored is in the resources themselves, and each request should be an atomic operation.</span></span> <span data-ttu-id="7c98e-130">A többi modell hatékonyan, egy adott kérelem átkerül egy erőforrást egy jól meghatározott nem átmeneti állapotból, egy másik véges állapotjelző gép valósítja meg.</span><span class="sxs-lookup"><span data-stu-id="7c98e-130">Effectively, a REST model implements a finite state machine where a request transitions a resource from one well-defined non-transient state to another.</span></span>

> [!NOTE]
> <span data-ttu-id="7c98e-131">Egyes kérelmeket a többi modell állapotmentes jellege lehetővé teszi, hogy a rendszer következő alapelvek magas szinten méretezhető kell kialakítani.</span><span class="sxs-lookup"><span data-stu-id="7c98e-131">The stateless nature of individual requests in the REST model enables a system constructed by following these principles to be highly scalable.</span></span> <span data-ttu-id="7c98e-132">Nincs szükség semmilyen egy ügyfélalkalmazást, így azokat a kérelmeket és ezeket a kérelmeket kezelő adott webkiszolgálók közötti kapcsolat megőrzéséhez.</span><span class="sxs-lookup"><span data-stu-id="7c98e-132">There is no need to retain any affinity between a client application making a series of requests and the specific web servers handling those requests.</span></span>
>
>

<span data-ttu-id="7c98e-133">Egy hatékony REST-modell végrehajtása során egy másik kritikus fontosságú pont, amelyre a modell hozzáférést biztosít a különböző erőforrásainak kapcsolatai megértése.</span><span class="sxs-lookup"><span data-stu-id="7c98e-133">Another crucial point in implementing an effective REST model is to understand the relationships between the various resources to which the model provides access.</span></span> <span data-ttu-id="7c98e-134">Ezeket az erőforrásokat általában vannak sorolva gyűjtemények és a kapcsolatokat.</span><span class="sxs-lookup"><span data-stu-id="7c98e-134">These resources are typically organized as collections and relationships.</span></span> <span data-ttu-id="7c98e-135">Tegyük fel, hogy egy kereskedelmi rendszer gyors elemzését jeleníti meg, hogy vannak-e két gyűjtemények belül alkalmazások valószínűleg érdekelt: rendeléseket és ügyfelek.</span><span class="sxs-lookup"><span data-stu-id="7c98e-135">For example, suppose that a quick analysis of an ecommerce system shows that there are two collections in which client applications are likely to be interested: orders and customers.</span></span> <span data-ttu-id="7c98e-136">Minden sorrendje, az ügyfél azonosítására szolgál a saját egyedi kulcsot kell rendelkeznie.</span><span class="sxs-lookup"><span data-stu-id="7c98e-136">Each order and customer should have its own unique key for identification purposes.</span></span> <span data-ttu-id="7c98e-137">Lehet, hogy valami más dolga, mint a gyűjtemény rendelések eléréséhez URI */rendelések*, és ugyanígy URI-JÁNAK beolvasása az összes ügyfél lehet */customers*.</span><span class="sxs-lookup"><span data-stu-id="7c98e-137">The URI to access the collection of orders could be something as simple as */orders*, and similarly the URI for retrieving all customers could be */customers*.</span></span> <span data-ttu-id="7c98e-138">Kiállító egy HTTP GET kérést a */rendelések* URI visszaadja-e egy HTTP-válasz kódolása a gyűjteményben lévő összes rendeléseket reprezentáló listáját:</span><span class="sxs-lookup"><span data-stu-id="7c98e-138">Issuing an HTTP GET request to the */orders* URI should return a list representing all orders in the collection encoded as an HTTP response:</span></span>

```HTTP
GET http://adventure-works.com/orders HTTP/1.1
...
```

<span data-ttu-id="7c98e-139">A lent látható módon válasz egy JSON-lista szerkezetének kódolja a rendeléseket:</span><span class="sxs-lookup"><span data-stu-id="7c98e-139">The response shown below encodes the orders as a JSON list structure:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Date: Fri, 22 Aug 2014 08:49:02 GMT
Content-Length: ...
[{"orderId":1,"orderValue":99.90,"productId":1,"quantity":1},{"orderId":2,"orderValue":10.00,"productId":4,"quantity":2},{"orderId":3,"orderValue":16.60,"productId":2,"quantity":4},{"orderId":4,"orderValue":25.90,"productId":3,"quantity":1},{"orderId":5,"orderValue":99.90,"productId":1,"quantity":1}]
```
<span data-ttu-id="7c98e-140">Egyes sorrendhez fetch előírja, hogy a rendelés azonosító megadása a *rendelések* erőforrás, például a */kérelmek/2*:</span><span class="sxs-lookup"><span data-stu-id="7c98e-140">To fetch an individual order requires specifying the identifier for the order from the *orders* resource, such as */orders/2*:</span></span>

```HTTP
GET http://adventure-works.com/orders/2 HTTP/1.1
...
```

```HTTP
HTTP/1.1 200 OK
...
Date: Fri, 22 Aug 2014 08:49:02 GMT
Content-Length: ...
{"orderId":2,"orderValue":10.00,"productId":4,"quantity":2}
```

> [!NOTE]
> <span data-ttu-id="7c98e-141">Az egyszerűség kedvéért ezekben a példákban az információk megjelenítése válaszok JSON-szöveg adatokat ad vissza.</span><span class="sxs-lookup"><span data-stu-id="7c98e-141">For simplicity, these examples show the information in responses being returned as JSON text data.</span></span> <span data-ttu-id="7c98e-142">Azonban nincs ok erőforrások miért nem tartalmazhat más típusú adatok támogatott HTTP-alapú, például bináris vagy titkosított információk; a HTTP-válasz a tartalomtípus kell adja meg a típusát.</span><span class="sxs-lookup"><span data-stu-id="7c98e-142">However, there is no reason why resources should not contain any other type of data supported by HTTP, such as binary or encrypted information; the content-type in the HTTP response should specify the type.</span></span> <span data-ttu-id="7c98e-143">Emellett egy REST-modell tud visszatérni ugyanazokat az adatokat a különböző formátumokban, például az XML- vagy JSON lehet.</span><span class="sxs-lookup"><span data-stu-id="7c98e-143">Also, a REST model may be able to return the same data in different formats, such as XML or JSON.</span></span> <span data-ttu-id="7c98e-144">Ebben az esetben a webszolgáltatás kell tudni tartalom végrehajtani a kérést a ügyféllel.</span><span class="sxs-lookup"><span data-stu-id="7c98e-144">In this case, the web service should be able to perform content negotiation with the client making the request.</span></span> <span data-ttu-id="7c98e-145">A kérelem tartalmazhat egy *elfogadás* fejlécet, amely megadja az előnyben részesített formátumban, amely az ügyfél szeretne kapni, és a webszolgáltatás megkíséreljék-e ezt a formátumot tiszteletben Ha lehetséges.</span><span class="sxs-lookup"><span data-stu-id="7c98e-145">The request can include an *Accept* header which specifies the preferred format that the client would like to receive and the web service should attempt to honor this format if at all possible.</span></span>
>
>

<span data-ttu-id="7c98e-146">Figyelje meg, hogy a többi kérést kapott válasz alkalmazza, a szabványos HTTP állapotkód esetében.</span><span class="sxs-lookup"><span data-stu-id="7c98e-146">Notice that the response from a REST request makes use of the standard HTTP status codes.</span></span> <span data-ttu-id="7c98e-147">Például a kérelmeket, amelyek érvényes adatokat ad vissza tartalmaznia kell a HTTP-válaszkód a 200-as (OK), miközben a kérelmeket, amelyek nem található vagy nem megadott erőforrás törlése kell visszaadnia egy választ, amely tartalmazza a HTTP-állapotkód: 404-es (nem található).</span><span class="sxs-lookup"><span data-stu-id="7c98e-147">For example, a request that returns valid data should include the HTTP response code 200 (OK), while a request that fails to find or delete a specified resource should return a response that includes the HTTP status code 404 (Not Found).</span></span>

## <a name="design-and-structure-of-a-restful-web-api"></a><span data-ttu-id="7c98e-148">Tervezés és RESTful webes API-k szerkezete</span><span class="sxs-lookup"><span data-stu-id="7c98e-148">Design and structure of a RESTful web API</span></span>
<span data-ttu-id="7c98e-149">Az egy sikeres webes API kulcsai egyszerűség és konzisztenciáját.</span><span class="sxs-lookup"><span data-stu-id="7c98e-149">The keys to designing a successful web API are simplicity and consistency.</span></span> <span data-ttu-id="7c98e-150">Egy webes API, ez a két tényező mutat megkönnyíti az ügyfél-alkalmazások, amelyeket az API-t használ.</span><span class="sxs-lookup"><span data-stu-id="7c98e-150">A Web API that exhibits these two factors makes it easier to build client applications that need to consume the API.</span></span>

<span data-ttu-id="7c98e-151">A RESTful webes API kitettségének kapcsolódó erőforrások olyan készletét, és kezeléséről a alapvető műveleteket, amelyek lehetővé teszik az alkalmazások kezelheti ezeket az erőforrásokat, és könnyen kikereshetik közöttük összpontosít.</span><span class="sxs-lookup"><span data-stu-id="7c98e-151">A RESTful web API is focused on exposing a set of connected resources, and providing the core operations that enable an application to manipulate these resources and easily navigate between them.</span></span> <span data-ttu-id="7c98e-152">Emiatt a tipikus RESTful webes API-k alkotó URI-k legyen objektumorientált felé érheti el az adatokat, és a HTTP által biztosított eszközökkel használja ezeket az adatokat az való működésre.</span><span class="sxs-lookup"><span data-stu-id="7c98e-152">For this reason, the URIs that constitute a typical RESTful web API should be oriented towards the data that it exposes, and use the facilities provided by HTTP to operate on this data.</span></span> <span data-ttu-id="7c98e-153">Ez a módszer egy másik alaposan, hogy általában egy objektumorientált API, amely azt kell több számos alkalommal osztályok és objektumok viselkedését osztályok készlete tervezésekor a igényli.</span><span class="sxs-lookup"><span data-stu-id="7c98e-153">This approach requires a different mindset from that typically employed when designing a set of classes in an object-oriented API which tends to be more motivated by the behavior of objects and classes.</span></span> <span data-ttu-id="7c98e-154">Emellett a RESTful webes API állapotmentes legyen, és adott sorrendben meghívott műveletek nem függ.</span><span class="sxs-lookup"><span data-stu-id="7c98e-154">Additionally, a RESTful web API should be stateless and not depend on operations being invoked in a particular sequence.</span></span> <span data-ttu-id="7c98e-155">A következő szakaszok összegzik a RESTful webes API-k tervezésekor érdemes pontokat.</span><span class="sxs-lookup"><span data-stu-id="7c98e-155">The following sections summarize the points you should consider when designing a RESTful web API.</span></span>

### <a name="organizing-the-web-api-around-resources"></a><span data-ttu-id="7c98e-156">A webes API-k körül erőforrások rendszerezése</span><span class="sxs-lookup"><span data-stu-id="7c98e-156">Organizing the web API around resources</span></span>
> [!TIP]
> <span data-ttu-id="7c98e-157">Az URI-azonosítók egy REST-alapú webszolgáltatás által elérhetővé tett főnevek alapján (az adatokat, amelyhez hozzáférést biztosít a webes API-k) és a nem a műveleteket (az alkalmazás teendők adatokkal).</span><span class="sxs-lookup"><span data-stu-id="7c98e-157">The URIs exposed by a REST web service should be based on nouns (the data to which the web API provides access) and not verbs (what an application can do with the data).</span></span>
>
>

<span data-ttu-id="7c98e-158">Összpontosítson az üzleti entitásokat, amely a webes API-k elérhetővé teszi.</span><span class="sxs-lookup"><span data-stu-id="7c98e-158">Focus on the business entities that the web API exposes.</span></span> <span data-ttu-id="7c98e-159">Például a webes API-k arra tervezték, hogy a korábban leírt kereskedelmi rendszer, az elsődleges entitások legyenek az ügyfelek és a rendeléseket.</span><span class="sxs-lookup"><span data-stu-id="7c98e-159">For example, in a web API designed to support the ecommerce system described earlier, the primary entities are customers and orders.</span></span> <span data-ttu-id="7c98e-160">Folyamat, például az a folyamat egy rendelés egy HTTP POST művelet veszi a megrendelés információit, és hozzáadja azt az ügyfél rendelések listájának megadásával érheti el.</span><span class="sxs-lookup"><span data-stu-id="7c98e-160">Processes such as the act of placing an order can be achieved by providing an HTTP POST operation that takes the order information and adds it to the list of orders for the customer.</span></span> <span data-ttu-id="7c98e-161">A POST művelet belső, például a készlet szintjeinek ellenőrzése és az ügyfél számlázási műveleteket hajthatnak végre.</span><span class="sxs-lookup"><span data-stu-id="7c98e-161">Internally, this POST operation can perform tasks such as checking stock levels, and billing the customer.</span></span> <span data-ttu-id="7c98e-162">A HTTP-válasz adhatja meg, hogy a megbízást sikeres volt-e.</span><span class="sxs-lookup"><span data-stu-id="7c98e-162">The HTTP response can indicate whether the order was placed successfully or not.</span></span> <span data-ttu-id="7c98e-163">Ne feledje, hogy egy erőforrás nincs egyetlen fizikai adatelemet alapján.</span><span class="sxs-lookup"><span data-stu-id="7c98e-163">Also note that a resource does not have to be based on a single physical data item.</span></span> <span data-ttu-id="7c98e-164">Például egy rendelés erőforrást is elegendő lehet belső elosztva több táblázatot egy relációs adatbázisban, de az ügyfélnek egyetlen egységként jelenik meg a sorok összesítik információk segítségével.</span><span class="sxs-lookup"><span data-stu-id="7c98e-164">As an example, an order resource might be implemented internally by using information aggregated from many rows spread across several tables in a relational database but presented to the client as a single entity.</span></span>

> [!TIP]
> <span data-ttu-id="7c98e-165">Ne tervezése egy REST-felület, amely tükrözi, vagy a belső struktúra, amely azt mutatja meg az adatok függ.</span><span class="sxs-lookup"><span data-stu-id="7c98e-165">Avoid designing a REST interface that mirrors or depends on the internal structure of the data that it exposes.</span></span> <span data-ttu-id="7c98e-166">REST tárgya több megvalósítása egyszerű (létrehozása, beolvasása, Update, Delete) CRUD műveletek keresztül külön táblázatban egy relációs adatbázisban.</span><span class="sxs-lookup"><span data-stu-id="7c98e-166">REST is about more than implementing simple CRUD (Create, Retrieve, Update, Delete) operations over separate tables in a relational database.</span></span> <span data-ttu-id="7c98e-167">REST célja üzleti entitásokat, és ezeket az entitásokat ezeket az entitásokat fizikai megvalósításához is képesek elvégezni egy alkalmazás, de nem szabad felfedni ügyfél műveletek leképezése a fizikai részleteit.</span><span class="sxs-lookup"><span data-stu-id="7c98e-167">The purpose of REST is to map business entities and the operations that an application can perform on these entities to the physical implementation of these entities, but a client should not be exposed to these physical details.</span></span>
>
>

<span data-ttu-id="7c98e-168">Az egyes üzleti ritkán entitások elkülönítési (bár előfordulhat, hogy létezik néhány egypéldányú objektum), de ehelyett az egyes csoportosítja a gyűjteményekbe.</span><span class="sxs-lookup"><span data-stu-id="7c98e-168">Individual business entities rarely exist in isolation (although some singleton objects may exist), but instead tend to be grouped together into collections.</span></span> <span data-ttu-id="7c98e-169">A többi feltételek, minden entitáshoz és minden gyűjteményben olyan erőforrások.</span><span class="sxs-lookup"><span data-stu-id="7c98e-169">In REST terms, each entity and each collection are resources.</span></span> <span data-ttu-id="7c98e-170">A RESTful webes API-k egyes gyűjtemények belül a webszolgáltatás a saját URI tartozik, és egy gyűjtemény URI keresztül hajtja végre a HTTP GET kérelemre lekér egy listát azokról a gyűjtemény elemeinek.</span><span class="sxs-lookup"><span data-stu-id="7c98e-170">In a RESTful web API, each collection has its own URI within the web service, and performing an HTTP GET request over a URI for a collection retrieves a list of items in that collection.</span></span> <span data-ttu-id="7c98e-171">Az egyes elemekre is a saját URI-azonosító tartozik, és egy alkalmazás elküldheti az adott URI-Beállításokkal történő részleteinek lehívására szolgáló, hogy az elem egy másik HTTP GET kérést.</span><span class="sxs-lookup"><span data-stu-id="7c98e-171">Each individual item also has its own URI, and an application can submit another HTTP GET request using that URI to retrieve the details of that item.</span></span> <span data-ttu-id="7c98e-172">Az URI-azonosítók gyűjteményekhez és elemeket kell szervezni hierarchikus elrendezését.</span><span class="sxs-lookup"><span data-stu-id="7c98e-172">You should organize the URIs for collections and items in a hierarchical manner.</span></span> <span data-ttu-id="7c98e-173">A kereskedelmi rendszerben, az URI */customers* azt jelzi, a felhasználói gyűjteménybe, és */ügyfelek/5* részleteit lekéri az egyetlen ügyfél az azonosító 5 ebből a gyűjteményből.</span><span class="sxs-lookup"><span data-stu-id="7c98e-173">In the ecommerce system, the URI */customers* denotes the customer’s collection, and */customers/5* retrieves the details for the single customer with the ID 5 from this collection.</span></span> <span data-ttu-id="7c98e-174">Ez a megközelítés segít távol tartani nyújt a webes API-k intuitív.</span><span class="sxs-lookup"><span data-stu-id="7c98e-174">This approach helps to keep the web API intuitive.</span></span>

> [!TIP]
> <span data-ttu-id="7c98e-175">Az URI-azonosítók; egységes elnevezési elfogadása általában segít, hogy a referencia-gyűjtemények használata többes számú főnevek az URI-azonosítók.</span><span class="sxs-lookup"><span data-stu-id="7c98e-175">Adopt a consistent naming convention in URIs; in general it helps to use plural nouns for URIs that reference collections.</span></span>
>
>

<span data-ttu-id="7c98e-176">Is kell figyelembe venni a különböző típusú erőforrások, és hogyan akkor esetleg felfedi a társításokat közötti kapcsolatokat.</span><span class="sxs-lookup"><span data-stu-id="7c98e-176">You also need to consider the relationships between different types of resources and how you might expose these associations.</span></span> <span data-ttu-id="7c98e-177">Például az ügyfelek helyezhet nulla vagy több rendelés.</span><span class="sxs-lookup"><span data-stu-id="7c98e-177">For example, customers may place zero or more orders.</span></span> <span data-ttu-id="7c98e-178">Ezt a kapcsolatot képviselő természetes módon lenne egy URI segítségével például */customers/5/orders* ügyfél 5 a rendeléseket kereséséhez.</span><span class="sxs-lookup"><span data-stu-id="7c98e-178">A natural way to represent this relationship would be through a URI such as */customers/5/orders* to find all the orders for customer 5.</span></span> <span data-ttu-id="7c98e-179">Érdemes megfontolnia a társítás megrendelés vissza az adott ügyfélhez egy URI segítségével például képviselő */orders/99/customer* az ügyfél található rendelés 99, de ez a modell túlságosan válhat nehézkes lehet kiterjesztése valósítja meg.</span><span class="sxs-lookup"><span data-stu-id="7c98e-179">You might also consider representing the association from an order back to a specific customer through a URI such as */orders/99/customer* to find the customer for order 99, but extending this model too far can become cumbersome to implement.</span></span> <span data-ttu-id="7c98e-180">Jobb megoldás az, hogy hajózható kapcsolatot kapcsolódó erőforrások, például az ügyfél a HTTP-válaszüzenetnek értéket adott vissza a sorrendet le kell kérdezni törzsében.</span><span class="sxs-lookup"><span data-stu-id="7c98e-180">A better solution is to provide navigable links to associated resources, such as the customer, in the body of the HTTP response message returned when the order is queried.</span></span> <span data-ttu-id="7c98e-181">A mechanizmus navigációs engedélyezése a kapcsolódó erőforrások HATEOAS módszert használva ez az útmutató későbbi szakaszában a szakaszban részletesen ismertetett.</span><span class="sxs-lookup"><span data-stu-id="7c98e-181">This mechanism is described in more detail in the section Using the HATEOAS Approach to Enable Navigation To Related Resources later in this guidance.</span></span>

<span data-ttu-id="7c98e-182">Összetettebb rendszereken előfordulhat többféle típusú entitás, és azok tempting URI-azonosítók, amelyek lehetővé teszik több szintet kapcsolatokat, például a navigálni ügyfélalkalmazás biztosításához */customers/1/orders/99/products* számára Szerezze be az ügyfél 1 elhelyezett 99 sorrendben termékek listáját.</span><span class="sxs-lookup"><span data-stu-id="7c98e-182">In more complex systems there may be many more types of entity, and it can be tempting to provide URIs that enable a client application to navigate through several levels of relationships, such as */customers/1/orders/99/products* to obtain the list of products in order 99 placed by customer 1.</span></span> <span data-ttu-id="7c98e-183">Azonban ez a szint összetettségi nehéz lehet karbantartása és rugalmatlan, ha erőforrásainak kapcsolatai később módosíthatja.</span><span class="sxs-lookup"><span data-stu-id="7c98e-183">However, this level of complexity can be difficult to maintain and is inflexible if the relationships between resources change in the future.</span></span> <span data-ttu-id="7c98e-184">Ehelyett kell törekedni tartsa URI-azonosítók viszonylag egyszerű.</span><span class="sxs-lookup"><span data-stu-id="7c98e-184">Rather, you should seek to keep URIs relatively simple.</span></span> <span data-ttu-id="7c98e-185">Figyelembe kell vennie, hogy az alkalmazás legalább egy erőforráshoz, amennyiben lehetővé kell tenni ezt a hivatkozást használata erőforráshoz kapcsolódó elemek kereséséhez.</span><span class="sxs-lookup"><span data-stu-id="7c98e-185">Bear in mind that once an application has a reference to a resource, it should be possible to use this reference to find items related to that resource.</span></span> <span data-ttu-id="7c98e-186">Az előző lekérdezés az URI azonosító lehet cserélni */customers/1/orders* található összes ügyfél 1 rendelés, majd lekérdezheti és az URI */orders/99/products* (feltéve, sorrendben sorrendje a termékek kereséséhez 99 helyezte ügyfél 1).</span><span class="sxs-lookup"><span data-stu-id="7c98e-186">The preceding query can be replaced with the URI */customers/1/orders* to find all the orders for customer 1, and then query the URI */orders/99/products* to find the products in this order (assuming order 99 was placed by customer 1).</span></span>

> [!TIP]
> <span data-ttu-id="7c98e-187">Kerülni, hogy az erőforrás URI-azonosítók eddigieknél még bonyolultabbá kelljen *gyűjtemény/elemgyűjtemény*.</span><span class="sxs-lookup"><span data-stu-id="7c98e-187">Avoid requiring resource URIs more complex than *collection/item/collection*.</span></span>
>
>

<span data-ttu-id="7c98e-188">Egy másik és megfontolandó szempont, hogy minden webes kérésnek ugyanazok a kiszolgáló terhelése, de minél nagyobb a kérelmek száma nagyobb a terhelést.</span><span class="sxs-lookup"><span data-stu-id="7c98e-188">Another point to consider is that all web requests impose a load on the web server, and the greater the number of requests the bigger the load.</span></span> <span data-ttu-id="7c98e-189">Meg kell próbálni határozza meg az erőforrások "chatty" webes API-k kis erőforrások nagy számú visszaállítását elkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="7c98e-189">You should attempt to define your resources to avoid “chatty” web APIs that expose a large number of small resources.</span></span> <span data-ttu-id="7c98e-190">Ilyen az API-k több kérelmek elküldése a szükséges adatok ügyfélalkalmazás lehet szükség.</span><span class="sxs-lookup"><span data-stu-id="7c98e-190">Such an API may require a client application to submit multiple requests to find all the data that it requires.</span></span> <span data-ttu-id="7c98e-191">Akkor lehet hasznos adatok denormalize és egyesítése egyetlen kérelmet lekérhetők nagyobb erőforrások együtt történő kapcsolódó információk.</span><span class="sxs-lookup"><span data-stu-id="7c98e-191">It may be beneficial to denormalize data and combine related information together into bigger resources that can be retrieved by issuing a single request.</span></span> <span data-ttu-id="7c98e-192">Azonban kell ezt a módszert használja a terhelést növelni az adatok, amelyek nem gyakran szüksége lehet az ügyfél beolvasása elleni elosztása érdekében.</span><span class="sxs-lookup"><span data-stu-id="7c98e-192">However, you need to balance this approach against the overhead of fetching data that might not be frequently required by the client.</span></span> <span data-ttu-id="7c98e-193">Nagy objektumok beolvasása növelje a Tiltás késése a kérelmet, és fel Önnek további sávszélességgel kapcsolatos költségek származik sok előnye az, ha a további adatok nem gyakran használják.</span><span class="sxs-lookup"><span data-stu-id="7c98e-193">Retrieving large objects can increase the latency of a request and incur additional bandwidth costs for little advantage if the additional data is not often used.</span></span>

<span data-ttu-id="7c98e-194">Ne vezet be, a webes API-t a struktúra, típus vagy hely alapul szolgáló adatforrások közötti függőségek.</span><span class="sxs-lookup"><span data-stu-id="7c98e-194">Avoid introducing dependencies between the web API to the structure, type, or location of the underlying data sources.</span></span> <span data-ttu-id="7c98e-195">Például ha az adatok egy relációs adatbázisban található, a webes API nem kell olyan erőforrások gyűjteménye, mint minden tábla közzétételét.</span><span class="sxs-lookup"><span data-stu-id="7c98e-195">For example, if your data is located in a relational database, the web API does not need to expose each table as a collection of resources.</span></span> <span data-ttu-id="7c98e-196">Gondolja át, hogy a webes API-t, az adatbázis absztrakciós, és szükség esetén szükség leképezési réteg az adatbázis és a webes API-k között.</span><span class="sxs-lookup"><span data-stu-id="7c98e-196">Think of the web API as an abstraction of the database, and if necessary introduce a mapping layer between the database and the web API.</span></span> <span data-ttu-id="7c98e-197">Ily módon, ha megváltozik a Tervező vagy az adatbázis végrehajtásának (például a védelemről egy relációs adatbázisban, egy nosql-alapú denormalizált tárolórendszer, például egy dokumentum-adatbázis normalizált táblázatokat gyűjteményét tartalmazó) ügyfélalkalmazások megfelelően a módosítások.</span><span class="sxs-lookup"><span data-stu-id="7c98e-197">In this way, if the design or implementation of the database changes (for example, you move from a relational database containing a collection of normalized tables to a denormalized NoSQL storage system such as a document database) client applications are insulated from these changes.</span></span>

> [!TIP]
> <span data-ttu-id="7c98e-198">Egy webes API ösztönzője adatok forrása nem kell a tárolóban; Ez lehet egy másik szolgáltatás vagy sor üzleti alkalmazás vagy akár egy örökölt alkalmazást futtató helyi szervezeten belül.</span><span class="sxs-lookup"><span data-stu-id="7c98e-198">The source of the data that underpins a web API does not have to be a data store; it could be another service or line-of-business application or even a legacy application running on-premises within an organization.</span></span>
>
>

<span data-ttu-id="7c98e-199">Végül hogy előfordulhat, hogy nem lehet megfeleltetni minden műveletet a webes API-k egy adott erőforrás által megvalósított.</span><span class="sxs-lookup"><span data-stu-id="7c98e-199">Finally, it might not be possible to map every operation implemented by a web API to a specific resource.</span></span> <span data-ttu-id="7c98e-200">Például kezelheti *nem erőforrás-* forgatókönyvek meghívni egy adott funkciót, és térjen vissza az eredményeket egy HTTP-válaszüzenetnek, HTTP GET kérelmek keresztül.</span><span class="sxs-lookup"><span data-stu-id="7c98e-200">You can handle such *non-resource* scenarios through HTTP GET requests that invoke a piece of functionality and return the results as an HTTP response message.</span></span> <span data-ttu-id="7c98e-201">A webes API-ja, amely megvalósítja az egyszerű számológép stílusú műveletek, mint hozzáadása, és kivonás teszi közzé a pszeudo erőforrásként ezeket a műveleteket, és a lekérdezési karakterlánc szükséges paramétereket felhasználását URI azonosítók biztosítani.</span><span class="sxs-lookup"><span data-stu-id="7c98e-201">A web API that implements simple calculator-style operations such as add and subtract could provide URIs that expose these operations as pseudo resources and utilize the query string to specify the parameters required.</span></span> <span data-ttu-id="7c98e-202">Például egy GET kérelem URI */ add? operand1 99 & operand2 = = 1* képes vissza válaszüzenetet 100 értéket tartalmazó szervezethez, és az URI kérelmek *kivonás /? operand1 = 50 & operand2 = 20* 30 értéket tartalmazó törzsű sikerült vissza válaszüzenetet.</span><span class="sxs-lookup"><span data-stu-id="7c98e-202">For example a GET request to the URI */add?operand1=99&operand2=1* could return a response message with the body containing the value 100, and GET request to the URI */subtract?operand1=50&operand2=20* could return a response message with the body containing the value 30.</span></span> <span data-ttu-id="7c98e-203">Azonban csak ezek forma közül választhat URI-azonosítók módjával.</span><span class="sxs-lookup"><span data-stu-id="7c98e-203">However, only use these forms of URIs sparingly.</span></span>

### <a name="defining-operations-in-terms-of-http-methods"></a><span data-ttu-id="7c98e-204">HTTP-metódus műveletek meghatározása</span><span class="sxs-lookup"><span data-stu-id="7c98e-204">Defining operations in terms of HTTP methods</span></span>
<span data-ttu-id="7c98e-205">A HTTP protokoll számos módszer, amely a szemantikai jelentés hozzárendelése egy kérelem határozza meg.</span><span class="sxs-lookup"><span data-stu-id="7c98e-205">The HTTP protocol defines a number of methods that assign semantic meaning to a request.</span></span> <span data-ttu-id="7c98e-206">A legtöbb RESTful webes API-k által használt közös HTTP megoldások a következők:</span><span class="sxs-lookup"><span data-stu-id="7c98e-206">The common HTTP methods used by most RESTful web APIs are:</span></span>

* <span data-ttu-id="7c98e-207">**ELSŐ**, beolvasni az erőforrás a megadott URI-t egy példányát.</span><span class="sxs-lookup"><span data-stu-id="7c98e-207">**GET**, to retrieve a copy of the resource at the specified URI.</span></span> <span data-ttu-id="7c98e-208">A szervezet a válaszüzenet a kért erőforrás részleteit tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="7c98e-208">The body of the response message contains the details of the requested resource.</span></span>
* <span data-ttu-id="7c98e-209">**POST**, új erőforrás létrehozása a megadott URI-t.</span><span class="sxs-lookup"><span data-stu-id="7c98e-209">**POST**, to create a new resource at the specified URI.</span></span> <span data-ttu-id="7c98e-210">A kérelem üzenet törzsét részletesen bemutatja az új erőforrás.</span><span class="sxs-lookup"><span data-stu-id="7c98e-210">The body of the request message provides the details of the new resource.</span></span> <span data-ttu-id="7c98e-211">Vegye figyelembe, hogy POST is használható, amelyek ténylegesen ne hozzon létre erőforrások műveleteket indítsanak.</span><span class="sxs-lookup"><span data-stu-id="7c98e-211">Note that POST can also be used to trigger operations that don't actually create resources.</span></span>
* <span data-ttu-id="7c98e-212">**PUT**, és cserélje le a megadott URI azonosító helyen található erőforrás frissítése.</span><span class="sxs-lookup"><span data-stu-id="7c98e-212">**PUT**, to replace or update the resource at the specified URI.</span></span> <span data-ttu-id="7c98e-213">A kérelem üzenet törzsét határozza meg, a módosítani kívánt erőforrás és az alkalmazni kívánt értékeket.</span><span class="sxs-lookup"><span data-stu-id="7c98e-213">The body of the request message specifies the resource to be modified and the values to be applied.</span></span>
* <span data-ttu-id="7c98e-214">**Törlés**, hogy távolítsa el az erőforrás a megadott URI-t.</span><span class="sxs-lookup"><span data-stu-id="7c98e-214">**DELETE**, to remove the resource at the specified URI.</span></span>

> [!NOTE]
> <span data-ttu-id="7c98e-215">A HTTP protokollt is meghatároz más kevesebb mint a gyakran használt módszerek, például a javítás, amellyel szelektív frissítést lehessen egy erőforrást, HEAD, amely kérhet egy erőforrás leírása, beállítások, amely lehetővé teszi a rájuk vonatkozó információ beszerzéséhez egy ügyfél-információt kérő a kommunikációs lehetőségekről, a kiszolgáló és a NYOMKÖVETÉSI, amely lehetővé teszi a tesztelés és diagnosztikai célokra használhat kérelmekkel kapcsolatos információ az ügyfél által támogatott.</span><span class="sxs-lookup"><span data-stu-id="7c98e-215">The HTTP protocol also defines other less commonly-used methods, such as PATCH which is used to request selective updates to a resource, HEAD which is used to request a description of a resource, OPTIONS which enables a client information to obtain information about the communication options supported by the server, and TRACE which allows a client to request information that it can use for testing and diagnostics purposes.</span></span>
>
>

<span data-ttu-id="7c98e-216">Egy adott kérelem hatásának függ-e az erőforrást, amely érvényben van a gyűjtemény vagy egy egyéni elemet.</span><span class="sxs-lookup"><span data-stu-id="7c98e-216">The effect of a specific request should depend on whether the resource to which it is applied is a collection or an individual item.</span></span> <span data-ttu-id="7c98e-217">A következő táblázat összefoglalja az kereskedelmi példát a RESTful megvalósítások által elfogadott közös szabályok.</span><span class="sxs-lookup"><span data-stu-id="7c98e-217">The following table summarizes the common conventions adopted by most RESTful implementations using the ecommerce example.</span></span> <span data-ttu-id="7c98e-218">Vegye figyelembe, hogy ezek a kérelmek nem az összes is elegendő lehet; az adott forgatókönyv függ.</span><span class="sxs-lookup"><span data-stu-id="7c98e-218">Note that not all of these requests might be implemented; it depends on the specific scenario.</span></span>

| <span data-ttu-id="7c98e-219">**Erőforrás**</span><span class="sxs-lookup"><span data-stu-id="7c98e-219">**Resource**</span></span> | <span data-ttu-id="7c98e-220">**POST**</span><span class="sxs-lookup"><span data-stu-id="7c98e-220">**POST**</span></span> | <span data-ttu-id="7c98e-221">**GET**</span><span class="sxs-lookup"><span data-stu-id="7c98e-221">**GET**</span></span> | <span data-ttu-id="7c98e-222">**A PUT**</span><span class="sxs-lookup"><span data-stu-id="7c98e-222">**PUT**</span></span> | <span data-ttu-id="7c98e-223">**TÖRLÉSE**</span><span class="sxs-lookup"><span data-stu-id="7c98e-223">**DELETE**</span></span> |
| --- | --- | --- | --- | --- |
| <span data-ttu-id="7c98e-224">/Customers</span><span class="sxs-lookup"><span data-stu-id="7c98e-224">/customers</span></span> |<span data-ttu-id="7c98e-225">Hozzon létre egy új ügyfél</span><span class="sxs-lookup"><span data-stu-id="7c98e-225">Create a new customer</span></span> |<span data-ttu-id="7c98e-226">Összes ügyfél beolvasása</span><span class="sxs-lookup"><span data-stu-id="7c98e-226">Retrieve all customers</span></span> |<span data-ttu-id="7c98e-227">Tömeges frissítés vevők (*Ha megvalósított*)</span><span class="sxs-lookup"><span data-stu-id="7c98e-227">Bulk update of customers (*if implemented*)</span></span> |<span data-ttu-id="7c98e-228">Távolítsa el az összes ügyfél számára</span><span class="sxs-lookup"><span data-stu-id="7c98e-228">Remove all customers</span></span> |
| <span data-ttu-id="7c98e-229">/ ügyfelek/1</span><span class="sxs-lookup"><span data-stu-id="7c98e-229">/customers/1</span></span> |<span data-ttu-id="7c98e-230">Hiba</span><span class="sxs-lookup"><span data-stu-id="7c98e-230">Error</span></span> |<span data-ttu-id="7c98e-231">Ügyfél 1 adatainak beolvasása</span><span class="sxs-lookup"><span data-stu-id="7c98e-231">Retrieve the details for customer 1</span></span> |<span data-ttu-id="7c98e-232">A adatainak frissítéséhez ügyfél 1 Ha létezik, vagy visszatérési hiba</span><span class="sxs-lookup"><span data-stu-id="7c98e-232">Update the details of customer 1 if it exists, otherwise return an error</span></span> |<span data-ttu-id="7c98e-233">Távolítsa el az ügyfél 1</span><span class="sxs-lookup"><span data-stu-id="7c98e-233">Remove customer 1</span></span> |
| <span data-ttu-id="7c98e-234">/Customers/1/orders</span><span class="sxs-lookup"><span data-stu-id="7c98e-234">/customers/1/orders</span></span> |<span data-ttu-id="7c98e-235">Hozzon létre egy új ahhoz, hogy az ügyfél 1</span><span class="sxs-lookup"><span data-stu-id="7c98e-235">Create a new order for customer 1</span></span> |<span data-ttu-id="7c98e-236">Ügyfél 1 összes rendelés beolvasása</span><span class="sxs-lookup"><span data-stu-id="7c98e-236">Retrieve all orders for customer 1</span></span> |<span data-ttu-id="7c98e-237">Tömeges frissítés rendelések ügyfél 1 (*Ha megvalósított*)</span><span class="sxs-lookup"><span data-stu-id="7c98e-237">Bulk update of orders for customer 1 (*if implemented*)</span></span> |<span data-ttu-id="7c98e-238">Távolítsa el az összes rendelés ügyfél 1 (*Ha megvalósított*)</span><span class="sxs-lookup"><span data-stu-id="7c98e-238">Remove all orders for customer 1(*if implemented*)</span></span> |

<span data-ttu-id="7c98e-239">A GET és DELETE kérelmek célját viszonylag egyszerű, de a cél és a POST és a PUT kérelmek hatásait kapcsolatos zavarok hatóköre van.</span><span class="sxs-lookup"><span data-stu-id="7c98e-239">The purpose of GET and DELETE requests are relatively straightforward, but there is scope for confusion concerning the purpose and effects of POST and PUT requests.</span></span>

<span data-ttu-id="7c98e-240">Egy POST kérést hozzon létre egy új erőforrást a kérés törzsében megadott adatokkal.</span><span class="sxs-lookup"><span data-stu-id="7c98e-240">A POST request should create a new resource with data provided in the body of the request.</span></span> <span data-ttu-id="7c98e-241">A többi modell gyakran alkalmaz POST-kérésnél az erőforrásokat, amelyek a gyűjtemények; az új erőforrás van hozzá a gyűjteményhez.</span><span class="sxs-lookup"><span data-stu-id="7c98e-241">In the REST model, you frequently apply POST requests to resources that are collections; the new resource is added to the collection.</span></span>

> [!NOTE]
> <span data-ttu-id="7c98e-242">Azt is megadhatja a POST kérelmek, amelyek indul el, hogy bizonyos funkciók (és, amely nem feltétlenül vissza adatokat), és az ilyen típusú kérelmet gyűjteményekre alkalmazhatók.</span><span class="sxs-lookup"><span data-stu-id="7c98e-242">You can also define POST requests that trigger some functionality (and that don't necessarily return data), and these types of request can be applied to collections.</span></span> <span data-ttu-id="7c98e-243">Használhat például egy POST kérést a időrendben átadása egy bérlista-feldolgozó szolgáltatás, és a számított adók vissza válaszként.</span><span class="sxs-lookup"><span data-stu-id="7c98e-243">For example you could use a POST request to pass a timesheet to a payroll processing service and get the calculated taxes back as a response.</span></span>
>
>

<span data-ttu-id="7c98e-244">Egy PUT-kérelmekben célja, hogy módosítsa a meglévő erőforrás.</span><span class="sxs-lookup"><span data-stu-id="7c98e-244">A PUT request is intended to modify an existing resource.</span></span> <span data-ttu-id="7c98e-245">Ha a megadott erőforrás nem létezik, a PUT kérés visszaadhatja hiba (néhány esetben az lehet, hogy ténylegesen létrehozása az erőforrás).</span><span class="sxs-lookup"><span data-stu-id="7c98e-245">If the specified resource does not exist, the PUT request could return an error (in some cases, it might actually create the resource).</span></span> <span data-ttu-id="7c98e-246">PUT kérelmek leggyakrabban érvényesek erőforrásokhoz (például egy adott ügyfélhez vagy a sorrendben), az egyes elemek bár alkalmazhatók a gyűjteményekhez, bár ez általában kevésbé van megvalósítva.</span><span class="sxs-lookup"><span data-stu-id="7c98e-246">PUT requests are most frequently applied to resources that are individual items (such as a specific customer or order), although they can be applied to collections, although this is less-commonly implemented.</span></span> <span data-ttu-id="7c98e-247">Vegye figyelembe, hogy a PUT kérelmek idempotent, mivel a POST kérelmek nem; Ha egy alkalmazás elküldi a azonos PUT kérés többször az eredmények mindig meg kell egyeznie (az azonos erőforrás módosulnak ugyanazokat az értékeket), de ha egy alkalmazás ismétlődik a azonos POST kérelem eredménye több erőforrás létrehozása.</span><span class="sxs-lookup"><span data-stu-id="7c98e-247">Note that PUT requests are idempotent whereas POST requests are not; if an application submits the same PUT request multiple times the results should always be the same (the same resource will be modified with the same values), but if an application repeats the same POST request the result will be the creation of multiple resources.</span></span>

> [!NOTE]
> <span data-ttu-id="7c98e-248">Szigorúan fogalmazva egy HTTP PUT-kérelmet meglévő erőforrás lecseréli a kérés törzsében megadott erőforrás.</span><span class="sxs-lookup"><span data-stu-id="7c98e-248">Strictly speaking, an HTTP PUT request replaces an existing resource with the resource specified in the body of the request.</span></span> <span data-ttu-id="7c98e-249">Ha nem módosítja a kiválasztott erőforrás-tulajdonságokat, de más tulajdonságok változatlanul hagyja kívánja, majd ezt kell végrehajtani egy javítás HTTP-kérelem használatával.</span><span class="sxs-lookup"><span data-stu-id="7c98e-249">If the intention is to modify a selection of properties in a resource but leave other properties unchanged, then this should be implemented by using an HTTP PATCH request.</span></span> <span data-ttu-id="7c98e-250">Számos RESTful megvalósítását azonban ez a szabály enyhíteni, és mindkét szituációkban PUT használható.</span><span class="sxs-lookup"><span data-stu-id="7c98e-250">However, many RESTful implementations relax this rule and use PUT for both situations.</span></span>
>
>

### <a name="processing-http-requests"></a><span data-ttu-id="7c98e-251">HTTP-kérelmek feldolgozása</span><span class="sxs-lookup"><span data-stu-id="7c98e-251">Processing HTTP requests</span></span>
<span data-ttu-id="7c98e-252">Egy ügyfélalkalmazás a webkiszolgálóról a HTTP-kérelmekre, és a megfelelő válaszüzenetek által tartalmazott adatokkal sikerült jelenik meg a különböző formátumokban (vagy az adathordozók típusairól).</span><span class="sxs-lookup"><span data-stu-id="7c98e-252">The data included by a client application in many HTTP requests, and the corresponding response messages from the web server, could be presented in a variety of formats (or media types).</span></span> <span data-ttu-id="7c98e-253">Például az adatokat, amely meghatározza egy ügyfél vagy a rendelés részleteit XML, JSON vagy valamilyen más kódolt és tömörített formátumú lehet megadni.</span><span class="sxs-lookup"><span data-stu-id="7c98e-253">For example, the data that specifies the details for a customer or order could be provided as XML, JSON, or some other encoded and compressed format.</span></span> <span data-ttu-id="7c98e-254">A RESTful webes API támogatnia kell a különböző típusú kérést ügyfél alkalmazás által kért.</span><span class="sxs-lookup"><span data-stu-id="7c98e-254">A RESTful web API should support different media types as requested by the client application that submits a request.</span></span>

<span data-ttu-id="7c98e-255">Amikor egy ügyfél-alkalmazás, amely visszaadja az adatokat egy üzenet törzsében kérelmet küld, az adathordozók típusairól is képes kezelni az elfogadás a kérelem fejlécében határozhatja meg.</span><span class="sxs-lookup"><span data-stu-id="7c98e-255">When a client application sends a request that returns data in the body of a message, it can specify the media types it can handle in the Accept header of the request.</span></span> <span data-ttu-id="7c98e-256">Az alábbi kód bemutatja a HTTP GET kérelemre, amely lekéri 2 rendelés részleteit, és az eredményt a adódik vissza (az az ügyfél továbbra is kell vizsgálni az adathordozó-típusát a visszaadott adatok formátumának ellenőrzése a válaszban szereplő adatok) JSON-kérelmek :</span><span class="sxs-lookup"><span data-stu-id="7c98e-256">The following code illustrates an HTTP GET request that retrieves the details of order 2 and requests the result to be returned as JSON (the client should still examine the media type of the data in the response to verify the format of the data returned):</span></span>

```HTTP
GET http://adventure-works.com/orders/2 HTTP/1.1
...
Accept: application/json
...
```

<span data-ttu-id="7c98e-257">Ha a webkiszolgálón az adathordozó-típus, megválaszolhatja azt egy választ, amely magában foglalja a Content-Type fejléc, amely megadja az adatok formátumát az üzenet törzsében:</span><span class="sxs-lookup"><span data-stu-id="7c98e-257">If the web server supports this media type, it can reply with a response that includes Content-Type header that specifies the format of the data in the body of the message:</span></span>

> [!NOTE]
> <span data-ttu-id="7c98e-258">A maximális való együttműködés az adathordozót az elfogadás és a Content-Type fejléc a hivatkozott típusok kell lennie, hanem néhány egyéni médiatípus felismerni MIME-típusok.</span><span class="sxs-lookup"><span data-stu-id="7c98e-258">For maximum interoperability, the media types referenced in the Accept and Content-Type headers should be recognized MIME types rather than some custom media type.</span></span>
>
>

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"orderID":2,"productID":4,"quantity":2,"orderValue":10.00}
```

<span data-ttu-id="7c98e-259">A webalkalmazás-kiszolgáló nem támogatja a kért adathordozó-típust, ha más formátumban is küldheti az adatokat.</span><span class="sxs-lookup"><span data-stu-id="7c98e-259">If the web server does not support the requested media type, it can send the data in a different format.</span></span> <span data-ttu-id="7c98e-260">Minden esetben meg kell határoznia azt az adathordozó típusát (pl. *az application/json*) a Content-Type fejléc.</span><span class="sxs-lookup"><span data-stu-id="7c98e-260">IN all cases it must specify the media type (such as *application/json*) in the Content-Type header.</span></span> <span data-ttu-id="7c98e-261">A feladata az ügyfélalkalmazás elemzi a válaszüzenetet, és az eredményeket az üzenettörzs megfelelően értelmezni.</span><span class="sxs-lookup"><span data-stu-id="7c98e-261">It is the responsibility of the client application to parse the response message and interpret the results in the message body appropriately.</span></span>

<span data-ttu-id="7c98e-262">Ne feledje, hogy ebben a példában a webalkalmazás-kiszolgáló sikeresen kéri le a kért adatokat úgy, hogy a válaszfejlécet vissza 200 állapotkódot sikert jelez.</span><span class="sxs-lookup"><span data-stu-id="7c98e-262">Note that in this example, the web server successfully retrieves the requested data and indicates success by passing back a status code of 200 in the response header.</span></span> <span data-ttu-id="7c98e-263">Ha nem egyező adatokat, ehelyett az kell visszaadnia (nem található) 404 állapotkódot, és a válasz üzenet törzsét további információkat is tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="7c98e-263">If no matching data is found, it should instead return a status code of 404 (not found) and the body of the response message can contain additional information.</span></span> <span data-ttu-id="7c98e-264">Ez az információ formátuma van megadva a Content-Type fejléc a következő példában látható módon:</span><span class="sxs-lookup"><span data-stu-id="7c98e-264">The format of this information is specified by the Content-Type header, as shown in the following example:</span></span>

```HTTP
GET http://adventure-works.com/orders/222 HTTP/1.1
...
Accept: application/json
...
```

<span data-ttu-id="7c98e-265">Rendelés 222 nem létezik, ezért a válaszüzenetet néz ki:</span><span class="sxs-lookup"><span data-stu-id="7c98e-265">Order 222 does not exist, so the response message looks like this:</span></span>

```HTTP
HTTP/1.1 404 Not Found
...
Content-Type: application/json; charset=utf-8
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"message":"No such order"}
```

<span data-ttu-id="7c98e-266">Amikor egy alkalmazás egy erőforrás frissítése egy HTTP PUT-kérelmet küld, azt határozza meg az erőforrás URI, és adja meg a kérelem üzenet törzsét módosítani adatait.</span><span class="sxs-lookup"><span data-stu-id="7c98e-266">When an application sends an HTTP PUT request to update a resource, it specifies the URI of the resource and provides the data to be modified in the body of the request message.</span></span> <span data-ttu-id="7c98e-267">Akkor kell is használatával adja meg az adatok formátumát az a Content-Type fejléc.</span><span class="sxs-lookup"><span data-stu-id="7c98e-267">It should also specify the format of this data by using the Content-Type header.</span></span> <span data-ttu-id="7c98e-268">Egy általános szöveges információ használt formátuma *alkalmazás/x-www-form-urlencoded*, amely magában foglalja a elválasztott név/érték párok halmaza a & karakter.</span><span class="sxs-lookup"><span data-stu-id="7c98e-268">A common format used for text-based information is *application/x-www-form-urlencoded*, which comprises a set of name/value pairs separated by the & character.</span></span> <span data-ttu-id="7c98e-269">A következő példa bemutatja, egy HTTP PUT kérelmet, amely 1 sorrendben adatainak módosítása:</span><span class="sxs-lookup"><span data-stu-id="7c98e-269">The next example shows an HTTP PUT request that modifies the information in order 1:</span></span>

```HTTP
PUT http://adventure-works.com/orders/1 HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
ProductID=3&Quantity=5&OrderValue=250
```

<span data-ttu-id="7c98e-270">Sikeres a módosítás esetén azt kell ideális válaszol egy HTTP 204-es állapotkód, amely azt jelzi, hogy a folyamat sikeresen kezelve van azonban, hogy az adott válasz törzsének tartalmazza-e további információ.</span><span class="sxs-lookup"><span data-stu-id="7c98e-270">If the modification is successful, it should ideally respond with an HTTP 204 status code, indicating that the process has been successfully handled, but that the response body contains no further information.</span></span> <span data-ttu-id="7c98e-271">A hely egy fejléc a következő a válasz URI-azonosítója az újonnan frissített erőforrás tartalmazza:</span><span class="sxs-lookup"><span data-stu-id="7c98e-271">The Location header in the response contains the URI of the newly updated resource:</span></span>

```HTTP
HTTP/1.1 204 No Content
...
Location: http://adventure-works.com/orders/1
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
```

> [!TIP]
> <span data-ttu-id="7c98e-272">Ha egy HTTP PUT kérelemüzenet dátum-és szerepel, ellenőrizze, hogy a webszolgáltatás dátumok fogad-e, és időpontokban formátuma a következő az ISO 8601 szabványnak.</span><span class="sxs-lookup"><span data-stu-id="7c98e-272">If the data in an HTTP PUT request message includes date and time information, make sure that your web service accepts dates and times formatted following the ISO 8601 standard.</span></span>
>
>

<span data-ttu-id="7c98e-273">Ha frissítenie kell az erőforrás nem létezik, a webalkalmazás-kiszolgáló nem talált választ válaszolhassanak, a fentebb leírt módon.</span><span class="sxs-lookup"><span data-stu-id="7c98e-273">If the resource to be updated does not exist, the web server can respond with a Not Found response as described earlier.</span></span> <span data-ttu-id="7c98e-274">Azt is megteheti Ha a kiszolgáló tényleges hoz létre az objektum az sikerült visszaadnia állapotát kódok HTTP 200 (OK) vagy HTTP 201-es (létrehozva) és az adott válasz törzsének tartalmazhatnak az adatokat az új erőforrás.</span><span class="sxs-lookup"><span data-stu-id="7c98e-274">Alternatively, if the server actually creates the object itself it could return the status codes HTTP 200 (OK) or HTTP 201 (Created) and the response body could contain the data for the new resource.</span></span> <span data-ttu-id="7c98e-275">Ha a kérelemben Content-Type fejlécében a webkiszolgáló nem tudja kezelni adatok formátuma nem határoz meg, azt kell válaszolnia HTTP-állapotkód 415 (nem támogatott adathordozó-típust).</span><span class="sxs-lookup"><span data-stu-id="7c98e-275">If the Content-Type header of the request specifies a data format that the web server cannot handle, it should respond with HTTP status code 415 (Unsupported Media Type).</span></span>

> [!TIP]
> <span data-ttu-id="7c98e-276">Vegye figyelembe, hogy csak egy erőforráshoz egy gyűjtemény frissítések kötegelhető tömeges HTTP PUT műveletek végrehajtása.</span><span class="sxs-lookup"><span data-stu-id="7c98e-276">Consider implementing bulk HTTP PUT operations that can batch updates to multiple resources in a collection.</span></span> <span data-ttu-id="7c98e-277">A PUT kérés URI-azonosítója a gyűjteményt kell megadnia, és a kérés törzsében adja meg a módosítani kívánt erőforrások részleteit.</span><span class="sxs-lookup"><span data-stu-id="7c98e-277">The PUT request should specify the URI of the collection, and the request body should specify the details of the resources to be modified.</span></span> <span data-ttu-id="7c98e-278">Ez a megközelítés segíthet chattiness csökkentéséhez és a teljesítmény javításához.</span><span class="sxs-lookup"><span data-stu-id="7c98e-278">This approach can help to reduce chattiness and improve performance.</span></span>
>
>

<span data-ttu-id="7c98e-279">A formátuma, hogy hozzon létre új erőforrásokat egy HTTP POST-kérelem hasonlóak a PUT kérelmek; az üzenettörzs tartalmazza az új erőforrás lehet hozzáadni.</span><span class="sxs-lookup"><span data-stu-id="7c98e-279">The format of an HTTP POST requests that create new resources are similar to those of PUT requests; the message body contains the details of the new resource to be added.</span></span> <span data-ttu-id="7c98e-280">Azonban az URI általában határozza meg, a gyűjteményt, amelyhez az erőforrás hozzá kell adni.</span><span class="sxs-lookup"><span data-stu-id="7c98e-280">However, the URI typically specifies the collection to which the resource should be added.</span></span> <span data-ttu-id="7c98e-281">Az alábbi példa létrehoz egy új rendelést, és hozzáadja azt a rendeléseket gyűjteményhez:</span><span class="sxs-lookup"><span data-stu-id="7c98e-281">The following example creates a new order and adds it to the orders collection:</span></span>

```HTTP
POST http://adventure-works.com/orders HTTP/1.1
...
Content-Type: application/x-www-form-urlencoded
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
productID=5&quantity=15&orderValue=400
```

<span data-ttu-id="7c98e-282">Ha a kérelem sikeres, a webkiszolgáló egy HTTP-állapotkód (létrehozva) 201 üzenet kódot kell válaszolnia.</span><span class="sxs-lookup"><span data-stu-id="7c98e-282">If the request is successful, the web server should respond with a message code with HTTP status code 201 (Created).</span></span> <span data-ttu-id="7c98e-283">A helyet megjelölő fejlécet az újonnan létrehozott erőforrás URI kell tartalmaznia, és a választörzs tartalmaznia kell egy példányát az új erőforrás; a Content-Type fejléc megadja az adatok formátumát:</span><span class="sxs-lookup"><span data-stu-id="7c98e-283">The Location header should contain the URI of the newly created resource, and the body of the response should contain a copy of the new resource; the Content-Type header specifies the format of this data:</span></span>

```HTTP
HTTP/1.1 201 Created
...
Content-Type: application/json; charset=utf-8
Location: http://adventure-works.com/orders/99
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
Content-Length: ...
{"orderID":99,"productID":5,"quantity":15,"orderValue":400}
```

> [!TIP]
> <span data-ttu-id="7c98e-284">A PUT vagy POST kérelem által megadott adat érvénytelen, ha a webkiszolgáló egy üzenetet, amelyben a HTTP-állapotkód: 400 (hibás kérés) kell válaszolnia.</span><span class="sxs-lookup"><span data-stu-id="7c98e-284">If the data provided by a PUT or POST request is invalid, the web server should respond with a message with HTTP status code 400 (Bad Request).</span></span> <span data-ttu-id="7c98e-285">Ez az üzenet törzsét a kérelem és a várt formátumok a problémával kapcsolatos további információkat is tartalmazhat, vagy tartalmazhat egy hivatkozást egy URL-címet, amely további adatokat.</span><span class="sxs-lookup"><span data-stu-id="7c98e-285">The body of this message can contain additional information about the problem with the request and the formats expected, or it can contain a link to a URL that provides more details.</span></span>
>
>

<span data-ttu-id="7c98e-286">Eltávolít egy erőforrást, egy HTTP DELETE kérelmet egyszerűen biztosít, az erőforrás URI törölhető.</span><span class="sxs-lookup"><span data-stu-id="7c98e-286">To remove a resource, an HTTP DELETE request simply provides the URI of the resource to be deleted.</span></span> <span data-ttu-id="7c98e-287">Az alábbi példa megpróbálja sorrend 99 eltávolítása:</span><span class="sxs-lookup"><span data-stu-id="7c98e-287">The following example attempts to remove order 99:</span></span>

```HTTP
DELETE http://adventure-works.com/orders/99 HTTP/1.1
...
```

<span data-ttu-id="7c98e-288">A törlési művelet végrehajtása sikeres, ha a webkiszolgáló válaszolnia kell arról, hogy a folyamat sikeresen kezelve van azonban, hogy az adott válasz törzsének tartalmazza-e további információ nem (Ez ugyanaz a válasz egy sikeres által visszaadott HTTP-állapotkód: 204, PUT művelet, de az erőforrás helye fejléc nélküli már nem létezik.) Akkor is a DELETE kérelmek HTTP-állapotkód 200 (OK) vagy 202 (elfogadható) vissza, ha a törlés aszinkron módon történik.</span><span class="sxs-lookup"><span data-stu-id="7c98e-288">If the delete operation is successful, the web server should respond with HTTP status code 204, indicating that the process has been successfully handled, but that the response body contains no further information (this is the same response returned by a successful PUT operation, but without a Location header as the resource no longer exists.) It is also possible for a DELETE request to return HTTP status code 200 (OK) or 202 (Accepted) if the deletion is performed asynchronously.</span></span>

```HTTP
HTTP/1.1 204 No Content
...
Date: Fri, 22 Aug 2014 09:18:37 GMT
```

<span data-ttu-id="7c98e-289">Ha az erőforrás nem található, a webkiszolgáló helyette 404-es (nem található) üzenet kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="7c98e-289">If the resource is not found, the web server should return a 404 (Not Found) message instead.</span></span>

> [!TIP]
> <span data-ttu-id="7c98e-290">Ha egy gyűjtemény összes erőforrása kell törölni, engedélyezése egy HTTP DELETE kérelmet kell adni az URI-azonosítója egy alkalmazást az egyes erőforrások pedig eltávolítása a gyűjteményből újraindítás helyett a gyűjteményben.</span><span class="sxs-lookup"><span data-stu-id="7c98e-290">If all the resources in a collection need to be deleted, enable an HTTP DELETE request to be specified for the URI of the collection rather than forcing an application to remove each resource in turn from the collection.</span></span>
>
>

### <a name="filtering-and-paginating-data"></a><span data-ttu-id="7c98e-291">Szűrés és paginating adatok</span><span class="sxs-lookup"><span data-stu-id="7c98e-291">Filtering and paginating data</span></span>
<span data-ttu-id="7c98e-292">Meg kell tartani az URI-k egyszerű és intuitív endeavor.</span><span class="sxs-lookup"><span data-stu-id="7c98e-292">You should endeavor to keep the URIs simple and intuitive.</span></span> <span data-ttu-id="7c98e-293">Az ilyen egyetlen erőforrások gyűjteményét URI ezzel segít, de nagy mennyiségű adat beolvasása, amikor szükség az információkat csak egy részhalmazát alkalmazások vezethet.</span><span class="sxs-lookup"><span data-stu-id="7c98e-293">Exposing a collection of resources through a single URI assists in this respect, but it can lead to applications fetching large amounts of data when only a subset of the information is required.</span></span> <span data-ttu-id="7c98e-294">A nagy forgalom létrehozása hatással van, nem csak teljesítményét és méretezhetőségét, a webkiszolgáló, de is hátrányosan befolyásolhatja a a figyelt alkalmazások az adatokat kér-e.</span><span class="sxs-lookup"><span data-stu-id="7c98e-294">Generating a large volume of traffic impacts not only the performance and scalability of the web server but also adversely affect the responsiveness of client applications requesting the data.</span></span>

<span data-ttu-id="7c98e-295">Például ha rendelések sorrendje fizetett tartalmazhat, egy ügyfélalkalmazást, amelyet a költségekkel keresztül megadott értékkel rendelkező összes rendelés beolvasása módosítania kell beolvasni az összes rendelést a */rendelések* URI és szűréssel ezeket a rendeléseket helyileg.</span><span class="sxs-lookup"><span data-stu-id="7c98e-295">For example, if orders contain the price paid for the order, a client application that needs to retrieve all orders that have a cost over a specific value might need to retrieve all orders from the */orders* URI and then filter these orders locally.</span></span> <span data-ttu-id="7c98e-296">Egyértelműen a folyamat nem nagyon hatékony; a webes API-t futtató kiszolgálón hulladékok azt a hálózati sávszélesség és a feldolgozási kapacitást.</span><span class="sxs-lookup"><span data-stu-id="7c98e-296">Clearly this process is highly inefficient; it wastes network bandwidth and processing power on the server hosting the web API.</span></span>

<span data-ttu-id="7c98e-297">Lehet, hogy egyik megoldást egy URI-séma biztosításához */kérelmek/ordervalue_greater_than_n* ahol  *n*  rendelés ár, de a díjak csak korlátozott számú kivételével megközelítéssel van nem célszerű.</span><span class="sxs-lookup"><span data-stu-id="7c98e-297">One solution may be to provide a URI scheme such as */orders/ordervalue_greater_than_n* where *n* is the order price, but for all but a limited number of prices such an approach is impractical.</span></span> <span data-ttu-id="7c98e-298">Emellett lekérdezés rendelések más feltétel alapján kell, ha fejezheti be alatt szembesül hosszú listáját tartalmazó URI-azonosítók valószínűleg nem intuitív nevű biztosítása.</span><span class="sxs-lookup"><span data-stu-id="7c98e-298">Additionally, if you need to query orders based on other criteria, you can end up being faced with providing with a long list of URIs with possibly non-intuitive names.</span></span>

<span data-ttu-id="7c98e-299">Jobb stratégia adatok szűrése, hogy adja meg a szűrési feltételeket a lekérdezési karakterláncban a webes API-hoz, például a átadott */rendelések? ordervaluethreshold = n*.</span><span class="sxs-lookup"><span data-stu-id="7c98e-299">A better strategy to filtering data is to provide the filter criteria in the query string that is passed to the web API, such as */orders?ordervaluethreshold=n*.</span></span> <span data-ttu-id="7c98e-300">Ebben a példában a megfelelő műveletet, a webes API-t a felelős a elemzése és kezelése a `ordervaluethreshold` paraméter a lekérdezési karakterláncot, és a szűrt eredmények visszaadni a HTTP-válasz.</span><span class="sxs-lookup"><span data-stu-id="7c98e-300">In this example, the corresponding operation in the web API is responsible for parsing and handling the `ordervaluethreshold` parameter in the query string and returning the filtered results in the HTTP response.</span></span>

<span data-ttu-id="7c98e-301">Néhány egyszerű HTTP GET kérelmek keresztül gyűjtemény-erőforrások potenciálisan visszaadhatja nagyszámú elemet.</span><span class="sxs-lookup"><span data-stu-id="7c98e-301">Some simple HTTP GET requests over collection resources could potentially return a large number of items.</span></span> <span data-ttu-id="7c98e-302">A folyamatban, akkor lehetősége elleni tervezzen a webes API-t bármely egyetlen kérelem által visszaadott adatok korlátozásához.</span><span class="sxs-lookup"><span data-stu-id="7c98e-302">To combat the possibility of this occurring you should design the web API to limit the amount of data returned by any single request.</span></span> <span data-ttu-id="7c98e-303">Lehet ezt elérni azáltal támogatja a lekérdezési karakterláncok, amelyek lehetővé teszik a kérhető elemek maximális számát adja meg (amely maga képezhetik egy felső korlátot szolgáltatásmegtagadási támadások megelőzése érdekében), és a kezdő eltolása a gyűjteményhez.</span><span class="sxs-lookup"><span data-stu-id="7c98e-303">You can achieve this by supporting query strings that enable the user to specify the maximum number of items to be retrieved (which could itself be subject to an upperbound limit to help prevent Denial of Service attacks), and a starting offset into the collection.</span></span> <span data-ttu-id="7c98e-304">Például a lekérdezési karakterlánc URI azonosítójában */rendelések? korlát 25 & eltolás = = 50* kezdődő, és a rendeléseket gyűjteményében található 50 sorrendje 25 rendelések kell beolvasni.</span><span class="sxs-lookup"><span data-stu-id="7c98e-304">For example, the query string in the URI */orders?limit=25&offset=50* should retrieve 25 orders starting with the 50th order found in the orders collection.</span></span> <span data-ttu-id="7c98e-305">Mivel az adatok szűrése, a művelet, amely a GET kérelmet a webes API felelős elemzése és kezelése a `limit` és `offset` paraméterek a lekérdezési karakterláncban.</span><span class="sxs-lookup"><span data-stu-id="7c98e-305">As with filtering data, the operation that implements the GET request in the web API is responsible for parsing and handling the `limit` and `offset` parameters in the query string.</span></span> <span data-ttu-id="7c98e-306">Segít az ügyfélalkalmazások, GET kérések többoldalas adatokat is tartalmaznia kell a metaadatok valamilyen visszaadó jelző érhető el a gyűjteményben lévő erőforrások teljes száma.</span><span class="sxs-lookup"><span data-stu-id="7c98e-306">To assist client applications, GET requests that return paginated data should also include some form of metadata that indicate the total number of resources available in the collection.</span></span> <span data-ttu-id="7c98e-307">Emellett érdemes valamilyen más intelligens lapozás stratégiák; További információkért lásd: [API tervezési megjegyzések: intelligens lapozás](http://bizcoder.com/api-design-notes-smart-paging)</span><span class="sxs-lookup"><span data-stu-id="7c98e-307">You might also consider other intelligent paging strategies; for more information, see [API Design Notes: Smart Paging](http://bizcoder.com/api-design-notes-smart-paging)</span></span>

<span data-ttu-id="7c98e-308">Hajtsa végre az adatok rendezése, lehívása; hasonló stratégia biztosíthatja, hogy egy rendezési paraméter, amely a mezőnév értékeként, például a */rendelések? rendezési = ProductID*.</span><span class="sxs-lookup"><span data-stu-id="7c98e-308">You can follow a similar strategy for sorting data as it is fetched; you could provide a sort parameter that takes a field name as the value, such as */orders?sort=ProductID*.</span></span> <span data-ttu-id="7c98e-309">Azonban ügyeljen arra, hogy ez a megközelítés lehet gyorsítótárazást (a lekérdezési karakterlánc paramétereket kulcsként számos gyorsítótár megvalósítását által a gyorsítótárazott adatokat az erőforrás-azonosító részét képezik) káros hatással.</span><span class="sxs-lookup"><span data-stu-id="7c98e-309">However, note that this approach can have a deleterious effect on caching (query string parameters form part of the resource identifier used by many cache implementations as the key to cached data).</span></span>

<span data-ttu-id="7c98e-310">Bővítheti ezt a módszert a korlátot (projekt) mezők adott vissza, ha csak egyetlen elemet tartalmazza-e nagy mennyiségű adatot.</span><span class="sxs-lookup"><span data-stu-id="7c98e-310">You can extend this approach to limit (project) the fields returned if a single resource item contains a large amount of data.</span></span> <span data-ttu-id="7c98e-311">Például használhatja a lekérdezési karakterlánc paraméterként, amely a mezőket, vesszővel tagolt listáját fogadja el, mint */rendelések? mezők ProductID, mennyiség =*.</span><span class="sxs-lookup"><span data-stu-id="7c98e-311">For example, you could use a query string parameter that accepts a comma-delimited list of fields, such as */orders?fields=ProductID,Quantity*.</span></span>

> [!TIP]
> <span data-ttu-id="7c98e-312">Adjon meg a lekérdezési karakterláncok a választható paramétereket jelentéssel bíró alapértelmezett értékeket.</span><span class="sxs-lookup"><span data-stu-id="7c98e-312">Give all optional parameters in query strings meaningful defaults.</span></span> <span data-ttu-id="7c98e-313">Például a `limit` 10 paraméter és a `offset` paraméter 0 értékre tördelési, ha a rendezési paraméter értéke az erőforrás kulcsa, amennyiben rendezést alkalmazza, és állítsa be a `fields` paramétert az erőforrás található összes mezőhöz Ha Ön támogatja a leképezések.</span><span class="sxs-lookup"><span data-stu-id="7c98e-313">For example, set the `limit` parameter to 10 and the `offset` parameter to 0 if you implement pagination, set the sort parameter to the key of the resource if you implement ordering, and set the `fields` parameter to all fields in the resource if you support projections.</span></span>
>
>

### <a name="handling-large-binary-resources"></a><span data-ttu-id="7c98e-314">Nagy bináris erőforrások kezelése</span><span class="sxs-lookup"><span data-stu-id="7c98e-314">Handling large binary resources</span></span>
<span data-ttu-id="7c98e-315">Egyetlen nagy bináris mezőkön, például a fájlok vagy a képek is tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="7c98e-315">A single resource may contain large binary fields, such as files or images.</span></span> <span data-ttu-id="7c98e-316">Megoldásához, az átviteli problémák megbízhatatlanná és időszakos kapcsolatok által okozott és javításához válaszidejét, próbáljon műveleteket, amelyek lehetővé teszik az ezekhez az erőforrásokhoz az ügyfélalkalmazás által adattömbök kérhető.</span><span class="sxs-lookup"><span data-stu-id="7c98e-316">To overcome the transmission problems caused by unreliable and intermittent connections and to improve response times, consider providing operations that enable such resources to be retrieved in chunks by the client application.</span></span> <span data-ttu-id="7c98e-317">Ehhez az szükséges, a webes API-t kell támogatja az elfogadás-tartományokat fejlécet nagy erőforrások GET kérelmek, és ideális a HTTP HEAD kérések megvalósításához.</span><span class="sxs-lookup"><span data-stu-id="7c98e-317">To do this, the web API should support the Accept-Ranges header for GET requests for large resources, and ideally implement HTTP HEAD requests for these resources.</span></span> <span data-ttu-id="7c98e-318">Az elfogadás-tartományokat fejléc azt jelzi, hogy támogatja-e a GET műveletet részleges eredményt, és, hogy egy ügyfél-alkalmazás elküldheti a GET-kérésekhez megadott bájttartomány erőforrás részhalmazát adja vissza.</span><span class="sxs-lookup"><span data-stu-id="7c98e-318">The Accept-Ranges header indicates that the GET operation supports partial results, and that a client application can submit GET requests that return a subset of a resource specified as a range of bytes.</span></span> <span data-ttu-id="7c98e-319">Egy HEAD kérelem hasonlít a GET kérés, azzal a különbséggel, hogy csak egy fejlécet tartalmazta, amely ismerteti az erőforrás- és egy üres üzenettörzs adja vissza.</span><span class="sxs-lookup"><span data-stu-id="7c98e-319">A HEAD request is similar to a GET request except that it only returns a header that describes the resource and an empty message body.</span></span> <span data-ttu-id="7c98e-320">Egy ügyfélalkalmazás adhatnak ki olyan HEAD kérelem annak megállapításához, hogy egy erőforrást beolvasni a részleges GET kérelmek használatával.</span><span class="sxs-lookup"><span data-stu-id="7c98e-320">A client application can issue a HEAD request to determine whether to fetch a resource by using partial GET requests.</span></span> <span data-ttu-id="7c98e-321">A következő példa bemutatja, hogy beolvassa a termék lemezképére vonatkozó információ HEAD kérelem:</span><span class="sxs-lookup"><span data-stu-id="7c98e-321">The following example shows a HEAD request that obtains information about a product image:</span></span>

```HTTP
HEAD http://adventure-works.com/products/10?fields=productImage HTTP/1.1
...
```

<span data-ttu-id="7c98e-322">A válaszüzenetet, amely tartalmazza az erőforrás (4580 bájt) mérete fejlécet, valamint az, hogy a megfelelő GET műveletet támogatja-e a részleges eredmények elfogadás-tartományokat fejléc tartalmazza:</span><span class="sxs-lookup"><span data-stu-id="7c98e-322">The response message contains a header that includes the size of the resource (4580 bytes), and the Accept-Ranges header that the corresponding GET operation supports partial results:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 4580
...
```

<span data-ttu-id="7c98e-323">Az ügyfélalkalmazás ezen információk használatával hozható létre a kisebb csoportjai képének beolvasása GET műveletek sorozata.</span><span class="sxs-lookup"><span data-stu-id="7c98e-323">The client application can use this information to construct a series of GET operations to retrieve the image in smaller chunks.</span></span> <span data-ttu-id="7c98e-324">Az első kérelem első 2500 bájtok beolvassa a tartomány fejléc használatával:</span><span class="sxs-lookup"><span data-stu-id="7c98e-324">The first request fetches the first 2500 bytes by using the Range header:</span></span>

```HTTP
GET http://adventure-works.com/products/10?fields=productImage HTTP/1.1
Range: bytes=0-2499
...
```

<span data-ttu-id="7c98e-325">A hibaválasz-üzenet jelzi, hogy a részleges válasz HTTP-állapotkód 206 vissza.</span><span class="sxs-lookup"><span data-stu-id="7c98e-325">The response message indicates that this is a partial response by returning HTTP status code 206.</span></span> <span data-ttu-id="7c98e-326">A Content-Length fejlécet az üzenet törzsében (nem az erőforrás mérete) visszaadott bájtok tényleges számát adja meg, és a Content-Range fejléc azt jelzi, hogy melyik erőforrás része azt (0-2499 kívüli 4580. bájt):</span><span class="sxs-lookup"><span data-stu-id="7c98e-326">The Content-Length header specifies the actual number of bytes returned in the message body (not the size of the resource), and the Content-Range header indicates which part of the resource this is (bytes 0-2499 out of 4580):</span></span>

```HTTP
HTTP/1.1 206 Partial Content
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2500
Content-Range: bytes 0-2499/4580
...
_{binary data not shown}_
```

<span data-ttu-id="7c98e-327">Az ügyfélalkalmazás egy későbbi kérés egy megfelelő tartományon fejléc használatával lekérhető az erőforrás fennmaradó:</span><span class="sxs-lookup"><span data-stu-id="7c98e-327">A subsequent request from the client application can retrieve the remainder of the resource by using an appropriate Range header:</span></span>

```HTTP
GET http://adventure-works.com/products/10?fields=productImage HTTP/1.1
Range: bytes=2500-
...
```

<span data-ttu-id="7c98e-328">A megfelelő eredmény üzenetet kell kinéznie:</span><span class="sxs-lookup"><span data-stu-id="7c98e-328">The corresponding result message should look like this:</span></span>

```HTTP
HTTP/1.1 206 Partial Content
...
Accept-Ranges: bytes
Content-Type: image/jpeg
Content-Length: 2080
Content-Range: bytes 2500-4580/4580
...
```

## <a name="using-the-hateoas-approach-to-enable-navigation-to-related-resources"></a><span data-ttu-id="7c98e-329">A HATEOAS módszer segítségével lehetővé a navigációt kapcsolódó erőforrások</span><span class="sxs-lookup"><span data-stu-id="7c98e-329">Using the HATEOAS approach to enable navigation to related resources</span></span>
<span data-ttu-id="7c98e-330">Az elsődleges összefüggések mögött REST egyik, hogy lehetővé kell tenni az erőforrások teljes készletét megnyitása anélkül, hogy az URI-séma előzetes ismerete.</span><span class="sxs-lookup"><span data-stu-id="7c98e-330">One of the primary motivations behind REST is that it should be possible to navigate the entire set of resources without requiring prior knowledge of the URI scheme.</span></span> <span data-ttu-id="7c98e-331">Minden HTTP GET kérést kell visszaadnia az információk szükségesek ahhoz, hogy a közvetlenül a kért objektum keresztül a válaszban szereplő hivatkozások kapcsolódó erőforrás megkeresése, és azt is rendelkezniük kell az elérhető műveletek leíró adatokat minden egyes ezeket az erőforrásokat.</span><span class="sxs-lookup"><span data-stu-id="7c98e-331">Each HTTP GET request should return the information necessary to find the resources related directly to the requested object through hyperlinks included in the response, and it should also be provided with information that describes the operations available on each of these resources.</span></span> <span data-ttu-id="7c98e-332">Ez az elv HATEOAS, vagy az alkalmazás motor állapot Hypertext néven ismert.</span><span class="sxs-lookup"><span data-stu-id="7c98e-332">This principle is known as HATEOAS, or Hypertext as the Engine of Application State.</span></span> <span data-ttu-id="7c98e-333">A rendszer gyakorlatilag egy véges állapotjelző gép, és az egyes irányuló kérelemre adott válasz tartalmazza a szükséges áthelyezése egy másik; adatok nincs más információ szükséges kell lennie.</span><span class="sxs-lookup"><span data-stu-id="7c98e-333">The system is effectively a finite state machine, and the response to each request contains the information necessary to move from one state to another; no other information should be necessary.</span></span>

> [!NOTE]
> <span data-ttu-id="7c98e-334">Jelenleg nincsenek szabványok vagy meghatározhatja, hogyan kell a HATEOAS elv modell specifikációk.</span><span class="sxs-lookup"><span data-stu-id="7c98e-334">Currently there are no standards or specifications that define how to model the HATEOAS principle.</span></span> <span data-ttu-id="7c98e-335">Az ebben a szakaszban szereplő példák bemutatják, egy lehetséges megoldás.</span><span class="sxs-lookup"><span data-stu-id="7c98e-335">The examples shown in this section illustrate one possible solution.</span></span>
>
>

<span data-ttu-id="7c98e-336">Tegyük fel a vásárlók és a rendeléseket, közötti kapcsolat kezelése a kívánt sorrendjét a válaszban visszaadott adatok kell tartalmaznia, és az ügyfél a rendelést, amely a végrehajtható műveletek azonosító hivatkozás formájában URI ügyfél.</span><span class="sxs-lookup"><span data-stu-id="7c98e-336">As an example, to handle the relationship between customers and orders, the data returned in the response for a specific order should contain URIs in the form of a hyperlink identifying the customer that placed the order, and the operations that can be performed on that customer.</span></span>

```HTTP
GET http://adventure-works.com/orders/3 HTTP/1.1
Accept: application/json
...
```

<span data-ttu-id="7c98e-337">A hibaválasz-üzenet törzsében egy `links` tömb (kiemelt a kódpéldát), amely megadja a kapcsolat jellege (*ügyfél*), az ügyfél az URI (*http://adventure-works.com/ az ügyfelek/3*), hogyan lehet lekérni a felhasználói adatait (*beolvasása*), és a MIME-típusok, amely a webalkalmazás-kiszolgáló támogatja az adatok beolvasása (*text/xml* és *az application/json*).</span><span class="sxs-lookup"><span data-stu-id="7c98e-337">The body of the response message contains a `links` array (highlighted in the code example) that specifies the nature of the relationship (*Customer*), the URI of the customer (*http://adventure-works.com/customers/3*), how to retrieve the details of this customer (*GET*), and the MIME types that the web server supports for retrieving this information (*text/xml* and *application/json*).</span></span> <span data-ttu-id="7c98e-338">Ez az összes adatot, amelyet a ügyfélalkalmazás beolvashatja az ügyfél részletes adatait.</span><span class="sxs-lookup"><span data-stu-id="7c98e-338">This is all the information that a client application needs to be able to fetch the details of the customer.</span></span> <span data-ttu-id="7c98e-339">Emellett a hivatkozások tömb hivatkozások is végrehajtható, például a PUT (az ügyfél és a formátuma, hogy a webkiszolgáló az ügyféltől vár módosítandó), és törölje a többi művelet.</span><span class="sxs-lookup"><span data-stu-id="7c98e-339">Additionally, the Links array also includes links for the other operations that can be performed, such as PUT (to modify the customer, together with the format that the web server expects the client to provide), and DELETE.</span></span>

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"orderID":3,"productID":2,"quantity":4,"orderValue":16.60,"links":[(some links omitted){"rel":"customer","href":" http://adventure-works.com/customers/3", "action":"GET","types":["text/xml","application/json"]},{"rel":"
customer","href":" http://adventure-works.com /customers/3", "action":"PUT","types":["application/x-www-form-urlencoded"]},{"rel":"customer","href":" http://adventure-works.com /customers/3","action":"DELETE","types":[]}]}
```

<span data-ttu-id="7c98e-340">A teljesség kedvéért a hivatkozások tömb is beolvasása erőforrás önmagára hivatkozó információkat kell tartalmaznia.</span><span class="sxs-lookup"><span data-stu-id="7c98e-340">For completeness, the Links array should also include self-referencing information pertaining to the resource that has been retrieved.</span></span> <span data-ttu-id="7c98e-341">Ezeket a hivatkozásokat az előző példából kimaradtak, de a következő kódban vannak kiemelve.</span><span class="sxs-lookup"><span data-stu-id="7c98e-341">These links have been omitted from the previous example, but are highlighted in the following code.</span></span> <span data-ttu-id="7c98e-342">Figyelje meg, hogy ezeket a hivatkozásokat, a kapcsolat *önkiszolgáló* azt jelzi, hogy ez az erőforrás a művelet által visszaadott hivatkozás használatban van:</span><span class="sxs-lookup"><span data-stu-id="7c98e-342">Notice that in these links, the relationship *self* has been used to indicate that this is a reference to the resource being returned by the operation:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"orderID":3,"productID":2,"quantity":4,"orderValue":16.60,"links":[{"rel":"self","href":" http://adventure-works.com/orders/3", "action":"GET","types":["text/xml","application/json"]},{"rel":" self","href":" http://adventure-works.com /orders/3", "action":"PUT","types":["application/x-www-form-urlencoded"]},{"rel":"self","href":" http://adventure-works.com /orders/3", "action":"DELETE","types":[]},{"rel":"customer",
"href":" http://adventure-works.com /customers/3", "action":"GET","types":["text/xml","application/json"]},{"rel":" customer" (customer links omitted)}]}
```

<span data-ttu-id="7c98e-343">Ezzel a megközelítéssel hatékony ügyfélalkalmazások lekérni, és ez az információ elemezni kell készíteni.</span><span class="sxs-lookup"><span data-stu-id="7c98e-343">For this approach to be effective, client applications must be prepared to retrieve and parse this additional information.</span></span>

## <a name="versioning-a-restful-web-api"></a><span data-ttu-id="7c98e-344">Versioning egy RESTful webes API</span><span class="sxs-lookup"><span data-stu-id="7c98e-344">Versioning a RESTful web API</span></span>
<span data-ttu-id="7c98e-345">Nagyon valószínű, hogy az összes olyan helyzetekben, hogy a webes API statikus marad a legegyszerűbb.</span><span class="sxs-lookup"><span data-stu-id="7c98e-345">It is highly unlikely that in all but the simplest of situations that a web API will remain static.</span></span> <span data-ttu-id="7c98e-346">Üzleti követelmények módosítása az új gyűjtemények erőforrások vehetők, erőforrásainak kapcsolatai változhat, és erőforrásokat az adatok szerkezete, előfordulhat, hogy módosítani kell.</span><span class="sxs-lookup"><span data-stu-id="7c98e-346">As business requirements change new collections of resources may be added, the relationships between resources might change, and the structure of the data in resources might be amended.</span></span> <span data-ttu-id="7c98e-347">Amíg a webes API-k új vagy eltérő követelmények kezelésére frissítése egy viszonylag egyszerű folyamat, meg kell fontolnia, hogy a változások rendelkezik majd a webes API-t használó ügyfélalkalmazások által okozott hatások.</span><span class="sxs-lookup"><span data-stu-id="7c98e-347">While updating a web API to handle new or differing requirements is a relatively straightforward process, you must consider the effects that such changes will have on client applications consuming the web API.</span></span> <span data-ttu-id="7c98e-348">A probléma oka, hogy a fejlesztő tervezésével és megvalósításával webes API-k, hogy API keresztül teljes körű vezérléssel rendelkezik, bár a fejlesztői nincs szabályozhatják, előfordulhat, hogy kialakítani, harmadik féltől származó szervezetek működő távoli ügyfél-alkalmazással azonos szinten.</span><span class="sxs-lookup"><span data-stu-id="7c98e-348">The issue is that although the developer designing and implementing a web API has full control over that API, the developer does not have the same degree of control over client applications which may be built by third party organizations operating remotely.</span></span> <span data-ttu-id="7c98e-349">Az elsődleges imperatív a meglévő ügyfél alkalmazások is működjenek, miközben lehetővé teszi az új ügyfél alkalmazások új szolgáltatásait és az erőforrások kihasználását változatlan.</span><span class="sxs-lookup"><span data-stu-id="7c98e-349">The primary imperative is to enable existing client applications to continue functioning unchanged while allowing new client applications to take advantage of new features and resources.</span></span>

<span data-ttu-id="7c98e-350">Versioning lehetővé teszi, hogy a webes API-k jelzi a következő szolgáltatásokat és erőforrásokat, amely azt mutatja, és egy ügyfélalkalmazás kérelmezheti irányított egy szolgáltatás vagy az erőforrás egy adott verziójához.</span><span class="sxs-lookup"><span data-stu-id="7c98e-350">Versioning enables a web API to indicate the features and resources that it exposes, and a client application can submit requests that are directed to a specific version of a feature or resource.</span></span> <span data-ttu-id="7c98e-351">A következő szakaszok ismertetik, amelyek mindegyikének saját előnyei és vonzatai több különböző módon.</span><span class="sxs-lookup"><span data-stu-id="7c98e-351">The following sections describe several different approaches, each of which has its own benefits and trade-offs.</span></span>

### <a name="no-versioning"></a><span data-ttu-id="7c98e-352">Semmilyen verziószámozási</span><span class="sxs-lookup"><span data-stu-id="7c98e-352">No versioning</span></span>
<span data-ttu-id="7c98e-353">Ez a legegyszerűbb módszere az, és egyes belső API-k elfogadható.</span><span class="sxs-lookup"><span data-stu-id="7c98e-353">This is the simplest approach, and may be acceptable for some internal APIs.</span></span> <span data-ttu-id="7c98e-354">Nagy változások sikerült jeleníthető meg új erőforrások vagy mutató új hivatkozásokat.</span><span class="sxs-lookup"><span data-stu-id="7c98e-354">Big changes could be represented as new resources or new links.</span></span>  <span data-ttu-id="7c98e-355">Tartalom hozzáadása a meglévő erőforrásokkal nem találhatók használhatatlanná tévő változást, ügyfélalkalmazások, amelyek nem számított a tartalom egyszerűen figyelmen kívül hagyja azt.</span><span class="sxs-lookup"><span data-stu-id="7c98e-355">Adding content to existing resources might not present a breaking change as client applications that are not expecting to see this content will simply ignore it.</span></span>

<span data-ttu-id="7c98e-356">Például az URI kérelem *http://adventure-works.com/customers/3* visszaadja-e részletes adatait tartalmazó egyetlen ügyfél `id`, `name`, és `address` az ügyfélalkalmazás által várt mezők :</span><span class="sxs-lookup"><span data-stu-id="7c98e-356">For example, a request to the URI *http://adventure-works.com/customers/3* should return the details of a single customer containing `id`, `name`, and `address` fields expected by the client application:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","address":"1 Microsoft Way Redmond WA 98053"}
```

> [!NOTE]
> <span data-ttu-id="7c98e-357">Az egyszerűség és egyértelműség céljából az itt látható példa válaszok nem HATEOAS mutató hivatkozásokat tartalmaznak.</span><span class="sxs-lookup"><span data-stu-id="7c98e-357">For the purposes of simplicity and clarity, the example responses shown in this section do not include HATEOAS links.</span></span>
>
>

<span data-ttu-id="7c98e-358">Ha a `DateCreated` mező hozzáadódik a séma, a felhasználói erőforrás, akkor a válasz néz ki:</span><span class="sxs-lookup"><span data-stu-id="7c98e-358">If the `DateCreated` field is added to the schema of the customer resource, then the response would look like this:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","dateCreated":"2014-09-04T12:11:38.0376089Z","address":"1 Microsoft Way Redmond WA 98053"}
```

<span data-ttu-id="7c98e-359">Meglévő ügyfélalkalmazások továbbra is megfelelően működik, ha azok figyelmen kívül hagyása ismeretlen mezők, amíg új ügyfélalkalmazások is kell megtervezni, hogy ez az új mező kezelésére képes.</span><span class="sxs-lookup"><span data-stu-id="7c98e-359">Existing client applications might continue functioning correctly if they are capable of ignoring unrecognized fields, while new client applications can be designed to handle this new field.</span></span> <span data-ttu-id="7c98e-360">Azonban a sémában az erőforrások több legradikálisabb változások történnek (például eltávolítása, vagy mezők átnevezése) vagy a erőforrásainak kapcsolatai módosítani majd ezek jelenthet akár jelentős változásokat, amelyek meggátolják a meglévő ügyfél alkalmazások megfelelően működik-e .</span><span class="sxs-lookup"><span data-stu-id="7c98e-360">However, if more radical changes to the schema of resources occur (such as removing or renaming fields) or the relationships between resources change then these may constitute breaking changes that prevent existing client applications from functioning correctly.</span></span> <span data-ttu-id="7c98e-361">Ezekben az esetekben érdemes lehet a következő módszerek egyikét.</span><span class="sxs-lookup"><span data-stu-id="7c98e-361">In these situations you should consider one of the following approaches.</span></span>

### <a name="uri-versioning"></a><span data-ttu-id="7c98e-362">URI versioning</span><span class="sxs-lookup"><span data-stu-id="7c98e-362">URI versioning</span></span>
<span data-ttu-id="7c98e-363">Minden alkalommal, amikor módosítja a webes API-t vagy módosítja a sémát, az erőforrások hozzáadása egy verziószámot minden erőforrás URI.</span><span class="sxs-lookup"><span data-stu-id="7c98e-363">Each time you modify the web API or change the schema of resources, you add a version number to the URI for each resource.</span></span> <span data-ttu-id="7c98e-364">A korábban meglévő URI-k továbbra is működnek, mint korábban tartó erőforrások visszatér az eredeti séma.</span><span class="sxs-lookup"><span data-stu-id="7c98e-364">The previously existing URIs should continue to operate as before, returning resources that conform to their original schema.</span></span>

<span data-ttu-id="7c98e-365">Az előző példában kiterjesztése, ha a `address` mező új alárendelt mezőkbe tartalmazó minden részét képezi a cím szerkezete (például `streetAddress`, `city`, `state`, és `zipCode`), az erőforrás ezen verziója lehet egy verziószámot, például a http://adventure-works.com/v2/customers/3 tartalmazó URI keresztül közzétett:</span><span class="sxs-lookup"><span data-stu-id="7c98e-365">Extending the previous example, if the `address` field is restructured into sub-fields containing each constituent part of the address (such as `streetAddress`, `city`, `state`, and `zipCode`), this version of the resource could be exposed through a URI containing a version number, such as http://adventure-works.com/v2/customers/3:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","dateCreated":"2014-09-04T12:11:38.0376089Z","address":{"streetAddress":"1 Microsoft Way","city":"Redmond","state":"WA","zipCode":98053}}
```

<span data-ttu-id="7c98e-366">A verziókezelő mechanizmus nagyon egyszerű, de a kiszolgáló a kérés útválasztási a megfelelő végpontnak függ.</span><span class="sxs-lookup"><span data-stu-id="7c98e-366">This versioning mechanism is very simple but depends on the server routing the request to the appropriate endpoint.</span></span> <span data-ttu-id="7c98e-367">Azonban, a webes API Miután kiforrottá válik, több lépés keresztül kezelése nehézkessé válhat, és a kiszolgáló rendelkezik egy különböző verziói számának támogatásához.</span><span class="sxs-lookup"><span data-stu-id="7c98e-367">However, it can become unwieldy as the web API matures through several iterations and the server has to support a number of different versions.</span></span> <span data-ttu-id="7c98e-368">Is, egy purist szempontjából, minden esetben az ügyfélalkalmazások számára vannak a azonos adatok beolvasása (ügyfél 3), így az URI nem valóban szabad verziójától függően eltérnek.</span><span class="sxs-lookup"><span data-stu-id="7c98e-368">Also, from a purist’s point of view, in all cases the client applications are fetching the same data (customer 3), so the URI should not really be different depending on the version.</span></span> <span data-ttu-id="7c98e-369">Ez a séma HATEOAS végrehajtását is növeli az összes hivatkozás kell ahhoz, hogy a verziószám szerepeljen az URI-azonosítók szerint.</span><span class="sxs-lookup"><span data-stu-id="7c98e-369">This scheme also complicates implementation of HATEOAS as all links will need to include the version number in their URIs.</span></span>

### <a name="query-string-versioning"></a><span data-ttu-id="7c98e-370">Lekérdezési karakterlánc versioning</span><span class="sxs-lookup"><span data-stu-id="7c98e-370">Query string versioning</span></span>
<span data-ttu-id="7c98e-371">Ahelyett, hogy így több URI-k, megadhatja a verziót az erőforrás egy paraméterrel, a lekérdezési karakterláncot, mint a HTTP-kérelem fűzött belül *http://adventure-works.com/customers/3?version=2*.</span><span class="sxs-lookup"><span data-stu-id="7c98e-371">Rather than providing multiple URIs, you can specify the version of the resource by using a parameter within the query string appended to the HTTP request, such as *http://adventure-works.com/customers/3?version=2*.</span></span> <span data-ttu-id="7c98e-372">A version paramétert kell alapértelmezés szerint egy jelentéssel bíró értékre, például 1, ha ki van hagyva régebbi ügyfélalkalmazások.</span><span class="sxs-lookup"><span data-stu-id="7c98e-372">The version parameter should default to a meaningful value such as 1 if it is omitted by older client applications.</span></span>

<span data-ttu-id="7c98e-373">Ez a megközelítés azzal az szemantikai előnye, hogy ugyanaz az erőforrás mindig lekért ugyanilyen URI, de a kódot, amely kezeli a kérelmet a lekérdezési karakterlánc elemzése és a megfelelő HTTP-választ küldött függ.</span><span class="sxs-lookup"><span data-stu-id="7c98e-373">This approach has the semantic advantage that the same resource is always retrieved from the same URI, but it depends on the code that handles the request to parse the query string and send back the appropriate HTTP response.</span></span> <span data-ttu-id="7c98e-374">Ez a megközelítés is szenved az azonos komplikációk URI versioning mechanizmusként HATEOAS megvalósításához.</span><span class="sxs-lookup"><span data-stu-id="7c98e-374">This approach also suffers from the same complications for implementing HATEOAS as the URI versioning mechanism.</span></span>

> [!NOTE]
> <span data-ttu-id="7c98e-375">Egyes régebbi webböngészők és a webalkalmazás-proxy nem gyorsítótárazhatják az választ adjon az URL-CÍMÉT egy lekérdezési karakterláncot tartalmazó kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="7c98e-375">Some older web browsers and web proxies will not cache responses for requests that include a query string in the URL.</span></span> <span data-ttu-id="7c98e-376">Ez kedvezőtlen hatással lehet webes alkalmazásokhoz, amelyek a webes API-k használják, és futtatni egy webes böngésző belül, amely teljesítmény.</span><span class="sxs-lookup"><span data-stu-id="7c98e-376">This can have an adverse impact on performance for web applications that use a web API and that run from within such a web browser.</span></span>
>
>

### <a name="header-versioning"></a><span data-ttu-id="7c98e-377">Fejléc versioning</span><span class="sxs-lookup"><span data-stu-id="7c98e-377">Header versioning</span></span>
<span data-ttu-id="7c98e-378">Ahelyett, hogy hozzáfűzi a lekérdezési karakterlánc paraméterként a verziószámot, egy egyéni fejlécet, amely jelzi a verziót az erőforrás sikertelen végrehajtása.</span><span class="sxs-lookup"><span data-stu-id="7c98e-378">Rather than appending the version number as a query string parameter, you could implement a custom header that indicates the version of the resource.</span></span> <span data-ttu-id="7c98e-379">Ez a módszer igényli, hogy, hogy az ügyfélalkalmazás a megfelelő fejlécet ad a kéréseit, bár a kódot az ügyfél kérelmet kezelő használhatja az alapértelmezett értéket (verzió: 1), ha meg van adva a verziófejléc.</span><span class="sxs-lookup"><span data-stu-id="7c98e-379">This approach requires that the client application adds the appropriate header to any requests, although the code handling the client request could use a default value (version 1) if the version header is omitted.</span></span> <span data-ttu-id="7c98e-380">Az alábbi példák használatára egy elnevezésű egyéni fejlécet *egyéni-fejléc*.</span><span class="sxs-lookup"><span data-stu-id="7c98e-380">The following examples utilize a custom header named *Custom-Header*.</span></span> <span data-ttu-id="7c98e-381">A fejléc értékének webes API verzióját adja meg.</span><span class="sxs-lookup"><span data-stu-id="7c98e-381">The value of this header indicates the version of web API.</span></span>

<span data-ttu-id="7c98e-382">1. verzió:</span><span class="sxs-lookup"><span data-stu-id="7c98e-382">Version 1:</span></span>

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Custom-Header: api-version=1
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","address":"1 Microsoft Way Redmond WA 98053"}
```

<span data-ttu-id="7c98e-383">2. verzió:</span><span class="sxs-lookup"><span data-stu-id="7c98e-383">Version 2:</span></span>

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Custom-Header: api-version=2
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","dateCreated":"2014-09-04T12:11:38.0376089Z","address":{"streetAddress":"1 Microsoft Way","city":"Redmond","state":"WA","zipCode":98053}}
```

<span data-ttu-id="7c98e-384">Vegye figyelembe, hogy az előző két megközelítés a HATEOAS végrehajtási igényel a együtt megfelelő egyéni szereplő esetleges hivatkozások.</span><span class="sxs-lookup"><span data-stu-id="7c98e-384">Note that as with the previous two approaches, implementing HATEOAS requires including the appropriate custom header in any links.</span></span>

### <a name="media-type-versioning"></a><span data-ttu-id="7c98e-385">Az adathordozó típusa versioning</span><span class="sxs-lookup"><span data-stu-id="7c98e-385">Media type versioning</span></span>
<span data-ttu-id="7c98e-386">Amikor egy ügyfél-alkalmazás egy HTTP GET kérést küld egy webkiszolgálóhoz történő azt kell kötni, is képes kezelni az Accept fejlécet, használatával, ez az útmutató korábbi szakaszaiban ismertetett tartalom formátuma.</span><span class="sxs-lookup"><span data-stu-id="7c98e-386">When a client application sends an HTTP GET request to a web server it should stipulate the format of the content that it can handle by using an Accept header, as described earlier in this guidance.</span></span> <span data-ttu-id="7c98e-387">Gyakran a célja a *elfogadás* fejléc, hogy lehetővé tegyék az ügyfélalkalmazás adhatja meg, hogy a választörzs XML, JSON vagy valamilyen más általános formátumú, mely az ügyfél képes legyen-e.</span><span class="sxs-lookup"><span data-stu-id="7c98e-387">Frequently the purpose of the *Accept* header is to allow the client application to specify whether the body of the response should be XML, JSON, or some other common format that the client can parse.</span></span> <span data-ttu-id="7c98e-388">Azonban úgy is, amely tartalmazza az információt, amely alapján az ügyfélalkalmazás annak jelzésére, hogy melyik erőforrás verzióját is megfelelő egyéni adathordozó-típust határoznak meg.</span><span class="sxs-lookup"><span data-stu-id="7c98e-388">However, it is possible to define custom media types that include information enabling the client application to indicate which version of a resource it is expecting.</span></span> <span data-ttu-id="7c98e-389">A következő példa bemutatja egy olyan kérelmet, amely meghatározza egy *elfogadás* értékű fejléc *application/vnd.adventure-works.v1+json*.</span><span class="sxs-lookup"><span data-stu-id="7c98e-389">The following example shows a request that specifies an *Accept* header with the value *application/vnd.adventure-works.v1+json*.</span></span> <span data-ttu-id="7c98e-390">A *vnd.adventure-works.v1* elem határozza meg, hogy a webkiszolgáló, hogy az visszaküldje-e az 1 verziót az erőforrás, amíg a *json* elem megadhatja, hogy az adott válasz törzsének formátuma JSON:</span><span class="sxs-lookup"><span data-stu-id="7c98e-390">The *vnd.adventure-works.v1* element indicates to the web server that it should return version 1 of the resource, while the *json* element specifies that the format of the response body should be JSON:</span></span>

```HTTP
GET http://adventure-works.com/customers/3 HTTP/1.1
...
Accept: application/vnd.adventure-works.v1+json
...
```

<span data-ttu-id="7c98e-391">A kódot, a kérelem feldolgozása felelős a *elfogadás* fejléc és a lehető érvényesítenie azt (az ügyfélalkalmazás adhatnak meg több formátumok a *elfogadás* fejléc, ebben az esetben a webalkalmazás-kiszolgáló is válassza ki a legmegfelelőbb az adott válasz törzsének formátumát).</span><span class="sxs-lookup"><span data-stu-id="7c98e-391">The code handling the request is responsible for processing the *Accept* header and honoring it as far as possible (the client application may specify multiple formats in the *Accept* header, in which case the web server can choose the most appropriate format for the response body).</span></span> <span data-ttu-id="7c98e-392">A webkiszolgáló megerősíti, hogy a válasz törzsében szereplő adatok formátumának a Content-Type fejléc használatával:</span><span class="sxs-lookup"><span data-stu-id="7c98e-392">The web server confirms the format of the data in the response body by using the Content-Type header:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/vnd.adventure-works.v1+json; charset=utf-8
...
Content-Length: ...
{"id":3,"name":"Contoso LLC","address":"1 Microsoft Way Redmond WA 98053"}
```

<span data-ttu-id="7c98e-393">Az Accept fejlécet bármely ismert adathordozó típusa nem határoz meg, ha a webkiszolgáló nem sikerült létrehozni egy HTTP 406 (elfogadható) válaszüzenetet vagy egy üzenetet, amelyben egy alapértelmezett az adathordozó típusát adja vissza.</span><span class="sxs-lookup"><span data-stu-id="7c98e-393">If the Accept header does not specify any known media types, the web server could generate an HTTP 406 (Not Acceptable) response message or return a message with a default media type.</span></span>

<span data-ttu-id="7c98e-394">Ez a megközelítés késései referenciavegyületeknek a lehető legtisztább versioning mechanizmusok és adatmodelljeinek természetes HATEOAS, ami magában foglalhatja a kapcsolódó adatokra vonatkozó MIME-típusát a források hivatkozásait.</span><span class="sxs-lookup"><span data-stu-id="7c98e-394">This approach is arguably the purest of the versioning mechanisms and lends itself naturally to HATEOAS, which can include the MIME type of related data in resource links.</span></span>

> [!NOTE]
> <span data-ttu-id="7c98e-395">Amikor kiválaszt egy versioning stratégia, is érdemes a gyakorolt hatása a teljesítményre, különösen gyorsítótárazása a webkiszolgálón.</span><span class="sxs-lookup"><span data-stu-id="7c98e-395">When you select a versioning strategy, you should also consider the implications on performance, especially caching on the web server.</span></span> <span data-ttu-id="7c98e-396">Az URI versioning és a lekérdezési karakterlánc versioning sémák áll a gyorsítótár-barát amennyiben ugyanazokhoz az adatokhoz minden alkalommal, amikor a azonos URI-lekérdezés-karakterlánc kombinációja hivatkozik.</span><span class="sxs-lookup"><span data-stu-id="7c98e-396">The URI versioning and Query String versioning schemes are cache-friendly inasmuch as the same URI/query string combination refers to the same data each time.</span></span>
>
> <span data-ttu-id="7c98e-397">A fejléc versioning és médiatípus versioning mechanizmusok használatához általában szükség van további logikát vizsgálja meg az értékeket az egyéni fejlécet vagy az Accept fejlécet.</span><span class="sxs-lookup"><span data-stu-id="7c98e-397">The Header versioning and Media Type versioning mechanisms typically require additional logic to examine the values in the custom header or the Accept header.</span></span> <span data-ttu-id="7c98e-398">A nagyméretű környezetben sok ügyfél különböző verzióit egy webes API-t használ a kiszolgálóoldali gyorsítótár duplikált adatok jelentős mennyiségű eredményezhet.</span><span class="sxs-lookup"><span data-stu-id="7c98e-398">In a large-scale environment, many clients using different versions of a web API can result in a significant amount of duplicated data in a server-side cache.</span></span> <span data-ttu-id="7c98e-399">Lehet, hogy a probléma akut, ha egy ügyfél-alkalmazás egy webkiszolgálón, amely megvalósítja a gyorsítótárazás, és, hogy csak továbbítja a kérést a webkiszolgáló Ha azt jelenleg nem vonatkozik a kért adatok másolatát gyorsítótárában proxyn keresztül kommunikál.</span><span class="sxs-lookup"><span data-stu-id="7c98e-399">This issue can become acute if a client application communicates with a web server through a proxy that implements caching, and that only forwards a request to the web server if it does not currently hold a copy of the requested data in its cache.</span></span>
>
>

## <a name="open-api-initiative"></a><span data-ttu-id="7c98e-400">Nyissa meg az API kezdeményezés</span><span class="sxs-lookup"><span data-stu-id="7c98e-400">Open API Initiative</span></span>
<span data-ttu-id="7c98e-401">A [nyitott API kezdeményezésére](https://www.openapis.org/) egy iparági konzorcium normalizálnia REST API leírása több szállító hozta létre.</span><span class="sxs-lookup"><span data-stu-id="7c98e-401">The [Open API Initiative](https://www.openapis.org/) was created by an industry consortium to standardize REST API descriptions across vendors.</span></span> <span data-ttu-id="7c98e-402">A kezdeményezés részeként a Swagger 2.0-s specifikációnak volt a OpenAPI Specification (OAS) neve, és nyissa meg az API kezdeményezésére alapján.</span><span class="sxs-lookup"><span data-stu-id="7c98e-402">As part of this initiative, the Swagger 2.0 specification was renamed the OpenAPI Specification (OAS) and brought under the Open API Initiative.</span></span>

<span data-ttu-id="7c98e-403">Érdemes lehet OpenAPI elfogadják a Web API-k.</span><span class="sxs-lookup"><span data-stu-id="7c98e-403">You may want to adopt OpenAPI for your web APIs.</span></span> <span data-ttu-id="7c98e-404">Néhány megfontolandó szempontok:</span><span class="sxs-lookup"><span data-stu-id="7c98e-404">Some points to consider:</span></span>

- <span data-ttu-id="7c98e-405">A OpenAPI megadását a opinionated irányelvek állítja be a hogyan egy REST API-t úgy kell megtervezni, előre.</span><span class="sxs-lookup"><span data-stu-id="7c98e-405">The OpenAPI Specification comes with with a set of opinionated guidelines on how a REST API should be designed.</span></span> <span data-ttu-id="7c98e-406">Amely a való együttműködés előnye is van, de további figyelmet igényel, az API-t a specifikációnak megfelelő tervezésekor.</span><span class="sxs-lookup"><span data-stu-id="7c98e-406">That has advantages for interoperability, but requires more care when designing your API to conform to the specification.</span></span>
- <span data-ttu-id="7c98e-407">OpenAPI elősegíti a szerződés-első megközelítés ahelyett, hogy egy megvalósítási-first-módszert is.</span><span class="sxs-lookup"><span data-stu-id="7c98e-407">OpenAPI promotes a contract-first approach, rather than an implementation-first approach.</span></span> <span data-ttu-id="7c98e-408">Adategyezmény-első azt jelenti, hogy alakítson ki az API-t először szerződést (a felület), és jegyezze meg a szerződés megvalósító kódot.</span><span class="sxs-lookup"><span data-stu-id="7c98e-408">Contract-first means you design the API contract (the interface) first and then write code that implements the contract.</span></span> 
- <span data-ttu-id="7c98e-409">Eszközök, például a Swagger API-szerződések hozhat létre ügyfélkódtárai vagy dokumentációját.</span><span class="sxs-lookup"><span data-stu-id="7c98e-409">Tools like Swagger can generate client libraries or documentation from API contracts.</span></span> <span data-ttu-id="7c98e-410">Lásd például: [ASP.NET API segítségével weblapok a Swagger](/aspnet/core/tutorials/web-api-help-pages-using-swagger).</span><span class="sxs-lookup"><span data-stu-id="7c98e-410">For example, see [ASP.NET Web API Help Pages using Swagger](/aspnet/core/tutorials/web-api-help-pages-using-swagger).</span></span>

## <a name="more-information"></a><span data-ttu-id="7c98e-411">További információ</span><span class="sxs-lookup"><span data-stu-id="7c98e-411">More information</span></span>
* <span data-ttu-id="7c98e-412">A [Microsoft REST API-irányelvek](https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md) tartalmaz részletes információkat találhat a nyilvános REST API-k tervezéséhez.</span><span class="sxs-lookup"><span data-stu-id="7c98e-412">The [Microsoft REST API Guidelines](https://github.com/Microsoft/api-guidelines/blob/master/Guidelines.md) contain detailed recommendations for designing public REST APIs.</span></span>
* <span data-ttu-id="7c98e-413">A [RESTful Cookbook](http://restcookbook.com/) RESTful API-k létrehozása bemutatása tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="7c98e-413">The [RESTful Cookbook](http://restcookbook.com/) contains an introduction to building RESTful APIs.</span></span>
* <span data-ttu-id="7c98e-414">A [webes API ellenőrzőlista](https://mathieu.fenniak.net/the-api-checklist/) megfontolandó tervezésével és megvalósításával webes API-k hasznos listáját tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="7c98e-414">The [Web API Checklist](https://mathieu.fenniak.net/the-api-checklist/) contains a useful list of items to consider when designing and implementing a web API.</span></span>
* <span data-ttu-id="7c98e-415">A [nyitott API kezdeményezésére](https://www.openapis.org/) helyet, a nyílt API-t minden kapcsolódó dokumentáció és megvalósítási részleteit tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="7c98e-415">The [Open API Initiative](https://www.openapis.org/) site, contains all related documentation and implementation details on Open API.</span></span>
