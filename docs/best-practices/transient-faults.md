---
title: "Ismételje meg az általános útmutatást"
description: "Átmeneti hiba célból újrapróbálkozási útmutatást."
author: dragon119
ms.date: 07/13/2016
pnp.series.title: Best Practices
ms.openlocfilehash: 9562e3447b2219fe2f3df96cfca24b845efa39b0
ms.sourcegitcommit: c53adf50d3a787956fc4ebc951b163a10eeb5d20
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 11/23/2017
---
# <a name="transient-fault-handling"></a><span data-ttu-id="2cf8a-103">Átmeneti hiba kezelése</span><span class="sxs-lookup"><span data-stu-id="2cf8a-103">Transient fault handling</span></span>

[!INCLUDE [header](../_includes/header.md)]

<span data-ttu-id="2cf8a-104">Minden alkalmazás, amely kommunikálni a távoli szolgáltatásokat és erőforrásokat kell átmeneti-és nagybetűket.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-104">All applications that communicate with remote services and resources must be sensitive to transient faults.</span></span> <span data-ttu-id="2cf8a-105">Ez különösen a helyzet a felhőben, ahol a környezet és a kapcsolatot az interneten keresztül jellege azt jelenti, ezek a típusok hibák várhatóan gyakran előforduló futtatható alkalmazások esetében.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-105">This is especially the case for applications that run in the cloud, where the nature of the environment and connectivity over the Internet means these types of faults are likely to be encountered more often.</span></span> <span data-ttu-id="2cf8a-106">Átmeneti hálózati összetevőkkel és szolgáltatásokkal kapcsolatban a pillanatnyi elvesztését, egy szolgáltatás, vagy merülhetnek fel, ha a "szolgáltatás" foglalt időtúllépések ideiglenes elérhetetlensége tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-106">Transient faults include the momentary loss of network connectivity to components and services, the temporary unavailability of a service, or timeouts that arise when a service is busy.</span></span> <span data-ttu-id="2cf8a-107">Ezek a hibák gyakran önállóan korrigálja, és ha a művelet ismétlődik megfelelő várakozás után már valószínűleg sikeres.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-107">These faults are often self-correcting, and if the action is repeated after a suitable delay it is likely succeed.</span></span>

<span data-ttu-id="2cf8a-108">Ez a dokumentum átmeneti hiba kezelésére szolgáló általános útmutatást tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-108">This document covers general guidance for transient fault handling.</span></span> <span data-ttu-id="2cf8a-109">További információ a átmeneti hibák kezelése a Microsoft Azure-szolgáltatások használatakor: [Azure szolgáltatással kapcsolatos újrapróbálkozási irányelvek](./retry-service-specific.md).</span><span class="sxs-lookup"><span data-stu-id="2cf8a-109">For information about handling transient faults when using Microsoft Azure services, see [Azure service-specific retry guidelines](./retry-service-specific.md).</span></span>

## <a name="why-do-transient-faults-occur-in-the-cloud"></a><span data-ttu-id="2cf8a-110">Miért tegye átmeneti hibák merülnek fel a felhőben?</span><span class="sxs-lookup"><span data-stu-id="2cf8a-110">Why do transient faults occur in the cloud?</span></span>
<span data-ttu-id="2cf8a-111">Átmeneti bármely környezetben, bármilyen platformra vagy az operációs rendszer, és bármilyen alkalmazás fordul elő.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-111">Transient faults can occur in any environment, on any platform or operating system, and in any kind of application.</span></span> <span data-ttu-id="2cf8a-112">A helyi rendszeren futó megoldások általában megmarad költséges és gyakran alatt használt hardver-redundancia segítségével helyszíni infrastruktúra-, teljesítmény- és az alkalmazás és az összetevőinek rendelkezésre állását, és összetevők és erőforrások találhatók bezárása egymáshoz.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-112">In solutions that run on local, on-premises infrastructure, performance and availability of the application and its components is typically maintained through expensive and often under-used hardware redundancy, and components and resources are located close to each another.</span></span> <span data-ttu-id="2cf8a-113">Így hiba kisebb valószínűséggel, miközben továbbra is eredményezhet átmeneti - és előre nem látható esemény, például a külső tápegység vagy hálózati problémák vagy egyéb vészhelyreállítási forgatókönyvek keresztül kimaradás is.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-113">While this makes a failure less likely, it can still result in transient faults - and even an outage through unforeseen events such as external power supply or network issues, or other disaster scenarios.</span></span>

<span data-ttu-id="2cf8a-114">Felhő üzemeltet, beleértve a magánfelhő-alapú rendszerek is egy magasabb rendelkezésre állását segítségével lehetőséget megosztott erőforrások, a redundancia, az Automatikus feladatátvétel és a dinamikus erőforrás-elosztás hagyományos számítási csomópontok hatalmas számú.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-114">Cloud hosting, including private cloud systems, can offer a higher overall availability by using shared resources, redundancy, automatic failover, and dynamic resource allocation across a huge number of commodity compute nodes.</span></span> <span data-ttu-id="2cf8a-115">Azonban ezekben a környezetekben jellege azt, hogy átmeneti fordul-e.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-115">However, the nature of these environments can mean that transient faults are more likely to occur.</span></span> <span data-ttu-id="2cf8a-116">Nincsenek ennek több oka:</span><span class="sxs-lookup"><span data-stu-id="2cf8a-116">There are several reasons for this:</span></span>

* <span data-ttu-id="2cf8a-117">Egy felhőalapú környezetben sok erőforrás van megosztva, és ezekhez az erőforrásokhoz való hozzáférés védelme az erőforrás-szabályozás.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-117">Many resources in a cloud environment are shared, and access to these resources is subject to throttling in order to protect the resource.</span></span> <span data-ttu-id="2cf8a-118">Egyes szolgáltatások elutasítják az kapcsolatok, amikor valamilyen konkrét szintje a nő a terhelés, vagy a maximális átviteli sebesség elérése, annak érdekében, hogy a meglévő kérelmek feldolgozási és az összes felhasználó számára a szolgáltatás teljesítményének fenntartása.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-118">Some services will refuse connections when the load rises to a specific level, or a maximum throughput rate is reached, in order to allow processing of existing requests and to maintain performance of the service for all users.</span></span> <span data-ttu-id="2cf8a-119">Sávszélesség-szabályozási segíti a szolgáltatásminőség szomszédok és a megosztott erőforrás segítségével más bérlők karbantartása.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-119">Throttling helps to maintain the quality of service for neighbors and other tenants using the shared resource.</span></span>
* <span data-ttu-id="2cf8a-120">Felhőalapú környezetek hatalmas mennyiségű hagyományos hardver egységek használatával készített.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-120">Cloud environments are built using vast numbers of commodity hardware units.</span></span> <span data-ttu-id="2cf8a-121">Több számítógépes egységek és infrastruktúra-összetevőihez a terhelés dinamikusan elosztásával teljesítményt biztosítanak, és megbízhatóság kézbesítendő automatikusan újrahasznosítása vagy cseréje sikertelen egység.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-121">They deliver performance by dynamically distributing the load across multiple computing units and infrastructure components, and deliver reliability by automatically recycling or replacing failed units.</span></span> <span data-ttu-id="2cf8a-122">A dinamikus jellege azt jelenti, hogy, hogy átmeneti és ideiglenes kapcsolódási hibák alkalmanként fordulhat elő.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-122">This dynamic nature means that transient faults and temporary connection failures may occasionally occur.</span></span>
* <span data-ttu-id="2cf8a-123">Nincsenek gyakran további hardverösszetevők, beleértve a hálózati infrastruktúrát, például az útválasztók és terheléselosztók, az alkalmazás és az erőforrások és a használt szolgáltatások között.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-123">There are often more hardware components, including network infrastructure such as routers and load balancers, between the application and the resources and services it uses.</span></span> <span data-ttu-id="2cf8a-124">A további infrastruktúra alkalmanként vethet fel további kapcsolat késleltetése és átmeneti kapcsolati hibák.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-124">This additional infrastructure can occasionally introduce additional connection latency and transient connection faults.</span></span>
* <span data-ttu-id="2cf8a-125">Az ügyfél és a kiszolgáló közötti hálózati körülmények változó, lehet, különösen akkor, ha a kommunikáció áthalad az interneten.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-125">Network conditions between the client and the server may be variable, especially when communication crosses the Internet.</span></span> <span data-ttu-id="2cf8a-126">A helyszíni helyeken, még akkor is, a nagyon nagy forgalomterhelés kommunikációs lassú és időszakos kapcsolattal hibákhoz vezethet.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-126">Even in on-premises locations, very heavy traffic loads may slow communication and cause intermittent connection failures.</span></span>

## <a name="challenges"></a><span data-ttu-id="2cf8a-127">Kihívásai</span><span class="sxs-lookup"><span data-stu-id="2cf8a-127">Challenges</span></span>
<span data-ttu-id="2cf8a-128">Átmeneti akkor is, ha azt tesztelték alaposan minden előrelátható körülmények túl nagy hatással lehet egy alkalmazás érzékelt működési rendelkezésre állását.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-128">Transient faults can have a huge impact on the perceived availability of an application, even if it has been thoroughly tested under all foreseeable circumstances.</span></span> <span data-ttu-id="2cf8a-129">Győződjön meg arról, hogy a felhőben üzemeltetett alkalmazások megbízhatóan fog működni, hogy fel kell tudni válaszolni a következő problémákkal:</span><span class="sxs-lookup"><span data-stu-id="2cf8a-129">To ensure that cloud-hosted applications operate reliably, they must be able to respond to the following challenges:</span></span>

* <span data-ttu-id="2cf8a-130">Az alkalmazás észleléséhez hibák fordulnak elő, és határozza meg, hogy ezeket a hibákat valószínűleg átmeneti, több hosszú ideig tart képesnek kell lennie, vagy a Terminálszolgáltatások hibákat észlel.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-130">The application must be able to detect faults when they occur, and determine if these faults are likely to be transient, more long-lasting, or are terminal failures.</span></span> <span data-ttu-id="2cf8a-131">Különböző erőforrások valószínűleg különböző válaszok vissza, ha a hiba akkor fordul elő, és ezeket a válaszokat is eltérhetnek attól függően, hogy a környezetben, a művelet; például a tárolási olvasása során hibát kapott válasz lehet hiba történt a válasz eltérő tárolási írásakor.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-131">Different resources are likely to return different responses when a fault occurs, and these responses may also vary depending on the context of the operation; for example, the response for an error when reading from storage may be different from response for an error when writing to storage.</span></span> <span data-ttu-id="2cf8a-132">Sok erőforrások és szolgáltatások rendelkeznek szerződések dokumentált átmeneti hiba történt.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-132">Many resources and services have well-documented transient failure contracts.</span></span> <span data-ttu-id="2cf8a-133">Azonban ha nem áll rendelkezésre, ezeket az információkat nehéz lehet felderíteni a hiba, valamint azt, hogy legyen valószínűleg átmeneti jellegétől.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-133">However, where such information is not available, it may be difficult to discover the nature of the fault and whether it is likely to be transient.</span></span>
* <span data-ttu-id="2cf8a-134">Az alkalmazás meg tudjanak próbálja megismételni a műveletet, ha azt állapítja meg, hogy a tartalék várhatóan átmenetiek lehetnek, és nyomon követheti, a szám, ahányszor a műveletet a rendszer újra megpróbálja elvégezni.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-134">The application must be able to retry the operation if it determines that the fault is likely to be transient and keep track of the number of times the operation was retried.</span></span>
* <span data-ttu-id="2cf8a-135">Az alkalmazás a próbálkozások megfelelő stratégiát kell használnia.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-135">The application must use an appropriate strategy for the retries.</span></span> <span data-ttu-id="2cf8a-136">Ezt a stratégiát határozza meg, hogy hányszor, akkor újra kell, a késleltetés között minden kísérlet, illetve a műveletek egy sikertelen kísérlet után.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-136">This strategy specifies the number of times it should retry, the delay between each attempt, and the actions to take after a failed attempt.</span></span> <span data-ttu-id="2cf8a-137">A megfelelő próbálkozások száma és a késleltetés között mindegyik nehezen gyakran határozza meg, és az erőforrás típusát, valamint magának az alkalmazásnak és az erőforrás jelenlegi üzemi körülmények függően változhat.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-137">The appropriate number of attempts and the delay between each one are often difficult to determine, and vary based on the type of resource as well as the current operating conditions of the resource and the application itself.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="2cf8a-138">Általános irányelveket</span><span class="sxs-lookup"><span data-stu-id="2cf8a-138">General guidelines</span></span>
<span data-ttu-id="2cf8a-139">A következő irányelveket segít kialakítani a megfelelő átmeneti hiba, az alkalmazások mechanizmus átadás:</span><span class="sxs-lookup"><span data-stu-id="2cf8a-139">The following guidelines will help you to design a suitable transient fault handing mechanism for your applications:</span></span>

* <span data-ttu-id="2cf8a-140">**Állapítsa meg, hogy van-e egy beépített újrapróbálkozási mechanizmus:**</span><span class="sxs-lookup"><span data-stu-id="2cf8a-140">**Determine if there is a built-in retry mechanism:**</span></span>
  * <span data-ttu-id="2cf8a-141">Sok egy SDK vagy az ügyfél könyvtár, egy átmeneti hiba mechanizmusban tartalmazó biztosítanak.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-141">Many services provide an SDK or client library that contains a transient fault handling mechanism.</span></span> <span data-ttu-id="2cf8a-142">Az újrapróbálkozási házirendet alkalmaz általában szabva jellege és a célként megadott szolgáltatás követelményeinek.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-142">The retry policy it uses is typically tailored to the nature and requirements of the target service.</span></span> <span data-ttu-id="2cf8a-143">REST illesztőfelületek a szolgáltatások azt is megteheti, hogy egy újabb megfelelő, és mennyi ideig várjon a következő újrapróbálkozási kísérlet előtt meghatározni, hogy hasznos információk térhetnek vissza.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-143">Alternatively, REST interfaces for services may return information that is useful in determining whether a retry is appropriate, and how long to wait before the next retry attempt.</span></span>
  * <span data-ttu-id="2cf8a-144">A automatikusan újrapróbálkozik mechanizmust használni, ahol egy áll rendelkezésre, kivéve, ha az adott és jól érthető a követelmények, amely egy másik újrapróbálási viselkedése pontosabb jelenti.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-144">Use the built-in retry mechanism where one is available unless you have specific and well-understood requirements that mean a different retry behavior is more appropriate.</span></span>
* <span data-ttu-id="2cf8a-145">**Annak megállapítása, hogy a művelet ismételt próbálkozás alkalmas**:</span><span class="sxs-lookup"><span data-stu-id="2cf8a-145">**Determine if the operation is suitable for retrying**:</span></span>
  * <span data-ttu-id="2cf8a-146">Műveletek csak újra kell próbálkoznia, ahol a hibákra átmeneti (általában a hiba természetét jelölve), és legalább néhány a valószínűsége annak, hogy a művelet sikeres lesz, amikor reattempted.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-146">You should only retry operations where the faults are transient (typically indicated by the nature of the error), and if there is at least some likelihood that the operation will succeed when reattempted.</span></span> <span data-ttu-id="2cf8a-147">Nincs a műveletek, például egy adatbázis érvénytelen műveletet jelző megoldódhat pont frissítése egy elem nem létezik, vagy egy szolgáltatás vagy az erőforrások, amelyek egy végzetes hiba jelentkezett-kérelmeket</span><span class="sxs-lookup"><span data-stu-id="2cf8a-147">There is no point in reattempting operations that indicate an invalid operation such as a database update to an item that does not exist, or requests to a service or resource that has suffered a fatal error</span></span>
  * <span data-ttu-id="2cf8a-148">Meg kell valósítania általában újrapróbálkozások, csak ha a teljes hatásának lehet meghatározni, és a feltételek helyes értendők, és érvényesíteni lehessen.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-148">In general, you should implement retries only where the full impact of this can be determined, and the conditions are well understood and can be validated.</span></span> <span data-ttu-id="2cf8a-149">Ha nem, akkor hagyja a mezőt a hívó kód újrapróbálkozások végrehajtásához.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-149">If not, leave it to the calling code to implement retries.</span></span> <span data-ttu-id="2cf8a-150">Ne feledje, hogy erőforrások által visszaadott hibák a verzióinformációk előfordulhat, hogy a vezérlő kívül szolgáltatások és az átmeneti hiba észlelési logika le újra szeretne.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-150">Remember that the errors returned from resources and services outside your control may evolve over time, and you may need to revisit your transient fault detection logic.</span></span>
  * <span data-ttu-id="2cf8a-151">Szolgáltatásokért és összetevőkért létrehozásakor fontolja meg a műveletek hibakódok és üzenetek, amely segít meghatározni, hogy azokat újra kell ügyfelek végrehajtása nem sikerült.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-151">When you create services or components, consider implementing error codes and messages that will help clients determine whether they should retry failed operations.</span></span> <span data-ttu-id="2cf8a-152">Különösen jelzik, ha az ügyfél érdemes újra megpróbálnia a művelet (lehet, hogy az adatszolgáltató által egy **isTransient** érték), és felajánlja a megfelelő késleltetést a következő újrapróbálkozási kísérlet előtt.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-152">In particular, indicate if the client should retry the operation (perhaps by returning an **isTransient** value) and suggest a suitable delay before the next retry attempt.</span></span> <span data-ttu-id="2cf8a-153">Ha egy webszolgáltatás, fontolja meg a szolgáltatási egyezmény belül definiált egyéni hibák visszaadása.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-153">If you build a web service, consider returning custom errors defined within your service contracts.</span></span> <span data-ttu-id="2cf8a-154">Annak ellenére, hogy általános előfordulhat, hogy nem tudják olvassa el az alábbi, fogják hasznos egyéni ügyfelek felépítése közben.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-154">Even though generic clients may not be able to read these, they will be useful when building custom clients.</span></span>
* <span data-ttu-id="2cf8a-155">**Határozza meg egy megfelelő újrapróbálkozások maximális számát és időköz:**</span><span class="sxs-lookup"><span data-stu-id="2cf8a-155">**Determine an appropriate retry count and interval:**</span></span>
  * <span data-ttu-id="2cf8a-156">Elengedhetetlen az újrapróbálkozások maximális számát és a használati eset típusú intervallum optimalizálása érdekében.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-156">It is vital to optimize the retry count and the interval to the type of use case.</span></span> <span data-ttu-id="2cf8a-157">Nem megfelelő számú alkalommal újra, ha az alkalmazás nem tudja végrehajtani a műveletet, és valószínűleg hibát tapasztal.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-157">If you do not retry a sufficient number of times, the application will be unable to complete the operation and is likely to experience a failure.</span></span> <span data-ttu-id="2cf8a-158">Ha túl sokszor újra, vagy a közötti túl rövid intervallum próbálkozik, az alkalmazás esetleg tárolására képes erőforrások, például a szálak, kapcsolatok és memória hosszú ideig, ami kedvezőtlen hatással lesz az alkalmazás állapotáról.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-158">If you retry too many times, or with too short an interval between tries, the application can potentially hold resources such as threads, connections, and memory for long periods, which will adversely affect the health of the application.</span></span>
  * <span data-ttu-id="2cf8a-159">A megfelelő értékeket az időintervallum és újrapróbálkozási kísérleteinek száma attól függ, hogy a művelet végrehajtására történt kísérlet típusú.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-159">The appropriate values for the time interval and the number of retry attempts depend on the type of operation being attempted.</span></span> <span data-ttu-id="2cf8a-160">Például, ha a művelet a felhasználói beavatkozás része, a időköz csak rövid és a csak néhány próbálkozás történt elkerülése érdekében, így a felhasználók a válaszra való várakozás (amely tartalmazza a nyitott kapcsolatot, és csökkentheti a rendelkezésre állási más felhasználók számára).</span><span class="sxs-lookup"><span data-stu-id="2cf8a-160">For example, if the operation is part of a user interaction, the interval should be short and only a few retries attempted to avoid making users wait for a response (which holds open connections and can reduce availability for other users).</span></span> <span data-ttu-id="2cf8a-161">Ha a művelet hosszú ideig futó vagy kritikus munkafolyamat részét képezi, hol található a program megszakítja, és indítsa újra a folyamatot, hogy költséges vagy időigényes, célszerű már próbálkozások között várnia, majd próbálja megismételni a több alkalommal.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-161">If the operation is part of a long running or critical workflow, where cancelling and restarting the process is expensive or time-consuming, it is appropriate to wait longer between attempts and retry more times.</span></span>
  * <span data-ttu-id="2cf8a-162">A megfelelő próbálkozások közötti időintervallumot meghatározása része a legbonyolultabb sikeres stratégia tervezése.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-162">Determining the appropriate intervals between retries is the most difficult part of designing a successful strategy.</span></span> <span data-ttu-id="2cf8a-163">Tipikus stratégiák használja a következő típusú újrapróbálkozási időköz:</span><span class="sxs-lookup"><span data-stu-id="2cf8a-163">Typical strategies use the following types of retry interval:</span></span>
    * <span data-ttu-id="2cf8a-164">**Az exponenciális vissza ki**.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-164">**Exponential back-off**.</span></span> <span data-ttu-id="2cf8a-165">Az alkalmazás rövid időn belül az első újrapróbálkozásnál, és exponenciálisan növelése minden ezt követő újrapróbálkozási közötti idő előtt megvárja-e.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-165">The application waits a short time before the first retry, and then exponentially increasing times between each subsequent retry.</span></span> <span data-ttu-id="2cf8a-166">Előfordulhat például, próbálja megismételni a műveletet után 3 másodpercet, 12 másodperc, 30 másodperces, és így tovább.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-166">For example, it may retry the operation after 3 seconds, 12 seconds, 30 seconds, and so on.</span></span>
    * <span data-ttu-id="2cf8a-167">**Növekményes intervallumok**.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-167">**Incremental intervals**.</span></span> <span data-ttu-id="2cf8a-168">Az alkalmazás rövid időn belül az első újrapróbálkozásnál, és fokozatosan növekszik minden ezt követő újrapróbálkozási közötti idő előtt megvárja-e.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-168">The application waits a short time before the first retry, and then incrementally increasing times between each subsequent retry.</span></span> <span data-ttu-id="2cf8a-169">Előfordulhat, hogy például akkor próbálja megismételni a műveletet után 3 másodpercet, 7 másodperc, 13 másodpercen belül, és így tovább.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-169">For example, it may retry the operation after 3 seconds, 7 seconds, 13 seconds, and so on.</span></span>
    * <span data-ttu-id="2cf8a-170">**Rendszeres időközönként**.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-170">**Regular intervals**.</span></span> <span data-ttu-id="2cf8a-171">Az alkalmazás egyes kísérletek között eltelt idő azonos időszakára vár.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-171">The application waits for the same period of time between each attempt.</span></span> <span data-ttu-id="2cf8a-172">Például akkor lehet, hogy újra a művelettel 3 másodpercenként.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-172">For example, it may retry the operation every 3 seconds.</span></span>
    * <span data-ttu-id="2cf8a-173">**Azonnali újrapróbálkozási**.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-173">**Immediate retry**.</span></span> <span data-ttu-id="2cf8a-174">Néha egy átmeneti hiba nagyon rövid, esetleg egy eseményt, például egy hálózati csomag ütközési vagy egy csúcs az igények egy hardverösszetevő okozza.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-174">Sometimes a transient fault is extremely short, perhaps caused by an event such as a network packet collision or a spike in a hardware component.</span></span> <span data-ttu-id="2cf8a-175">Ebben az esetben azonnal megpróbálná megismételni a műveletet nem megfelelő mert sikeres lehet, ha a hiba az alkalmazás összeállítása és a következő kérés küldése szükséges idő a törölve.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-175">In this case, retrying the operation immediately is appropriate because it may succeed if the fault has cleared in the time it takes the application to assemble and send the next request.</span></span> <span data-ttu-id="2cf8a-176">Azonban soha nem kell több azonnali újrapróbálkozási kísérletek, és kell vált alternatív stratégiák, mint például az exponenciális vissza ki- és tartalék műveletek, ha az azonnali újrapróbálkozási sikertelen.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-176">However, there should never be more than one immediate retry attempt, and you should switch to alternative strategies, such as such as exponential back-off or fallback actions, if the immediate retry fails.</span></span>
    * <span data-ttu-id="2cf8a-177">**Véletlenszerű**.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-177">**Randomization**.</span></span> <span data-ttu-id="2cf8a-178">A fent felsorolt stratégiák újrapróbálkozási bármelyikét tartalmazhatják a véletlenszerű, hogy megakadályozza az ügyfél későbbi újrapróbálkozások egyszerre több példányát.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-178">Any of the retry strategies listed above may include a randomization to prevent multiple instances of the client sending subsequent retry attempts at the same time.</span></span> <span data-ttu-id="2cf8a-179">Például egy példány újrapróbálkozik a művelet után 3 másodpercet, 11 másodperc, 28 másodperc és így tovább, amíg egy másik példánya lehet, hogy után próbálja megismételni a műveletet 4 másodperc, 12 másodperc, 26 másodperc, és így tovább.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-179">For example, one instance may retry the operation after 3 seconds, 11 seconds, 28 seconds, and so on while another instance may retry the operation after 4 seconds, 12 seconds, 26 seconds, and so on.</span></span> <span data-ttu-id="2cf8a-180">Véletlenszerű a hasznos technika, amely más stratégiák kombinálhatók.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-180">Randomization is a useful technique that may be combined with other strategies.</span></span>  
  * <span data-ttu-id="2cf8a-181">Általános irányelvként elmondható használja a exponenciális vissza az indító stratégia háttér üzemelnek, és azonnali vagy rendszeres időköz újrapróbálkozási stratégiák interaktív műveletekhez.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-181">As a general guideline, use an exponential back-off strategy for background operations, and immediate or regular interval retry strategies for interactive operations.</span></span> <span data-ttu-id="2cf8a-182">Mindkét esetben a késleltetés kell kiválasztani, és az újrapróbálkozások maximális számát, hogy az összes maximális késleltetés az újrapróbálkozások megfelel a szükséges végpontok-késési követelménynek.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-182">In both cases, you should choose the delay and the retry count so that the maximum latency for all retry attempts is within the required end-to-end latency requirement.</span></span>
  * <span data-ttu-id="2cf8a-183">Vegye figyelembe a tényezőket, amelyek a rendszer művelet teljes maximális időtúllépés kombinációja.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-183">Take into account the combination of all the factors that contribute to the overall maximum timeout for a retried operation.</span></span> <span data-ttu-id="2cf8a-184">Ezek a tényezők közé tartoznak a sikertelen kapcsolódás választ (általában az ügyfél egy időtúllépési értéket állítja be) eredményezett igénybe vett idő és a késleltetés, újrapróbálkozások és az újrapróbálkozások maximális számát</span><span class="sxs-lookup"><span data-stu-id="2cf8a-184">These factors include the time taken for a failed connection to produce a response (typically set by a timeout value in the client) as well as the delay between retry attempts and the maximum number of retries.</span></span> <span data-ttu-id="2cf8a-185">Ezekben az időszakokban az összes eredményezhet nagy általános művelet időpontokat, különösen ha egy exponenciális késleltetés stratégia használata, ahol az újrapróbálkozások között növekedésének gyorsan minden egyes hiba után.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-185">The total of all these times can result in very large overall operation times, especially when using an exponential delay strategy where the interval between retries grows rapidly after each failure.</span></span> <span data-ttu-id="2cf8a-186">Ha egy folyamatot meg kell felelnie egy meghatározott szolgáltatásiszint-szerződéssel (SLA), a teljes műveletet idejét, az összes időtúllépések és várakozás, beleértve belül, amely definiálni kell a szolgáltatásiszint-szerződés</span><span class="sxs-lookup"><span data-stu-id="2cf8a-186">If a process must meet a specific service level agreement (SLA), the overall operation time, including all timeouts and delays, must be within that defined in the SLA</span></span>
  * <span data-ttu-id="2cf8a-187">Over-Aggressive újrapróbálkozási stratégiát, túl rövid intervallumok rendelkezik vagy túl is újrapróbálkozik, a cél erőforráson vagy szolgáltatás kedvezőtlen hatással lehet.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-187">Over-aggressive retry strategies, which have too short intervals or too may retries, can have an adverse effect on the target resource or service.</span></span> <span data-ttu-id="2cf8a-188">Ez előfordulhat, hogy az erőforrás vagy a szolgáltatás túlterhelt állapotát helyre, és továbbra is letilthatja vagy elutasítja a kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-188">This may prevent the resource or service from recovering from its overloaded state, and it will continue to block or refuse requests.</span></span> <span data-ttu-id="2cf8a-189">Ennek eredményeképp a ahol egyre több kérelmeket küld az erőforrás vagy szolgáltatás, és ezért képességét a helyreállítás vicious kör további csökken.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-189">This results in a vicious circle where more and more requests are sent to the resource or service, and consequently its ability to recover is further reduced.</span></span>
  * <span data-ttu-id="2cf8a-190">Vegye figyelembe az időtúllépés a műveletek indítása a következő kísérlet azonnal (például, ha az időkorlát hasonlít az újrapróbálkozási időköz) elkerülése érdekében az újrapróbálkozási időközöket kiválasztásakor.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-190">Take into account the timeout of the operations when choosing the retry intervals to avoid launching a subsequent attempt immediately (for example, if the timeout period is similar to the retry interval).</span></span> <span data-ttu-id="2cf8a-191">Is figyelembe vennie, ha a teljes lehetséges időszak (időkorlát és az újrapróbálkozási időközöket) egy adott időtartam alatt tartani.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-191">Also consider if you need to keep the total possible period (the timeout plus the retry intervals) to below a specific total time.</span></span> <span data-ttu-id="2cf8a-192">Szokatlanul hosszú vagy nagyon rövid időtúllépések rendelkező műveletek befolyásolhatják, mennyi ideig való várja meg, és hogy milyen gyakran próbálja megismételni a műveletet.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-192">Operations that have unusually short or very long timeouts may influence how long to wait, and how often to retry the operation.</span></span>
  * <span data-ttu-id="2cf8a-193">A kivétel és bármilyen adatot tartalmaz, vagy a hibakódok és a szolgáltatás által visszaadott üzenetek segítségével optimalizálhatja azt az időközt, és az újbóli próbálkozások számát.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-193">Use the type of the exception and any data it contains, or the error codes and messages returned from the service, to optimize the interval and the number of retries.</span></span> <span data-ttu-id="2cf8a-194">Például bizonyos kivételek vagy hiba kódok (például a HTTP 503-as szolgáltatás nem használható egy fejléccel újrapróbálkozási után a válaszban szereplő kód) jelezheti mennyi ideig lehet, hogy utoljára a hiba, illetve hogy a szolgáltatás sikertelen volt, ezért nem fog válaszolni bármely ezt követő kísérletek.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-194">For example, some exceptions or error codes (such as the HTTP code 503 Service Unavailable with a Retry-After header in the response) may indicate how long the error might last, or that the service has failed and will not respond to any subsequent attempt.</span></span>
* <span data-ttu-id="2cf8a-195">**Víruskereső minták elkerülése**:</span><span class="sxs-lookup"><span data-stu-id="2cf8a-195">**Avoid anti-patterns**:</span></span>
  * <span data-ttu-id="2cf8a-196">Az esetek többsége ne megvalósításokhoz, amely tartalmazza az újrapróbálkozási szabályzat duplikált rétegek.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-196">In the vast majority of cases, you should avoid implementations that include duplicated layers of retry code.</span></span> <span data-ttu-id="2cf8a-197">Elkerüléséhez terveket, amelyek tartalmazzák a kaszkádolt újrapróbálkozási mechanizmus, vagy amelyek megvalósítják az újrapróbálkozási egy művelet, amely magában foglalja a kérelmek, a hierarchia minden szakaszban, ha nincs konkrét követelmények, hogy igény szerint.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-197">Avoid designs that include cascading retry mechanisms, or that implement retry at every stage of an operation that involves a hierarchy of requests, unless you have specific requirements that demand this.</span></span> <span data-ttu-id="2cf8a-198">Ilyen kivételes körülmények között házirendekkel, amelyek megakadályozzák az újrapróbálkozások és a késleltetés időszakok túlzott számát, és győződjön meg arról, hogy tisztában a következményekkel.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-198">In these exceptional circumstances, use policies that prevent excessive numbers of retries and delay periods, and make sure you understand the consequences.</span></span> <span data-ttu-id="2cf8a-199">Például egy összetevő egy kérést küld egy másik, mely majd fér hozzá a célként megadott szolgáltatás, és valósítja meg a számával, három mindkét hívásoknál nem lesznek újra kilenc újra próbálja összesen a szolgáltatásra.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-199">For example, if one component makes a request to another, which then accesses the target service, and you implement retry with a count of three on both calls there will be nine retry attempts in total against the service.</span></span> <span data-ttu-id="2cf8a-200">Sok szolgáltatásokat és erőforrásokat megvalósítása beépített újrapróbálkozási mechanizmussal, és ki kell vizsgálni, hogyan tiltsa le, vagy módosítsa, ha kell megvalósítani a magasabb szintű újrapróbálkozások.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-200">Many services and resources implement a built-in retry mechanism and you should investigate how you can disable or modify this if you need to implement retries at a higher level.</span></span>
  * <span data-ttu-id="2cf8a-201">Soha nem valósítja meg az végtelen újrapróbálkozási mechanizmus.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-201">Never implement an endless retry mechanism.</span></span> <span data-ttu-id="2cf8a-202">Valószínű, hogy megakadályozza a erőforrás és a szolgáltatás történő helyreállítás túlterhelési helyzetekben, és a szabályozás, és a kapcsolatok hosszabb ideig folytatja visszautasította.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-202">This is likely to prevent the resource or service recovering from overload situations, and cause throttling and refused connections to continue for a longer period.</span></span> <span data-ttu-id="2cf8a-203">Véges számnak vagy az újrapróbálkozások, illetve valósítja meg, mint a minta [áramköri megszakító](http://msdn.microsoft.com/library/dn589784.aspx) ahhoz, hogy a helyreállítása.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-203">Use a finite number or retries, or implement a pattern such as [Circuit Breaker](http://msdn.microsoft.com/library/dn589784.aspx) to allow the service to recover.</span></span>
  * <span data-ttu-id="2cf8a-204">Soha ne hajtsa végre a egy azonnali újrapróbálkozási egynél többször.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-204">Never perform an immediate retry more than once.</span></span>
  * <span data-ttu-id="2cf8a-205">Kerülje a rendszeres újrapróbálkozási időközt, különösen, ha nagyszámú újrapróbálkozások, szolgáltatások és erőforrások az Azure-ban való hozzáféréskor.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-205">Avoid using a regular retry interval, especially when you have a large number of retry attempts, when accessing services and resources in Azure.</span></span> <span data-ttu-id="2cf8a-206">Az optimális megközelítés ebben a forgatókönyvben egy exponenciális vissza az indító stratégia a kapcsolatcsoport legfrissebb alkalmas.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-206">The optimum approach is this scenario is an exponential back-off strategy with a circuit-breaking capability.</span></span>
  * <span data-ttu-id="2cf8a-207">Megakadályozza a több példánya ugyanazt az ügyfelet, és az újrapróbálkozások küldjenek a azonos időpontokban a különböző ügyfelek több példányát.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-207">Prevent multiple instances of the same client, or multiple instances of different clients, from sending retries at the same times.</span></span> <span data-ttu-id="2cf8a-208">Ennek oka az lehet, hogy mi történjen, ha vezethet be a újrapróbálkozási időközt véletlenszerű.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-208">If this is likely to occur, introduce randomization into the retry intervals.</span></span>
* <span data-ttu-id="2cf8a-209">**Az újrapróbálkozási stratégiát és -megvalósítási teszteléséhez:**</span><span class="sxs-lookup"><span data-stu-id="2cf8a-209">**Test your retry strategy and implementation:**</span></span>
  * <span data-ttu-id="2cf8a-210">Győződjön meg arról, teljes mértékben tesztelése alatt újrapróbálkozási stratégia megvalósítását készletként kiterjedő körülmények között a lehető, különösen akkor, ha mind az alkalmazás és a cél erőforrásokhoz vagy szolgáltatásokhoz használja szélsőséges terhelés alatt van.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-210">Ensure you fully test your retry strategy implementation under as wide a set of circumstances as possible, especially when both the application and the target resources or services it uses are under extreme load.</span></span> <span data-ttu-id="2cf8a-211">Viselkedés a tesztelés során ellenőrzéséhez a következőket teheti:</span><span class="sxs-lookup"><span data-stu-id="2cf8a-211">To check behavior during testing, you can:</span></span>
    * <span data-ttu-id="2cf8a-212">Átmeneti és nem átmeneti hibák szúrjon be a szolgáltatásba.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-212">Inject transient and non-transient faults into the service.</span></span> <span data-ttu-id="2cf8a-213">Például küldjön érvénytelen kérelmeket, vagy adja hozzá a kódot, amely észleli a vizsgálat kér, és válaszol, különböző típusú hibák.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-213">For example, send invalid requests or add code that detects test requests and responds with different types of errors.</span></span> <span data-ttu-id="2cf8a-214">TestApi használatával példáért lásd: [tartalék TestApi tesztelést injektálási](http://msdn.microsoft.com/magazine/ff898404.aspx) és [TestApi – rész 5 bemutatása: felügyelt kód tartalék beszúrására szolgáló API-k](http://blogs.msdn.com/b/ivo_manolov/archive/2009/11/25/9928447.aspx).</span><span class="sxs-lookup"><span data-stu-id="2cf8a-214">For an example using TestApi, see [Fault Injection Testing with TestApi](http://msdn.microsoft.com/magazine/ff898404.aspx) and [Introduction to TestApi – Part 5: Managed Code Fault Injection APIs](http://blogs.msdn.com/b/ivo_manolov/archive/2009/11/25/9928447.aspx).</span></span>
    * <span data-ttu-id="2cf8a-215">Hozzon létre egy mock erőforrás vagy szolgáltatás, amely a hibákat, a tényleges szolgáltatás térhetnek vissza számos adja vissza.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-215">Create a mock of the resource or service that returns a range of errors that the real service may return.</span></span> <span data-ttu-id="2cf8a-216">Győződjön meg arról, fedik le a hiba minden típusú, amely az újrapróbálkozási stratégiát észlelésére szolgál.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-216">Ensure you cover all the types of error that your retry strategy is designed to detect.</span></span>
    * <span data-ttu-id="2cf8a-217">Átmeneti hibát ideiglenesen letiltása, vagy ha egy egyéni szolgáltatás létrehozott és telepített, túl van terhelve, hogy a szolgáltatás által kényszerített (meg kell nem, természetesen megkísérelhetik túlterhelni a megosztott erőforrás vagy megosztott szolgáltatások, Azure-ban).</span><span class="sxs-lookup"><span data-stu-id="2cf8a-217">Force transient errors to occur by temporarily disabling or overloading the service if it is a custom service that you created and deployed (you should not, of course, attempt to overload any shared resources or shared services within Azure).</span></span>
    * <span data-ttu-id="2cf8a-218">HTTP-alapú API-k esetében fontolja meg az automatikus tesztek a FiddlerCore szalagtár módosítása a HTTP-kérelmek eredményét extra körbejárási alkalommal hozzáadásával vagy a válasz (például a HTTP-állapotkód:, fejléc, törzs vagy egyéb tényezők) módosításával.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-218">For HTTP-based APIs, consider using the FiddlerCore library in your automated tests to change the outcome of HTTP requests, either by adding extra roundtrip times or by changing the response (such as the HTTP status code, headers, body, or other factors).</span></span> <span data-ttu-id="2cf8a-219">Ez lehetővé teszi a meghibásodás részhalmazát, determinisztikus teszteléséhez e átmeneti hibák vagy egyéb típusú hiba.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-219">This enables deterministic testing of a subset of the failure conditions, whether transient faults or other types of failure.</span></span> <span data-ttu-id="2cf8a-220">További információkért lásd: [FiddlerCore](http://www.telerik.com/fiddler/fiddlercore).</span><span class="sxs-lookup"><span data-stu-id="2cf8a-220">For more information, see [FiddlerCore](http://www.telerik.com/fiddler/fiddlercore).</span></span> <span data-ttu-id="2cf8a-221">Példákat arra, hogyan használható a könyvtár különösen a **HttpMangler** osztály, tekintse meg a [forráskód az Azure Storage szolgáltatás SDK](https://github.com/Azure/azure-storage-net/tree/master/Test).</span><span class="sxs-lookup"><span data-stu-id="2cf8a-221">For examples of how to use the library, particularly the **HttpMangler** class, examine the [source code for the Azure Storage SDK](https://github.com/Azure/azure-storage-net/tree/master/Test).</span></span>
    * <span data-ttu-id="2cf8a-222">Hajtsa végre a nagy terhelés tényező és egyidejűleg vizsgálatok ügyeljen arra, hogy az újrapróbálkozási mechanizmus és stratégia működik megfelelően a ezeket a feltételeket, és nem rendelkezik a művelet az ügyfél kedvezőtlen hatással vagy okozhat a kereszt-szennyezés kérelmek között.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-222">Perform high load factor and concurrent tests to ensure that the retry mechanism and strategy works correctly under these conditions, and does not have an adverse effect on the operation of the client or cause cross-contamination between requests.</span></span>
* <span data-ttu-id="2cf8a-223">**Újrapróbálkozási házirend-konfigurációk kezelése:**</span><span class="sxs-lookup"><span data-stu-id="2cf8a-223">**Manage retry policy configurations:**</span></span>
  * <span data-ttu-id="2cf8a-224">A *újrapróbálkozási házirendet* az elemek az újrapróbálkozási stratégia kombinációja.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-224">A *retry policy* is a combination of all of the elements of your retry strategy.</span></span> <span data-ttu-id="2cf8a-225">Azt határozza meg az észlelési folyamat, amely meghatározza, hogy a hibát valószínűleg átmeneti, az időköz, majd ismételje meg a tényleges időköz értékének és az a szám, ahányszor (például a normál, exponenciális vissza ki, és a véletlenszerű) használatához típusát.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-225">It defines the detection mechanism that determines whether a fault is likely to be transient, the type of interval to use (such as regular, exponential back-off, and randomization), the actual interval value(s), and the number of times to retry.</span></span>
  * <span data-ttu-id="2cf8a-226">Az újrapróbálkozások kell megvalósítani, még akkor is a legegyszerűbb alkalmazáson belül több helyen, és minden réteget összetettebb alkalmazásokat.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-226">Retries must be implemented in many places within even the simplest application, and in every layer of more complex applications.</span></span> <span data-ttu-id="2cf8a-227">Ahelyett, hogy a rögzített megadás egyes házirendek a különböző helyeken az elemek, érdemes lehet egy központi helyen a házirendek tárolásához.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-227">Rather than hard-coding the elements of each policy at multiple locations, consider using a central point for storing all the policies.</span></span> <span data-ttu-id="2cf8a-228">Például tárolja az értékeket, például az az időköz és ismételje meg az alkalmazás konfigurációs fájlok száma, futási időben olvashatja őket és az újrapróbálkozási házirendek programozott módon build.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-228">For example, store the values such as the interval and retry count in application configuration files, read them at runtime, and programmatically build the retry policies.</span></span> <span data-ttu-id="2cf8a-229">Így könnyebben kezelheti a beállításokat, és módosítsa, és konfigurálva finomhangolhatják a értékek ahhoz, hogy reagálni a követelményeket és forgatókönyvek.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-229">This makes it easier to manage the settings, and to modify and fine tune the values in order to respond to changing requirements and scenarios.</span></span> <span data-ttu-id="2cf8a-230">A rendszer az értékek tárolásához helyett rereading a konfigurációs fájlt minden olyan alkalommal, és megfelelő alapértelmezett értékeket használják, ha az érték nem lehet lekérdezni a configuration azonban tervezhet.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-230">However, design the system to store the values rather than rereading a configuration file every time, and ensure suitable defaults are used if the values cannot be obtained from configuration.</span></span>
  * <span data-ttu-id="2cf8a-231">Azure Cloud Services kérelmet fontolja meg az tárolása az értékek, amelyek alapján állítja össze az újrapróbálkozási házirendeket a szolgáltatás konfigurációs fájljában futásidőben, így módosíthatja őket anélkül, hogy indítsa újra az alkalmazást.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-231">In an Azure Cloud Services application, consider storing the values that are used to build the retry policies at runtime in the service configuration file so that they can be changed without needing to restart the application.</span></span>
  * <span data-ttu-id="2cf8a-232">Kihasználni a beépített vagy az alapértelmezett érték az ügyfél API-kat használ, de csak akkor, ha azok a forgatókönyvnek megfelelő újrapróbálkozási stratégiát.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-232">Take advantage of built-in or default retry strategies available in the client APIs you use, but only where they are appropriate for your scenario.</span></span> <span data-ttu-id="2cf8a-233">Ezek a stratégiák általában általános célú.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-233">These strategies are typically general-purpose.</span></span> <span data-ttu-id="2cf8a-234">Bizonyos esetekben lehet szükséges, de más esetekben előfordulhat, hogy nem biztosítanak a teljes számos olyan lehetőséget konkrét igényeinek.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-234">In some scenarios they may be all that is required, but in other scenarios they may not offer the full range of options to suit your specific requirements.</span></span> <span data-ttu-id="2cf8a-235">Ismernie kell arról, hogy a beállítások milyen hatással van az alkalmazás tesztelése keresztül a leginkább megfelelő értékek meghatározásáról.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-235">You must understand how the settings will affect your application through testing to determine the most appropriate values.</span></span>
* <span data-ttu-id="2cf8a-236">**Naplófájl, és nyomon követéséhez átmeneti és nem átmeneti hibák:**</span><span class="sxs-lookup"><span data-stu-id="2cf8a-236">**Log and track transient and non-transient faults:**</span></span>
  * <span data-ttu-id="2cf8a-237">Az újrapróbálkozási stratégia részeként tartalmazza a kivétel- és egyéb instrumentation, amelyre bejelentkezik, amikor újra kísérletet tesz.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-237">As part of your retry strategy, include exception handling and other instrumentation that logs when retry attempts are made.</span></span> <span data-ttu-id="2cf8a-238">Míg egy alkalmi átmeneti hiba történt, és próbálkozzon újra várható, és nem jelölnek újrapróbálkozások problémát, rendszeres és növekvő száma általában azt jelzi, hogy a hibát, amely hibákat okozhatnak, vagy jelenleg van hatással az alkalmazások teljesítményének és a rendelkezésre állás.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-238">While an occasional transient failure and retry are to be expected, and do not indicate a problem, regular and increasing numbers of retries are often an indicator of an issue that may cause a failure, or is currently impacting application performance and availability.</span></span>
  * <span data-ttu-id="2cf8a-239">Jelentkezzen be átmeneti hiba bejegyzéseket, hanem figyelmeztetés bejegyzéseket, úgy, hogy a rendszerek nem észlelt őket, lehetséges, hogy a téves riasztások kiváltó alkalmazáshibák.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-239">Log transient faults as Warning entries rather than Error entries so that monitoring systems do not detect them as application errors that may trigger false alerts.</span></span>
  * <span data-ttu-id="2cf8a-240">Érdemes tárolni egy értéket a naplóbejegyzéseket, amely jelzi, ha az újrapróbálkozások okozta, a szolgáltatás szabályozásával, illetve más típusú hibák esetén kapcsolódási hibákat, például így meg lehet különböztetni ezeket az adatok elemzése során.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-240">Consider storing a value in your log entries that indicates if the retries were caused by throttling in the service, or by other types of faults such as connection failures, so that you can differentiate them during analysis of the data.</span></span> <span data-ttu-id="2cf8a-241">A sávszélesség-szabályozási hibák száma növekedése legtöbbször azt jelzi, hogy az alkalmazást, vagy váltson át a premium szolgáltatás, amely nyújt, dedikált hardver szükséges tervezési hibája.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-241">An increase in the number of throttling errors is often an indicator of a design flaw in the application or the need to switch to a premium service that offers dedicated hardware.</span></span>  
  * <span data-ttu-id="2cf8a-242">Vegye figyelembe a mérésére, és a teljes idő, amely tartalmazza az újrapróbálkozási mechanizmussal műveletek naplózása.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-242">Consider measuring and logging the overall time taken for operations that include a retry mechanism.</span></span> <span data-ttu-id="2cf8a-243">Ez az átmeneti végeredményben jól jelzi a felhasználó válaszidejét, folyamat várakozási ideje és az alkalmazás használati esete hatékonyságát.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-243">This is a good indicator of the overall effect of transient faults on user response times, process latency, and the efficiency of the application use cases.</span></span> <span data-ttu-id="2cf8a-244">Napló az újbóli próbálkozások számát is történt ahhoz, hogy a válaszidő hozzájáruló tényezők megértéséhez.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-244">Also log the number of retries occurred in order to understand the factors that contributed to the response time.</span></span>
  * <span data-ttu-id="2cf8a-245">Vegye figyelembe a telemetriai adatok végrehajtási és is növelheti a riasztásokat, amikor a rendszer és sikertelen, az újbóli próbálkozások átlagos számának figyelése, vagy a teljes időpontok végrehajtott műveletek, növekszik.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-245">Consider implementing a telemetry and monitoring system that can raise alerts when the number and rate of failures, the average number of retries, or the overall times taken for operations to succeed, is increasing.</span></span>
* <span data-ttu-id="2cf8a-246">**Folyamatosan eleget nem tevő műveletek kezelése:**</span><span class="sxs-lookup"><span data-stu-id="2cf8a-246">**Manage operations that continually fail:**</span></span>
  
  * <span data-ttu-id="2cf8a-247">Ha a művelet továbbra is minden kísérlet sikertelen, és fontos figyelembe venni, hogyan fogja kezelni ezt a helyzetet körülmények között lesz:</span><span class="sxs-lookup"><span data-stu-id="2cf8a-247">There will be circumstances where the operation continues to fail at every attempt, and it is vital to consider how you will handle this situation:</span></span>
    * <span data-ttu-id="2cf8a-248">Bár egy újrapróbálkozási stratégiát határozza meg az a maximális száma egy műveletet meg kell ismételni, nem akadályozza meg a műveletet, ismétlődő újrapróbálkozások azonos számú az alkalmazás.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-248">Although a retry strategy will define the maximum number of times that an operation should be retried, it does not prevent the application repeating the operation again, with the same number of retries.</span></span> <span data-ttu-id="2cf8a-249">Például egy rendelés feldolgozása szolgáltatás súlyos hiba, amely véglegesen az kívüli művelet sikertelen, az újrapróbálkozási stratégiát is észlelése kapcsolódási időtúllépés és vegye figyelembe, hogy egy átmeneti hiba lehet.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-249">For example, if an order processing service fails with a fatal error that puts it out of action permanently, the retry strategy may detect a connection timeout and consider it to be a transient fault.</span></span> <span data-ttu-id="2cf8a-250">A kód fogja próbálja megismételni a műveletet a megadott számú alkalommal és majd feladták.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-250">The code will retry the operation a specified number of times and then give up.</span></span> <span data-ttu-id="2cf8a-251">Azonban, ha egy másik felhasználói sorrendben, a műveletet a rendszer ismét megkísérli - akkor is, ha arra, hogy minden olyan alkalommal sikertelen lesz.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-251">However, when another customer places an order, the operation will be attempted again - even though it is sure to fail every time.</span></span>
    * <span data-ttu-id="2cf8a-252">Folyamatosan sikertelen, vegye fontolóra műveletek folyamatos újrapróbálásainak megelőzése érdekében a [áramköri megszakító mintát](http://msdn.microsoft.com/library/dn589784.aspx).</span><span class="sxs-lookup"><span data-stu-id="2cf8a-252">To prevent continual retries for operations that continually fail, consider implementing the [Circuit Breaker pattern](http://msdn.microsoft.com/library/dn589784.aspx).</span></span> <span data-ttu-id="2cf8a-253">Ebben a mintában belül egy megadott időkeretnél hibák száma meghaladja a küszöbértéket, ha kérelmek vissza a hívónak azonnal, hibák, anélkül, hogy az erőforrás vagy a szolgáltatás elérésére tett kísérlet.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-253">In this pattern, if the number of failures within a specified time window exceeds the threshold, requests are returned to the caller immediately as errors, without attempting to access the failed resource or service.</span></span>
    * <span data-ttu-id="2cf8a-254">Az alkalmazás rendszeres időközönként tesztelheti a szolgáltatást, az időszakos alapján, hogy az nagyon hosszú kérelmek, észleléséhez, amikor elérhetővé válik gyakoriságát.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-254">The application can periodically test the service, on an intermittent basis and with very long intervals between requests, to detect when it becomes available.</span></span> <span data-ttu-id="2cf8a-255">Megfelelő időközönként a forgatókönyvet, például a kritikusság a művelet és a szolgáltatás jellegétől függ, és semmi néhány perc és több óra közötti lehet.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-255">An appropriate interval will depend on the scenario, such as the criticality of the operation and the nature of the service, and might be anything between a few minutes and several hours.</span></span> <span data-ttu-id="2cf8a-256">A pontnál, ahol a teszt sikeres az alkalmazás folytassa a munkát, és az újonnan helyreállított szolgáltatás kérelmek átadásához.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-256">At the point where the test succeeds, the application can resume normal operations and pass requests to the newly recovered service.</span></span>
    * <span data-ttu-id="2cf8a-257">Addig is, lehetséges, hogy lehetséges, hogy a szolgáltatás (feltehetően egy másik datacenter vagy alkalmazás) egy másik példánya visszaállni, használjon, amely kompatibilis (lehet, hogy egyszerűbb) funkciót kínál hasonló szolgáltatást, vagy valamilyen alternatív műveleteinek elvégzéséhez a reménysugár hogy a szolgáltatás hamarosan elérhető lesz.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-257">In the meantime, it may be possible to fall back to another instance of the service (perhaps in a different datacenter or application), use a similar service that offers compatible (perhaps simpler) functionality, or perform some alternative operations in the hope that the service will become available soon.</span></span> <span data-ttu-id="2cf8a-258">Például elképzelhető, hogy a megfelelő tárolja a beérkező kéréseket a sorhoz vagy adatokat tárolja, és később visszajátszásos őket.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-258">For example, it may be appropriate to store requests for the service in a queue or data store and replay them later.</span></span> <span data-ttu-id="2cf8a-259">Ellenkező esetben elképzelhető átirányítja a felhasználót az alkalmazás egy másik példánya, az alkalmazás teljesítményét, de továbbra is az elfogadható funkciókat kínálnak, vagy csak térjen vissza egy üzenet arról, hogy az alkalmazás nem érhető el a felhasználó jelenleg.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-259">Otherwise you might be able to redirect the user to an alternative instance of the application, degrade the performance of the application but still offer acceptable functionality, or just return a message to the user indicating that the application is not available at present.</span></span>
* <span data-ttu-id="2cf8a-260">**Egyéb szempontok**</span><span class="sxs-lookup"><span data-stu-id="2cf8a-260">**Other considerations**</span></span>
  
  * <span data-ttu-id="2cf8a-261">Az újrapróbálkozások számának és a házirend újrapróbálkozási intervallumok meghatározásakor vegye figyelembe, ha a szolgáltatás vagy az erőforrás a művelet hosszú futású vagy többlépéses művelet része.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-261">When deciding on the values for the number of retries and the retry intervals for a policy, consider if the operation on the service or resource is part of a long-running or multi-step operation.</span></span> <span data-ttu-id="2cf8a-262">Nehéz lehet, vagy drága kiegyensúlyozása működési lépést a, ha egy már sikeres volt sikertelen.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-262">It may be difficult or expensive to compensate all the other operational steps that have already succeeded when one fails.</span></span> <span data-ttu-id="2cf8a-263">Ebben az esetben egy nagyon hosszú időtartamot és nagyszámú újrapróbálkozások is elfogadható mindaddig, amíg nem blokkolja a többi művelet okozó vagy szűkös erőforrások zárolása.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-263">In this case, a very long interval and a large number of retries may be acceptable as long as it does not block other operations by holding or locking scarce resources.</span></span>
  * <span data-ttu-id="2cf8a-264">Vegye figyelembe, ha megpróbálná megismételni a műveletet is inkonzisztenciát okozhat adatok.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-264">Consider if retrying the same operation may cause inconsistencies in data.</span></span> <span data-ttu-id="2cf8a-265">Ha a folyamat egyes részei ismétlődjenek-e, és a műveletek még nem idempotent, akkor azt eredményezheti, inkonzisztencia.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-265">If some parts of a multi-step process are repeated, and the operations are not idempotent, it may result in an inconsistency.</span></span> <span data-ttu-id="2cf8a-266">Például-os értéket, művelet ismétlődik, ha a művelet létrehoz egy érvénytelen eredményt.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-266">For example, an operation that increments a value, if repeated, will produce an invalid result.</span></span> <span data-ttu-id="2cf8a-267">Üzenet küldése egy üzenetsorba műveletet ismétlődő okozhat Inkonzisztencia a üzenetfogyasztó Ha nem tudja megállapítani a duplikált üzenetek.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-267">Repeating an operation that sends a message to a queue may cause an inconsistency in the message consumer if it cannot detect duplicate messages.</span></span> <span data-ttu-id="2cf8a-268">Ennek megelőzése érdekében győződjön meg arról, hogy alakítson ki minden lépés idempotent műveletként.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-268">To prevent this, ensure that you design each step as an idempotent operation.</span></span> <span data-ttu-id="2cf8a-269">Idempotencia kapcsolatos további információkért lásd: [idempotencia minták][idempotency-patterns].</span><span class="sxs-lookup"><span data-stu-id="2cf8a-269">For more information about idempotency, see [Idempotency Patterns][idempotency-patterns].</span></span>
  * <span data-ttu-id="2cf8a-270">Vegye figyelembe a megpróbálja műveletek körét.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-270">Consider the scope of the operations that will be retried.</span></span> <span data-ttu-id="2cf8a-271">Elképzelhető például, amely magában foglalja a több művelet szinten újrapróbálkozási kód megvalósítását, majd próbálja újra őket minden meghibásodásakor könnyebben.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-271">For example, it may be easier to implement retry code at a level that encompasses several operations, and retry them all if one fails.</span></span> <span data-ttu-id="2cf8a-272">Azonban ez azt eredményezheti, idempotencia problémák vagy a felesleges visszaállítási műveleteket.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-272">However, doing this may result in idempotency issues or unnecessary rollback operations.</span></span>
  * <span data-ttu-id="2cf8a-273">Ha úgy dönt, amely magában foglalja a több művelet újrapróbálkozási hatókör, vegye figyelembe a teljes késést, az összes őket a újrapróbálkozási időközt meghatározásakor, amikor az igénybe vett idő, valamint a hibák riasztás kiváltása előtt.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-273">If you choose a retry scope that encompasses several operations, take into account the total latency of all of them when determining the retry intervals, when monitoring the time taken, and before raising alerts for failures.</span></span>
  * <span data-ttu-id="2cf8a-274">Vegye figyelembe, hogyan az újrapróbálkozási stratégiát befolyásolhatják a szomszédok és más bérlők egy megosztott alkalmazásban, illetve megosztott erőforrások és szolgáltatások használatakor.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-274">Consider how your retry strategy may affect neighbors and other tenants in a shared application, or when using shared resources and services.</span></span> <span data-ttu-id="2cf8a-275">Agresszív újrapróbálkozási házirend átmeneti hibák előforduló, ezek más felhasználók és az alkalmazások, szolgáltatások és erőforrások egyre több okozhat.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-275">Aggressive retry policies can cause an increasing number of transient faults to occur for these other users and for applications that share the resources and services.</span></span> <span data-ttu-id="2cf8a-276">Hasonlóképpen a más felhasználók, erőforrások és szolgáltatások által végrehajtott újrapróbálkozási házirend hatással lehet az alkalmazás.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-276">Likewise, your application may be affected by the retry policies implemented by other users of the resources and services.</span></span> <span data-ttu-id="2cf8a-277">Kritikus fontosságú alkalmazások esetén előfordulhat, hogy használata mellett dönt, amely nem megosztott premium-szolgáltatásokhoz.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-277">For mission-critical applications, you may decide to use premium services that are not shared.</span></span> <span data-ttu-id="2cf8a-278">Ez lehetővé teszi a több ellenőrzést a terhelés és ezt követő eldobására sávszélesség-szabályozási ezen erőforrások és szolgáltatások, így a további költségeket alkossanak.</span><span class="sxs-lookup"><span data-stu-id="2cf8a-278">This provides you with much more control over the load and consequent throttling of these resources and services, which can help to justify the additional cost.</span></span>

## <a name="more-information"></a><span data-ttu-id="2cf8a-279">További információ</span><span class="sxs-lookup"><span data-stu-id="2cf8a-279">More information</span></span>
* [<span data-ttu-id="2cf8a-280">Az Azure szolgáltatással kapcsolatos újrapróbálkozási irányelvek</span><span class="sxs-lookup"><span data-stu-id="2cf8a-280">Azure service-specific retry guidelines</span></span>](./retry-service-specific.md)
* [<span data-ttu-id="2cf8a-281">Az átmeneti hiba kezelési alkalmazás letiltása</span><span class="sxs-lookup"><span data-stu-id="2cf8a-281">The Transient Fault Handling Application Block</span></span>](http://msdn.microsoft.com/library/hh680934.aspx)
* [<span data-ttu-id="2cf8a-282">Áramköri megszakító minta</span><span class="sxs-lookup"><span data-stu-id="2cf8a-282">Circuit Breaker Pattern</span></span>](http://msdn.microsoft.com/library/dn589784.aspx)
* [<span data-ttu-id="2cf8a-283">Tranzakció mintát Compensating</span><span class="sxs-lookup"><span data-stu-id="2cf8a-283">Compensating Transaction Pattern</span></span>](http://msdn.microsoft.com/library/dn589804.aspx)
* <span data-ttu-id="2cf8a-284">[Idempotencia minták][idempotency-patterns]</span><span class="sxs-lookup"><span data-stu-id="2cf8a-284">[Idempotency Patterns][idempotency-patterns]</span></span>

[idempotency-patterns]: http://blog.jonathanoliver.com/idempotency-patterns/

