---
title: Újrapróbálkozásokra vonatkozó általános útmutató
titleSuffix: Best practices for cloud applications
description: Útmutatás az újrapróbálkozáshoz az átmeneti hibák kezelésénél.
author: dragon119
ms.date: 07/13/2016
ms.topic: best-practice
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: b7728a9cd06fc7788e83db3973f797ae6d696916
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 03/20/2019
ms.locfileid: "58298470"
---
# <a name="transient-fault-handling"></a><span data-ttu-id="87635-103">Átmeneti hibák kezelése</span><span class="sxs-lookup"><span data-stu-id="87635-103">Transient fault handling</span></span>

<span data-ttu-id="87635-104">A távoli szolgáltatásokkal és erőforrásokkal kommunikáló alkalmazásoknak érzékenynek kell lenniük az átmeneti hibákra.</span><span class="sxs-lookup"><span data-stu-id="87635-104">All applications that communicate with remote services and resources must be sensitive to transient faults.</span></span> <span data-ttu-id="87635-105">Ez különösen igaz a felhőben futó alkalmazások esetében, ahol a környezet és az internetes kapcsolat természetéből adódóan gyakrabban lehet találkozni ezzel a hibatípussal.</span><span class="sxs-lookup"><span data-stu-id="87635-105">This is especially the case for applications that run in the cloud, where the nature of the environment and connectivity over the Internet means these types of faults are likely to be encountered more often.</span></span> <span data-ttu-id="87635-106">Az átmeneti hibák közé tartozik az összetevők és szolgáltatások hálózati kapcsolatának pillanatnyi megszakadása, a szolgáltatások átmeneti elérhetetlensége, valamint a foglalt szolgáltatás miatt jelentkező időtúllépés.</span><span class="sxs-lookup"><span data-stu-id="87635-106">Transient faults include the momentary loss of network connectivity to components and services, the temporary unavailability of a service, or timeouts that arise when a service is busy.</span></span> <span data-ttu-id="87635-107">Ezek a hibák gyakran maguktól megoldódnak, és ha később megismételik a műveletet, az nagy eséllyel sikeres lesz.</span><span class="sxs-lookup"><span data-stu-id="87635-107">These faults are often self-correcting, and if the action is repeated after a suitable delay it is likely succeed.</span></span>

<span data-ttu-id="87635-108">Ez a dokumentum az átmeneti hibák kezeléséhez nyújt általános útmutatást.</span><span class="sxs-lookup"><span data-stu-id="87635-108">This document covers general guidance for transient fault handling.</span></span> <span data-ttu-id="87635-109">További információt az átmeneti hibák a Microsoft Azure-szolgáltatások használatakor történő kezeléséről az [Azure-szolgáltatásokra vonatkozó újrapróbálkozási irányelvekben](./retry-service-specific.md) talál.</span><span class="sxs-lookup"><span data-stu-id="87635-109">For information about handling transient faults when using Microsoft Azure services, see [Azure service-specific retry guidelines](./retry-service-specific.md).</span></span>

<!-- markdownlint-disable MD026 -->

## <a name="why-do-transient-faults-occur-in-the-cloud"></a><span data-ttu-id="87635-110">Miért fordulnak elő átmeneti hibák a felhőben?</span><span class="sxs-lookup"><span data-stu-id="87635-110">Why do transient faults occur in the cloud?</span></span>

<!-- markdownlint-enable MD026 -->

<span data-ttu-id="87635-111">Az átmeneti hibák bármilyen környezet, platform vagy operációs rendszer esetén, illetve bármilyen típusú alkalmazásban előfordulhatnak.</span><span class="sxs-lookup"><span data-stu-id="87635-111">Transient faults can occur in any environment, on any platform or operating system, and in any kind of application.</span></span> <span data-ttu-id="87635-112">A helyszíni infrastruktúrákon futó megoldásoknál az alkalmazás, valamint az összetevőinek teljesítményét és rendelkezésre állását általában költséges, és gyakran kihasználatlan hardverredundancia révén tartják fenn, az összetevők és az erőforrások pedig egymás közelében helyezkednek el.</span><span class="sxs-lookup"><span data-stu-id="87635-112">In solutions that run on local, on-premises infrastructure, performance and availability of the application and its components is typically maintained through expensive and often under-used hardware redundancy, and components and resources are located close to each another.</span></span> <span data-ttu-id="87635-113">Bár ennek köszönhetően ritkábban fordulnak elő hibák, ez nem zárja ki az átmeneti hibákat – sőt, az olyan előre nem látható események miatti kimaradásokat sem, mint a külső tápegységgel vagy a hálózattal kapcsolatos problémák, vagy egyéb katasztrófák.</span><span class="sxs-lookup"><span data-stu-id="87635-113">While this makes a failure less likely, it can still result in transient faults - and even an outage through unforeseen events such as external power supply or network issues, or other disaster scenarios.</span></span>

<span data-ttu-id="87635-114">A felhőalapú üzemeltetés, a magánfelhő-alapú rendszereket is beleértve, magasabb általános rendelkezésre állást tesz lehetővé azáltal, hogy nagyon sok hagyományos számítási csomóponton használ megosztott erőforrásokat, redundanciát, automatikus feladatátvételt és dinamikus erőforrás-kiosztást.</span><span class="sxs-lookup"><span data-stu-id="87635-114">Cloud hosting, including private cloud systems, can offer a higher overall availability by using shared resources, redundancy, automatic failover, and dynamic resource allocation across a huge number of commodity compute nodes.</span></span> <span data-ttu-id="87635-115">Az ilyen típusú környezeteknél azonban gyakrabban fordulhatnak elő átmeneti hibák.</span><span class="sxs-lookup"><span data-stu-id="87635-115">However, the nature of these environments can mean that transient faults are more likely to occur.</span></span> <span data-ttu-id="87635-116">Ennek több oka is van:</span><span class="sxs-lookup"><span data-stu-id="87635-116">There are several reasons for this:</span></span>

- <span data-ttu-id="87635-117">A felhőalapú környezetekben sok a megosztott erőforrás, és ezek a védelmük érdekében szabályozott hozzáféréssel rendelkeznek.</span><span class="sxs-lookup"><span data-stu-id="87635-117">Many resources in a cloud environment are shared, and access to these resources is subject to throttling in order to protect the resource.</span></span> <span data-ttu-id="87635-118">Egyes szolgáltatások el fogják utasítani a kapcsolatokat, ha a terhelés egy bizonyos szintre emelkedik, vagy ha elérik a maximális átviteli sebességet, hogy lehetővé tegyék a meglévő kérések feldolgozását, és fenntartsák a szolgáltatás teljesítményét az összes felhasználónál.</span><span class="sxs-lookup"><span data-stu-id="87635-118">Some services will refuse connections when the load rises to a specific level, or a maximum throughput rate is reached, in order to allow processing of existing requests and to maintain performance of the service for all users.</span></span> <span data-ttu-id="87635-119">A szabályozás segít fenntartani a szolgáltatás minőségét a szomszédoknál és a többi olyan bérlőnél, amelyek a megosztott erőforrást használják.</span><span class="sxs-lookup"><span data-stu-id="87635-119">Throttling helps to maintain the quality of service for neighbors and other tenants using the shared resource.</span></span>

- <span data-ttu-id="87635-120">A felhőalapú környezetek létrehozásához hatalmas mennyiségű hagyományos hardveregységre van szükség.</span><span class="sxs-lookup"><span data-stu-id="87635-120">Cloud environments are built using vast numbers of commodity hardware units.</span></span> <span data-ttu-id="87635-121">Ezek az egységek biztosítják a teljesítményt a terhelés több számítási egység és infrastruktúra-összetevő közötti dinamikus elosztásával, valamint a megbízhatóságot a hibás egységek automatikus újraindításával vagy lecserélésével.</span><span class="sxs-lookup"><span data-stu-id="87635-121">They deliver performance by dynamically distributing the load across multiple computing units and infrastructure components, and deliver reliability by automatically recycling or replacing failed units.</span></span> <span data-ttu-id="87635-122">Ennek a dinamikus jellegnek köszönhetően időnként előfordulhatnak átmeneti hibák és ideiglenes csatlakozási hibák.</span><span class="sxs-lookup"><span data-stu-id="87635-122">This dynamic nature means that transient faults and temporary connection failures may occasionally occur.</span></span>

- <span data-ttu-id="87635-123">Az alkalmazás és az általa használt erőforrások és szolgáltatások között gyakran több hardverösszetevő is található, többek között olyan hálózati infrastruktúrák, mint az útválasztók és a terheléselosztók.</span><span class="sxs-lookup"><span data-stu-id="87635-123">There are often more hardware components, including network infrastructure such as routers and load balancers, between the application and the resources and services it uses.</span></span> <span data-ttu-id="87635-124">Ez a további infrastruktúra alkalmanként további kapcsolódási késést és átmeneti kapcsolati hibákat okozhat.</span><span class="sxs-lookup"><span data-stu-id="87635-124">This additional infrastructure can occasionally introduce additional connection latency and transient connection faults.</span></span>

- <span data-ttu-id="87635-125">Az ügyfél és a kiszolgáló közötti hálózati körülmények változékonyak lehetnek, különösen akkor, amikor az interneten keresztül folyik a kommunikáció.</span><span class="sxs-lookup"><span data-stu-id="87635-125">Network conditions between the client and the server may be variable, especially when communication crosses the Internet.</span></span> <span data-ttu-id="87635-126">A nagy forgalmi terhelés még a helyszíni helyeken is lelassíthatja a kommunikációt, és időszakos csatlakozási hibákat okozhat.</span><span class="sxs-lookup"><span data-stu-id="87635-126">Even in on-premises locations, very heavy traffic loads may slow communication and cause intermittent connection failures.</span></span>

## <a name="challenges"></a><span data-ttu-id="87635-127">Problémák</span><span class="sxs-lookup"><span data-stu-id="87635-127">Challenges</span></span>

<span data-ttu-id="87635-128">Az átmeneti hibák egy nagyon nagy hatással lehet a egy alkalmazás észlelhető rendelkezésre állását még akkor is, ha alapos teszteléssel alatt összes előrelátható körülmény figyelembevételével.</span><span class="sxs-lookup"><span data-stu-id="87635-128">Transient faults can have a huge effect on the perceived availability of an application, even if it has been thoroughly tested under all foreseeable circumstances.</span></span> <span data-ttu-id="87635-129">Ahhoz, hogy a felhőben üzemeltetett alkalmazások megbízhatóan működjenek, meg kell tudniuk felelni a következő kihívásoknak:</span><span class="sxs-lookup"><span data-stu-id="87635-129">To ensure that cloud-hosted applications operate reliably, they must be able to respond to the following challenges:</span></span>

- <span data-ttu-id="87635-130">Az alkalmazásnak észlelnie kell a hibákat, amikor azok bekövetkeznek, és meg kell tudnia határozni, hogy ezek a hibák várhatóan átmenetiek, annál tartósabbak, vagy végzetesek.</span><span class="sxs-lookup"><span data-stu-id="87635-130">The application must be able to detect faults when they occur, and determine if these faults are likely to be transient, more long-lasting, or are terminal failures.</span></span> <span data-ttu-id="87635-131">A különböző erőforrások hiba esetén nagy eséllyel eltérő válaszokat adnak vissza, és ezek a válaszok a művelet kontextusától függően is eltérhetnek. Például az erőforrások más választ adhatnak a tárolóból való olvasásakor jelentkező hibára, mint a tárolóba való íráskor jelentkező hibára.</span><span class="sxs-lookup"><span data-stu-id="87635-131">Different resources are likely to return different responses when a fault occurs, and these responses may also vary depending on the context of the operation; for example, the response for an error when reading from storage may be different from response for an error when writing to storage.</span></span> <span data-ttu-id="87635-132">Sok erőforrás és szolgáltatás részletesen dokumentált átmeneti meghibásodási szerződésekkel rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="87635-132">Many resources and services have well-documented transient failure contracts.</span></span> <span data-ttu-id="87635-133">Azonban ha nem állnak rendelkezésre ilyen adatok, nehéz lehet kideríteni a hiba jellegét és tartósságát.</span><span class="sxs-lookup"><span data-stu-id="87635-133">However, where such information is not available, it may be difficult to discover the nature of the fault and whether it is likely to be transient.</span></span>

- <span data-ttu-id="87635-134">Az alkalmazásnak képesnek kell lennie újra végrehajtani a műveletet, ha ezzel meg tudja határozni a hiba tartósságát, továbbá nyomon kell követnie, hogy a rendszer hányszor kísérelte meg újból a műveletet.</span><span class="sxs-lookup"><span data-stu-id="87635-134">The application must be able to retry the operation if it determines that the fault is likely to be transient and keep track of the number of times the operation was retried.</span></span>

- <span data-ttu-id="87635-135">Az alkalmazásnak megfelelő stratégiát kell alkalmaznia az újrapróbálkozásokhoz.</span><span class="sxs-lookup"><span data-stu-id="87635-135">The application must use an appropriate strategy for the retries.</span></span> <span data-ttu-id="87635-136">Ez a stratégia határozza meg az újrapróbálkozások számát, a kísérletek közötti késleltetést, valamint a sikertelen próbálkozások után elvégzendő műveleteket.</span><span class="sxs-lookup"><span data-stu-id="87635-136">This strategy specifies the number of times it should retry, the delay between each attempt, and the actions to take after a failed attempt.</span></span> <span data-ttu-id="87635-137">A próbálkozások megfelelő számát és a köztük lévő időt gyakran nehéz meghatározni, sőt, ezek az erőforrás típusától, valamint az erőforrás és az alkalmazás aktuális működési feltételeitől függően változnak.</span><span class="sxs-lookup"><span data-stu-id="87635-137">The appropriate number of attempts and the delay between each one are often difficult to determine, and vary based on the type of resource as well as the current operating conditions of the resource and the application itself.</span></span>

## <a name="general-guidelines"></a><span data-ttu-id="87635-138">Általános irányelvek</span><span class="sxs-lookup"><span data-stu-id="87635-138">General guidelines</span></span>

<span data-ttu-id="87635-139">Az alábbi irányelvek segítenek megtervezni egy megfelelő átmeneti hibakezelési mechanizmust az alkalmazásai számára:</span><span class="sxs-lookup"><span data-stu-id="87635-139">The following guidelines will help you to design a suitable transient fault handing mechanism for your applications:</span></span>

- <span data-ttu-id="87635-140">**Állapítsa meg, hogy van-e beépített újrapróbálkozási mechanizmus:**</span><span class="sxs-lookup"><span data-stu-id="87635-140">**Determine if there is a built-in retry mechanism:**</span></span>

  - <span data-ttu-id="87635-141">Számos szolgáltatás biztosít átmeneti hibakezelési mechanizmust tartalmazó SDK-t vagy ügyfélkódtárat.</span><span class="sxs-lookup"><span data-stu-id="87635-141">Many services provide an SDK or client library that contains a transient fault handling mechanism.</span></span> <span data-ttu-id="87635-142">A mechanizmus által használt újrapróbálkozási szabályzat általában a célszolgáltatás természetéhez és követelményeihez igazodik.</span><span class="sxs-lookup"><span data-stu-id="87635-142">The retry policy it uses is typically tailored to the nature and requirements of the target service.</span></span> <span data-ttu-id="87635-143">Másik lehetőségként a szolgáltatások REST-felületei is visszaadhatnak olyan információkat, amelyek segítenek meghatározni, hogy érdemes-e újrapróbálkozni, és mennyi időt kell várni a következő újrapróbálkozási kísérletig.</span><span class="sxs-lookup"><span data-stu-id="87635-143">Alternatively, REST interfaces for services may return information that is useful in determining whether a retry is appropriate, and how long to wait before the next retry attempt.</span></span>

  - <span data-ttu-id="87635-144">Ha elérhető, használja a beépített újrapróbálkozási mechanizmust, hacsak nincsenek konkrét és jól érthető követelmények, amelyek más újrapróbálkozási viselkedést igényelnek.</span><span class="sxs-lookup"><span data-stu-id="87635-144">Use the built-in retry mechanism where one is available unless you have specific and well-understood requirements that mean a different retry behavior is more appropriate.</span></span>

- <span data-ttu-id="87635-145">**Döntse el, hogy a művelet alkalmas-e az újrapróbálkozásra**:</span><span class="sxs-lookup"><span data-stu-id="87635-145">**Determine if the operation is suitable for retrying**:</span></span>

  - <span data-ttu-id="87635-146">Csak azokat a műveleteket érdemes újrapróbálni, ahol a hibák átmenetiek (ezt általában a hiba természetéből lehet megállapítani), és legalább némi esély van arra, hogy a művelet megismétlése sikerrel fog járni.</span><span class="sxs-lookup"><span data-stu-id="87635-146">You should only retry operations where the faults are transient (typically indicated by the nature of the error), and if there is at least some likelihood that the operation will succeed when reattempted.</span></span> <span data-ttu-id="87635-147">Nincs értelme újrapróbálkozni azoknál a műveleteknél, amelyek érvénytelen műveletet jeleznek, például egy nem létező elemhez tartozó adatbázis-frissítést, vagy kérések küldését egy olyan szolgáltatásnak vagy erőforrásnak, amelyben végzetes hiba történt</span><span class="sxs-lookup"><span data-stu-id="87635-147">There is no point in reattempting operations that indicate an invalid operation such as a database update to an item that does not exist, or requests to a service or resource that has suffered a fatal error</span></span>

  - <span data-ttu-id="87635-148">Általában csak akkor érdemes implementálni az újrapróbálkozásokat, ha meg lehet határozni a próbálkozások teljes hatását, valamint jól értelmezhetők és érvényesíthetők a feltételek.</span><span class="sxs-lookup"><span data-stu-id="87635-148">In general, you should implement retries only where the full impact of this can be determined, and the conditions are well understood and can be validated.</span></span> <span data-ttu-id="87635-149">Ha ez nem így van, hagyja, hogy a hívó kód implementálja az újrapróbálkozásokat.</span><span class="sxs-lookup"><span data-stu-id="87635-149">If not, leave it to the calling code to implement retries.</span></span> <span data-ttu-id="87635-150">Ne feledje, hogy a hatáskörén kívül eső erőforrások és szolgáltatások által visszaadott hibák idővel változhatnak. Előfordulhat, hogy újra kell gondolnia az átmeneti hibák észlelési logikáját.</span><span class="sxs-lookup"><span data-stu-id="87635-150">Remember that the errors returned from resources and services outside your control may evolve over time, and you may need to revisit your transient fault detection logic.</span></span>

  - <span data-ttu-id="87635-151">A szolgáltatások vagy összetevők létrehozásakor vegye fontolóra a hibakódok és -üzenetek alkalmazását, amelyek segítenek az ügyfeleknek eldönteni, hogy megpróbálják-e újra végrehajtani a sikertelen műveleteket.</span><span class="sxs-lookup"><span data-stu-id="87635-151">When you create services or components, consider implementing error codes and messages that will help clients determine whether they should retry failed operations.</span></span> <span data-ttu-id="87635-152">Jelezze, ha az ügyfélnek érdemes újrapróbálkoznia a művelettel (például az **isTransient** érték visszaadásával), és tegyen javaslatot a következő próbálkozás előtti késleltetés idejére.</span><span class="sxs-lookup"><span data-stu-id="87635-152">In particular, indicate if the client should retry the operation (perhaps by returning an **isTransient** value) and suggest a suitable delay before the next retry attempt.</span></span> <span data-ttu-id="87635-153">Ha webszolgáltatást hoz létre, fontolja meg a szolgáltatási szerződésekben meghatározott egyéni hibaüzenetek visszaadását.</span><span class="sxs-lookup"><span data-stu-id="87635-153">If you build a web service, consider returning custom errors defined within your service contracts.</span></span> <span data-ttu-id="87635-154">Az általános ügyfelek lehet, hogy nem fogják tudni beolvasni ezeket, viszont jól fognak jönni majd az egyéni ügyfelek létrehozásakor.</span><span class="sxs-lookup"><span data-stu-id="87635-154">Even though generic clients may not be able to read these, they will be useful when building custom clients.</span></span>

- <span data-ttu-id="87635-155">**Határozzon meg egy megfelelő újrapróbálkozási számot és időközt:**</span><span class="sxs-lookup"><span data-stu-id="87635-155">**Determine an appropriate retry count and interval:**</span></span>

  - <span data-ttu-id="87635-156">Rendkívül fontos, hogy a használat típusához optimalizálja az újrapróbálkozások számát és időközét.</span><span class="sxs-lookup"><span data-stu-id="87635-156">It is vital to optimize the retry count and the interval to the type of use case.</span></span> <span data-ttu-id="87635-157">Ha nem próbálkozik elégszer, az alkalmazás nem fogja tudni végrehajtani a műveletet, és hiba léphet fel.</span><span class="sxs-lookup"><span data-stu-id="87635-157">If you do not retry a sufficient number of times, the application will be unable to complete the operation and is likely to experience a failure.</span></span> <span data-ttu-id="87635-158">Ha túl sokszor próbálkozik újra, vagy túl kevés ideig vár a próbálkozások között, előfordulhat, hogy az alkalmazás hosszú ideig tartja az erőforrásokat (például a szálakat, a kapcsolatokat és a memóriát), amely kedvezőtlen hatással lesz az alkalmazás állapotára.</span><span class="sxs-lookup"><span data-stu-id="87635-158">If you retry too many times, or with too short an interval between tries, the application can potentially hold resources such as threads, connections, and memory for long periods, which will adversely affect the health of the application.</span></span>

  - <span data-ttu-id="87635-159">Az időközök megfelelő értéke és az újrapróbálkozási kísérletek száma a megkísérelt művelet típusától függ.</span><span class="sxs-lookup"><span data-stu-id="87635-159">The appropriate values for the time interval and the number of retry attempts depend on the type of operation being attempted.</span></span> <span data-ttu-id="87635-160">Például ha a művelet egy felhasználói beavatkozás része, ajánlott rövid időközöket beállítani, és csak néhányszor újrapróbálkozni, hogy a felhasználóknak ne kelljen várniuk a válaszra (ami nyitott kapcsolatokat tart fenn, és csökkentheti a rendelkezésre állást a többi felhasználónál).</span><span class="sxs-lookup"><span data-stu-id="87635-160">For example, if the operation is part of a user interaction, the interval should be short and only a few retries attempted to avoid making users wait for a response (which holds open connections and can reduce availability for other users).</span></span> <span data-ttu-id="87635-161">Ha a művelet egy hosszan tartó vagy kritikus fontosságú munkafolyamat része, és a folyamat megszakítása és újraindítása költséges vagy időigényes, célszerű hosszabb ideig várni a kísérletek között, és többször újrapróbálkozni.</span><span class="sxs-lookup"><span data-stu-id="87635-161">If the operation is part of a long running or critical workflow, where cancelling and restarting the process is expensive or time-consuming, it is appropriate to wait longer between attempts and retry more times.</span></span>

  - <span data-ttu-id="87635-162">Az újrapróbálkozások közötti megfelelő időközök meghatározása a sikeres stratégiák megtervezésének legnehezebb része.</span><span class="sxs-lookup"><span data-stu-id="87635-162">Determining the appropriate intervals between retries is the most difficult part of designing a successful strategy.</span></span> <span data-ttu-id="87635-163">A stratégiák általában az alábbi újrapróbálkozási időköztípusokat használják:</span><span class="sxs-lookup"><span data-stu-id="87635-163">Typical strategies use the following types of retry interval:</span></span>

    - <span data-ttu-id="87635-164">**Exponenciális visszatartás**.</span><span class="sxs-lookup"><span data-stu-id="87635-164">**Exponential back-off**.</span></span> <span data-ttu-id="87635-165">Az alkalmazás rövid ideig várakozik az első újrapróbálkozás előtt, majd exponenciálisan növeli a próbálkozások közötti időt.</span><span class="sxs-lookup"><span data-stu-id="87635-165">The application waits a short time before the first retry, and then exponentially increasing times between each subsequent retry.</span></span> <span data-ttu-id="87635-166">Például megpróbálhatja újra végrehajtani a műveletet 3 másodperc, 12 másodperc, 30 másodperc múlva és így tovább.</span><span class="sxs-lookup"><span data-stu-id="87635-166">For example, it may retry the operation after 3 seconds, 12 seconds, 30 seconds, and so on.</span></span>

    - <span data-ttu-id="87635-167">**Növekményes időközök**.</span><span class="sxs-lookup"><span data-stu-id="87635-167">**Incremental intervals**.</span></span> <span data-ttu-id="87635-168">Az alkalmazás rövid ideig várakozik az első újrapróbálkozás előtt, majd fokozatosan növeli a próbálkozások közötti időt.</span><span class="sxs-lookup"><span data-stu-id="87635-168">The application waits a short time before the first retry, and then incrementally increasing times between each subsequent retry.</span></span> <span data-ttu-id="87635-169">Például megpróbálhatja újra végrehajtani a műveletet 3 másodperc, 7 másodperc, 13 másodperc múlva és így tovább.</span><span class="sxs-lookup"><span data-stu-id="87635-169">For example, it may retry the operation after 3 seconds, 7 seconds, 13 seconds, and so on.</span></span>

    - <span data-ttu-id="87635-170">**Rendszeres időközök**.</span><span class="sxs-lookup"><span data-stu-id="87635-170">**Regular intervals**.</span></span> <span data-ttu-id="87635-171">Az alkalmazás ugyanannyi ideig várakozik a próbálkozások között.</span><span class="sxs-lookup"><span data-stu-id="87635-171">The application waits for the same period of time between each attempt.</span></span> <span data-ttu-id="87635-172">Például megpróbálhatja újra végrehajtani a műveletet 3 másodpercenként.</span><span class="sxs-lookup"><span data-stu-id="87635-172">For example, it may retry the operation every 3 seconds.</span></span>

    - <span data-ttu-id="87635-173">**Azonnali újrapróbálkozás**.</span><span class="sxs-lookup"><span data-stu-id="87635-173">**Immediate retry**.</span></span> <span data-ttu-id="87635-174">Az átmeneti hibák néha nagyon rövid ideig tartanak, például ha olyan esemény váltja ki őket, mint a hálózati csomagok ütközése, vagy egy megnövekedett terhelés az egyik hardverösszetevőben.</span><span class="sxs-lookup"><span data-stu-id="87635-174">Sometimes a transient fault is extremely short, perhaps caused by an event such as a network packet collision or a spike in a hardware component.</span></span> <span data-ttu-id="87635-175">Ebben az esetben célszerű azonnal megismételni a műveletet, mivel az sikerrel járhat, ha a hiba még az idő alatt megszűnik, hogy az alkalmazás összeállítja és elküldi a következő kérést.</span><span class="sxs-lookup"><span data-stu-id="87635-175">In this case, retrying the operation immediately is appropriate because it may succeed if the fault has cleared in the time it takes the application to assemble and send the next request.</span></span> <span data-ttu-id="87635-176">Soha ne hajtson végre egynél több azonnali újrapróbálkozási kísérletet, és ha az meghiúsul, váltson át alternatív stratégiákra, például exponenciális visszatartásra vagy helyettesítő műveletekre.</span><span class="sxs-lookup"><span data-stu-id="87635-176">However, there should never be more than one immediate retry attempt, and you should switch to alternative strategies, such as such as exponential back-off or fallback actions, if the immediate retry fails.</span></span>

    - <span data-ttu-id="87635-177">**Véletlenszerűsítés**.</span><span class="sxs-lookup"><span data-stu-id="87635-177">**Randomization**.</span></span> <span data-ttu-id="87635-178">A fent említett újrapróbálkozási stratégiák bármelyike tartalmazhat véletlenszerűsítést, amely megakadályozza, hogy az ügyfél több példánya egyszerre küldjön újrapróbálkozási kísérleteket.</span><span class="sxs-lookup"><span data-stu-id="87635-178">Any of the retry strategies listed above may include a randomization to prevent multiple instances of the client sending subsequent retry attempts at the same time.</span></span> <span data-ttu-id="87635-179">Például egy példány megpróbálhatja újra végrehajtani a műveletet 3 másodperc, 11 másodperc, 28 másodperc stb. múlva, egy másik példány pedig 4 másodperc, 12 másodperc, 26 másodperc múlva és így tovább.</span><span class="sxs-lookup"><span data-stu-id="87635-179">For example, one instance may retry the operation after 3 seconds, 11 seconds, 28 seconds, and so on while another instance may retry the operation after 4 seconds, 12 seconds, 26 seconds, and so on.</span></span> <span data-ttu-id="87635-180">A véletlenszerűsítés hasznos módszer, amelyet más stratégiákkal együtt is alkalmazni lehet.</span><span class="sxs-lookup"><span data-stu-id="87635-180">Randomization is a useful technique that may be combined with other strategies.</span></span>

  - <span data-ttu-id="87635-181">Általános irányelvként a háttérműveletekhez használja az exponenciális visszatartást, az interaktív műveletekhez pedig az azonnali vagy a rendszeres időközű újrapróbálkozási stratégiát.</span><span class="sxs-lookup"><span data-stu-id="87635-181">As a general guideline, use an exponential back-off strategy for background operations, and immediate or regular interval retry strategies for interactive operations.</span></span> <span data-ttu-id="87635-182">Mindkét esetben úgy kell kiválasztania a késleltetést és az újrapróbálkozások számát, hogy az újrapróbálkozási kísérletek maximális késleltetése megfeleljen a végpontok közötti késés szükséges követelményeinek.</span><span class="sxs-lookup"><span data-stu-id="87635-182">In both cases, you should choose the delay and the retry count so that the maximum latency for all retry attempts is within the required end-to-end latency requirement.</span></span>

  - <span data-ttu-id="87635-183">Vegye figyelembe az összes tényezőt, amely hozzájárul az újra megkísérelt művelet teljes maximális időtúllépéséhez.</span><span class="sxs-lookup"><span data-stu-id="87635-183">Take into account the combination of all the factors that contribute to the overall maximum timeout for a retried operation.</span></span> <span data-ttu-id="87635-184">E tényezők közé tartozik a sikertelen kapcsolat válaszadási ideje (általában az ügyfél egyik időtúllépési értéke állítja be), valamint az újrapróbálkozási kísérletek közötti késleltetés és az újrapróbálkozások maximális száma.</span><span class="sxs-lookup"><span data-stu-id="87635-184">These factors include the time taken for a failed connection to produce a response (typically set by a timeout value in the client) as well as the delay between retry attempts and the maximum number of retries.</span></span> <span data-ttu-id="87635-185">Ezek együtt nagyon hosszú teljes működési időt eredményezhetnek, főleg az exponenciális késleltetési stratégia használatánál, ahol a meghiúsult kísérletek után gyorsan növekszik az újrapróbálkozások közötti idő.</span><span class="sxs-lookup"><span data-stu-id="87635-185">The total of all these times can result in very large overall operation times, especially when using an exponential delay strategy where the interval between retries grows rapidly after each failure.</span></span> <span data-ttu-id="87635-186">Ha egy folyamatnak meg kell felelnie egy adott szolgáltatói szerződés (SLA), a teljes működési időnek, beleértve az összes időtúllépéseket és késéseket belül, amely definiálni kell az SLA-ban.</span><span class="sxs-lookup"><span data-stu-id="87635-186">If a process must meet a specific service level agreement (SLA), the overall operation time, including all timeouts and delays, must be within that defined in the SLA.</span></span>

  - <span data-ttu-id="87635-187">Túl rövid időközökkel vagy túl sok újrapróbálkozást rendelkezik, rendelkező agresszív újrapróbálkozási stratégiák kedvezőtlen hatással a célként megadott erőforrás vagy szolgáltatás rendelkezhet.</span><span class="sxs-lookup"><span data-stu-id="87635-187">Over-aggressive retry strategies, which have too short intervals or too many retries, can have an adverse effect on the target resource or service.</span></span> <span data-ttu-id="87635-188">Ez megakadályozhatja, hogy az erőforrás vagy szolgáltatás helyreálljon a túlterhelt állapotból, és továbbra is blokkolni fogja vagy el fogja utasítani a kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="87635-188">This may prevent the resource or service from recovering from its overloaded state, and it will continue to block or refuse requests.</span></span> <span data-ttu-id="87635-189">Ez egy ördögi kört eredményez, ahol az erőforrás vagy szolgáltatás egyre több kérést kap, és ennek köszönhetően tovább romlik a helyreállási képessége.</span><span class="sxs-lookup"><span data-stu-id="87635-189">This results in a vicious circle where more and more requests are sent to the resource or service, and consequently its ability to recover is further reduced.</span></span>

  - <span data-ttu-id="87635-190">Az újrapróbálkozási időközök megadásakor vegye figyelembe a műveletek időtúllépését, hogy ne indítsa el azonnal a következő kísérletet (például abban az esetben, ha hasonló az időkorlát és az újrapróbálkozási időköz).</span><span class="sxs-lookup"><span data-stu-id="87635-190">Take into account the timeout of the operations when choosing the retry intervals to avoid launching a subsequent attempt immediately (for example, if the timeout period is similar to the retry interval).</span></span> <span data-ttu-id="87635-191">Azt is vegye figyelembe, ha a teljes lehetséges időtartamot (az időtúllépések és az újrapróbálkozási időközök együttesét) a megadott teljes idő alatt kell tartani.</span><span class="sxs-lookup"><span data-stu-id="87635-191">Also consider if you need to keep the total possible period (the timeout plus the retry intervals) to below a specific total time.</span></span> <span data-ttu-id="87635-192">A szokatlanul rövid vagy hosszú időtúllépéssel rendelkező műveletek befolyásolhatják a várakozási időt és a művelet újbóli megkísérlésének gyakoriságát.</span><span class="sxs-lookup"><span data-stu-id="87635-192">Operations that have unusually short or very long timeouts may influence how long to wait, and how often to retry the operation.</span></span>

  - <span data-ttu-id="87635-193">Az újrapróbálkozások időközének és számának optimalizálásához használja a kivétel típusát és a benne szereplő adatokat, vagy a szolgáltatástól visszakapott hibakódokat és -üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="87635-193">Use the type of the exception and any data it contains, or the error codes and messages returned from the service, to optimize the interval and the number of retries.</span></span> <span data-ttu-id="87635-194">Néhány kivétel vagy hibakód (mint az 503-as „A szolgáltatás nem érhető el” HTTP-kód, egy Retry-After fejléccel a válaszban) például jelezheti, hogy mennyi ideig tarthat a hiba, vagy hogy a szolgáltatás leállt, és nem fog reagálni a további kísérletekre.</span><span class="sxs-lookup"><span data-stu-id="87635-194">For example, some exceptions or error codes (such as the HTTP code 503 Service Unavailable with a Retry-After header in the response) may indicate how long the error might last, or that the service has failed and will not respond to any subsequent attempt.</span></span>

- <span data-ttu-id="87635-195">**Kerülje el a kizárási mintákat**:</span><span class="sxs-lookup"><span data-stu-id="87635-195">**Avoid anti-patterns**:</span></span>

  - <span data-ttu-id="87635-196">A legtöbb esetben érdemes elkerülni azokat az implementálásokat, amelyek duplikált rétegű újrapróbálkozási kódot tartalmaznak.</span><span class="sxs-lookup"><span data-stu-id="87635-196">In the vast majority of cases, you should avoid implementations that include duplicated layers of retry code.</span></span> <span data-ttu-id="87635-197">Kerülje továbbá azokat a kialakításokat, amelyek lépcsőzetes újrapróbálkozási mechanizmusokat tartalmaznak, illetve azokat, amelyek a kéréshierarchiával rendelkező műveletek összes szakaszában implementálják az újrapróbálkozást, hacsak a konkrét követelmények ezt nem igénylik.</span><span class="sxs-lookup"><span data-stu-id="87635-197">Avoid designs that include cascading retry mechanisms, or that implement retry at every stage of an operation that involves a hierarchy of requests, unless you have specific requirements that demand this.</span></span> <span data-ttu-id="87635-198">Ezekben a kivételes esetekben használjon olyan szabályzatokat, amelyek megakadályozzák a túl sok újrapróbálkozást és a túl nagy késleltetési időközöket, és győződjön meg róla, hogy tisztában van a következményekkel.</span><span class="sxs-lookup"><span data-stu-id="87635-198">In these exceptional circumstances, use policies that prevent excessive numbers of retries and delay periods, and make sure you understand the consequences.</span></span> <span data-ttu-id="87635-199">Például ha az egyik összetevő kérést küld a másiknak, amely ezután hozzáfér a célszolgáltatáshoz, és Ön mindkét hívásnál implementál három újrapróbálkozást, akkor a rendszer összesen kilenc újrapróbálkozási kísérletet hajt végre a szolgáltatás irányába.</span><span class="sxs-lookup"><span data-stu-id="87635-199">For example, if one component makes a request to another, which then accesses the target service, and you implement retry with a count of three on both calls there will be nine retry attempts in total against the service.</span></span> <span data-ttu-id="87635-200">Sok szolgáltatás és erőforrás használ beépített újrapróbálkozási mechanizmust, ezért ha magasabb szinten kell újrapróbálkozásokat implementálnia, nézzen utána, hogyan tilthatja le vagy módosíthatja ezeket.</span><span class="sxs-lookup"><span data-stu-id="87635-200">Many services and resources implement a built-in retry mechanism and you should investigate how you can disable or modify this if you need to implement retries at a higher level.</span></span>

  - <span data-ttu-id="87635-201">Soha ne implementáljon végtelen újrapróbálkozási mechanizmust.</span><span class="sxs-lookup"><span data-stu-id="87635-201">Never implement an endless retry mechanism.</span></span> <span data-ttu-id="87635-202">Ez nagy eséllyel megakadályozza, hogy az erőforrás vagy szolgáltatás helyreálljon a túlterhelési helyzetekből, és a hatására tovább fog tartani a szabályozás és a kapcsolatok elutasítása.</span><span class="sxs-lookup"><span data-stu-id="87635-202">This is likely to prevent the resource or service recovering from overload situations, and cause throttling and refused connections to continue for a longer period.</span></span> <span data-ttu-id="87635-203">Ha azt szeretné, hogy a szolgáltatás helyre tudjon állni, használjon véges számú újrapróbálkozást, vagy implementáljon egy mintát, például az [áramkör-megszakítót](../patterns/circuit-breaker.md).</span><span class="sxs-lookup"><span data-stu-id="87635-203">Use a finite number or retries, or implement a pattern such as [Circuit Breaker](../patterns/circuit-breaker.md) to allow the service to recover.</span></span>

  - <span data-ttu-id="87635-204">Soha ne végezzen azonnali újrapróbálkozást egynél több alkalommal.</span><span class="sxs-lookup"><span data-stu-id="87635-204">Never perform an immediate retry more than once.</span></span>

  - <span data-ttu-id="87635-205">Kerülje a rendszeres újrapróbálkozási időköz használatát, különösen akkor, ha az Azure-beli szolgáltatások és erőforrások elérésekor sok az újrapróbálkozási kísérlet.</span><span class="sxs-lookup"><span data-stu-id="87635-205">Avoid using a regular retry interval, especially when you have a large number of retry attempts, when accessing services and resources in Azure.</span></span> <span data-ttu-id="87635-206">Ebben a forgatókönyvben az optimális megközelítés az áramkör-megszakító képességgel kombinált exponenciális visszatartási stratégia.</span><span class="sxs-lookup"><span data-stu-id="87635-206">The optimum approach is this scenario is an exponential back-off strategy with a circuit-breaking capability.</span></span>

  - <span data-ttu-id="87635-207">Akadályozza meg, hogy egy adott ügyfél több példánya, vagy különböző ügyfelek több példánya egyszerre küldjön újrapróbálkozásokat.</span><span class="sxs-lookup"><span data-stu-id="87635-207">Prevent multiple instances of the same client, or multiple instances of different clients, from sending retries at the same times.</span></span> <span data-ttu-id="87635-208">Ha nagy az esély erre, vezessen be véletlenszerűsítést az újrapróbálkozási időközökbe.</span><span class="sxs-lookup"><span data-stu-id="87635-208">If this is likely to occur, introduce randomization into the retry intervals.</span></span>

- <span data-ttu-id="87635-209">**Tesztelje az újrapróbálkozási stratégiát és az implementálást:**</span><span class="sxs-lookup"><span data-stu-id="87635-209">**Test your retry strategy and implementation:**</span></span>

  - <span data-ttu-id="87635-210">Ügyeljen arra, hogy teljes körűen tesztelje az újrapróbálkozási stratégia implementálását, a lehető legkülönfélébb körülmények mellett, különösen akkor, ha az alkalmazás, és az általa használt célerőforrások vagy -szolgáltatások is nagy terhelés alatt állnak.</span><span class="sxs-lookup"><span data-stu-id="87635-210">Ensure you fully test your retry strategy implementation under as wide a set of circumstances as possible, especially when both the application and the target resources or services it uses are under extreme load.</span></span> <span data-ttu-id="87635-211">A következőképpen ellenőrizheti a viselkedést a tesztelés közben:</span><span class="sxs-lookup"><span data-stu-id="87635-211">To check behavior during testing, you can:</span></span>

    - <span data-ttu-id="87635-212">Szúrjon be átmeneti és nem átmeneti hibákat a szolgáltatásba.</span><span class="sxs-lookup"><span data-stu-id="87635-212">Inject transient and non-transient faults into the service.</span></span> <span data-ttu-id="87635-213">Például küldjön érvénytelen kéréseket, vagy adjon hozzá egy kódot, amely észleli a tesztelési kéréseket, és különböző típusú hibákat ad vissza válaszként.</span><span class="sxs-lookup"><span data-stu-id="87635-213">For example, send invalid requests or add code that detects test requests and responds with different types of errors.</span></span> <span data-ttu-id="87635-214">TestApi használatával egy példa: [tesztelést hibabeszúrással](https://msdn.microsoft.com/magazine/ff898404.aspx) és [TestApi – 5. rész – Bevezetés: Felügyelt kód tartalék injektálási API-k](https://blogs.msdn.microsoft.com/ivo_manolov/2009/11/25/introduction-to-testapi-part-5-managed-code-fault-injection-apis/).</span><span class="sxs-lookup"><span data-stu-id="87635-214">For an example using TestApi, see [Fault Injection Testing with TestApi](https://msdn.microsoft.com/magazine/ff898404.aspx) and [Introduction to TestApi – Part 5: Managed Code Fault Injection APIs](https://blogs.msdn.microsoft.com/ivo_manolov/2009/11/25/introduction-to-testapi-part-5-managed-code-fault-injection-apis/).</span></span>

    - <span data-ttu-id="87635-215">Hozza létre az erőforrás vagy szolgáltatás utánzatát, amely ugyanazt a hibatartományt adja vissza, mint a valódi szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="87635-215">Create a mock of the resource or service that returns a range of errors that the real service may return.</span></span> <span data-ttu-id="87635-216">Győződjön meg róla, hogy az összes hibatípust lefedi, amelyet az újrapróbálkozási stratégia észlelni tud.</span><span class="sxs-lookup"><span data-stu-id="87635-216">Ensure you cover all the types of error that your retry strategy is designed to detect.</span></span>

    - <span data-ttu-id="87635-217">Kényszerítse az átmeneti hibák előfordulását a szolgáltatás ideiglenes letiltásával vagy túlterhelésével, de csak abban az esetben, ha az egy egyéni szolgáltatás, amelyet Ön hozott létre és helyezett üzembe (természetesen ne próbálja meg túlterhelni az Azure-ban megosztott erőforrásokat vagy szolgáltatásokat).</span><span class="sxs-lookup"><span data-stu-id="87635-217">Force transient errors to occur by temporarily disabling or overloading the service if it is a custom service that you created and deployed (you should not, of course, attempt to overload any shared resources or shared services within Azure).</span></span>

    - <span data-ttu-id="87635-218">A HTTP-alapú API-k esetén fontolja meg a FiddlerCore kódtár használatát az automatikus tesztekben a HTTP-kérések eredményének megváltoztatásához. Ezt további adatváltási idők hozzáadásával, vagy a válasz (például a HTTP-állapotkód, fejlécek, törzs vagy egyéb tényezők) módosításával érheti el.</span><span class="sxs-lookup"><span data-stu-id="87635-218">For HTTP-based APIs, consider using the FiddlerCore library in your automated tests to change the outcome of HTTP requests, either by adding extra roundtrip times or by changing the response (such as the HTTP status code, headers, body, or other factors).</span></span> <span data-ttu-id="87635-219">Ez lehetővé teszi a hibafeltételek egy részének determinisztikus tesztelését, legyen szó akár átmeneti hibákról, akár más hibatípusokról.</span><span class="sxs-lookup"><span data-stu-id="87635-219">This enables deterministic testing of a subset of the failure conditions, whether transient faults or other types of failure.</span></span> <span data-ttu-id="87635-220">További információért lásd a [FiddlerCore](https://www.telerik.com/fiddler/fiddlercore) ismertetését.</span><span class="sxs-lookup"><span data-stu-id="87635-220">For more information, see [FiddlerCore](https://www.telerik.com/fiddler/fiddlercore).</span></span> <span data-ttu-id="87635-221">A kódtár, de különösen a **HttpMangler** osztály használatát bemutató példákért tekintse meg [az Azure Storage SDK forráskódját](https://github.com/Azure/azure-storage-net/tree/master/Test).</span><span class="sxs-lookup"><span data-stu-id="87635-221">For examples of how to use the library, particularly the **HttpMangler** class, examine the [source code for the Azure Storage SDK](https://github.com/Azure/azure-storage-net/tree/master/Test).</span></span>

    - <span data-ttu-id="87635-222">Végezzen magas terhelési tényezős és párhuzamos teszteket annak ellenőrzéséhez, hogy az újrapróbálkozási mechanizmus és a stratégia megfelelően működik-e ilyen feltételek mellett, nincsenek-e kedvezőtlen hatással az ügyfél működésére, valamint nem okoznak-e keresztkontaminációt a kérések között.</span><span class="sxs-lookup"><span data-stu-id="87635-222">Perform high load factor and concurrent tests to ensure that the retry mechanism and strategy works correctly under these conditions, and does not have an adverse effect on the operation of the client or cause cross-contamination between requests.</span></span>

- <span data-ttu-id="87635-223">**Kezelje az újrapróbálkozási szabályzat-konfigurációkat:**</span><span class="sxs-lookup"><span data-stu-id="87635-223">**Manage retry policy configurations:**</span></span>

  - <span data-ttu-id="87635-224">Az *újrapróbálkozási szabályzat* az újrapróbálkozási stratégia elemeiből tevődik össze.</span><span class="sxs-lookup"><span data-stu-id="87635-224">A *retry policy* is a combination of all of the elements of your retry strategy.</span></span> <span data-ttu-id="87635-225">Ez határozza meg az észlelési mechanizmust, amely megadja a hibák feltételezett típusát, a használandó időközt (például rendszeres, exponenciális visszatartás és véletlenszerűsítés), a tényleges időközi érték(ek)et és az újrapróbálkozások számát.</span><span class="sxs-lookup"><span data-stu-id="87635-225">It defines the detection mechanism that determines whether a fault is likely to be transient, the type of interval to use (such as regular, exponential back-off, and randomization), the actual interval value(s), and the number of times to retry.</span></span>

  - <span data-ttu-id="87635-226">Az újrapróbálkozásokat még a legegyszerűbb alkalmazásokban is sok helyen implementálni kell, az összetettebb alkalmazásokban pedig minden rétegben.</span><span class="sxs-lookup"><span data-stu-id="87635-226">Retries must be implemented in many places within even the simplest application, and in every layer of more complex applications.</span></span> <span data-ttu-id="87635-227">A szabályzatok elemeinek több helyen való fix kódolása helyett fontolja meg egy központi hely használatát, ahol az összes szabályzatot tárolhatja.</span><span class="sxs-lookup"><span data-stu-id="87635-227">Rather than hard-coding the elements of each policy at multiple locations, consider using a central point for storing all the policies.</span></span> <span data-ttu-id="87635-228">Például tárolja az időközt és az újrapróbálkozások számát az alkalmazás konfigurációs fájljaiban, olvassa be őket a futtatáskor, és hozza létre az újrapróbálkozási szabályzatokat a szoftverből.</span><span class="sxs-lookup"><span data-stu-id="87635-228">For example, store the values such as the interval and retry count in application configuration files, read them at runtime, and programmatically build the retry policies.</span></span> <span data-ttu-id="87635-229">Ez megkönnyíti a beállítások kezelését, valamint az értékek módosítását és finomhangolását, hogy azok megfeleljenek a változó követelményeknek és forgatókönyveknek.</span><span class="sxs-lookup"><span data-stu-id="87635-229">This makes it easier to manage the settings, and to modify and fine tune the values in order to respond to changing requirements and scenarios.</span></span> <span data-ttu-id="87635-230">A rendszert azonban úgy tervezze meg, hogy tárolja az értékeket ahelyett, hogy minden alkalommal újra beolvasná a konfigurációs fájlt, és biztosítsa a megfelelő alapértelmezett értékek használatát, ha az értékeket nem lehet lekérni a konfigurációból.</span><span class="sxs-lookup"><span data-stu-id="87635-230">However, design the system to store the values rather than rereading a configuration file every time, and ensure suitable defaults are used if the values cannot be obtained from configuration.</span></span>

  - <span data-ttu-id="87635-231">Az Azure Cloud Services-alkalmazásokban érdemes az újrapróbálkozási szabályzatok futásidőben való létrehozásához használt értékeket a szolgáltatáskonfigurációs fájlban tárolni, hogy az alkalmazás újraindítása nélkül meg lehessen változtatni őket.</span><span class="sxs-lookup"><span data-stu-id="87635-231">In an Azure Cloud Services application, consider storing the values that are used to build the retry policies at runtime in the service configuration file so that they can be changed without needing to restart the application.</span></span>

  - <span data-ttu-id="87635-232">Használja ki az Ön által használt ügyfél API-kban elérhető beépített vagy alapértelmezett újrapróbálkozási stratégiák előnyeit, de csak akkor, ha azok megfelelnek a forgatókönyvének.</span><span class="sxs-lookup"><span data-stu-id="87635-232">Take advantage of built-in or default retry strategies available in the client APIs you use, but only where they are appropriate for your scenario.</span></span> <span data-ttu-id="87635-233">Ezek a stratégiák általában általános célúak.</span><span class="sxs-lookup"><span data-stu-id="87635-233">These strategies are typically general-purpose.</span></span> <span data-ttu-id="87635-234">Egyes forgatókönyveknél ezek is elegendőek lehetnek, viszont más forgatókönyvek esetében előfordulhat, hogy nem tartalmaznak elég beállítást ahhoz, hogy megfeleljenek a követelményeknek.</span><span class="sxs-lookup"><span data-stu-id="87635-234">In some scenarios they may be all that is required, but in other scenarios they may not offer the full range of options to suit your specific requirements.</span></span> <span data-ttu-id="87635-235">A legmegfelelőbb értékek meghatározásához tesztelés útján ki kell tapasztalnia, hogy milyen hatással vannak a beállítások az alkalmazásra.</span><span class="sxs-lookup"><span data-stu-id="87635-235">You must understand how the settings will affect your application through testing to determine the most appropriate values.</span></span>

- <span data-ttu-id="87635-236">**Naplózza és kövesse nyomon az átmeneti és nem átmeneti hibákat:**</span><span class="sxs-lookup"><span data-stu-id="87635-236">**Log and track transient and non-transient faults:**</span></span>

  - <span data-ttu-id="87635-237">Az újrapróbálkozási stratégiába foglaljon bele kivételkezelést, és olyan rendszerállapotokat, amelyek naplózzák az újrapróbálkozási kísérleteket.</span><span class="sxs-lookup"><span data-stu-id="87635-237">As part of your retry strategy, include exception handling and other instrumentation that logs when retry attempts are made.</span></span> <span data-ttu-id="87635-238">Bár egy átmeneti hibákra alkalmanként és számítani lehet, és jelzi, hogy hibás, rendszeresen és egyre nagyobb számú újrapróbálkozás általában azt jelzi, hogy a hibát, amely meghibásodást okozhat, vagy van jelenleg gyorsítótárazhatók az alkalmazások teljesítményéről és rendelkezésre állás.</span><span class="sxs-lookup"><span data-stu-id="87635-238">While an occasional transient failure and retry are to be expected, and do not indicate a problem, regular and increasing numbers of retries are often an indicator of an issue that may cause a failure, or is currently degrading application performance and availability.</span></span>

  - <span data-ttu-id="87635-239">Az átmeneti hibákat „Hiba” bejegyzések helyett naplózza „Figyelmeztetés” bejegyzésként, nehogy a monitorozó rendszerek alkalmazáshibaként észleljék őket, és téves riasztásokat küldjenek.</span><span class="sxs-lookup"><span data-stu-id="87635-239">Log transient faults as Warning entries rather than Error entries so that monitoring systems do not detect them as application errors that may trigger false alerts.</span></span>

  - <span data-ttu-id="87635-240">Érdemes egy olyan értéket tárolni a naplóbejegyzésekben, amely jelzi, ha az újrapróbálkozásokat a szolgáltatás szabályozása, vagy más típusú hibák (például csatlakozási hibák) okozták, hogy meg tudja őket különböztetni az adatok elemzése során.</span><span class="sxs-lookup"><span data-stu-id="87635-240">Consider storing a value in your log entries that indicates if the retries were caused by throttling in the service, or by other types of faults such as connection failures, so that you can differentiate them during analysis of the data.</span></span> <span data-ttu-id="87635-241">A szabályozási hibák számának növekedése gyakran egy tervezési hibát jelez az alkalmazásban, vagy azt, hogy át kell váltani egy dedikált hardvereket kínáló prémium szolgáltatásra.</span><span class="sxs-lookup"><span data-stu-id="87635-241">An increase in the number of throttling errors is often an indicator of a design flaw in the application or the need to switch to a premium service that offers dedicated hardware.</span></span>

  - <span data-ttu-id="87635-242">Fontolja meg az újrapróbálkozási mechanizmust tartalmazó műveletek teljes időtartamának mérését és naplózását.</span><span class="sxs-lookup"><span data-stu-id="87635-242">Consider measuring and logging the overall time taken for operations that include a retry mechanism.</span></span> <span data-ttu-id="87635-243">Ez remekül szemlélteti az átmeneti hibák általános hatását a felhasználók válaszidejére, a folyamat késleltetésére és az alkalmazás használati eseteinek hatékonyságára.</span><span class="sxs-lookup"><span data-stu-id="87635-243">This is a good indicator of the overall effect of transient faults on user response times, process latency, and the efficiency of the application use cases.</span></span> <span data-ttu-id="87635-244">Emellett az újrapróbálkozások számát is naplózza, hogy megismerje a válaszidőhöz hozzájáruló tényezőket.</span><span class="sxs-lookup"><span data-stu-id="87635-244">Also log the number of retries occurred in order to understand the factors that contributed to the response time.</span></span>

  - <span data-ttu-id="87635-245">Fontolja meg egy telemetrikus és monitorozó rendszer használatát, amely riasztást ad ki, ha növekedni kezd a hibák száma és mértéke, az újrapróbálkozások átlagos száma, vagy a műveletek sikeres elvégzésének teljes időtartama.</span><span class="sxs-lookup"><span data-stu-id="87635-245">Consider implementing a telemetry and monitoring system that can raise alerts when the number and rate of failures, the average number of retries, or the overall times taken for operations to succeed, is increasing.</span></span>

- <span data-ttu-id="87635-246">**Kezelje a folyamatosan meghiúsuló műveleteket:**</span><span class="sxs-lookup"><span data-stu-id="87635-246">**Manage operations that continually fail:**</span></span>
  
  - <span data-ttu-id="87635-247">Elő fognak fordulni olyan esetek, amikor a művelet minden kísérletnél folyamatosan meghiúsul. Rendkívül fontos végiggondolni, hogyan fogja kezelni ezt a helyzetet:</span><span class="sxs-lookup"><span data-stu-id="87635-247">There will be circumstances where the operation continues to fail at every attempt, and it is vital to consider how you will handle this situation:</span></span>

    - <span data-ttu-id="87635-248">Az újrapróbálkozási stratégia meg fogja határozni a művelet újrapróbálkozásának maximális számát, viszont nem akadályozza meg, hogy az alkalmazás még egyszer megismételje a műveletet ugyanannyi újrapróbálkozással.</span><span class="sxs-lookup"><span data-stu-id="87635-248">Although a retry strategy will define the maximum number of times that an operation should be retried, it does not prevent the application repeating the operation again, with the same number of retries.</span></span> <span data-ttu-id="87635-249">Például ha egy megrendelésfeldolgozó szolgáltatás meghiúsul egy végzetes hibával, és emiatt működésképtelenné válik, az újrapróbálkozási stratégia kapcsolati időtúllépést észlelhet, és átmeneti hibának tekintheti azt.</span><span class="sxs-lookup"><span data-stu-id="87635-249">For example, if an order processing service fails with a fatal error that puts it out of action permanently, the retry strategy may detect a connection timeout and consider it to be a transient fault.</span></span> <span data-ttu-id="87635-250">A kód meg fogja próbálni újra végrehajtani a műveletet a megadott számú alkalommal, majd feladja.</span><span class="sxs-lookup"><span data-stu-id="87635-250">The code will retry the operation a specified number of times and then give up.</span></span> <span data-ttu-id="87635-251">Amikor azonban egy másik ügyfél lead egy megrendelést, a rendszer ismét meg fogja kísérelni a műveletet – annak ellenére, hogy az minden alkalommal garantáltan meghiúsul.</span><span class="sxs-lookup"><span data-stu-id="87635-251">However, when another customer places an order, the operation will be attempted again - even though it is sure to fail every time.</span></span>

    - <span data-ttu-id="87635-252">Ha el szeretné kerülni a folyamatosan meghiúsuló műveletek újbóli végrehajtását, vegye fontolóra az [áramkör-megszakító minta](../patterns/circuit-breaker.md) alkalmazását.</span><span class="sxs-lookup"><span data-stu-id="87635-252">To prevent continual retries for operations that continually fail, consider implementing the [Circuit Breaker pattern](../patterns/circuit-breaker.md).</span></span> <span data-ttu-id="87635-253">Ebben a mintában, ha a hibák száma meghaladja a határértéket a megadott időtartományon belül, a rendszer azonnal visszaküldi a kéréseket hibaként a meghívónak, és meg sem próbál hozzáférni a hibás erőforráshoz vagy szolgáltatáshoz.</span><span class="sxs-lookup"><span data-stu-id="87635-253">In this pattern, if the number of failures within a specified time window exceeds the threshold, requests are returned to the caller immediately as errors, without attempting to access the failed resource or service.</span></span>

    - <span data-ttu-id="87635-254">Az alkalmazás időről időre tesztelheti a szolgáltatást (időszakos jelleggel és nagyon hosszú kérések közötti időközökkel), hogy észlelje, mikor válik elérhetővé.</span><span class="sxs-lookup"><span data-stu-id="87635-254">The application can periodically test the service, on an intermittent basis and with very long intervals between requests, to detect when it becomes available.</span></span> <span data-ttu-id="87635-255">A megfelelő időköz az adott forgatókönyvtől függ, például a művelet kritikusságától és a szolgáltatás jellegétől, és a hossza néhány perc vagy akár több óra is lehet.</span><span class="sxs-lookup"><span data-stu-id="87635-255">An appropriate interval will depend on the scenario, such as the criticality of the operation and the nature of the service, and might be anything between a few minutes and several hours.</span></span> <span data-ttu-id="87635-256">Amikor a teszt sikeresen befejeződik, az alkalmazás folytathatja a normál működést, és kéréseket továbbíthat az újonnan helyreállított szolgáltatásnak.</span><span class="sxs-lookup"><span data-stu-id="87635-256">At the point where the test succeeds, the application can resume normal operations and pass requests to the newly recovered service.</span></span>

    - <span data-ttu-id="87635-257">Addig is lehetősége van visszaváltani a szolgáltatás egy másik (például egy másik adatközpontban vagy alkalmazásban található) példányára, használhat egy kompatibilis (talán egyszerűbb) funkciókat kínáló, hasonló szolgáltatást, vagy elvégezhet néhány alternatív műveletet annak reményében, hogy a szolgáltatás hamarosan elérhetővé válik.</span><span class="sxs-lookup"><span data-stu-id="87635-257">In the meantime, it may be possible to fall back to another instance of the service (perhaps in a different datacenter or application), use a similar service that offers compatible (perhaps simpler) functionality, or perform some alternative operations in the hope that the service will become available soon.</span></span> <span data-ttu-id="87635-258">Például célszerű lehet egy üzenetsorban vagy egy adattárban tárolni a szolgáltatásra vonatkozó kéréseket, és később visszajátszani őket.</span><span class="sxs-lookup"><span data-stu-id="87635-258">For example, it may be appropriate to store requests for the service in a queue or data store and replay them later.</span></span> <span data-ttu-id="87635-259">Egyéb esetben lehet, hogy át tudja irányítani a felhasználót az alkalmazás egy másik példányára, és csökkenteni tudja az alkalmazás teljesítményét úgy, hogy az még elfogadható funkciókat kínáljon, vagy szimplán visszaadhat egy üzenetet a felhasználónak, amely jelzi, hogy az alkalmazás jelenleg nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="87635-259">Otherwise you might be able to redirect the user to an alternative instance of the application, degrade the performance of the application but still offer acceptable functionality, or just return a message to the user indicating that the application is not available at present.</span></span>

- <span data-ttu-id="87635-260">**Egyéb szempontok**</span><span class="sxs-lookup"><span data-stu-id="87635-260">**Other considerations**</span></span>
  
  - <span data-ttu-id="87635-261">Amikor meghatározza az újrapróbálkozások számát és a szabályzatok újrapróbálkozási időközeit, gondolja át, hogy a szolgáltatás vagy az erőforrás művelete egy hosszú lefutású vagy többlépéses művelet része-e.</span><span class="sxs-lookup"><span data-stu-id="87635-261">When deciding on the values for the number of retries and the retry intervals for a policy, consider if the operation on the service or resource is part of a long-running or multi-step operation.</span></span> <span data-ttu-id="87635-262">Ha az egyik műveleti lépés meghiúsul, nehéz vagy költséges lehet kompenzálni a többi sikeresen végrehajtott lépést.</span><span class="sxs-lookup"><span data-stu-id="87635-262">It may be difficult or expensive to compensate all the other operational steps that have already succeeded when one fails.</span></span> <span data-ttu-id="87635-263">Ebben az esetben a nagyon hosszú időköz és a sok újrapróbálkozás elfogadható lehet, amíg nem blokkolja a többi műveletet a korlátozott erőforrások tartásával vagy zárolásával.</span><span class="sxs-lookup"><span data-stu-id="87635-263">In this case, a very long interval and a large number of retries may be acceptable as long as it does not block other operations by holding or locking scarce resources.</span></span>

  - <span data-ttu-id="87635-264">Gondolja át, hogy okozhat-e adatinkonzisztenciát, ha megpróbálja újra végrehajtani ugyanazt a műveletet.</span><span class="sxs-lookup"><span data-stu-id="87635-264">Consider if retrying the same operation may cause inconsistencies in data.</span></span> <span data-ttu-id="87635-265">Ha a rendszer megismétli egy többlépéses folyamat néhány részét, és a műveletek nem idempotensek, az inkonzisztenciához vezethet.</span><span class="sxs-lookup"><span data-stu-id="87635-265">If some parts of a multi-step process are repeated, and the operations are not idempotent, it may result in an inconsistency.</span></span> <span data-ttu-id="87635-266">Például egy értéknövelő művelet érvénytelen eredményt fog megadni, ha megismétlik.</span><span class="sxs-lookup"><span data-stu-id="87635-266">For example, an operation that increments a value, if repeated, will produce an invalid result.</span></span> <span data-ttu-id="87635-267">Ha a rendszer megismétel egy műveletet, amely üzenetet küld egy üzenetsorba, és az üzenetfogyasztó nem tudja észlelni a duplikált üzeneteket, az inkonzisztenciát okozhat a fogyasztóban.</span><span class="sxs-lookup"><span data-stu-id="87635-267">Repeating an operation that sends a message to a queue may cause an inconsistency in the message consumer if it cannot detect duplicate messages.</span></span> <span data-ttu-id="87635-268">Ennek megelőzése érdekében biztosítsa, hogy minden lépést idempotens műveletként tervez meg.</span><span class="sxs-lookup"><span data-stu-id="87635-268">To prevent this, ensure that you design each step as an idempotent operation.</span></span> <span data-ttu-id="87635-269">Idempotens kapcsolatos további információkért lásd: [Idempotens minták][idempotency-patterns].</span><span class="sxs-lookup"><span data-stu-id="87635-269">For more information about idempotency, see [Idempotency patterns][idempotency-patterns].</span></span>

  - <span data-ttu-id="87635-270">Vegye figyelembe azoknak a műveleteknek hatókörét, amelyeket a rendszer újra fog próbálni.</span><span class="sxs-lookup"><span data-stu-id="87635-270">Consider the scope of the operations that will be retried.</span></span> <span data-ttu-id="87635-271">Például egyszerűbb lehet olyan szinten megvalósítani az újrapróbálkozási kódot, amely több műveletre is kiterjed, és az összeset újból megkísérelni, ha az egyik meghiúsul.</span><span class="sxs-lookup"><span data-stu-id="87635-271">For example, it may be easier to implement retry code at a level that encompasses several operations, and retry them all if one fails.</span></span> <span data-ttu-id="87635-272">Ez azonban idempotencia-problémákat vagy szükségtelen visszaállítási műveleteket eredményezhet.</span><span class="sxs-lookup"><span data-stu-id="87635-272">However, doing this may result in idempotency issues or unnecessary rollback operations.</span></span>

  - <span data-ttu-id="87635-273">Ha több műveletre kiterjedő újrapróbálkozási hatókört választ, az újrapróbálkozási időközök meghatározásánál, a szükséges idő megfigyelésénél, valamint hibák esetén a riasztások kiadása előtt vegye figyelembe az összes művelet teljes késését.</span><span class="sxs-lookup"><span data-stu-id="87635-273">If you choose a retry scope that encompasses several operations, take into account the total latency of all of them when determining the retry intervals, when monitoring the time taken, and before raising alerts for failures.</span></span>

  - <span data-ttu-id="87635-274">Gondolja végig, hogyan érintheti az újrapróbálkozási stratégiája a szomszédokat és a többi bérlőt egy megosztott alkalmazásban, vagy amikor megosztott erőforrásokat és szolgáltatásokat használ.</span><span class="sxs-lookup"><span data-stu-id="87635-274">Consider how your retry strategy may affect neighbors and other tenants in a shared application, or when using shared resources and services.</span></span> <span data-ttu-id="87635-275">Az agresszív újrapróbálkozási szabályzatok egyre több átmeneti hibát okozhatnak a többi felhasználónál, és az olyan alkalmazásokban, amelyek közösen használják ezeket az erőforrásokat és szolgáltatásokat.</span><span class="sxs-lookup"><span data-stu-id="87635-275">Aggressive retry policies can cause an increasing number of transient faults to occur for these other users and for applications that share the resources and services.</span></span> <span data-ttu-id="87635-276">Hasonlóképpen, az erőforrások és szolgáltatások többi felhasználója által alkalmazott újrapróbálkozási szabályzatok is hatással lehetnek az Ön alkalmazására.</span><span class="sxs-lookup"><span data-stu-id="87635-276">Likewise, your application may be affected by the retry policies implemented by other users of the resources and services.</span></span> <span data-ttu-id="87635-277">A kritikus fontosságú alkalmazások esetén prémium szolgáltatásokat is használhat, amelyek nincsenek megosztva.</span><span class="sxs-lookup"><span data-stu-id="87635-277">For mission-critical applications, you may decide to use premium services that are not shared.</span></span> <span data-ttu-id="87635-278">Ezek sokkal nagyobb irányítást tesznek lehetővé az erőforrások és szolgáltatások terhelése és szabályozása felett, ami segíthet megindokolni a többletköltséget.</span><span class="sxs-lookup"><span data-stu-id="87635-278">This provides you with much more control over the load and consequent throttling of these resources and services, which can help to justify the additional cost.</span></span>

## <a name="more-information"></a><span data-ttu-id="87635-279">További információ</span><span class="sxs-lookup"><span data-stu-id="87635-279">More information</span></span>

- [<span data-ttu-id="87635-280">Azure-szolgáltatásokra vonatkozó újrapróbálkozási irányelvek</span><span class="sxs-lookup"><span data-stu-id="87635-280">Azure service-specific retry guidelines</span></span>](./retry-service-specific.md)
- [<span data-ttu-id="87635-281">Áramkör-megszakító minta</span><span class="sxs-lookup"><span data-stu-id="87635-281">Circuit Breaker pattern</span></span>](../patterns/circuit-breaker.md)
- [<span data-ttu-id="87635-282">Kompenzáló tranzakció mintája</span><span class="sxs-lookup"><span data-stu-id="87635-282">Compensating Transaction pattern</span></span>](../patterns/compensating-transaction.md)
- <span data-ttu-id="87635-283">[Idempotens minták][idempotency-patterns]</span><span class="sxs-lookup"><span data-stu-id="87635-283">[Idempotency patterns][idempotency-patterns]</span></span>

<!-- links -->

[idempotency-patterns]: https://blog.jonathanoliver.com/idempotency-patterns/
