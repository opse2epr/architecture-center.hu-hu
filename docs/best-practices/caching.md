---
title: Gyorsítótárazási útmutató
titleSuffix: Best practices for cloud applications
description: Útmutatás a gyorsítótárazáshoz a teljesítmény és a méretezhetőség javítása érdekében.
author: dragon119
ms.date: 05/24/2017
ms.topic: best-practice
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 20f1e5c155aff445e2b2f15e07a5adf1dcc4c338
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 03/20/2019
ms.locfileid: "58298494"
---
# <a name="caching"></a><span data-ttu-id="b1fca-103">Gyorsítótárazás</span><span class="sxs-lookup"><span data-stu-id="b1fca-103">Caching</span></span>

<span data-ttu-id="b1fca-104">A gyorsítótárazás egy gyakran alkalmazott módszer, amelynek célja egy rendszer teljesítményének és méretezhetőségének javítása.</span><span class="sxs-lookup"><span data-stu-id="b1fca-104">Caching is a common technique that aims to improve the performance and scalability of a system.</span></span> <span data-ttu-id="b1fca-105">Ehhez a rendszer ideiglenesen átmásolja a gyakran használt adatokat egy, az alkalmazás közelében lévő gyors tárolóba.</span><span class="sxs-lookup"><span data-stu-id="b1fca-105">It does this by temporarily copying frequently accessed data to fast storage that's located close to the application.</span></span> <span data-ttu-id="b1fca-106">Ha ez a gyors adattároló közelebb van az alkalmazáshoz, mint az eredeti forrás, akkor a gyorsabb adatkiszolgálás révén a gyorsítótárazással lényegesen javítható az ügyfélalkalmazások válaszideje.</span><span class="sxs-lookup"><span data-stu-id="b1fca-106">If this fast data storage is located closer to the application than the original source, then caching can significantly improve response times for client applications by serving data more quickly.</span></span>

<span data-ttu-id="b1fca-107">A gyorsítótárazás akkor a leghatékonyabb, ha egy ügyfélpéldány rendszeresen ugyanazokat az adatokat olvassa be, és különösen akkor, ha az eredeti adattárat az alábbi tulajdonságok jellemzik:</span><span class="sxs-lookup"><span data-stu-id="b1fca-107">Caching is most effective when a client instance repeatedly reads the same data, especially if all the following conditions apply to the original data store:</span></span>

- <span data-ttu-id="b1fca-108">Viszonylag statikus marad.</span><span class="sxs-lookup"><span data-stu-id="b1fca-108">It remains relatively static.</span></span>
- <span data-ttu-id="b1fca-109">A gyorsítótár sebességéhez képest lassú.</span><span class="sxs-lookup"><span data-stu-id="b1fca-109">It's slow compared to the speed of the cache.</span></span>
- <span data-ttu-id="b1fca-110">Magas szintű versengésnek van kitéve.</span><span class="sxs-lookup"><span data-stu-id="b1fca-110">It's subject to a high level of contention.</span></span>
- <span data-ttu-id="b1fca-111">Távoli, és a hálózati késleltetés lassú hozzáférést eredményezhet.</span><span class="sxs-lookup"><span data-stu-id="b1fca-111">It's far away when network latency can cause access to be slow.</span></span>

## <a name="caching-in-distributed-applications"></a><span data-ttu-id="b1fca-112">Gyorsítótárazás az elosztott alkalmazásokban</span><span class="sxs-lookup"><span data-stu-id="b1fca-112">Caching in distributed applications</span></span>

<span data-ttu-id="b1fca-113">Az elosztott alkalmazások általában az alábbi stratégiák egyikét vagy mindegyikét alkalmazzák az adatok gyorsítótárazása során:</span><span class="sxs-lookup"><span data-stu-id="b1fca-113">Distributed applications typically implement either or both of the following strategies when caching data:</span></span>

- <span data-ttu-id="b1fca-114">Privát gyorsítótár használata, amikor az adatok helyileg vannak tárolva az alkalmazás- vagy szolgáltatáspéldányt futtató számítógépen.</span><span class="sxs-lookup"><span data-stu-id="b1fca-114">Using a private cache, where data is held locally on the computer that's running an instance of an application or service.</span></span>
- <span data-ttu-id="b1fca-115">Megosztott gyorsítótár használata, amely több folyamat és/vagy számítógép által elérhető, közös adatforrásként szolgál.</span><span class="sxs-lookup"><span data-stu-id="b1fca-115">Using a shared cache, serving as a common source which can be accessed by multiple processes and/or machines.</span></span>

<span data-ttu-id="b1fca-116">A gyorsítótárazásra mindkét esetben sor kerülhet az ügyféloldalon és/vagy a kiszolgálóoldalon.</span><span class="sxs-lookup"><span data-stu-id="b1fca-116">In both cases, caching can be performed client-side and/or server-side.</span></span> <span data-ttu-id="b1fca-117">Az ügyféloldali gyorsítótárazást az a folyamat végzi el, amely egy rendszer felhasználói felületét biztosítja, például egy webböngészőt vagy egy asztali alkalmazást.</span><span class="sxs-lookup"><span data-stu-id="b1fca-117">Client-side caching is done by the process that provides the user interface for a system, such as a web browser or desktop application.</span></span> <span data-ttu-id="b1fca-118">A kiszolgálóoldali gyorsítótárazás a távolról futtatott üzleti szolgáltatásokat biztosító folyamattal történik.</span><span class="sxs-lookup"><span data-stu-id="b1fca-118">Server-side caching is done by the process that provides the business services that are running remotely.</span></span>

### <a name="private-caching"></a><span data-ttu-id="b1fca-119">Privát gyorsítótárazás</span><span class="sxs-lookup"><span data-stu-id="b1fca-119">Private caching</span></span>

<span data-ttu-id="b1fca-120">A legegyszerűbb gyorsítótárazási módszer a memóriában történő tárolás.</span><span class="sxs-lookup"><span data-stu-id="b1fca-120">The most basic type of cache is an in-memory store.</span></span> <span data-ttu-id="b1fca-121">Az adatok tárolása egyetlen folyamat címtartományában történik, és a tár közvetlenül, az adott folyamatban futó kóddal érhető el.</span><span class="sxs-lookup"><span data-stu-id="b1fca-121">It's held in the address space of a single process and accessed directly by the code that runs in that process.</span></span> <span data-ttu-id="b1fca-122">Ez a gyorsítótártípus nagyon gyors hozzáférést biztosít.</span><span class="sxs-lookup"><span data-stu-id="b1fca-122">This type of cache is very quick to access.</span></span> <span data-ttu-id="b1fca-123">Igen hatékony módszernek bizonyult közepes mennyiségű statikus adat tárolására, mivel a gyorsítótár méretét jellemzően a folyamatot futtató számítógép szabad memóriájának mennyisége korlátozza.</span><span class="sxs-lookup"><span data-stu-id="b1fca-123">It can also provide an extremely effective means for storing modest amounts of static data, since the size of a cache is typically constrained by the volume of memory that's available on the machine hosting the process.</span></span>

<span data-ttu-id="b1fca-124">Ha több adatot kell gyorsítótárazni, mint amennyit a memória fizikailag lehetségessé tesz, a gyorsítótárazott adatokat a helyi fájlrendszerbe is kiírhatja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-124">If you need to cache more information than is physically possible in memory, you can write cached data to the local file system.</span></span> <span data-ttu-id="b1fca-125">Ezek hozzáférése lassabb, mint a memóriában tárolt adatoké, de még mindig gyorsabb és megbízhatóbb, mint az adatok hálózaton keresztüli lekérése.</span><span class="sxs-lookup"><span data-stu-id="b1fca-125">This will be slower to access than data that's held in-memory, but should still be faster and more reliable than retrieving data across a network.</span></span>

<span data-ttu-id="b1fca-126">Ha egy, a modellt használó alkalmazásból egyszerre több példányt is futtat, akkor minden alkalmazáspéldány saját, független gyorsítótárral rendelkezik, benne az adatok másolati példányaival.</span><span class="sxs-lookup"><span data-stu-id="b1fca-126">If you have multiple instances of an application that uses this model running concurrently, each application instance has its own independent cache holding its own copy of the data.</span></span>

<span data-ttu-id="b1fca-127">A gyorsítótárat az eredeti adatok múltbeli pillanatfelvételeként képzelje el.</span><span class="sxs-lookup"><span data-stu-id="b1fca-127">Think of a cache as a snapshot of the original data at some point in the past.</span></span> <span data-ttu-id="b1fca-128">Ha ezek az adatok nem statikusak, akkor valószínű, hogy a különböző alkalmazáspéldányok az adatok különböző verzióit tárolják a gyorsítótárukban.</span><span class="sxs-lookup"><span data-stu-id="b1fca-128">If this data is not static, it is likely that different application instances hold different versions of the data in their caches.</span></span> <span data-ttu-id="b1fca-129">Ezért az ilyen példányok által végrehajtott azonos lekérdezés különböző eredményeket adhat, ahogy az 1. ábrán is látható.</span><span class="sxs-lookup"><span data-stu-id="b1fca-129">Therefore, the same query performed by these instances can return different results, as shown in Figure 1.</span></span>

![Memórián belüli gyorsítótár használata egy alkalmazás különböző példányaiban](./images/caching/Figure1.png)

<span data-ttu-id="b1fca-131">*1. ábra: Egy alkalmazás különböző példányaiban memórián belüli gyorsítótár használata.*</span><span class="sxs-lookup"><span data-stu-id="b1fca-131">*Figure 1: Using an in-memory cache in different instances of an application.*</span></span>

### <a name="shared-caching"></a><span data-ttu-id="b1fca-132">Megosztott gyorsítótár használata</span><span class="sxs-lookup"><span data-stu-id="b1fca-132">Shared caching</span></span>

<span data-ttu-id="b1fca-133">A megosztott gyorsítótárral kiküszöbölhető az a memórián belüli gyorsítótár használatakor előforduló probléma, hogy az egyes gyorsítótárakban lévő adatok eltérhetnek egymástól.</span><span class="sxs-lookup"><span data-stu-id="b1fca-133">Using a shared cache can help alleviate concerns that data might differ in each cache, which can occur with in-memory caching.</span></span> <span data-ttu-id="b1fca-134">A megosztott gyorsítótárazással biztosítható, hogy a különböző alkalmazáspéldányok a gyorsítótárazott adatok azonos nézetét lássák.</span><span class="sxs-lookup"><span data-stu-id="b1fca-134">Shared caching ensures that different application instances see the same view of cached data.</span></span> <span data-ttu-id="b1fca-135">Ehhez a rendszer a gyorsítótár számára egy külön helyet hoz létre, amelyet rendszerint egy különálló szolgáltatás részeként üzemeltet, a 2. ábrán látható módon.</span><span class="sxs-lookup"><span data-stu-id="b1fca-135">It does this by locating the cache in a separate location, typically hosted as part of a separate service, as shown in Figure 2.</span></span>

![Megosztott gyorsítótár használata](./images/caching/Figure2.png)

<span data-ttu-id="b1fca-137">*2. ábra: Megosztott gyorsítótár használata.*</span><span class="sxs-lookup"><span data-stu-id="b1fca-137">*Figure 2: Using a shared cache.*</span></span>

<span data-ttu-id="b1fca-138">A megosztott gyorsítótár használatának egyik fontos előnye az általa biztosított méretezhetőség.</span><span class="sxs-lookup"><span data-stu-id="b1fca-138">An important benefit of the shared caching approach is the scalability it provides.</span></span> <span data-ttu-id="b1fca-139">Sok olyan megosztott gyorsítótárazási szolgáltatás van, amely kiszolgálófürtön alapul, és olyan szoftvereket használ, amelyek átlátható módon osztják el az adatokat a fürtön keresztül.</span><span class="sxs-lookup"><span data-stu-id="b1fca-139">Many shared cache services are implemented by using a cluster of servers, and utilize software that distributes the data across the cluster in a transparent manner.</span></span> <span data-ttu-id="b1fca-140">Az alkalmazáspéldány egyszerűen elküld egy kérelmet a gyorsítótár-szolgáltatásnak.</span><span class="sxs-lookup"><span data-stu-id="b1fca-140">An application instance simply sends a request to the cache service.</span></span> <span data-ttu-id="b1fca-141">Az alapul szolgáló infrastruktúra felelős a gyorsítótárazott adatok fürtbeli helyének meghatározásáért.</span><span class="sxs-lookup"><span data-stu-id="b1fca-141">The underlying infrastructure is responsible for determining the location of the cached data in the cluster.</span></span> <span data-ttu-id="b1fca-142">A gyorsítótár további kiszolgálók hozzáadásával egyszerűen méretezhető.</span><span class="sxs-lookup"><span data-stu-id="b1fca-142">You can easily scale the cache by adding more servers.</span></span>

<span data-ttu-id="b1fca-143">A megosztott gyorsítótár használatának két fő hátránya van:</span><span class="sxs-lookup"><span data-stu-id="b1fca-143">There are two main disadvantages of the shared caching approach:</span></span>

- <span data-ttu-id="b1fca-144">Lassabb a hozzáférés, mivel a gyorsítótár tárolása már nem helyileg, az egyes alkalmazáspéldányokban történik.</span><span class="sxs-lookup"><span data-stu-id="b1fca-144">The cache is slower to access because it is no longer held locally to each application instance.</span></span>
- <span data-ttu-id="b1fca-145">Az, hogy külön gyorsítótár-szolgáltatást kell kiépíteni, összetettebbé teheti az alkalmazott megoldást.</span><span class="sxs-lookup"><span data-stu-id="b1fca-145">The requirement to implement a separate cache service might add complexity to the solution.</span></span>

## <a name="considerations-for-using-caching"></a><span data-ttu-id="b1fca-146">A gyorsítótár használatának szempontjai</span><span class="sxs-lookup"><span data-stu-id="b1fca-146">Considerations for using caching</span></span>

<span data-ttu-id="b1fca-147">A következő szakaszokban részletesebben is ismertetjük a gyorsítótár tervezése és használata során megfontolandó szempontokat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-147">The following sections describe in more detail the considerations for designing and using a cache.</span></span>

### <a name="decide-when-to-cache-data"></a><span data-ttu-id="b1fca-148">Hogyan lehet megállapítani, hogy mikor van szükség az adatok gyorsítótárazására?</span><span class="sxs-lookup"><span data-stu-id="b1fca-148">Decide when to cache data</span></span>

<span data-ttu-id="b1fca-149">A gyorsítótárazással jelentősen javítható a teljesítmény, a méretezhetőség és a rendelkezésre állás.</span><span class="sxs-lookup"><span data-stu-id="b1fca-149">Caching can dramatically improve performance, scalability, and availability.</span></span> <span data-ttu-id="b1fca-150">Minél több adattal dolgozik, és minél nagyobb azon felhasználók száma, akik számára az adatokhoz hozzáférést kell biztosítani, annál inkább jelentkeznek a gyorsítótár használatának előnyei.</span><span class="sxs-lookup"><span data-stu-id="b1fca-150">The more data that you have and the larger the number of users that need to access this data, the greater the benefits of caching become.</span></span> <span data-ttu-id="b1fca-151">Ez azért van így, mert a gyorsítótárazás révén csökken az a késleltetés és versengés, amely az eredeti adattárban kialakult a túl sok egyidejű kérelem kezelése miatt.</span><span class="sxs-lookup"><span data-stu-id="b1fca-151">That's because caching reduces the latency and contention that's associated with handling large volumes of concurrent requests in the original data store.</span></span>

<span data-ttu-id="b1fca-152">Előfordulhat például, hogy egy adatbázis csak korlátozott számú párhuzamos kapcsolatot támogat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-152">For example, a database might support a limited number of concurrent connections.</span></span> <span data-ttu-id="b1fca-153">Ha azonban az adatokat a megosztott gyorsítótárból, nem pedig az alapul szolgáló adatbázisból kérik le, akkor az ügyfélalkalmazás abban az esetben is hozzáfér az adatokhoz, ha éppen nem áll rendelkezésre szabad kapcsolat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-153">Retrieving data from a shared cache, however, rather than the underlying database, makes it possible for a client application to access this data even if the number of available connections is currently exhausted.</span></span> <span data-ttu-id="b1fca-154">Ha pedig az adatbázis nem érhető el, a gyorsítótárban tárolt adatok felhasználásával az ügyfélalkalmazások továbbra is működőképesek maradhatnak.</span><span class="sxs-lookup"><span data-stu-id="b1fca-154">Additionally, if the database becomes unavailable, client applications might be able to continue by using the data that's held in the cache.</span></span>

<span data-ttu-id="b1fca-155">Érdemes megfontolni a gyorsítótárazás alkalmazását a gyakran beolvasott, de ritkán módosított adatok esetében (ha például bizonyos adatok olvasási műveleteinek száma nagyobb, mint az írási műveleteké).</span><span class="sxs-lookup"><span data-stu-id="b1fca-155">Consider caching data that is read frequently but modified infrequently (for example, data that has a higher proportion of read operations than write operations).</span></span> <span data-ttu-id="b1fca-156">Nem javasoljuk azonban, hogy a gyorsítótárat a kritikus fontosságú információk mérvadó tárolójaként használja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-156">However, we don't recommend that you use the cache as the authoritative store of critical information.</span></span> <span data-ttu-id="b1fca-157">Ehelyett gondoskodjon arról, hogy egy állandó adattárba kerüljön az összes olyan módosítás, amely nem veszhet el az alkalmazásból.</span><span class="sxs-lookup"><span data-stu-id="b1fca-157">Instead, ensure that all changes that your application cannot afford to lose are always saved to a persistent data store.</span></span> <span data-ttu-id="b1fca-158">Ez azt eredményezi, hogy ha a gyorsítótár nem érhető el, az adattár használatával az alkalmazás továbbra is működőképes maradhat, és nem vesznek el fontos információk.</span><span class="sxs-lookup"><span data-stu-id="b1fca-158">This means that if the cache is unavailable, your application can still continue to operate by using the data store, and you won't lose important information.</span></span>

### <a name="determine-how-to-cache-data-effectively"></a><span data-ttu-id="b1fca-159">Az adatok hatékony gyorsítótárazási módszerének meghatározása</span><span class="sxs-lookup"><span data-stu-id="b1fca-159">Determine how to cache data effectively</span></span>

<span data-ttu-id="b1fca-160">A gyorsítótár hatékony használatának kulcsa, hogy meg tudjuk határozni a gyorsítótárazásra leginkább alkalmas adatokat és időpontokat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-160">The key to using a cache effectively lies in determining the most appropriate data to cache, and caching it at the appropriate time.</span></span> <span data-ttu-id="b1fca-161">Az adatok például hozzáadhatók a gyorsítótárhoz akkor, amikor egy alkalmazás először lekéri őket.</span><span class="sxs-lookup"><span data-stu-id="b1fca-161">The data can be added to the cache on demand the first time it is retrieved by an application.</span></span> <span data-ttu-id="b1fca-162">Ez azt jelenti, hogy az alkalmazásnak csak egyszer kell beolvasnia az adatokat az adattárból, ezt követően a hozzáférés a gyorsítótár használatával már megoldható.</span><span class="sxs-lookup"><span data-stu-id="b1fca-162">This means that the application needs to fetch the data only once from the data store, and that subsequent access can be satisfied by using the cache.</span></span>

<span data-ttu-id="b1fca-163">Alternatív megoldásként a gyorsítótár részlegesen vagy teljesen előre is feltölthető az adatokkal, jellemzően az alkalmazás indításakor (ez a megoldás áttöltésként is ismert).</span><span class="sxs-lookup"><span data-stu-id="b1fca-163">Alternatively, a cache can be partially or fully populated with data in advance, typically when the application starts (an approach known as seeding).</span></span> <span data-ttu-id="b1fca-164">Nem feltétlenül ajánlott azonban az áttöltés használata nagy méretű gyorsítótárak esetében, mert ez a megoldás az alkalmazás indításakor hirtelenül és túlzott mértékben leterhelheti az eredeti adattárat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-164">However, it might not be advisable to implement seeding for a large cache because this approach can impose a sudden, high load on the original data store when the application starts running.</span></span>

<span data-ttu-id="b1fca-165">Gyakran a használati minták elemzése segíthet eldönteni, hogy érdemes-e teljesen vagy részlegesen előre feltölteni a gyorsítótárat, és hogy mely adatokat érdemes e célból kiválasztani.</span><span class="sxs-lookup"><span data-stu-id="b1fca-165">Often an analysis of usage patterns can help you decide whether to fully or partially prepopulate a cache, and to choose the data to cache.</span></span> <span data-ttu-id="b1fca-166">Hasznosnak bizonyulhat például a gyorsítótár feltöltése olyan ügyfelek statikus felhasználóiprofil-adataival, akik rendszeresen (esetleg minden nap) használják az alkalmazást, azokéval azonban nem, akik csak hetente egyszer veszik használatba.</span><span class="sxs-lookup"><span data-stu-id="b1fca-166">For example, it can be useful to seed the cache with the static user profile data for customers who use the application regularly (perhaps every day), but not for customers who use the application only once a week.</span></span>

<span data-ttu-id="b1fca-167">A gyorsítótárazás általában jól működik olyan adatokkal, amelyek nem módosíthatók vagy csak ritkán változnak.</span><span class="sxs-lookup"><span data-stu-id="b1fca-167">Caching typically works well with data that is immutable or that changes infrequently.</span></span> <span data-ttu-id="b1fca-168">Ilyenek lehetnek a referenciainformációk, például egy elektronikus kereskedelmi alkalmazás termék- és díjszabási adatai, illetve olyan megosztott statikus erőforrások, amelyeknek a létrehozása nagyobb költséggel jár.</span><span class="sxs-lookup"><span data-stu-id="b1fca-168">Examples include reference information such as product and pricing information in an e-commerce application, or shared static resources that are costly to construct.</span></span> <span data-ttu-id="b1fca-169">Ezek az adatok részben vagy teljes egészében betölthetők a gyorsítótárba az alkalmazás indításakor, így minimalizálható az erőforrásigény, és fokozható a teljesítmény.</span><span class="sxs-lookup"><span data-stu-id="b1fca-169">Some or all of this data can be loaded into the cache at application startup to minimize demand on resources and to improve performance.</span></span> <span data-ttu-id="b1fca-170">Érdemes lehet alkalmazni egy olyan háttérfolyamat is, amely a naprakész állapot biztosítása érdekében rendszeresen frissíti a referenciaadatokat a gyorsítótárban, vagy amely a referenciaadatok módosításakor frissíti a gyorsítótárat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-170">It might also be appropriate to have a background process that periodically updates reference data in the cache to ensure it is up to date, or that refreshes the cache when reference data changes.</span></span>

<span data-ttu-id="b1fca-171">A gyorsítótárazás kevésbé hasznos, ha dinamikus adatokról van szó, bár vannak kivételek (további információkért lásd lejjebb a „Nagymértékben dinamikus adatok gyorsítótárazása” szakaszt).</span><span class="sxs-lookup"><span data-stu-id="b1fca-171">Caching is less useful for dynamic data, although there are some exceptions to this consideration (see the section Cache highly dynamic data later in this article for more information).</span></span> <span data-ttu-id="b1fca-172">Ha az eredeti adatok rendszeresen változnak, a gyorsítótárban lévő információk nagyon gyorsan elavulhatnak, illetve a gyorsítótár és az eredeti adattár szinkronizálásának szükséglete csökkenti a gyorsítótárazás hatékonyságát.</span><span class="sxs-lookup"><span data-stu-id="b1fca-172">When the original data changes regularly, either the cached information becomes stale very quickly or the overhead of synchronizing the cache with the original data store reduces the effectiveness of caching.</span></span>

<span data-ttu-id="b1fca-173">Vegye figyelembe, hogy a gyorsítótárnak nem kell tartalmaznia egy-egy entitás minden adatát.</span><span class="sxs-lookup"><span data-stu-id="b1fca-173">Note that a cache does not have to include the complete data for an entity.</span></span> <span data-ttu-id="b1fca-174">Ha például egy adatelem többértékű objektumot jelöl (például egy banki ügyfelet névvel, címmel és számlaegyenleggel), akkor ezen elemek közül egyesek statikusak (például a név és a cím), míg mások (például a számlaegyenleg) dinamikusabban változók lehetnek.</span><span class="sxs-lookup"><span data-stu-id="b1fca-174">For example, if a data item represents a multivalued object such as a bank customer with a name, address, and account balance, some of these elements might remain static (such as the name and address), while others (such as the account balance) might be more dynamic.</span></span> <span data-ttu-id="b1fca-175">Ilyen esetekben hasznos lehet az adatok statikus részét gyorsítótárba helyezni, és csak akkor lekérdezni (vagy kiszámítani) a többi adatot, amikor szükség van rájuk.</span><span class="sxs-lookup"><span data-stu-id="b1fca-175">In these situations, it can be useful to cache the static portions of the data and retrieve (or calculate) only the remaining information when it is required.</span></span>

<span data-ttu-id="b1fca-176">Javasoljuk, hogy végezzen teljesítménytesztelést és használatelemzést annak meghatározására, hogy a gyorsítótár előre történő vagy igény szerinti feltöltése, esetleg ezek valamilyen kombinációja jelenti-e a megfelelő megoldást az Ön számára.</span><span class="sxs-lookup"><span data-stu-id="b1fca-176">We recommend that you carry out performance testing and usage analysis to determine whether pre-population or on-demand loading of the cache, or a combination of both, is appropriate.</span></span> <span data-ttu-id="b1fca-177">A döntésnek az adatok változékonyságán és használati módján kell alapulnia.</span><span class="sxs-lookup"><span data-stu-id="b1fca-177">The decision should be based on the volatility and usage pattern of the data.</span></span> <span data-ttu-id="b1fca-178">A gyorsítótár-kihasználtság és a teljesítmény elemzése különösen fontos azoknál az alkalmazásoknál, amelyeknek nagy terheléssel kell megbirkózniuk, és hatékonyan méretezhetőnek kell lenniük.</span><span class="sxs-lookup"><span data-stu-id="b1fca-178">Cache utilization and performance analysis is particularly important in applications that encounter heavy loads and must be highly scalable.</span></span> <span data-ttu-id="b1fca-179">Hatékonyan méretezhető alkalmazások esetén hasznosnak bizonyulhat például a gyorsítótár áttöltése, hogy csökkenjen az adattárat csúcsidőben érő terhelés.</span><span class="sxs-lookup"><span data-stu-id="b1fca-179">For example, in highly scalable scenarios it might make sense to seed the cache to reduce the load on the data store at peak times.</span></span>

<span data-ttu-id="b1fca-180">A gyorsítótárazással az is elkerülhető, ismétlődő számításokat kelljen elvégezni, miközben az alkalmazás fut.</span><span class="sxs-lookup"><span data-stu-id="b1fca-180">Caching can also be used to avoid repeating computations while the application is running.</span></span> <span data-ttu-id="b1fca-181">Ha egy művelet adatátalakítást vagy bonyolult számításokat végez, akkor a művelet eredményei elmenthetők a gyorsítótárba.</span><span class="sxs-lookup"><span data-stu-id="b1fca-181">If an operation transforms data or performs a complicated calculation, it can save the results of the operation in the cache.</span></span> <span data-ttu-id="b1fca-182">Ha később ugyanazt a számítást kell elvégezni, az alkalmazás egyszerűen lekérheti az eredményeket a gyorsítótárból.</span><span class="sxs-lookup"><span data-stu-id="b1fca-182">If the same calculation is required afterward, the application can simply retrieve the results from the cache.</span></span>

<span data-ttu-id="b1fca-183">Az alkalmazások módosíthatják a gyorsítótárban tárolt adatokat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-183">An application can modify data that's held in a cache.</span></span> <span data-ttu-id="b1fca-184">Azt javasoljuk azonban, hogy a gyorsítótárat olyan átmeneti adattárként kezelje, amelynek az adatai bármikor elveszhetnek.</span><span class="sxs-lookup"><span data-stu-id="b1fca-184">However, we recommend thinking of the cache as a transient data store that could disappear at any time.</span></span> <span data-ttu-id="b1fca-185">Értékes adatokat ne tároljon kizárólag a gyorsítótárban; győződjön meg róla, hogy az adatok továbbra is megtalálhatók az eredeti adattárban.</span><span class="sxs-lookup"><span data-stu-id="b1fca-185">Do not store valuable data in the cache only; make sure that you maintain the information in the original data store as well.</span></span> <span data-ttu-id="b1fca-186">Így minimálisra csökken az adatvesztés esélye akkor, ha a gyorsítótár nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="b1fca-186">This means that if the cache becomes unavailable, you minimize the chance of losing data.</span></span>

### <a name="cache-highly-dynamic-data"></a><span data-ttu-id="b1fca-187">Nagymértékben dinamikus adatok gyorsítótárazása</span><span class="sxs-lookup"><span data-stu-id="b1fca-187">Cache highly dynamic data</span></span>

<span data-ttu-id="b1fca-188">Ha gyorsan változó információkat egy állandó adattárolóban tárol, az többletterhelést okozhat a rendszerben.</span><span class="sxs-lookup"><span data-stu-id="b1fca-188">When you store rapidly-changing information in a persistent data store, it can impose an overhead on the system.</span></span> <span data-ttu-id="b1fca-189">Vegyünk például egy olyan eszközt, amely folyamatos jelentést küld az állapotról vagy egyéb mérőszámokról.</span><span class="sxs-lookup"><span data-stu-id="b1fca-189">For example, consider a device that continually reports status or some other measurement.</span></span> <span data-ttu-id="b1fca-190">Ha egy alkalmazás nem tárolja ezeket az adatokat a gyorsítótárban, mivel a gyorsítótárazott adatok így szinte mindig elavultak lennének, akkor ugyanez az információknak az adattárban való tárolására és onnan történő lekérésére is igaz lehet.</span><span class="sxs-lookup"><span data-stu-id="b1fca-190">If an application chooses not to cache this data on the basis that the cached information will nearly always be outdated, then the same consideration could be true when storing and retrieving this information from the data store.</span></span> <span data-ttu-id="b1fca-191">Az adatok mentéséhez és beolvasásához szükséges idő alatt az adatok már módosulhattak is.</span><span class="sxs-lookup"><span data-stu-id="b1fca-191">In the time it takes to save and fetch this data, it might have changed.</span></span>

<span data-ttu-id="b1fca-192">Ilyen esetekben érdemes megfontolni, hogy milyen előnyökkel járhat a dinamikus információk tárolása közvetlenül a gyorsítótárban, az állandó adattár helyett.</span><span class="sxs-lookup"><span data-stu-id="b1fca-192">In a situation such as this, consider the benefits of storing the dynamic information directly in the cache instead of in the persistent data store.</span></span> <span data-ttu-id="b1fca-193">Ha az adatok nem kritikus fontosságúak és nem kell őket naplózni, akkor nem számít, ha egy-egy módosítás elvész.</span><span class="sxs-lookup"><span data-stu-id="b1fca-193">If the data is non-critical and does not require auditing, then it doesn't matter if the occasional change is lost.</span></span>

### <a name="manage-data-expiration-in-a-cache"></a><span data-ttu-id="b1fca-194">A gyorsítótárazott adatok lejáratának kezelése</span><span class="sxs-lookup"><span data-stu-id="b1fca-194">Manage data expiration in a cache</span></span>

<span data-ttu-id="b1fca-195">A legtöbb esetben a gyorsítótárban tárolt adatok az eredeti adattárban lévő adatok másolatai.</span><span class="sxs-lookup"><span data-stu-id="b1fca-195">In most cases, data that's held in a cache is a copy of data that's held in the original data store.</span></span> <span data-ttu-id="b1fca-196">A gyorsítótárba helyezést követően az eredeti adattárban lévő adatok módosulhatnak, ami a gyorsítótárazott adatok elavulását eredményezi.</span><span class="sxs-lookup"><span data-stu-id="b1fca-196">The data in the original data store might change after it was cached, causing the cached data to become stale.</span></span> <span data-ttu-id="b1fca-197">Számos gyorsítótárazási rendszer teszi lehetővé a gyorsítótár konfigurálását arra, hogy elévültnek jelölje meg az adatokat, így csökkenthető az az időszak, amíg elavult adatokat tárol.</span><span class="sxs-lookup"><span data-stu-id="b1fca-197">Many caching systems enable you to configure the cache to expire data and reduce the period for which data may be out of date.</span></span>

<span data-ttu-id="b1fca-198">Az elévült adatokat a rendszer eltávolítja a gyorsítótárból, és az alkalmazásnak az eredeti adattárból kell visszaállítania az adatokat (ezek az újonnan lekért adatok aztán visszahelyezhetők a gyorsítótárba).</span><span class="sxs-lookup"><span data-stu-id="b1fca-198">When cached data expires, it's removed from the cache, and the application must retrieve the data from the original data store (it can put the newly-fetched information back into cache).</span></span> <span data-ttu-id="b1fca-199">A gyorsítótár konfigurálásakor beállíthat egy alapértelmezett elévülési szabályzatot.</span><span class="sxs-lookup"><span data-stu-id="b1fca-199">You can set a default expiration policy when you configure the cache.</span></span> <span data-ttu-id="b1fca-200">Több gyorsítótár-szolgáltatásban az egyes objektumok lejárati idejét is meg lehet szabni, ha azokat programozott módon tárolja a gyorsítótárban.</span><span class="sxs-lookup"><span data-stu-id="b1fca-200">In many cache services, you can also stipulate the expiration period for individual objects when you store them programmatically in the cache.</span></span> <span data-ttu-id="b1fca-201">Egyes gyorsítótárak lehetővé teszik a lejárati idő abszolút vagy mozgó értékként történő megadását, amely alapján a rendszer eltávolítja az adott elemeket a gyorsítótárból, ha a megszabott idő alatt nem próbáltak meg hozzájuk férni.</span><span class="sxs-lookup"><span data-stu-id="b1fca-201">Some caches enable you to specify the expiration period as an absolute value, or as a sliding value that causes the item to be removed from the cache if it is not accessed within the specified time.</span></span> <span data-ttu-id="b1fca-202">Ez a beállítás felülbírál bármely, a teljes gyorsítótárra érvényes elévülési szabályzatot, de csak a megadott objektumokra vonatkozik.</span><span class="sxs-lookup"><span data-stu-id="b1fca-202">This setting overrides any cache-wide expiration policy, but only for the specified objects.</span></span>

> [!NOTE]
> <span data-ttu-id="b1fca-203">Körültekintően vegye figyelembe a gyorsítótár és az abban lévő objektumok lejárati idejét.</span><span class="sxs-lookup"><span data-stu-id="b1fca-203">Consider the expiration period for the cache and the objects that it contains carefully.</span></span> <span data-ttu-id="b1fca-204">Ha az túl rövid, az objektumok túl hamar lejárnak, és így kevésbé érvényesülnek a gyorsítótár használatának előnyei.</span><span class="sxs-lookup"><span data-stu-id="b1fca-204">If you make it too short, objects will expire too quickly and you will reduce the benefits of using the cache.</span></span> <span data-ttu-id="b1fca-205">Ha viszont az időszakot túl hosszúra állítja be, azzal az adatok elévülését kockáztatja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-205">If you make the period too long, you risk the data becoming stale.</span></span>

<span data-ttu-id="b1fca-206">Amennyiben az adatokat hosszabb ideig nem távolítja el, előfordulhat, hogy a gyorsítótár megtelik.</span><span class="sxs-lookup"><span data-stu-id="b1fca-206">It's also possible that the cache might fill up if data is allowed to remain resident for a long time.</span></span> <span data-ttu-id="b1fca-207">Ebben az esetben, ha új elemeket próbál hozzáadni a gyorsítótárhoz, sor kerülhet bizonyos elemek kényszerített eltávolítására – ezt a folyamatot kiürítésnek nevezzük.</span><span class="sxs-lookup"><span data-stu-id="b1fca-207">In this case, any requests to add new items to the cache might cause some items to be forcibly removed in a process known as eviction.</span></span> <span data-ttu-id="b1fca-208">A gyorsítótár-szolgáltatások jellemzően a legrégebben használt (least-recently-used, LRU) adatokat ürítik ki, de általában lehetőség van a szabályzat felülírására és az ilyen elemek kiürítésének megakadályozására.</span><span class="sxs-lookup"><span data-stu-id="b1fca-208">Cache services typically evict data on a least-recently-used (LRU) basis, but you can usually override this policy and prevent items from being evicted.</span></span> <span data-ttu-id="b1fca-209">Ez azonban a gyorsítótárban rendelkezésre álló memória megtelésének kockázatával jár,</span><span class="sxs-lookup"><span data-stu-id="b1fca-209">However, if you adopt this approach, you risk exceeding the memory that's available in the cache.</span></span> <span data-ttu-id="b1fca-210">és az elemet a gyorsítótárhoz hozzáadni próbáló alkalmazás futtatása egy kivétellel meghiúsulhat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-210">An application that attempts to add an item to the cache will fail with an exception.</span></span>

<span data-ttu-id="b1fca-211">Egyes gyorsítótárazási megoldások további kiürítési szabályzatokat is biztosíthatnak.</span><span class="sxs-lookup"><span data-stu-id="b1fca-211">Some caching implementations might provide additional eviction policies.</span></span> <span data-ttu-id="b1fca-212">Többféle típusú kiürítési szabályzat létezik.</span><span class="sxs-lookup"><span data-stu-id="b1fca-212">There are several types of eviction policies.</span></span> <span data-ttu-id="b1fca-213">Ezek a következők:</span><span class="sxs-lookup"><span data-stu-id="b1fca-213">These include:</span></span>

- <span data-ttu-id="b1fca-214">Legutóbbi használaton alapuló szabályzat (ha az adatokra a továbbiakban feltehetően nem lesz szükség).</span><span class="sxs-lookup"><span data-stu-id="b1fca-214">A most-recently-used policy (in the expectation that the data will not be required again).</span></span>
- <span data-ttu-id="b1fca-215">Elsőnek be, elsőnek ki szabályzat (először mindig a legrégebbi adatok kiürítésére kerül sor).</span><span class="sxs-lookup"><span data-stu-id="b1fca-215">A first-in-first-out policy (oldest data is evicted first).</span></span>
- <span data-ttu-id="b1fca-216">Kiváltott eseményen (például módosított adatokon) alapuló explicit eltávolítási szabályzat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-216">An explicit removal policy based on a triggered event (such as the data being modified).</span></span>

### <a name="invalidate-data-in-a-client-side-cache"></a><span data-ttu-id="b1fca-217">Adatok érvénytelenítése egy ügyféloldali gyorsítótárban</span><span class="sxs-lookup"><span data-stu-id="b1fca-217">Invalidate data in a client-side cache</span></span>

<span data-ttu-id="b1fca-218">Az ügyféloldali gyorsítótárban tárolt adatokat általában nem tekintjük ahhoz a szolgáltatáshoz tartozónak, amely adatokat szolgáltat az ügyfél számára.</span><span class="sxs-lookup"><span data-stu-id="b1fca-218">Data that's held in a client-side cache is generally considered to be outside the auspices of the service that provides the data to the client.</span></span> <span data-ttu-id="b1fca-219">A szolgáltatások közvetlenül nem kényszeríthetik az ügyfeleket az ügyféloldali gyorsítótár információinak hozzáadására vagy eltávolítására.</span><span class="sxs-lookup"><span data-stu-id="b1fca-219">A service cannot directly force a client to add or remove information from a client-side cache.</span></span>

<span data-ttu-id="b1fca-220">Ezért előfordulhat, hogy a nem megfelelően konfigurált gyorsítótárat használó ügyfelek elavult információkkal fognak dolgozni.</span><span class="sxs-lookup"><span data-stu-id="b1fca-220">This means that it's possible for a client that uses a poorly configured cache to continue using outdated information.</span></span> <span data-ttu-id="b1fca-221">Ha például a gyorsítótár elévülési szabályzatainak megvalósítása nem megfelelő, akkor lehetséges, hogy az ügyfelek helyileg gyorsítótárazott, elavult információkat fognak használni, miközben az eredeti adatforrás adatai már módosultak.</span><span class="sxs-lookup"><span data-stu-id="b1fca-221">For example, if the expiration policies of the cache aren't properly implemented, a client might use outdated information that's cached locally when the information in the original data source has changed.</span></span>

<span data-ttu-id="b1fca-222">Ha olyan webalkalmazást épít ki, amely HTTP-kapcsolaton keresztül szolgáltat adatokat, akkor implicit módon kényszeríthet egy webes ügyfelet (például böngészőt vagy webproxyt) a legfrissebb információk lekérésére.</span><span class="sxs-lookup"><span data-stu-id="b1fca-222">If you are building a web application that serves data over an HTTP connection, you can implicitly force a web client (such as a browser or web proxy) to fetch the most recent information.</span></span> <span data-ttu-id="b1fca-223">Ezt akkor teheti meg, ha egy erőforrás az erőforrás URI-jának módosításával frissül.</span><span class="sxs-lookup"><span data-stu-id="b1fca-223">You can do this if a resource is updated by a change in the URI of that resource.</span></span> <span data-ttu-id="b1fca-224">A webes ügyfelek általában az erőforrás URI-ját használják az ügyféloldali gyorsítótár kulcsaként, tehát ha az URI módosul, akkor a webes ügyfél figyelmen kívül hagyja az adott erőforrás előzőleg gyorsítótárazott verzióit, és helyette az új verziót olvassa be.</span><span class="sxs-lookup"><span data-stu-id="b1fca-224">Web clients typically use the URI of a resource as the key in the client-side cache, so if the URI changes, the web client ignores any previously cached versions of a resource and fetches the new version instead.</span></span>

## <a name="managing-concurrency-in-a-cache"></a><span data-ttu-id="b1fca-225">Az egyidejűség kezelése a gyorsítótárakban</span><span class="sxs-lookup"><span data-stu-id="b1fca-225">Managing concurrency in a cache</span></span>

<span data-ttu-id="b1fca-226">A gyorsítótárak tervezése során gyakran az a cél, hogy egy alkalmazás több példánya által közösen használhatók legyenek.</span><span class="sxs-lookup"><span data-stu-id="b1fca-226">Caches are often designed to be shared by multiple instances of an application.</span></span> <span data-ttu-id="b1fca-227">Mindegyik alkalmazáspéldány képes olvasni és módosítani a gyorsítótár adatait.</span><span class="sxs-lookup"><span data-stu-id="b1fca-227">Each application instance can read and modify data in the cache.</span></span> <span data-ttu-id="b1fca-228">Következésképpen a megosztott adattárral kapcsolatban felmerülő egyidejűségi problémák a gyorsítótáraknál is fellépnek.</span><span class="sxs-lookup"><span data-stu-id="b1fca-228">Consequently, the same concurrency issues that arise with any shared data store also apply to a cache.</span></span> <span data-ttu-id="b1fca-229">Olyan helyzetben, amikor egy alkalmazásnak módosítania kell a gyorsítótárban tárolt adatokat, előfordulhat, hogy gondoskodni kell arról, hogy az alkalmazás egyik példánya által elvégzett frissítések ne írhassák felül a másik példány által végrehajtott módosításokat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-229">In a situation where an application needs to modify data that's held in the cache, you might need to ensure that updates made by one instance of the application do not overwrite the changes made by another instance.</span></span>

<span data-ttu-id="b1fca-230">Az adatok természetétől és az ütközések valószínűségétől függően kétféle egyidejűségi megközelítés létezik:</span><span class="sxs-lookup"><span data-stu-id="b1fca-230">Depending on the nature of the data and the likelihood of collisions, you can adopt one of two approaches to concurrency:</span></span>

- <span data-ttu-id="b1fca-231">**Az optimista**.</span><span class="sxs-lookup"><span data-stu-id="b1fca-231">**Optimistic**.</span></span> <span data-ttu-id="b1fca-232">Közvetlenül az adatok frissítése előtt az alkalmazás ellenőrzi, hogy a gyorsítótár adatai módosítva lettek-e a lekérésük óta.</span><span class="sxs-lookup"><span data-stu-id="b1fca-232">Immediately prior to updating the data, the application checks to see whether the data in the cache has changed since it was retrieved.</span></span> <span data-ttu-id="b1fca-233">Ha az adatok nem változtak, akkor a módosítás végrehajtható.</span><span class="sxs-lookup"><span data-stu-id="b1fca-233">If the data is still the same, the change can be made.</span></span> <span data-ttu-id="b1fca-234">Ellenkező esetben az alkalmazásnak kell meghatároznia, hogy elvégzi-e a frissítést.</span><span class="sxs-lookup"><span data-stu-id="b1fca-234">Otherwise, the application has to decide whether to update it.</span></span> <span data-ttu-id="b1fca-235">(A döntés alapjául szolgáló üzleti logika az adott alkalmazásra jellemző lesz.) Ez a megközelítés olyan esetekben alkalmazható, ahol a frissítések ritkák, vagy ahol az ütközések előfordulása nem valószínű.</span><span class="sxs-lookup"><span data-stu-id="b1fca-235">(The business logic that drives this decision will be application-specific.) This approach is suitable for situations where updates are infrequent, or where collisions are unlikely to occur.</span></span>
- <span data-ttu-id="b1fca-236">**A pesszimista**.</span><span class="sxs-lookup"><span data-stu-id="b1fca-236">**Pessimistic**.</span></span> <span data-ttu-id="b1fca-237">Az adatok lekérésekor az alkalmazás zárolja az adatokat a gyorsítótárban, nehogy egy másik példány módosíthassa őket.</span><span class="sxs-lookup"><span data-stu-id="b1fca-237">When it retrieves the data, the application locks it in the cache to prevent another instance from changing it.</span></span> <span data-ttu-id="b1fca-238">Ez a folyamat megakadályozza ugyan az ütközéseket, de blokkolhat olyan egyéb példányokat is, amelyeknek ugyanazokat az adatokat kell feldolgozniuk.</span><span class="sxs-lookup"><span data-stu-id="b1fca-238">This process ensures that collisions cannot occur, but they can also block other instances that need to process the same data.</span></span> <span data-ttu-id="b1fca-239">A pesszimista egyidejűségi megközelítés befolyásolhatja a megoldás méretezhetőségét, és alkalmazása csak rövid ideig tartó műveletek esetén javasolt.</span><span class="sxs-lookup"><span data-stu-id="b1fca-239">Pessimistic concurrency can affect the scalability of a solution and is recommended only for short-lived operations.</span></span> <span data-ttu-id="b1fca-240">Akkor lehet ideális megoldás, ha az ütközések nagyobb valószínűséggel fordulnak elő, különösen, ha egy alkalmazás több elemet is frissít a gyorsítótárban, és gondoskodni kell arról, hogy a módosítások következetesek legyenek.</span><span class="sxs-lookup"><span data-stu-id="b1fca-240">This approach might be appropriate for situations where collisions are more likely, especially if an application updates multiple items in the cache and must ensure that these changes are applied consistently.</span></span>

### <a name="implement-high-availability-and-scalability-and-improve-performance"></a><span data-ttu-id="b1fca-241">Magas rendelkezésre állás és méretezhetőség megvalósítása, illetve a teljesítmény javítása</span><span class="sxs-lookup"><span data-stu-id="b1fca-241">Implement high availability and scalability, and improve performance</span></span>

<span data-ttu-id="b1fca-242">Kerülje a gyorsítótár elsődleges adattárként való használatát; erre az eredeti adattár szolgál, amelyből a rendszer feltölti a gyorsítótárat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-242">Avoid using a cache as the primary repository of data; this is the role of the original data store from which the cache is populated.</span></span> <span data-ttu-id="b1fca-243">Az eredeti adattár feladata az adatok megőrzése.</span><span class="sxs-lookup"><span data-stu-id="b1fca-243">The original data store is responsible for ensuring the persistence of the data.</span></span>

<span data-ttu-id="b1fca-244">Ügyeljen arra, hogy a használt megoldásokban ne kapcsolódjanak kritikus függőségek a megosztott gyorsítótár-szolgáltatások elérhetőségéhez.</span><span class="sxs-lookup"><span data-stu-id="b1fca-244">Be careful not to introduce critical dependencies on the availability of a shared cache service into your solutions.</span></span> <span data-ttu-id="b1fca-245">Az alkalmazásoknak akkor is működőképesnek kell maradniuk, ha a megosztott gyorsítótárat biztosító szolgáltatás nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="b1fca-245">An application should be able to continue functioning if the service that provides the shared cache is unavailable.</span></span> <span data-ttu-id="b1fca-246">Addig sem szabad lefagyniuk vagy meghiúsulniuk, amíg a gyorsítótár-szolgáltatás újraindul.</span><span class="sxs-lookup"><span data-stu-id="b1fca-246">The application should not hang or fail while waiting for the cache service to resume.</span></span>

<span data-ttu-id="b1fca-247">Ezért az alkalmazásoknak képesnek kell lenniük a gyorsítótár-szolgáltatás rendelkezésre állási állapotának észlelésére, illetve az eredeti adattárra való visszaváltásra, ha a gyorsítótár nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="b1fca-247">Therefore, the application must be prepared to detect the availability of the cache service and fall back to the original data store if the cache is inaccessible.</span></span> <span data-ttu-id="b1fca-248">Ebben az esetben az [áramköri megszakítási minta](../patterns/circuit-breaker.md) használható eredményesen.</span><span class="sxs-lookup"><span data-stu-id="b1fca-248">The [Circuit-Breaker pattern](../patterns/circuit-breaker.md) is useful for handling this scenario.</span></span> <span data-ttu-id="b1fca-249">A gyorsítótárat üzemeltető szolgáltatás visszaállítható, és amint elérhetővé válik, a gyorsítótár újból feltölthető, mivel az adatokat a rendszer az eredeti adattárból olvassa be, egy olyan stratégiát követve, amilyen például a [gyorsítótár-feltöltési minta](../patterns/cache-aside.md).</span><span class="sxs-lookup"><span data-stu-id="b1fca-249">The service that provides the cache can be recovered, and once it becomes available, the cache can be repopulated as data is read from the original data store, following a strategy such as the [Cache-aside pattern](../patterns/cache-aside.md).</span></span>

<span data-ttu-id="b1fca-250">Rendszer skálázhatósági azonban érintheti, ha az alkalmazás visszavált az eredeti adattárra, amikor a gyorsítótár ideiglenesen nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="b1fca-250">However, system scalability may be affected if the application falls back to the original data store when the cache is temporarily unavailable.</span></span> <span data-ttu-id="b1fca-251">A gyorsítótár helyreállítása közben az eredeti adattárat eláraszthatják az adatkérések, ami időtúllépéseket és sikertelen kapcsolatokat eredményezhet.</span><span class="sxs-lookup"><span data-stu-id="b1fca-251">While the data store is being recovered, the original data store could be swamped with requests for data, resulting in timeouts and failed connections.</span></span>

<span data-ttu-id="b1fca-252">Érdemes lehet létrehozni egy helyi, privát gyorsítótárat mindegyik alkalmazáspéldányhoz a megosztott gyorsítótár mellett, amelyhez az összes alkalmazáspéldány hozzá tud férni.</span><span class="sxs-lookup"><span data-stu-id="b1fca-252">Consider implementing a local, private cache in each instance of an application, together with the shared cache that all application instances access.</span></span> <span data-ttu-id="b1fca-253">Amikor az alkalmazás lekér egy adott elemet, először a helyi, majd a megosztott gyorsítótárban, végül pedig az eredeti adattárban kereshet.</span><span class="sxs-lookup"><span data-stu-id="b1fca-253">When the application retrieves an item, it can check first in its local cache, then in the shared cache, and finally in the original data store.</span></span> <span data-ttu-id="b1fca-254">A helyi gyorsítótár a megosztott gyorsítótárban vagy (ha a megosztott gyorsítótár nem érhető el) az adatbázisban lévő adatokból is feltölthető.</span><span class="sxs-lookup"><span data-stu-id="b1fca-254">The local cache can be populated using the data in either the shared cache, or in the database if the shared cache is unavailable.</span></span>

<span data-ttu-id="b1fca-255">Ennél a megközelítésnél körültekintő konfigurálásra van szükség annak elkerülésére, hogy a helyi gyorsítótár túlságosan elavulttá váljon a megosztott gyorsítótárhoz képest,</span><span class="sxs-lookup"><span data-stu-id="b1fca-255">This approach requires careful configuration to prevent the local cache from becoming too stale with respect to the shared cache.</span></span> <span data-ttu-id="b1fca-256">de a helyi gyorsítótár megfelelő pufferként működhet, ha a megosztott gyorsítótár nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="b1fca-256">However, the local cache acts as a buffer if the shared cache is unreachable.</span></span> <span data-ttu-id="b1fca-257">Ez a struktúra látható a 3. ábrán.</span><span class="sxs-lookup"><span data-stu-id="b1fca-257">Figure 3 shows this structure.</span></span>

![Megosztott gyorsítótár egy helyi, privát gyorsítótár használata](./images/caching/Caching3.png)

<span data-ttu-id="b1fca-259">*3. ábra: Egy helyi, privát gyorsítótár használata egy megosztott gyorsítótárban.*</span><span class="sxs-lookup"><span data-stu-id="b1fca-259">*Figure 3: Using a local private cache with a shared cache.*</span></span>

<span data-ttu-id="b1fca-260">A viszonylag hosszú élettartamú adatokat tartalmazó, nagy méretű gyorsítótárak támogatása érdekében egyes gyorsítótár-szolgáltatások biztosítják a magas rendelkezésre állás lehetőségét, amely automatikus feladatátvételt hajt végre, ha a gyorsítótár nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="b1fca-260">To support large caches that hold relatively long-lived data, some cache services provide a high-availability option that implements automatic failover if the cache becomes unavailable.</span></span> <span data-ttu-id="b1fca-261">Ez a megközelítés általában magában foglalja az elsődleges gyorsítótár-kiszolgálón tárolt gyorsítótárazott adatok másodlagos gyorsítótár-kiszolgálóra történő replikációját, és ha az elsődleges kiszolgáló meghibásodik, vagy ha a kapcsolat megszakad, akkor a rendszer a másodlagos kiszolgáló használatára vált.</span><span class="sxs-lookup"><span data-stu-id="b1fca-261">This approach typically involves replicating the cached data that's stored on a primary cache server to a secondary cache server, and switching to the secondary server if the primary server fails or connectivity is lost.</span></span>

<span data-ttu-id="b1fca-262">A több célhelyre való írás okozta késleltetés csökkentése érdekében a másodlagos kiszolgálóra történő replikáció aszinkron módon is megvalósítható. Ilyenkor a rendszer az adatokat az elsődleges kiszolgáló gyorsítótárába írja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-262">To reduce the latency that's associated with writing to multiple destinations, the replication to the secondary server might occur asynchronously when data is written to the cache on the primary server.</span></span> <span data-ttu-id="b1fca-263">Ez a megközelítés annak lehetőségét, hogy meghibásodás esetén egyes gyorsítótárazott adatok elveszhetnek, de az időarány, amíg az adatok kis méretűnek kell lenniük a gyorsítótár teljes mérete képest vezet.</span><span class="sxs-lookup"><span data-stu-id="b1fca-263">This approach leads to the possibility that some cached information might be lost in the event of a failure, but the proportion of this data shuld be small compared to the overall size of the cache.</span></span>

<span data-ttu-id="b1fca-264">Ha a megosztott gyorsítótár mérete nagy, akkor előnyös lehet a gyorsítótárban tárolt adatok csomópontokra történő particionálása a versengés kialakulási esélyének csökkentése és a méretezhetőség javítása érdekében.</span><span class="sxs-lookup"><span data-stu-id="b1fca-264">If a shared cache is large, it might be beneficial to partition the cached data across nodes to reduce the chances of contention and improve scalability.</span></span> <span data-ttu-id="b1fca-265">Sok megosztott gyorsítótár támogatja a csomópontok dinamikus hozzáadását (és eltávolítását), valamint az adatok újraegyensúlyozását a partíciók között.</span><span class="sxs-lookup"><span data-stu-id="b1fca-265">Many shared caches support the ability to dynamically add (and remove) nodes and rebalance the data across partitions.</span></span> <span data-ttu-id="b1fca-266">Ez a megközelítés magában foglalhatja a fürtözést is, amikor a csomópontgyűjtemény az ügyfélalkalmazások számára egyetlen osztatlan gyorsítótárként jelenik meg.</span><span class="sxs-lookup"><span data-stu-id="b1fca-266">This approach might involve clustering, in which the collection of nodes is presented to client applications as a seamless, single cache.</span></span> <span data-ttu-id="b1fca-267">A rendszeren belül azonban az adatok egy előre megadott elosztási stratégia szerint vannak szétosztva a csomópontok között, így egyenlítve ki a terhelést.</span><span class="sxs-lookup"><span data-stu-id="b1fca-267">Internally, however, the data is dispersed between nodes following a predefined distribution strategy that balances the load evenly.</span></span> <span data-ttu-id="b1fca-268">További információ a lehetséges particionálási módszerekről: [Adatparticionálási útmutató](https://msdn.microsoft.com/library/dn589795.aspx).</span><span class="sxs-lookup"><span data-stu-id="b1fca-268">For more information about possible partitioning strategies, see [Data partitioning guidance](https://msdn.microsoft.com/library/dn589795.aspx).</span></span>

<span data-ttu-id="b1fca-269">A fürtözéssel a gyorsítótár rendelkezésre állása is megnövelhető.</span><span class="sxs-lookup"><span data-stu-id="b1fca-269">Clustering can also increase the availability of the cache.</span></span> <span data-ttu-id="b1fca-270">Ha egy csomópont meghibásodik, a gyorsítótár fennmaradó része továbbra is elérhető marad.</span><span class="sxs-lookup"><span data-stu-id="b1fca-270">If a node fails, the remainder of the cache is still accessible.</span></span> <span data-ttu-id="b1fca-271">A fürtözést gyakran használják a replikációval és a feladatátvétellel együtt.</span><span class="sxs-lookup"><span data-stu-id="b1fca-271">Clustering is frequently used in conjunction with replication and failover.</span></span> <span data-ttu-id="b1fca-272">Az egyes csomópontok replikálhatók, és a replika a csomópont meghibásodásakor gyorsan online állapotba helyezhető.</span><span class="sxs-lookup"><span data-stu-id="b1fca-272">Each node can be replicated, and the replica can be quickly brought online if the node fails.</span></span>

<span data-ttu-id="b1fca-273">Az olvasási és írási műveletek többsége nagy valószínűséggel egyetlen adatértéket vagy objektumot tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="b1fca-273">Many read and write operations are likely to involve single data values or objects.</span></span> <span data-ttu-id="b1fca-274">Esetenként azonban szükség lehet nagy adatmennyiségek gyors tárolására vagy lekérdezésére.</span><span class="sxs-lookup"><span data-stu-id="b1fca-274">However, at times it might be necessary to store or retrieve large volumes of data quickly.</span></span> <span data-ttu-id="b1fca-275">A gyorsítótár-áttöltés például több száz vagy ezer elem gyorsítótárba írásával is járhat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-275">For example, seeding a cache could involve writing hundreds or thousands of items to the cache.</span></span> <span data-ttu-id="b1fca-276">Előfordulhat, hogy egy alkalmazásnak egy adott kérelem részeként nagy mennyiségű kapcsolódó elemet is le kell kérnie a gyorsítótárból.</span><span class="sxs-lookup"><span data-stu-id="b1fca-276">An application might also need to retrieve a large number of related items from the cache as part of the same request.</span></span>

<span data-ttu-id="b1fca-277">Számos nagy méretű gyorsítótár biztosít kötegműveleteket erre a célra.</span><span class="sxs-lookup"><span data-stu-id="b1fca-277">Many large-scale caches provide batch operations for these purposes.</span></span> <span data-ttu-id="b1fca-278">Az ilyen műveletekkel az ügyfélalkalmazások nagy mennyiségű tételt csomagolhatnak össze egyetlen kérelemmé, így csökkenthető a sok kisebb kérelem végrehajtásával járó többletterhelés.</span><span class="sxs-lookup"><span data-stu-id="b1fca-278">This enables a client application to package up a large volume of items into a single request and reduces the overhead that's associated with performing a large number of small requests.</span></span>

## <a name="caching-and-eventual-consistency"></a><span data-ttu-id="b1fca-279">Gyorsítótárazás és végleges konzisztencia</span><span class="sxs-lookup"><span data-stu-id="b1fca-279">Caching and eventual consistency</span></span>

<span data-ttu-id="b1fca-280">Ahhoz, hogy a gyorsítótár-feltöltési minta működni tudjon, a gyorsítótárat feltöltő alkalmazáspéldánynak hozzáféréssel kell rendelkeznie az adatok legfrissebb és konzisztens verzióihoz.</span><span class="sxs-lookup"><span data-stu-id="b1fca-280">For the cache-aside pattern to work, the instance of the application that populates the cache must have access to the most recent and consistent version of the data.</span></span> <span data-ttu-id="b1fca-281">A végleges konzisztenciát megvalósító rendszerekben (például egy replikált adattárban) ez nem feltétlenül biztosítható.</span><span class="sxs-lookup"><span data-stu-id="b1fca-281">In a system that implements eventual consistency (such as a replicated data store) this might not be the case.</span></span>

<span data-ttu-id="b1fca-282">Egy alkalmazás egyik példánya módosíthat egy adatelemet, amely érvénytelenítheti az adott elem gyorsítótárazott verzióját.</span><span class="sxs-lookup"><span data-stu-id="b1fca-282">One instance of an application could modify a data item and invalidate the cached version of that item.</span></span> <span data-ttu-id="b1fca-283">Az alkalmazás egy másik példánya megpróbálhatja ezt az elemet kiolvasni egy gyorsítótárból, ami nem fog sikerülni, így az adatokat az adattárból olvassa ki, és hozzáadja a gyorsítótárhoz.</span><span class="sxs-lookup"><span data-stu-id="b1fca-283">Another instance of the application might attempt to read this item from a cache, which causes a cache-miss, so it reads the data from the data store and adds it to the cache.</span></span> <span data-ttu-id="b1fca-284">Ha azonban az adattár nem lett teljes mértékben szinkronizálva a többi replikával, akkor megtörténhet, hogy az alkalmazáspéldány a régi értéket olvassa ki, és azt tölti fel a gyorsítótárba.</span><span class="sxs-lookup"><span data-stu-id="b1fca-284">However, if the data store has not been fully synchronized with the other replicas, the application instance could read and populate the cache with the old value.</span></span>

<span data-ttu-id="b1fca-285">Az adatkonzisztencia kezelésére vonatkozó további információkért lásd az [adatkonzisztencia ismertetését](https://msdn.microsoft.com/library/dn589800.aspx).</span><span class="sxs-lookup"><span data-stu-id="b1fca-285">For more information about handling data consistency, see the [Data consistency primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

### <a name="protect-cached-data"></a><span data-ttu-id="b1fca-286">A gyorsítótárazott adatok védelme</span><span class="sxs-lookup"><span data-stu-id="b1fca-286">Protect cached data</span></span>

<span data-ttu-id="b1fca-287">A használt gyorsítótár-szolgáltatástól függetlenül mindig át kell gondolni, hogyan védheti meg a gyorsítótárban tárolt adatokat az illetéktelen hozzáféréstől.</span><span class="sxs-lookup"><span data-stu-id="b1fca-287">Irrespective of the cache service you use, consider how to protect the data that's held in the cache from unauthorized access.</span></span> <span data-ttu-id="b1fca-288">A következő két fő területtel kell foglalkoznunk:</span><span class="sxs-lookup"><span data-stu-id="b1fca-288">There are two main concerns:</span></span>

- <span data-ttu-id="b1fca-289">A gyorsítótárban lévő adatok adatvédelme.</span><span class="sxs-lookup"><span data-stu-id="b1fca-289">The privacy of the data in the cache.</span></span>
- <span data-ttu-id="b1fca-290">Adatvédelem a gyorsítótár és a gyorsítótárat használó alkalmazás közötti adatátvitel során.</span><span class="sxs-lookup"><span data-stu-id="b1fca-290">The privacy of data as it flows between the cache and the application that's using the cache.</span></span>

<span data-ttu-id="b1fca-291">A gyorsítótárban lévő adatok védelme érdekében a gyorsítótár-szolgáltatás olyan hitelesítési mechanizmust alkalmazhat, amely a következők meghatározását követeli meg az alkalmazásoktól:</span><span class="sxs-lookup"><span data-stu-id="b1fca-291">To protect data in the cache, the cache service might implement an authentication mechanism that requires that applications specify the following:</span></span>

- <span data-ttu-id="b1fca-292">Azon identitások, amelyek hozzáférhetnek a gyorsítótárban lévő adatokhoz.</span><span class="sxs-lookup"><span data-stu-id="b1fca-292">Which identities can access data in the cache.</span></span>
- <span data-ttu-id="b1fca-293">Azon (olvasási és írási) műveletek, amelyeket az identitások jogosultak elvégezni.</span><span class="sxs-lookup"><span data-stu-id="b1fca-293">Which operations (read and write) that these identities are allowed to perform.</span></span>

<span data-ttu-id="b1fca-294">Az adatok olvasásához és írásához kapcsolódó terhelés csökkentése érdekében az identitás a gyorsítótárban lévő összes adatot felhasználhatja, miután írási és/vagy olvasási hozzáférést kapott a gyorsítótárhoz.</span><span class="sxs-lookup"><span data-stu-id="b1fca-294">To reduce overhead that's associated with reading and writing data, after an identity has been granted write and/or read access to the cache, that identity can use any data in the cache.</span></span>

<span data-ttu-id="b1fca-295">Ha korlátozni kell a gyorsítótárazott adatok részhalmazainak hozzáférését, a következők szerint járhat el:</span><span class="sxs-lookup"><span data-stu-id="b1fca-295">If you need to restrict access to subsets of the cached data, you can do one of the following:</span></span>

- <span data-ttu-id="b1fca-296">Ossza fel a gyorsítótárat partíciókra (különböző gyorsítótár-kiszolgálók használatával), és csak azon partíciókhoz biztosítson hozzáférést, amelyeket az identitások használhatnak.</span><span class="sxs-lookup"><span data-stu-id="b1fca-296">Split the cache into partitions (by using different cache servers) and only grant access to identities for the partitions that they should be allowed to use.</span></span>
- <span data-ttu-id="b1fca-297">Más-más kulcsok használatával titkosítsa az egyes részhalmazok adatait, és a titkosítási kulcsokat csak azoknak az identitásoknak adja meg, amelyeknek mindegyik részhalmazhoz hozzá kell férniük.</span><span class="sxs-lookup"><span data-stu-id="b1fca-297">Encrypt the data in each subset by using different keys, and provide the encryption keys only to identities that should have access to each subset.</span></span> <span data-ttu-id="b1fca-298">Az ügyfélalkalmazások ugyan továbbra is képesek lehetnek lekérni a gyorsítótár bármely adatát, de csak azokat tudják visszafejteni, amelyek titkosítási kulcsaival rendelkeznek.</span><span class="sxs-lookup"><span data-stu-id="b1fca-298">A client application might still be able to retrieve all of the data in the cache, but it will only be able to decrypt the data for which it has the keys.</span></span>

<span data-ttu-id="b1fca-299">Biztosítani kell ezen kívül a gyorsítótár bejövő és kimenő adatainak védelmét is.</span><span class="sxs-lookup"><span data-stu-id="b1fca-299">You must also protect the data as it flows in and out of the cache.</span></span> <span data-ttu-id="b1fca-300">Ehhez a hálózati infrastruktúra által biztosított azon biztonsági szolgáltatásokra fog támaszkodni, amelyeket az ügyfélalkalmazások a gyorsítótárhoz történő kapcsolódáshoz használnak.</span><span class="sxs-lookup"><span data-stu-id="b1fca-300">To do this, you depend on the security features provided by the network infrastructure that client applications use to connect to the cache.</span></span> <span data-ttu-id="b1fca-301">Ha a gyorsítótár megvalósítása az ügyfélalkalmazásokat üzemeltető az ugyanazon szervezeten belüli helyszíni kiszolgáló használata, majd maga a hálózat elkülönítése nem feltétlenül igényelnek, hogy további lépéseket.</span><span class="sxs-lookup"><span data-stu-id="b1fca-301">If the cache is implemented using an on-site server within the same organization that hosts the client applications, then the isolation of the network itself might not require you to take additional steps.</span></span> <span data-ttu-id="b1fca-302">Ha a távoli gyorsítótár nyilvános hálózaton (például az interneten) történő használatához TCP- vagy HTTP-kapcsolat szükséges, fontolja meg az SSL alkalmazását.</span><span class="sxs-lookup"><span data-stu-id="b1fca-302">If the cache is located remotely and requires a TCP or HTTP connection over a public network (such as the Internet), consider implementing SSL.</span></span>

## <a name="considerations-for-implementing-caching-in-azure"></a><span data-ttu-id="b1fca-303">Az Azure gyorsítótár megvalósítási szempontjai</span><span class="sxs-lookup"><span data-stu-id="b1fca-303">Considerations for implementing caching in Azure</span></span>

<span data-ttu-id="b1fca-304">Az [Azure Redis Cache](/azure/redis-cache/) egy nyílt forráskódú Redis-gyorsítótár, amely szolgáltatásként fut egy Azure-adatközpontban.</span><span class="sxs-lookup"><span data-stu-id="b1fca-304">[Azure Redis Cache](/azure/redis-cache/) is an implementation of the open source Redis cache that runs as a service in an Azure datacenter.</span></span> <span data-ttu-id="b1fca-305">Olyan gyorsítótárazási szolgáltatást biztosít, amely bármely Azure-alkalmazásból elérhető, függetlenül attól, hogy az alkalmazás felhőszolgáltatásként, webhelyként vagy egy Azure-beli virtuális gépen belül lett létrehozva.</span><span class="sxs-lookup"><span data-stu-id="b1fca-305">It provides a caching service that can be accessed from any Azure application, whether the application is implemented as a cloud service, a website, or inside an Azure virtual machine.</span></span> <span data-ttu-id="b1fca-306">A gyorsítótáron olyan ügyfélalkalmazások osztozhatnak, amelyek rendelkeznek a megfelelő hozzáférési kulccsal.</span><span class="sxs-lookup"><span data-stu-id="b1fca-306">Caches can be shared by client applications that have the appropriate access key.</span></span>

<span data-ttu-id="b1fca-307">Az Azure Redis Cache egy nagy teljesítményű gyorsítótárazási megoldás, amely rendelkezésre állási, méretezhetőségi és biztonsági szolgáltatásokat nyújt.</span><span class="sxs-lookup"><span data-stu-id="b1fca-307">Azure Redis Cache is a high-performance caching solution that provides availability, scalability and security.</span></span> <span data-ttu-id="b1fca-308">Általában egy vagy több dedikált gépen elosztott szolgáltatásként fut.</span><span class="sxs-lookup"><span data-stu-id="b1fca-308">It typically runs as a service spread across one or more dedicated machines.</span></span> <span data-ttu-id="b1fca-309">A gyors hozzáférés biztosításához megpróbálja a lehető legtöbb információt eltárolni a memóriában.</span><span class="sxs-lookup"><span data-stu-id="b1fca-309">It attempts to store as much information as it can in memory to ensure fast access.</span></span> <span data-ttu-id="b1fca-310">Az architektúrának az a célja, hogy kevesebb lassú I/O műveletet kelljen végrehajtani, így alacsonyabb legyen a késleltetés, és nagyobb a teljesítmény.</span><span class="sxs-lookup"><span data-stu-id="b1fca-310">This architecture is intended to provide low latency and high throughput by reducing the need to perform slow I/O operations.</span></span>

<span data-ttu-id="b1fca-311">Az Azure Redis Cache az ügyfélalkalmazások által használt sokféle API-val kompatibilis.</span><span class="sxs-lookup"><span data-stu-id="b1fca-311">Azure Redis Cache is compatible with many of the various APIs that are used by client applications.</span></span> <span data-ttu-id="b1fca-312">Ha már rendelkezik olyan alkalmazásokkal, amelyek helyileg futtatják az Azure Redis Cache-t, akkor az Azure Redis Cache gyors migrálási útvonalat biztosít a felhőben történő gyorsítótárazáshoz.</span><span class="sxs-lookup"><span data-stu-id="b1fca-312">If you have existing applications that already use Azure Redis Cache running on-premises, the Azure Redis Cache provides a quick migration path to caching in the cloud.</span></span>

### <a name="features-of-redis"></a><span data-ttu-id="b1fca-313">A Redis jellemzői</span><span class="sxs-lookup"><span data-stu-id="b1fca-313">Features of Redis</span></span>

<span data-ttu-id="b1fca-314">A Redis több, mint egy egyszerű gyorsítótár-kiszolgáló.</span><span class="sxs-lookup"><span data-stu-id="b1fca-314">Redis is more than a simple cache server.</span></span> <span data-ttu-id="b1fca-315">Átfogó parancskészlettel ellátott, elosztott, memóriabeli adatbázisról van szó, amely számos gyakori alkalmazási helyzetet támogat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-315">It provides a distributed in-memory database with an extensive command set that supports many common scenarios.</span></span> <span data-ttu-id="b1fca-316">Ezekről az ebben a dokumentumban az a szakasz Redis-gyorsítótárazás használata című szakaszát.</span><span class="sxs-lookup"><span data-stu-id="b1fca-316">These are described later in this document, in the section Using Redis caching.</span></span> <span data-ttu-id="b1fca-317">Ez a szakasz a Redis néhány fő funkcióját foglalja össze.</span><span class="sxs-lookup"><span data-stu-id="b1fca-317">This section summarizes some of the key features that Redis provides.</span></span>

### <a name="redis-as-an-in-memory-database"></a><span data-ttu-id="b1fca-318">A Redis használata memóriabeli adatbázisként</span><span class="sxs-lookup"><span data-stu-id="b1fca-318">Redis as an in-memory database</span></span>

<span data-ttu-id="b1fca-319">A Redis az olvasási és az írási műveleteket is támogatja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-319">Redis supports both read and write operations.</span></span> <span data-ttu-id="b1fca-320">Redis írási vagy egy helyi pillanatképfájlba vagy egy csak hozzáfűzéssel bővíthető naplófájlba rendszeres időközönként tárolja a rendszer hibája biztosítható.</span><span class="sxs-lookup"><span data-stu-id="b1fca-320">In Redis, writes can be protected from system failure either by being stored periodically in a local snapshot file or in an append-only log file.</span></span> <span data-ttu-id="b1fca-321">Ez nem a helyzet a legtöbb gyorsítótárban (amelyeket kell adattárolóknak kell tekinteni).</span><span class="sxs-lookup"><span data-stu-id="b1fca-321">This is not the case in many caches (which should be considered transitory data stores).</span></span>

<span data-ttu-id="b1fca-322">Az összes írási művelet aszinkron módon lesz elvégezve, és nem akadályozzák az ügyfeleket az adatok írásában vagy olvasásában.</span><span class="sxs-lookup"><span data-stu-id="b1fca-322">All writes are asynchronous and do not block clients from reading and writing data.</span></span> <span data-ttu-id="b1fca-323">Amikor a Redis elindul, a pillanatkép- vagy naplófájlból olvassa ki az adatokat, és azokat használja a memórián belüli gyorsítótár létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="b1fca-323">When Redis starts running, it reads the data from the snapshot or log file and uses it to construct the in-memory cache.</span></span> <span data-ttu-id="b1fca-324">További információkat a Redis webhelyén elérhető, a [Redis adatmegőrzésével](https://redis.io/topics/persistence) foglalkozó témakörben talál.</span><span class="sxs-lookup"><span data-stu-id="b1fca-324">For more information, see [Redis persistence](https://redis.io/topics/persistence) on the Redis website.</span></span>

> [!NOTE]
> <span data-ttu-id="b1fca-325">A Redis nem garantálja, hogy egy katasztrofális hiba esetén az összes írási műveletet elmenti, de a legrosszabb esetben is csak néhány másodpercnyi adatmennyiséget veszíthet el.</span><span class="sxs-lookup"><span data-stu-id="b1fca-325">Redis does not guarantee that all writes will be saved in the event of a catastrophic failure, but at worst you might lose only a few seconds worth of data.</span></span> <span data-ttu-id="b1fca-326">Ne felejtse el, hogy a gyorsítótár nem kezelendő mérvadó adatforrásként, és a gyorsítótárat használó alkalmazások felelősek azért, hogy a kritikus fontosságú adatokat sikeresen elmentsék a megfelelő adattárba.</span><span class="sxs-lookup"><span data-stu-id="b1fca-326">Remember that a cache is not intended to act as an authoritative data source, and it is the responsibility of the applications using the cache to ensure that critical data is saved successfully to an appropriate data store.</span></span> <span data-ttu-id="b1fca-327">További információkért lásd: a [gyorsítótár-feltöltési minta](../patterns/cache-aside.md).</span><span class="sxs-lookup"><span data-stu-id="b1fca-327">For more information, see the [Cache-aside pattern](../patterns/cache-aside.md).</span></span>

#### <a name="redis-data-types"></a><span data-ttu-id="b1fca-328">Redis-adattípusok</span><span class="sxs-lookup"><span data-stu-id="b1fca-328">Redis data types</span></span>

<span data-ttu-id="b1fca-329">A Redis egy olyan kulcs-érték tároló, ahol az értékek egyszerű típusokat vagy összetett adatstruktúrákat (például kivonatokat, listákat és készleteket) tartalmazhatnak.</span><span class="sxs-lookup"><span data-stu-id="b1fca-329">Redis is a key-value store, where values can contain simple types or complex data structures such as hashes, lists, and sets.</span></span> <span data-ttu-id="b1fca-330">A Redis többféle atomi művelet elvégzését teszi lehetővé ezeken az adattípusokon.</span><span class="sxs-lookup"><span data-stu-id="b1fca-330">It supports a set of atomic operations on these data types.</span></span> <span data-ttu-id="b1fca-331">A kulcsok lehetnek állandóak vagy korlátozott időtartamúak, amelynek lejártakor a kulcs és annak értéke automatikusan el lesz távolítva a gyorsítótárból.</span><span class="sxs-lookup"><span data-stu-id="b1fca-331">Keys can be permanent or tagged with a limited time-to-live, at which point the key and its corresponding value are automatically removed from the cache.</span></span> <span data-ttu-id="b1fca-332">A Redis-kulcsokról és -értékekről további információkat a Redis webhelyén elérhető, [a Redis adattípusait és absztrakt entitásait bemutató](https://redis.io/topics/data-types-intro) témakörben talál.</span><span class="sxs-lookup"><span data-stu-id="b1fca-332">For more information about Redis keys and values, visit the page [An introduction to Redis data types and abstractions](https://redis.io/topics/data-types-intro) on the Redis website.</span></span>

#### <a name="redis-replication-and-clustering"></a><span data-ttu-id="b1fca-333">Redis-replikáció és -fürtözés</span><span class="sxs-lookup"><span data-stu-id="b1fca-333">Redis replication and clustering</span></span>

<span data-ttu-id="b1fca-334">A Redis támogatja a fölé-/alárendelt típusú replikációt a rendelkezésre állás biztosítása és az átviteli sebesség szinten tartása érdekében.</span><span class="sxs-lookup"><span data-stu-id="b1fca-334">Redis supports master/subordinate replication to help ensure availability and maintain throughput.</span></span> <span data-ttu-id="b1fca-335">A Redis-főcsomópontokra irányuló írási műveletek egy vagy több alárendelt csomópontra replikálhatók.</span><span class="sxs-lookup"><span data-stu-id="b1fca-335">Write operations to a Redis master node are replicated to one or more subordinate nodes.</span></span> <span data-ttu-id="b1fca-336">Az olvasási műveleteket a főcsomópont és az alárendelt csomópontok is kiszolgálhatják.</span><span class="sxs-lookup"><span data-stu-id="b1fca-336">Read operations can be served by the master or any of the subordinates.</span></span>

<span data-ttu-id="b1fca-337">Ha hálózatszakadás következik be, az alárendelt csomópontok továbbra is szolgáltathatnak adatokat, majd a kapcsolat helyreállásakor a rendszer transzparens módon újraszinkronizálja azokat a főcsomóponttal.</span><span class="sxs-lookup"><span data-stu-id="b1fca-337">In the event of a network partition, subordinates can continue to serve data and then transparently resynchronize with the master when the connection is reestablished.</span></span> <span data-ttu-id="b1fca-338">További részleteket a Redis webhelyén elérhető, a [replikációval](https://redis.io/topics/replication) foglalkozó oldalon talál.</span><span class="sxs-lookup"><span data-stu-id="b1fca-338">For further details, visit the [Replication](https://redis.io/topics/replication) page on the Redis website.</span></span>

<span data-ttu-id="b1fca-339">A redis fürtözésre is lehetőséget biztosít, amely lehetővé teszi, hogy transzparens módon adatok particionálása történő particionálását a kiszolgálók között, és a terhelés elosztását.</span><span class="sxs-lookup"><span data-stu-id="b1fca-339">Redis also provides clustering, which enables you to transparently partition data into shards across servers and spread the load.</span></span> <span data-ttu-id="b1fca-340">Ez a funkció javítja a méretezhetőséget, mivel a gyorsítótár méretének növekedésével új Redis-kiszolgálókat lehet hozzáadni, az adatok pedig újraparticionálhatók.</span><span class="sxs-lookup"><span data-stu-id="b1fca-340">This feature improves scalability, because new Redis servers can be added and the data repartitioned as the size of the cache increases.</span></span>

<span data-ttu-id="b1fca-341">A fürt mindegyik kiszolgálója replikálható fölé- vagy alárendelt típusú replikációval.</span><span class="sxs-lookup"><span data-stu-id="b1fca-341">Furthermore, each server in the cluster can be replicated by using master/subordinate replication.</span></span> <span data-ttu-id="b1fca-342">Ez mindegyik fürtcsomópont rendelkezésre állását biztosítja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-342">This ensures availability across each node in the cluster.</span></span> <span data-ttu-id="b1fca-343">A fürtözésről és a horizontális skálázásról további információkat a Redis webhelyén elérhető, a [Redis-fürt oktatóanyagát](https://redis.io/topics/cluster-tutorial) tartalmazó oldalon talál.</span><span class="sxs-lookup"><span data-stu-id="b1fca-343">For more information about clustering and sharding, visit the [Redis cluster tutorial page](https://redis.io/topics/cluster-tutorial) on the Redis website.</span></span>

### <a name="redis-memory-use"></a><span data-ttu-id="b1fca-344">A Redis-memória használata</span><span class="sxs-lookup"><span data-stu-id="b1fca-344">Redis memory use</span></span>

<span data-ttu-id="b1fca-345">A Redis-gyorsítótár mérete véges, és a gazdagépen rendelkezésre álló erőforrásoktól függ.</span><span class="sxs-lookup"><span data-stu-id="b1fca-345">A Redis cache has a finite size that depends on the resources available on the host computer.</span></span> <span data-ttu-id="b1fca-346">A Redis-kiszolgálók konfigurálásakor megadhatja az általuk maximálisan felhasználható memória mennyiségét.</span><span class="sxs-lookup"><span data-stu-id="b1fca-346">When you configure a Redis server, you can specify the maximum amount of memory it can use.</span></span> <span data-ttu-id="b1fca-347">Egy lejárati idővel ellátott kulcsot is a beállíthat a Redis-gyorsítótárban, amely a lejáratát követően automatikusan eltávolítódik a gyorsítótárból.</span><span class="sxs-lookup"><span data-stu-id="b1fca-347">You can also configure a key in a Redis cache to have an expiration time, after which it is automatically removed from the cache.</span></span> <span data-ttu-id="b1fca-348">Ezzel a funkcióval megakadályozható, hogy a memórián belüli gyorsítótár régi vagy elavult adatokkal legyen feltöltve.</span><span class="sxs-lookup"><span data-stu-id="b1fca-348">This feature can help prevent the in-memory cache from filling with old or stale data.</span></span>

<span data-ttu-id="b1fca-349">Ahogy a memória megtelik, a Redis adott szabályzatok alapján automatikusan ki tudja üríteni a kulcsokat és azok értékeit.</span><span class="sxs-lookup"><span data-stu-id="b1fca-349">As memory fills up, Redis can automatically evict keys and their values by following a number of policies.</span></span> <span data-ttu-id="b1fca-350">Az alapértelmezett szabályzat az LRU (least recently used, legrégebben használt), de más szabályzatokat is kiválaszthat, így például a kulcsok véletlenszerű kiürítését, vagy a kiürítés kikapcsolását (ekkor nem lehet új elemeket hozzáadni a megtelt gyorsítótárhoz).</span><span class="sxs-lookup"><span data-stu-id="b1fca-350">The default is LRU (least recently used), but you can also select other policies such as evicting keys at random or turning off eviction altogether (in which, case attempts to add items to the cache fail if it is full).</span></span> <span data-ttu-id="b1fca-351">További információkat [a Redis LRU-gyorsítótárként történő használatával](https://redis.io/topics/lru-cache) foglalkozó témakörben talál.</span><span class="sxs-lookup"><span data-stu-id="b1fca-351">The page [Using Redis as an LRU cache](https://redis.io/topics/lru-cache) provides more information.</span></span>

### <a name="redis-transactions-and-batches"></a><span data-ttu-id="b1fca-352">Redis-tranzakciók és -kötegek</span><span class="sxs-lookup"><span data-stu-id="b1fca-352">Redis transactions and batches</span></span>

<span data-ttu-id="b1fca-353">A Redis lehetővé teszi az ügyfélalkalmazások számára, hogy olyan műveletsort küldhessenek el, amelyek atomi tranzakciókként adatokat olvasnak és írnak a gyorsítótárba.</span><span class="sxs-lookup"><span data-stu-id="b1fca-353">Redis enables a client application to submit a series of operations that read and write data in the cache as an atomic transaction.</span></span> <span data-ttu-id="b1fca-354">A tranzakció összes parancsa garantáltan egymás után fog lefutni, a többi párhuzamos ügyfél által kiadott parancsok beékelődése nélkül.</span><span class="sxs-lookup"><span data-stu-id="b1fca-354">All the commands in the transaction are guaranteed to run sequentially, and no commands issued by other concurrent clients will be interwoven between them.</span></span>

<span data-ttu-id="b1fca-355">Ezek azonban nem valódi tranzakciók, hiszen a végrehajtásukért egy relációs adatbázis felel.</span><span class="sxs-lookup"><span data-stu-id="b1fca-355">However, these are not true transactions as a relational database would perform them.</span></span> <span data-ttu-id="b1fca-356">A tranzakciók feldolgozása két szakaszból áll: az első a parancsok üzenetsorba állítása, a második pedig a parancsok futtatása.</span><span class="sxs-lookup"><span data-stu-id="b1fca-356">Transaction processing consists of two stages--the first is when the commands are queued, and the second is when the commands are run.</span></span> <span data-ttu-id="b1fca-357">A parancsok sorkezelési szakaszában az ügyfél beküldi azokat a parancsokat, amelyekből a tranzakció áll.</span><span class="sxs-lookup"><span data-stu-id="b1fca-357">During the command queuing stage, the commands that comprise the transaction are submitted by the client.</span></span> <span data-ttu-id="b1fca-358">Ha ekkor valamilyen hiba történik (például szintaktikai hiba lép fel vagy helytelen számú paraméter van megadva), akkor a Redis megtagadja a teljes tranzakció feldolgozását, és elveti azt.</span><span class="sxs-lookup"><span data-stu-id="b1fca-358">If some sort of error occurs at this point (such as a syntax error, or the wrong number of parameters) then Redis refuses to process the entire transaction and discards it.</span></span>

<span data-ttu-id="b1fca-359">A futtatási szakaszban a Redis egymás után végrehajtja a sorba állított parancsokat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-359">During the run phase, Redis performs each queued command in sequence.</span></span> <span data-ttu-id="b1fca-360">Ha ebben a fázisban egy parancsot nem lehet végrehajtani, a Redis a sorban következő parancsra vált, és nem állítja vissza a már futtatott parancsok eredményét.</span><span class="sxs-lookup"><span data-stu-id="b1fca-360">If a command fails during this phase, Redis continues with the next queued command and does not roll back the effects of any commands that have already been run.</span></span> <span data-ttu-id="b1fca-361">Ezzel az egyszerűsített tranzakciós módszerrel szinten tartható a teljesítmény, és elkerülhetők a versengés okozta teljesítményproblémák.</span><span class="sxs-lookup"><span data-stu-id="b1fca-361">This simplified form of transaction helps to maintain performance and avoid performance problems that are caused by contention.</span></span>

<span data-ttu-id="b1fca-362">A Redis egyfajta optimista zárolást valósít meg a konzisztencia megőrzése érdekében.</span><span class="sxs-lookup"><span data-stu-id="b1fca-362">Redis does implement a form of optimistic locking to assist in maintaining consistency.</span></span> <span data-ttu-id="b1fca-363">A Redis használatával történő tranzakció-végrehajtásról és zárolásról további információkat a Redis webhelyén elérhető, a [tranzakciókat ismertető oldal](https://redis.io/topics/transactions) tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="b1fca-363">For detailed information about transactions and locking with Redis, visit the [Transactions page](https://redis.io/topics/transactions) on the Redis website.</span></span>

<span data-ttu-id="b1fca-364">A Redis a kérelmek nem tranzakciós célú kötegelését is támogatja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-364">Redis also supports non-transactional batching of requests.</span></span> <span data-ttu-id="b1fca-365">Az a Redis-protokoll, amellyel az ügyfelek parancsokat küldenek egy Redis-kiszolgálóra, lehetővé teszi az ügyfelek számára, hogy ugyanazon kérelem részeként egy egész műveletsort is elküldhessenek.</span><span class="sxs-lookup"><span data-stu-id="b1fca-365">The Redis protocol that clients use to send commands to a Redis server enables a client to send a series of operations as part of the same request.</span></span> <span data-ttu-id="b1fca-366">Ezzel csökkenthető a hálózat csomagtöredezettségének mértéke.</span><span class="sxs-lookup"><span data-stu-id="b1fca-366">This can help to reduce packet fragmentation on the network.</span></span> <span data-ttu-id="b1fca-367">A köteg feldolgozásakor a rendszer minden parancsot végrehajt.</span><span class="sxs-lookup"><span data-stu-id="b1fca-367">When the batch is processed, each command is performed.</span></span> <span data-ttu-id="b1fca-368">Ha a parancsok bármelyike helytelenül van megformázva, akkor az(ok)at a rendszer elutasítja (ami egy tranzakció esetén nem történik meg), a többi parancsot azonban végrehajtja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-368">If any of these commands are malformed, they will be rejected (which doesn't happen with a transaction), but the remaining commands will be performed.</span></span> <span data-ttu-id="b1fca-369">A kötegben lévő parancsok feldolgozási sorrendje nem garantálható.</span><span class="sxs-lookup"><span data-stu-id="b1fca-369">There is also no guarantee about the order in which the commands in the batch will be processed.</span></span>

### <a name="redis-security"></a><span data-ttu-id="b1fca-370">A Redis biztonsági funkciói</span><span class="sxs-lookup"><span data-stu-id="b1fca-370">Redis security</span></span>

<span data-ttu-id="b1fca-371">A Redis kizárólagos célja az adatokhoz való gyors hozzáférés biztosítása, és csak megbízható ügyfelek számára elérhető megbízható környezetben futtatható.</span><span class="sxs-lookup"><span data-stu-id="b1fca-371">Redis is focused purely on providing fast access to data, and is designed to run inside a trusted environment that can be accessed only by trusted clients.</span></span> <span data-ttu-id="b1fca-372">A Redis támogatja a jelszavas hitelesítésen alapuló, korlátozott biztonságot nyújtó modelleket.</span><span class="sxs-lookup"><span data-stu-id="b1fca-372">Redis supports a limited security model based on password authentication.</span></span> <span data-ttu-id="b1fca-373">(A hitelesítés teljesen el is hagyható, de ezt nem javasoljuk.)</span><span class="sxs-lookup"><span data-stu-id="b1fca-373">(It is possible to remove authentication completely, although we don't recommend this.)</span></span>

<span data-ttu-id="b1fca-374">Az összes hitelesített ügyfél ugyanazt a globális jelszót használja, és ugyanazokhoz az erőforrásokhoz fér hozzá.</span><span class="sxs-lookup"><span data-stu-id="b1fca-374">All authenticated clients share the same global password and have access to the same resources.</span></span> <span data-ttu-id="b1fca-375">Ha ennél átfogóbb bejelentkezési biztonsági megoldásra van szüksége, akkor létre kell hoznia egy saját biztonsági réteget a Redis-kiszolgáló előtt, és minden ügyfélkérelemnek ezen kell áthaladnia.</span><span class="sxs-lookup"><span data-stu-id="b1fca-375">If you need more comprehensive sign-in security, you must implement your own security layer in front of the Redis server, and all client requests should pass through this additional layer.</span></span> <span data-ttu-id="b1fca-376">Meg kell akadályozni, hogy a Redishez közvetlenül hozzáférhessenek nem megbízható vagy nem hitelesített ügyfelek.</span><span class="sxs-lookup"><span data-stu-id="b1fca-376">Redis should not be directly exposed to untrusted or unauthenticated clients.</span></span>

<span data-ttu-id="b1fca-377">A parancsok elérését a letiltásukkal vagy az átnevezésükkel korlátozhatja (és az új neveket csak az arra jogosult ügyfelek kapják meg).</span><span class="sxs-lookup"><span data-stu-id="b1fca-377">You can restrict access to commands by disabling them or renaming them (and by providing only privileged clients with the new names).</span></span>

<span data-ttu-id="b1fca-378">A Redis közvetlenül nem támogatja az adattitkosítás semmilyen formáját, így a teljes kódolást az ügyfélalkalmazásoknak kell elvégezniük.</span><span class="sxs-lookup"><span data-stu-id="b1fca-378">Redis does not directly support any form of data encryption, so all encoding must be performed by client applications.</span></span> <span data-ttu-id="b1fca-379">Ezenkívül a Redis nem biztosít semmiféle átviteli biztonsági megoldást sem.</span><span class="sxs-lookup"><span data-stu-id="b1fca-379">Additionally, Redis does not provide any form of transport security.</span></span> <span data-ttu-id="b1fca-380">Ha gondoskodnia kell az adatok védelméről a hálózati átvitel során, erre a célra SSL-proxy alkalmazását javasoljuk.</span><span class="sxs-lookup"><span data-stu-id="b1fca-380">If you need to protect data as it flows across the network, we recommend implementing an SSL proxy.</span></span>

<span data-ttu-id="b1fca-381">További információkat a Redis webhelyén elérhető, [a Redis biztonsági funkcióival foglalkozó](https://redis.io/topics/security) oldalon talál.</span><span class="sxs-lookup"><span data-stu-id="b1fca-381">For more information, visit the [Redis security](https://redis.io/topics/security) page on the Redis website.</span></span>

> [!NOTE]
> <span data-ttu-id="b1fca-382">Az Azure Redis Cache saját biztonsági réteget biztosít az ügyfelek csatlakozásához.</span><span class="sxs-lookup"><span data-stu-id="b1fca-382">Azure Redis Cache provides its own security layer through which clients connect.</span></span> <span data-ttu-id="b1fca-383">A Redis háttérkiszolgálói a nyilvános hálózaton nem érhetőek el.</span><span class="sxs-lookup"><span data-stu-id="b1fca-383">The underlying Redis servers are not exposed to the public network.</span></span>

### <a name="azure-redis-cache"></a><span data-ttu-id="b1fca-384">Azure Redis Cache</span><span class="sxs-lookup"><span data-stu-id="b1fca-384">Azure Redis cache</span></span>

<span data-ttu-id="b1fca-385">Az Azure Redis Cache az Azure-adatközpontokon üzemeltetett Redis-kiszolgálókhoz biztosít hozzáférést.</span><span class="sxs-lookup"><span data-stu-id="b1fca-385">Azure Redis Cache provides access to Redis servers that are hosted at an Azure datacenter.</span></span> <span data-ttu-id="b1fca-386">Az Azure Redis Cache hozzáférés-vezérlési és biztonsági előtérrendszerként funkcionál.</span><span class="sxs-lookup"><span data-stu-id="b1fca-386">It acts as a façade that provides access control and security.</span></span> <span data-ttu-id="b1fca-387">Telepíthet egy gyorsítótár az Azure portal használatával.</span><span class="sxs-lookup"><span data-stu-id="b1fca-387">You can provision a cache by using the Azure portal.</span></span>

<span data-ttu-id="b1fca-388">A portálon számos előre meghatározott konfiguráció érhető el.</span><span class="sxs-lookup"><span data-stu-id="b1fca-388">The portal provides a number of predefined configurations.</span></span> <span data-ttu-id="b1fca-389">Ilyen konfigurációra példa egy dedikált szolgáltatásként működő, 53 GB-os gyorsítótár, amely támogatja az SSL-kommunikációt (adatvédelmi célból) és a fölé/alárendelt típusú replikációt 99,9%-os rendelkezésre állást garantáló SLA-val, de a konfiguráció lehet akár egy replikáció nélküli, megosztott hardveren futó, 250 MB-os gyorsítótár is (garantált rendelkezésre állás nélkül).</span><span class="sxs-lookup"><span data-stu-id="b1fca-389">These range from a 53 GB cache running as a dedicated service that supports SSL communications (for privacy) and master/subordinate replication with an SLA of 99.9% availability, down to a 250 MB cache without replication (no availability guarantees) running on shared hardware.</span></span>

<span data-ttu-id="b1fca-390">Az Azure Portalon a gyorsítótár kiürítési szabályzatát is beállíthatja, és vezérelheti a gyorsítótárhoz való hozzáférést a felhasználók adott szerepkörökhöz történő hozzáadásával.</span><span class="sxs-lookup"><span data-stu-id="b1fca-390">Using the Azure portal, you can also configure the eviction policy of the cache, and control access to the cache by adding users to the roles provided.</span></span> <span data-ttu-id="b1fca-391">Ezek a tagok által elvégezhető műveleteket meghatározó szerepkörök a következők: tulajdonos, közreműködő és olvasó.</span><span class="sxs-lookup"><span data-stu-id="b1fca-391">These roles, which define the operations that members can perform, include Owner, Contributor, and Reader.</span></span> <span data-ttu-id="b1fca-392">A Tulajdonos szerepkör tagjai például teljes körű, a gyorsítótárra (beleértve a biztonsági megoldásokat) és annak tartalmára vonatkozó szabályozási jogosultsággal bírnak, a Közreműködő szerepkör tagjai olvasási és írási műveleteket végezhetnek a gyorsítótárban, az Olvasó szerepkör tagjai pedig csak adatokat kérhetnek le a gyorsítótárból.</span><span class="sxs-lookup"><span data-stu-id="b1fca-392">For example, members of the Owner role have complete control over the cache (including security) and its contents, members of the Contributor role can read and write information in the cache, and members of the Reader role can only retrieve data from the cache.</span></span>

<span data-ttu-id="b1fca-393">Az adminisztratív feladatok többségét az Azure Portalon kell végrehajtani.</span><span class="sxs-lookup"><span data-stu-id="b1fca-393">Most administrative tasks are performed through the Azure portal.</span></span> <span data-ttu-id="b1fca-394">Emiatt a Redis standard verziójában elérhető adminisztratív parancsok közül több nem áll rendelkezésre, így például a konfiguráció szoftveres módosításának, a Redis-kiszolgáló leállításának, további alárendelt elemek konfigurálásának vagy az adatok lemezre történő kényszerített mentésének lehetősége.</span><span class="sxs-lookup"><span data-stu-id="b1fca-394">For this reason, many of the administrative commands that are available in the standard version of Redis are not available, including the ability to modify the configuration programmatically, shut down the Redis server, configure additional subordinates, or forcibly save data to disk.</span></span>

<span data-ttu-id="b1fca-395">Az Azure Portal kényelmesen használható grafikus felülete lehetővé teszi a gyorsítótár teljesítményének monitorozását.</span><span class="sxs-lookup"><span data-stu-id="b1fca-395">The Azure portal includes a convenient graphical display that enables you to monitor the performance of the cache.</span></span> <span data-ttu-id="b1fca-396">Megtekinthető például a létrehozott kapcsolatok, a végrehajtott kérelmek, az olvasási és írási műveletek száma, valamint a gyorsítótár-találatok és -tévesztések aránya.</span><span class="sxs-lookup"><span data-stu-id="b1fca-396">For example, you can view the number of connections being made, the number of requests being performed, the volume of reads and writes, and the number of cache hits versus cache misses.</span></span> <span data-ttu-id="b1fca-397">Ezen információk alapján meghatározhatja a gyorsítótár hatékonyságát, és szükség esetén átválthat más konfigurációra, vagy módosíthatja a kiürítési szabályzatot.</span><span class="sxs-lookup"><span data-stu-id="b1fca-397">Using this information, you can determine the effectiveness of the cache and if necessary, switch to a different configuration or change the eviction policy.</span></span>

<span data-ttu-id="b1fca-398">Olyan riasztásokat is létrehozhat, amelyek e-mail-üzeneteket küldenek egy rendszergazdának, ha egy vagy több kritikus jelentőségű mérőszám értéke kívül esik a várható tartományon.</span><span class="sxs-lookup"><span data-stu-id="b1fca-398">Additionally, you can create alerts that send email messages to an administrator if one or more critical metrics fall outside of an expected range.</span></span> <span data-ttu-id="b1fca-399">Érdemes lehet riasztani a rendszergazdát például akkor, ha az elmúlt órában a gyorsítótár-tévesztések száma meghaladott egy adott értéket, mert ez azt jelentheti, hogy a gyorsítótár túl kicsi, vagy az adatok kiürítésére túl gyorsan kerül sor.</span><span class="sxs-lookup"><span data-stu-id="b1fca-399">For example, you might want to alert an administrator if the number of cache misses exceeds a specified value in the last hour, because it means the cache might be too small or data might be being evicted too quickly.</span></span>

<span data-ttu-id="b1fca-400">A gyorsítótár CPU-, memória- és hálózathasználata is monitorozható.</span><span class="sxs-lookup"><span data-stu-id="b1fca-400">You can also monitor the CPU, memory, and network usage for the cache.</span></span>

<span data-ttu-id="b1fca-401">Az Azure Redis Cache létrehozásával és konfigurálásával kapcsolatos további információkat és példákat az Azure blog [Azure Redis Cache-t körbejáró](https://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/) oldalán talál.</span><span class="sxs-lookup"><span data-stu-id="b1fca-401">For further information and examples showing how to create and configure an Azure Redis Cache, visit the page [Lap around Azure Redis Cache](https://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/) on the Azure blog.</span></span>

## <a name="caching-session-state-and-html-output"></a><span data-ttu-id="b1fca-402">A gyorsítótárazási munkamenet állapota és HTML-kimenete</span><span class="sxs-lookup"><span data-stu-id="b1fca-402">Caching session state and HTML output</span></span>

<span data-ttu-id="b1fca-403">Azure-beli webes szerepkörök használatával futtatott ASP.NET-webalkalmazások létrehozásakor a munkamenet állapotinformációit és a HTML-kimenetet egy Azure Redis Cache-ben mentheti el.</span><span class="sxs-lookup"><span data-stu-id="b1fca-403">If you're building ASP.NET web applications that run by using Azure web roles, you can save session state information and HTML output in an Azure Redis Cache.</span></span> <span data-ttu-id="b1fca-404">Az Azure Redis Cache munkamenetállapot-szolgáltatója engedélyezi a munkamenet-információk megosztását az ASP.NET-webalkalmazás különböző példányai között. Ez nagyon hasznos olyan webfarm-forgatókönyvek esetében, ahol az ügyfél-kiszolgáló affinitás nem áll rendelkezésre, és a munkamenetadatok memóriában történő gyorsítótárazása nem lenne megfelelő megoldás.</span><span class="sxs-lookup"><span data-stu-id="b1fca-404">The session state provider for Azure Redis Cache enables you to share session information between different instances of an ASP.NET web application, and is very useful in web farm situations where client-server affinity is not available and caching session data in-memory would not be appropriate.</span></span>

<span data-ttu-id="b1fca-405">Az Azure Redis Cache munkamenetállapot-szolgáltatójának használata számos előnnyel jár, például:</span><span class="sxs-lookup"><span data-stu-id="b1fca-405">Using the session state provider with Azure Redis Cache delivers several benefits, including:</span></span>

- <span data-ttu-id="b1fca-406">A munkamenet-állapot ASP.NET-webalkalmazások sok példányával osztható meg.</span><span class="sxs-lookup"><span data-stu-id="b1fca-406">Sharing session state with a large number of instances of ASP.NET web applications.</span></span>
- <span data-ttu-id="b1fca-407">Jobb a méretezhetőség.</span><span class="sxs-lookup"><span data-stu-id="b1fca-407">Providing improved scalability.</span></span>
- <span data-ttu-id="b1fca-408">Szabályozott, párhuzamos hozzáférést lehet biztosítani ugyanazon munkamenet-állapotadatokhoz több olvasó és egyetlen író számára.</span><span class="sxs-lookup"><span data-stu-id="b1fca-408">Supporting controlled, concurrent access to the same session state data for multiple readers and a single writer.</span></span>
- <span data-ttu-id="b1fca-409">Tömörítéssel menthető a memória és javítható a hálózati teljesítmény.</span><span class="sxs-lookup"><span data-stu-id="b1fca-409">Using compression to save memory and improve network performance.</span></span>

<span data-ttu-id="b1fca-410">További információkért lásd [az Azure Redis Cache ASP.NET munkamenetállapot-szolgáltatójával](/azure/redis-cache/cache-aspnet-session-state-provider/) foglalkozó cikket.</span><span class="sxs-lookup"><span data-stu-id="b1fca-410">For more information, see [ASP.NET session state provider for Azure Redis Cache](/azure/redis-cache/cache-aspnet-session-state-provider/).</span></span>

> [!NOTE]
> <span data-ttu-id="b1fca-411">Ne használja az Azure Redis Cache munkamenetállapot-szolgáltatóját Azure-környezeten kívül futtatott ASP.NET-alkalmazásokkal.</span><span class="sxs-lookup"><span data-stu-id="b1fca-411">Do not use the session state provider for Azure Redis Cache with ASP.NET applications that run outside of the Azure environment.</span></span> <span data-ttu-id="b1fca-412">Az Azure-on kívüli gyorsítótár hozzáférésének késleltetése miatt előfordulhat, hogy az adatok gyorsítótárazásának teljesítménybeli előnyei nem használhatók ki.</span><span class="sxs-lookup"><span data-stu-id="b1fca-412">The latency of accessing the cache from outside of Azure can eliminate the performance benefits of caching data.</span></span>

<span data-ttu-id="b1fca-413">Hasonlóképpen, az Azure Redis Cache kimeneti gyorsítótár-szolgáltatója az ASP.NET-webalkalmazások által létrehozott HTTP-válaszok mentését is lehetővé teszi.</span><span class="sxs-lookup"><span data-stu-id="b1fca-413">Similarly, the output cache provider for Azure Redis Cache enables you to save the HTTP responses generated by an ASP.NET web application.</span></span> <span data-ttu-id="b1fca-414">Az Azure Redis Cache kimeneti gyorsítótár-szolgáltatójának használatával csökkenthető az összetett HTML-kimeneteket renderelő alkalmazások válaszideje.</span><span class="sxs-lookup"><span data-stu-id="b1fca-414">Using the output cache provider with Azure Redis Cache can improve the response times of applications that render complex HTML output.</span></span> <span data-ttu-id="b1fca-415">Hasonló válaszokat visszaadó alkalmazáspéldányok a HTML-kimenet újbóli létrehozása helyett a gyorsítótárban lévő megosztott kimeneti töredékeket használhatják.</span><span class="sxs-lookup"><span data-stu-id="b1fca-415">Application instances that generate similar responses can use the shared output fragments in the cache rather than generating this HTML output afresh.</span></span> <span data-ttu-id="b1fca-416">További információkért lásd [az Azure Redis Cache ASP.NET-es kimeneti gyorsítótár-szolgáltatóját](/azure/redis-cache/cache-aspnet-output-cache-provider/) ismertető cikket.</span><span class="sxs-lookup"><span data-stu-id="b1fca-416">For more information, see [ASP.NET output cache provider for Azure Redis Cache](/azure/redis-cache/cache-aspnet-output-cache-provider/).</span></span>

## <a name="building-a-custom-redis-cache"></a><span data-ttu-id="b1fca-417">Egyéni Redis-gyorsítótár kiépítése</span><span class="sxs-lookup"><span data-stu-id="b1fca-417">Building a custom Redis cache</span></span>

<span data-ttu-id="b1fca-418">Az Azure Redis Cache a háttérbeli Redis-kiszolgálók előtérrendszereként funkcionál.</span><span class="sxs-lookup"><span data-stu-id="b1fca-418">Azure Redis Cache acts as a façade to the underlying Redis servers.</span></span> <span data-ttu-id="b1fca-419">Ha olyan speciális konfigurációra van szükség, amelyet az Azure Redis Cache nem támogat (például 53 GB-nál nagyobb méretű gyorsítótárra), az Azure-beli virtuális gépek segítségével saját Redis-kiszolgálókat is létrehozhat és üzemeltethet.</span><span class="sxs-lookup"><span data-stu-id="b1fca-419">If you require an advanced configuration that is not covered by the Azure Redis cache (such as a cache bigger than 53 GB) you can build and host your own Redis servers by using Azure virtual machines.</span></span>

<span data-ttu-id="b1fca-420">Ez a folyamat meglehetősen összetett lehet, hiszen ha replikációt szeretne végrehajtani, akkor esetenként több virtuális gépet is létre kell hoznia, amelyek a fő- és alárendelt csomópontok szerepét töltik be.</span><span class="sxs-lookup"><span data-stu-id="b1fca-420">This is a potentially complex process because you might need to create several VMs to act as master and subordinate nodes if you want to implement replication.</span></span> <span data-ttu-id="b1fca-421">Továbbá, ha fürtöt kíván létrehozni, akkor több fő- és alárendelt kiszolgálóra lesz szüksége.</span><span class="sxs-lookup"><span data-stu-id="b1fca-421">Furthermore, if you wish to create a cluster, then you need multiple masters and subordinate servers.</span></span> <span data-ttu-id="b1fca-422">Egy magas szintű rendelkezésre állást és méretezhetőséget biztosító, minimális méretű fürtözött replikációs topológia legalább hat virtuális gépből, azaz három pár fő- és alárendelt kiszolgálóból áll (egy fürtben legalább három főcsomópontnak kell lennie).</span><span class="sxs-lookup"><span data-stu-id="b1fca-422">A minimal clustered replication topology that provides a high degree of availability and scalability comprises at least six VMs organized as three pairs of master/subordinate servers (a cluster must contain at least three master nodes).</span></span>

<span data-ttu-id="b1fca-423">A késleltetés minimalizálása érdekében a fölé/alárendelt pároknak egymáshoz közel kell lenniük.</span><span class="sxs-lookup"><span data-stu-id="b1fca-423">Each master/subordinate pair should be located close together to minimize latency.</span></span> <span data-ttu-id="b1fca-424">Ha azonban a gyorsítótárban lévő adatokat az őket legtöbbször használó alkalmazásokhoz közel kívánja elhelyezni, az egyes párok futtathatók különböző régiókban található Azure-adatközpontokban is.</span><span class="sxs-lookup"><span data-stu-id="b1fca-424">However, each set of pairs can be running in different Azure datacenters located in different regions, if you wish to locate cached data close to the applications that are most likely to use it.</span></span> <span data-ttu-id="b1fca-425">Példa Azure-beli virtuális gépként futtatott Redis-csomópont kiépítésére és konfigurálására: [A Redis futtatása CentOS Linux rendszerű virtuális gépen az Azure-ban](https://blogs.msdn.microsoft.com/tconte/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure/) (blogbejegyzés).</span><span class="sxs-lookup"><span data-stu-id="b1fca-425">For an example of building and configuring a Redis node running as an Azure VM, see [Running Redis on a CentOS Linux VM in Azure](https://blogs.msdn.microsoft.com/tconte/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure/).</span></span>

> [!NOTE]
> <span data-ttu-id="b1fca-426">Vegye figyelembe, hogy ha egyéni Redis-gyorsítótárat hoz létre, akkor Ön felel a szolgáltatás monitorozásáért, felügyeletéért és biztonságáért.</span><span class="sxs-lookup"><span data-stu-id="b1fca-426">Please note that if you implement your own Redis cache in this way, you are responsible for monitoring, managing, and securing the service.</span></span>

## <a name="partitioning-a-redis-cache"></a><span data-ttu-id="b1fca-427">A Redis-gyorsítótár particionálása</span><span class="sxs-lookup"><span data-stu-id="b1fca-427">Partitioning a Redis cache</span></span>

<span data-ttu-id="b1fca-428">A gyorsítótár particionálása a gyorsítótár több számítógépre történő felosztását jelenti.</span><span class="sxs-lookup"><span data-stu-id="b1fca-428">Partitioning the cache involves splitting the cache across multiple computers.</span></span> <span data-ttu-id="b1fca-429">Ez a struktúra számos előnnyel jár egyetlen gyorsítótár-kiszolgáló használatával szemben, amelyek például a következők lehetnek:</span><span class="sxs-lookup"><span data-stu-id="b1fca-429">This structure gives you several advantages over using a single cache server, including:</span></span>

- <span data-ttu-id="b1fca-430">Sokkal nagyobb gyorsítótár hozható létre, mint amelyet egyetlen kiszolgálón tárolni lehetne.</span><span class="sxs-lookup"><span data-stu-id="b1fca-430">Creating a cache that is much bigger than can be stored on a single server.</span></span>
- <span data-ttu-id="b1fca-431">Az adatok eloszthatók a kiszolgálók között, így javul a rendelkezésre állás.</span><span class="sxs-lookup"><span data-stu-id="b1fca-431">Distributing data across servers, improving availability.</span></span> <span data-ttu-id="b1fca-432">Ha egy kiszolgáló meghibásodik vagy elérhetetlenné válik, az általa tárolt adatok sem érhetők el, a többi kiszolgálón található adatok viszont továbbra is hozzáférhetők maradnak.</span><span class="sxs-lookup"><span data-stu-id="b1fca-432">If one server fails or becomes inaccessible, the data that it holds is unavailable, but the data on the remaining servers can still be accessed.</span></span> <span data-ttu-id="b1fca-433">Gyorsítótárak esetén ez nem jelent nagy problémát, mert a gyorsítótárazott adatok csak az adatbázisban tárolt adatok átmeneti másolati példányai.</span><span class="sxs-lookup"><span data-stu-id="b1fca-433">For a cache, this is not crucial because the cached data is only a transient copy of the data that's held in a database.</span></span> <span data-ttu-id="b1fca-434">A hozzáférhetetlenné váló kiszolgáló gyorsítótárában tárolt adatok egy másik kiszolgálóra gyorsítótárába is áthelyezhetők.</span><span class="sxs-lookup"><span data-stu-id="b1fca-434">Cached data on a server that becomes inaccessible can be cached on a different server instead.</span></span>
- <span data-ttu-id="b1fca-435">A terhelés elosztható a kiszolgálók között, ezáltal javul a teljesítmény és méretezhetőség.</span><span class="sxs-lookup"><span data-stu-id="b1fca-435">Spreading the load across servers, thereby improving performance and scalability.</span></span>
- <span data-ttu-id="b1fca-436">Az adatok a hozzájuk férő felhasználókhoz földrajzilag közel helyezhetők el, így csökken a késleltetés mértéke.</span><span class="sxs-lookup"><span data-stu-id="b1fca-436">Geolocating data close to the users that access it, thus reducing latency.</span></span>

<span data-ttu-id="b1fca-437">Gyorsítótárak esetében a particionálás leggyakrabban használt módszere a horizontális skálázás.</span><span class="sxs-lookup"><span data-stu-id="b1fca-437">For a cache, the most common form of partitioning is sharding.</span></span> <span data-ttu-id="b1fca-438">Ilyenkor az egyes partíciók (vagy szilánkok) önmagukban is egy-egy Redis-gyorsítótárként működnek.</span><span class="sxs-lookup"><span data-stu-id="b1fca-438">In this strategy, each partition (or shard) is a Redis cache in its own right.</span></span> <span data-ttu-id="b1fca-439">Az adatokat horizontális skálázási logika alapján irányítják egy megadott partícióra, amely logika többféle megközelítést is alkalmazhat az adatok elosztására.</span><span class="sxs-lookup"><span data-stu-id="b1fca-439">Data is directed to a specific partition by using sharding logic, which can use a variety of approaches to distribute the data.</span></span> <span data-ttu-id="b1fca-440">További információkat a horizontális skálázás megvalósításáról a [horizontális skálázási mintát](../patterns/sharding.md) ismertető cikkben talál.</span><span class="sxs-lookup"><span data-stu-id="b1fca-440">The [Sharding pattern](../patterns/sharding.md) provides more information about implementing sharding.</span></span>

<span data-ttu-id="b1fca-441">A Redis-gyorsítótár particionálásának végrehajtása során a következő megközelítéseket alkalmazhatja:</span><span class="sxs-lookup"><span data-stu-id="b1fca-441">To implement partitioning in a Redis cache, you can take one of the following approaches:</span></span>

- <span data-ttu-id="b1fca-442">*Kiszolgálóoldali lekérdezés továbbítása.*</span><span class="sxs-lookup"><span data-stu-id="b1fca-442">*Server-side query routing.*</span></span> <span data-ttu-id="b1fca-443">Az ügyfélalkalmazás kérelmet küld a gyorsítótár részét képező valamelyik Redis-kiszolgálónak (nagy valószínűséggel a legközelebbinek).</span><span class="sxs-lookup"><span data-stu-id="b1fca-443">In this technique, a client application sends a request to any of the Redis servers that comprise the cache (probably the closest server).</span></span> <span data-ttu-id="b1fca-444">Mindegyik Redis-kiszolgáló tárolja a rajta található partíciót leíró metaadatokat, és arra vonatkozóan is tartalmaz információkat, hogy mely partíciók találhatók más kiszolgálókon.</span><span class="sxs-lookup"><span data-stu-id="b1fca-444">Each Redis server stores metadata that describes the partition that it holds, and also contains information about which partitions are located on other servers.</span></span> <span data-ttu-id="b1fca-445">A Redis-kiszolgáló megvizsgálja az ügyfélkérelmet.</span><span class="sxs-lookup"><span data-stu-id="b1fca-445">The Redis server examines the client request.</span></span> <span data-ttu-id="b1fca-446">Ha az helyileg megoldható, akkor elvégzi a kért műveletet.</span><span class="sxs-lookup"><span data-stu-id="b1fca-446">If it can be resolved locally, it will perform the requested operation.</span></span> <span data-ttu-id="b1fca-447">Ha nem oldható meg, akkor továbbítja a kérést a megfelelő kiszolgálóra.</span><span class="sxs-lookup"><span data-stu-id="b1fca-447">Otherwise it will forward the request on to the appropriate server.</span></span> <span data-ttu-id="b1fca-448">Erről a Redis-fürtözéssel megvalósított modellről további részleteket a Redis webhelyén elérhető, a [Redis-fürt oktatóanyagát](https://redis.io/topics/cluster-tutorial) tartalmazó oldalon talál.</span><span class="sxs-lookup"><span data-stu-id="b1fca-448">This model is implemented by Redis clustering, and is described in more detail on the [Redis cluster tutorial](https://redis.io/topics/cluster-tutorial) page on the Redis website.</span></span> <span data-ttu-id="b1fca-449">A Redis-fürtözés átlátható az ügyfélalkalmazások számára, és a fürthöz további Redis-kiszolgálók is hozzáadhatók (és az adatok újraparticionálhatók) anélkül, hogy az ügyfeleket újra kellene konfigurálni.</span><span class="sxs-lookup"><span data-stu-id="b1fca-449">Redis clustering is transparent to client applications, and additional Redis servers can be added to the cluster (and the data re-partitioned) without requiring that you reconfigure the clients.</span></span>
- <span data-ttu-id="b1fca-450">*Ügyféloldali particionálás.*</span><span class="sxs-lookup"><span data-stu-id="b1fca-450">*Client-side partitioning.*</span></span> <span data-ttu-id="b1fca-451">Ebben a modellben az ügyfélalkalmazás (valószínűleg kódtár formájában elérhető) logikája irányítja a megfelelő Redis-kiszolgálókra a kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="b1fca-451">In this model, the client application contains logic (possibly in the form of a library) that routes requests to the appropriate Redis server.</span></span> <span data-ttu-id="b1fca-452">Ez a módszer az Azure Redis Cache esetében is alkalmazható.</span><span class="sxs-lookup"><span data-stu-id="b1fca-452">This approach can be used with Azure Redis Cache.</span></span> <span data-ttu-id="b1fca-453">Hozzon létre több Azure Redis Cache-t (mindegyik adatpartícióhoz egyet-egyet), és léptesse életbe az ügyféloldali logikát, amely a kérelmeket a megfelelő gyorsítótárba irányítja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-453">Create multiple Azure Redis Caches (one for each data partition) and implement the client-side logic that routes the requests to the correct cache.</span></span> <span data-ttu-id="b1fca-454">Ha a particionálási séma módosul (például további Azure Redis Cache-ek létrehozása esetén), akkor az ügyfélalkalmazások újrakonfigurálására lehet szükség.</span><span class="sxs-lookup"><span data-stu-id="b1fca-454">If the partitioning scheme changes (if additional Azure Redis Caches are created, for example), client applications might need to be reconfigured.</span></span>
- <span data-ttu-id="b1fca-455">*Proxyval támogatott particionálás.*</span><span class="sxs-lookup"><span data-stu-id="b1fca-455">*Proxy-assisted partitioning.*</span></span> <span data-ttu-id="b1fca-456">Ebben a sémában az ügyfélalkalmazások egy közvetítőként szolgáló proxyszolgáltatásnak küldenek kérelmeket, amely értelmezi az adatok particionálását, majd a kérelmet a megfelelő Redis-kiszolgálóra irányítja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-456">In this scheme, client applications send requests to an intermediary proxy service which understands how the data is partitioned and then routes the request to the appropriate Redis server.</span></span> <span data-ttu-id="b1fca-457">Ez a módszer is alkalmazható az Azure Redis Cache esetében; a proxyszolgáltatás Azure-felhőszolgáltatásként is megvalósítható.</span><span class="sxs-lookup"><span data-stu-id="b1fca-457">This approach can also be used with Azure Redis Cache; the proxy service can be implemented as an Azure cloud service.</span></span> <span data-ttu-id="b1fca-458">Így összetettebb feladattá válik a szolgáltatás megvalósítása, és hosszabb időre lehet szükség a kérelmek végrehajtásához, mint az ügyféloldali particionálás esetében.</span><span class="sxs-lookup"><span data-stu-id="b1fca-458">This approach requires an additional level of complexity to implement the service, and requests might take longer to perform than using client-side partitioning.</span></span>

<span data-ttu-id="b1fca-459">A Redis használatával történő particionálásról további információkat a Redis webhelyén elérhető [Particionálás: adatok felosztása több Redis-példány között](https://redis.io/topics/partitioning) oldalon talál.</span><span class="sxs-lookup"><span data-stu-id="b1fca-459">The page [Partitioning: how to split data among multiple Redis instances](https://redis.io/topics/partitioning) on the Redis website provides further information about implementing partitioning with Redis.</span></span>

### <a name="implement-redis-cache-client-applications"></a><span data-ttu-id="b1fca-460">Redis gyorsítótár-ügyfélalkalmazások megvalósítása</span><span class="sxs-lookup"><span data-stu-id="b1fca-460">Implement Redis cache client applications</span></span>

<span data-ttu-id="b1fca-461">A Redis számos, különböző programozási nyelveken írt ügyfélalkalmazást támogat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-461">Redis supports client applications written in numerous programming languages.</span></span> <span data-ttu-id="b1fca-462">Ha a .NET-keretrendszer használatával hoz létre új alkalmazásokat, ehhez a StackExchange.Redis ügyfélkódtár használatát javasoljuk.</span><span class="sxs-lookup"><span data-stu-id="b1fca-462">If you are building new applications by using the .NET Framework, the recommended approach is to use the StackExchange.Redis client library.</span></span> <span data-ttu-id="b1fca-463">Ez a kódtár egy olyan .NET-keretrendszerbeli objektummodellt biztosít, amely kivonatolja a Redis-kiszolgálóhoz való csatlakozás, a parancsküldés és a válaszfogadás részleteit.</span><span class="sxs-lookup"><span data-stu-id="b1fca-463">This library provides a .NET Framework object model that abstracts the details for connecting to a Redis server, sending commands, and receiving responses.</span></span> <span data-ttu-id="b1fca-464">A Visual Studióban NuGet-csomagként érhető el.</span><span class="sxs-lookup"><span data-stu-id="b1fca-464">It is available in Visual Studio as a NuGet package.</span></span> <span data-ttu-id="b1fca-465">Ugyanezzel a kódtárral kapcsolódhat egy Azure Redis-gyorsítótárhoz vagy egy virtuális gépen lévő egyéni Redis-gyorsítótárhoz.</span><span class="sxs-lookup"><span data-stu-id="b1fca-465">You can use this same library to connect to an Azure Redis Cache, or a custom Redis cache hosted on a VM.</span></span>

<span data-ttu-id="b1fca-466">A Redis-kiszolgálóhoz való csatlakozáshoz használja a `ConnectionMultiplexer` osztály statikus `Connect` metódusát.</span><span class="sxs-lookup"><span data-stu-id="b1fca-466">To connect to a Redis server you use the static `Connect` method of the `ConnectionMultiplexer` class.</span></span> <span data-ttu-id="b1fca-467">A metódus által létrehozott kapcsolat úgy van kialakítva, hogy az ügyfélalkalmazás teljes élettartama alatt használható legyen, és ugyanezt a kapcsolatot több egyidejű szál is használhassa.</span><span class="sxs-lookup"><span data-stu-id="b1fca-467">The connection that this method creates is designed to be used throughout the lifetime of the client application, and the same connection can be used by multiple concurrent threads.</span></span> <span data-ttu-id="b1fca-468">Redis-műveletek végrehajtásakor ne hajtson végre minden alkalommal újracsatlakozást és leválasztást, mert ez ronthatja a teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="b1fca-468">Do not reconnect and disconnect each time you perform a Redis operation because this can degrade performance.</span></span>

<span data-ttu-id="b1fca-469">Megadhatja a kapcsolati paramétereket, például a Redis-gazdagép címét és a jelszót.</span><span class="sxs-lookup"><span data-stu-id="b1fca-469">You can specify the connection parameters, such as the address of the Redis host and the password.</span></span> <span data-ttu-id="b1fca-470">Azure Redis Cache használatakor a jelszó nem vagy az elsődleges vagy másodlagos kulcsot, amely az Azure Redis Cache jön létre az Azure felügyeleti portál használatával.</span><span class="sxs-lookup"><span data-stu-id="b1fca-470">If you are using Azure Redis Cache, the password is either the primary or secondary key that is generated for Azure Redis Cache by using the Azure Management portal.</span></span>

<span data-ttu-id="b1fca-471">Miután csatlakozott a Redis-kiszolgálóhoz, beszerezhet egy leírót a gyorsítótárként szolgáló Redis-adatbázishoz.</span><span class="sxs-lookup"><span data-stu-id="b1fca-471">After you have connected to the Redis server, you can obtain a handle on the Redis database that acts as the cache.</span></span> <span data-ttu-id="b1fca-472">A Redis-kapcsolat ehhez a `GetDatabase` metódust biztosítja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-472">The Redis connection provides the `GetDatabase` method to do this.</span></span> <span data-ttu-id="b1fca-473">Ezután a `StringGet` és a `StringSet` metódussal kérdezhet le elemeket a gyorsítótárból és menthet el benne adatokat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-473">You can then retrieve items from the cache and store data in the cache by using the `StringGet` and `StringSet` methods.</span></span> <span data-ttu-id="b1fca-474">Ezek a metódusok paraméterként egy kulcsot várnak, majd visszaadják az egyező értékű elemet a gyorsítótárból (`StringGet`), vagy ezzel a kulccsal adják hozzá az elemet a gyorsítótárhoz (`StringSet`).</span><span class="sxs-lookup"><span data-stu-id="b1fca-474">These methods expect a key as a parameter, and return the item either in the cache that has a matching value (`StringGet`) or add the item to the cache with this key (`StringSet`).</span></span>

<span data-ttu-id="b1fca-475">A Redis-kiszolgáló helyétől függően számos műveletnél számíthatunk késleltetésre, amíg a kérelem eljut a kiszolgálóhoz, illetve a válasz az ügyfélhez.</span><span class="sxs-lookup"><span data-stu-id="b1fca-475">Depending on the location of the Redis server, many operations might incur some latency while a request is transmitted to the server and a response is returned to the client.</span></span> <span data-ttu-id="b1fca-476">A StackExchange kódtár számos metódus aszinkron verzióját biztosítja, amelyek segítségével szinten tartható az ügyfélalkalmazások válaszkészsége.</span><span class="sxs-lookup"><span data-stu-id="b1fca-476">The StackExchange library provides asynchronous versions of many of the methods that it exposes to help client applications remain responsive.</span></span> <span data-ttu-id="b1fca-477">Ezek a metódusok támogatják a [feladatalapú aszinkron minta](/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap) a .NET-keretrendszer.</span><span class="sxs-lookup"><span data-stu-id="b1fca-477">These methods support the [Task-based Asynchronous pattern](/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap) in the .NET Framework.</span></span>

<span data-ttu-id="b1fca-478">A következő kódrészlet a `RetrieveItem` nevű metódust mutatja be.</span><span class="sxs-lookup"><span data-stu-id="b1fca-478">The following code snippet shows a method named `RetrieveItem`.</span></span> <span data-ttu-id="b1fca-479">A példa a Redis és a StackExchange-kódtáron alapuló gyorsítótár-feltöltési minta megvalósítását szemlélteti.</span><span class="sxs-lookup"><span data-stu-id="b1fca-479">It illustrates an implementation of the cache-aside pattern based on Redis and the StackExchange library.</span></span> <span data-ttu-id="b1fca-480">A metódus egy sztring formátumú kulcsérték használatával megkísérli lekérni a megfelelő elemet a Redis-gyorsítótárból a `StringGetAsync` metódus (a `StringGet` aszinkron verziója) meghívásával.</span><span class="sxs-lookup"><span data-stu-id="b1fca-480">The method takes a string key value and attempts to retrieve the corresponding item from the Redis cache by calling the `StringGetAsync` method (the asynchronous version of `StringGet`).</span></span>

<span data-ttu-id="b1fca-481">Ha az adott elem nem található, akkor a rendszer az alapul szolgáló adatforrásból kéri le a `GetItemFromDataSourceAsync` metódussal (helyi metódus, nem része a StackExchange-kódtárnak).</span><span class="sxs-lookup"><span data-stu-id="b1fca-481">If the item is not found, it is fetched from the underlying data source using the `GetItemFromDataSourceAsync` method (which is a local method and not part of the StackExchange library).</span></span> <span data-ttu-id="b1fca-482">A rendszer ezután a `StringSetAsync` metódussal hozzáadja az elemet a gyorsítótárhoz, így legközelebb gyorsabban le lehet majd kérdezni.</span><span class="sxs-lookup"><span data-stu-id="b1fca-482">It's then added to the cache by using the `StringSetAsync` method so it can be retrieved more quickly next time.</span></span>

```csharp
// Connect to the Azure Redis cache
ConfigurationOptions config = new ConfigurationOptions();
config.EndPoints.Add("<your DNS name>.redis.cache.windows.net");
config.Password = "<Redis cache key from management portal>";
ConnectionMultiplexer redisHostConnection = ConnectionMultiplexer.Connect(config);
IDatabase cache = redisHostConnection.GetDatabase();
...
private async Task<string> RetrieveItem(string itemKey)
{
    // Attempt to retrieve the item from the Redis cache
    string itemValue = await cache.StringGetAsync(itemKey);

    // If the value returned is null, the item was not found in the cache
    // So retrieve the item from the data source and add it to the cache
    if (itemValue == null)
    {
        itemValue = await GetItemFromDataSourceAsync(itemKey);
        await cache.StringSetAsync(itemKey, itemValue);
    }

    // Return the item
    return itemValue;
}
```

<span data-ttu-id="b1fca-483">A `StringGet` és a `StringSet` metódus nem korlátozódik a lekérésre és a sztringértékek tárolására.</span><span class="sxs-lookup"><span data-stu-id="b1fca-483">The `StringGet` and `StringSet` methods are not restricted to retrieving or storing string values.</span></span> <span data-ttu-id="b1fca-484">Ezek a metódusok minden, bájttömbként szerializált elemet támogatnak.</span><span class="sxs-lookup"><span data-stu-id="b1fca-484">They can take any item that is serialized as an array of bytes.</span></span> <span data-ttu-id="b1fca-485">Ha egy a .NET-objektumot kell elmentenie, bájtstreamként szerializálhatja, majd a `StringSet` metódussal a gyorsítótárba írhatja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-485">If you need to save a .NET object, you can serialize it as a byte stream and use the `StringSet` method to write it to the cache.</span></span>

<span data-ttu-id="b1fca-486">Hasonlóképpen, a `StringGet` metódus használatával beolvashatja az adott objektumot a gyorsítótárból, majd .NET-objektumként deszerializálhatja azt.</span><span class="sxs-lookup"><span data-stu-id="b1fca-486">Similarly, you can read an object from the cache by using the `StringGet` method and deserializing it as a .NET object.</span></span> <span data-ttu-id="b1fca-487">Az alábbi kódban az IDatabase-illesztő bővítési metódusai (egy Redis-kapcsolat `GetDatabase` metódusa egy `IDatabase` objektumot ad vissza), illetve néhány olyan mintakód látható, amelyek ezeket a metódusokat használják egy `BlogPost` objektum gyorsítótárbeli olvasásához és írásához:</span><span class="sxs-lookup"><span data-stu-id="b1fca-487">The following code shows a set of extension methods for the IDatabase interface (the `GetDatabase` method of a Redis connection returns an `IDatabase` object),  and some sample code that uses these methods to read and write a `BlogPost` object to the cache:</span></span>

```csharp
public static class RedisCacheExtensions
{
    public static async Task<T> GetAsync<T>(this IDatabase cache, string key)
    {
        return Deserialize<T>(await cache.StringGetAsync(key));
    }

    public static async Task<object> GetAsync(this IDatabase cache, string key)
    {
        return Deserialize<object>(await cache.StringGetAsync(key));
    }

    public static async Task SetAsync(this IDatabase cache, string key, object value)
    {
        await cache.StringSetAsync(key, Serialize(value));
    }

    static byte[] Serialize(object o)
    {
        byte[] objectDataAsStream = null;

        if (o != null)
        {
            BinaryFormatter binaryFormatter = new BinaryFormatter();
            using (MemoryStream memoryStream = new MemoryStream())
            {
                binaryFormatter.Serialize(memoryStream, o);
                objectDataAsStream = memoryStream.ToArray();
            }
        }

        return objectDataAsStream;
    }

    static T Deserialize<T>(byte[] stream)
    {
        T result = default(T);

        if (stream != null)
        {
            BinaryFormatter binaryFormatter = new BinaryFormatter();
            using (MemoryStream memoryStream = new MemoryStream(stream))
            {
                result = (T)binaryFormatter.Deserialize(memoryStream);
            }
        }

        return result;
    }
}
```

<span data-ttu-id="b1fca-488">Az alábbi kód egy `RetrieveBlogPost` nevű metódust szemléltet, amely ezeket a bővítő metódusokat használja egy szerializálható `BlogPost` objektum gyorsítótárbeli olvasásához és írásához, a gyorsítótár-feltöltési minta alapján:</span><span class="sxs-lookup"><span data-stu-id="b1fca-488">The following code illustrates a method named `RetrieveBlogPost` that uses these extension methods to read and write a serializable `BlogPost` object to the cache following the cache-aside pattern:</span></span>

```csharp
// The BlogPost type
[Serializable]
public class BlogPost
{
    private HashSet<string> tags;

    public BlogPost(int id, string title, int score, IEnumerable<string> tags)
    {
        this.Id = id;
        this.Title = title;
        this.Score = score;
        this.tags = new HashSet<string>(tags);
    }

    public int Id { get; set; }
    public string Title { get; set; }
    public int Score { get; set; }
    public ICollection<string> Tags => this.tags;
}
...
private async Task<BlogPost> RetrieveBlogPost(string blogPostKey)
{
    BlogPost blogPost = await cache.GetAsync<BlogPost>(blogPostKey);
    if (blogPost == null)
    {
        blogPost = await GetBlogPostFromDataSourceAsync(blogPostKey);
        await cache.SetAsync(blogPostKey, blogPost);
    }

    return blogPost;
}
```

<span data-ttu-id="b1fca-489">A Redis támogatja a parancsok adatcsatornás feldolgozását, ha egy ügyfélalkalmazás több aszinkron kérelmet küld.</span><span class="sxs-lookup"><span data-stu-id="b1fca-489">Redis supports command pipelining if a client application sends multiple asynchronous requests.</span></span> <span data-ttu-id="b1fca-490">A parancsok szigorú sorrendben történő fogadása és megválaszolása helyett a Redis képes az ugyanazt a kapcsolatot használó kérelmek multiplexálására.</span><span class="sxs-lookup"><span data-stu-id="b1fca-490">Redis can multiplex the requests using the same connection rather than receiving and responding to commands in a strict sequence.</span></span>

<span data-ttu-id="b1fca-491">Ez a módszer a hatékonyabb hálózathasználat révén hozzájárul a késleltetés csökkentéséhez.</span><span class="sxs-lookup"><span data-stu-id="b1fca-491">This approach helps to reduce latency by making more efficient use of the network.</span></span> <span data-ttu-id="b1fca-492">Az alábbi kódrészlet két ügyfél adatainak egyidejű lekérdezésére mutat példát.</span><span class="sxs-lookup"><span data-stu-id="b1fca-492">The following code snippet shows an example that retrieves the details of two customers concurrently.</span></span> <span data-ttu-id="b1fca-493">A kód két kérelmet küld el, majd végrehajt egy másik műveletet (amely itt nem látható), miközben az eredmények beérkezésére vár.</span><span class="sxs-lookup"><span data-stu-id="b1fca-493">The code submits two requests and then performs some other processing (not shown) before waiting to receive the results.</span></span> <span data-ttu-id="b1fca-494">A gyorsítótár-objektum `Wait` metódusa hasonló a .NET-keretrendszer `Task.Wait` metódusához:</span><span class="sxs-lookup"><span data-stu-id="b1fca-494">The `Wait` method of the cache object is similar to the .NET Framework `Task.Wait` method:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
var task1 = cache.StringGetAsync("customer:1");
var task2 = cache.StringGetAsync("customer:2");
...
var customer1 = cache.Wait(task1);
var customer2 = cache.Wait(task2);
```

<span data-ttu-id="b1fca-495">Az Azure Redis Cache ügyfélalkalmazások írásáról további információkért lásd: a [Azure Cache Redis dokumentációt](/azure/azure-cache-for-redis/).</span><span class="sxs-lookup"><span data-stu-id="b1fca-495">For additional information on writing client applications that can the Azure Redis Cache, see the [Azure Cache for Redis documentation](/azure/azure-cache-for-redis/).</span></span> <span data-ttu-id="b1fca-496">A [StackExchange.Redis](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md) is tartalmaz további tudnivalókat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-496">More information is also available at [StackExchange.Redis](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md).</span></span>

<span data-ttu-id="b1fca-497">Az ugyanezen a webhelyen található, [folyamatokkal és multiplexerekkel](https://stackexchange.github.io/StackExchange.Redis/PipelinesMultiplexers) foglalkozó oldalon további információkat talál az aszinkron műveletekről és az adatcsatornás feldolgozásról a Redis és a StackExchange kódtár használatával.</span><span class="sxs-lookup"><span data-stu-id="b1fca-497">The page [Pipelines and multiplexers](https://stackexchange.github.io/StackExchange.Redis/PipelinesMultiplexers) on the same website provides more information about asynchronous operations and pipelining with Redis and the StackExchange library.</span></span>

## <a name="using-redis-caching"></a><span data-ttu-id="b1fca-498">A Redis-gyorsítótárazás használata</span><span class="sxs-lookup"><span data-stu-id="b1fca-498">Using Redis caching</span></span>

<span data-ttu-id="b1fca-499">A gyorsítótárazás során a Redis legegyszerűbben kulcs-érték párok formájában használható, ahol az érték egy tetszőleges hosszúságú, nem értelmezett sztring, amely bármilyen bináris adatot tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-499">The simplest use of Redis for caching concerns is key-value pairs where the value is an uninterpreted string of arbitrary length that can contain any binary data.</span></span> <span data-ttu-id="b1fca-500">(Tulajdonképpen bájttömb egy karakterláncként kezelhető szó).</span><span class="sxs-lookup"><span data-stu-id="b1fca-500">(It is essentially an array of bytes that can be treated as a string).</span></span> <span data-ttu-id="b1fca-501">Ezt a forgatókönyvet a jelen cikk korábbi, „Redis gyorsítótár-ügyfélalkalmazások megvalósítása” című szakaszában mutattuk be.</span><span class="sxs-lookup"><span data-stu-id="b1fca-501">This scenario was illustrated in the section Implement Redis Cache client applications earlier in this article.</span></span>

<span data-ttu-id="b1fca-502">Vegye figyelembe, hogy a kulcsok nem értelmezett adatokat is tartalmaznak, így bármilyen bináris adat használható kulcsként.</span><span class="sxs-lookup"><span data-stu-id="b1fca-502">Note that keys also contain uninterpreted data, so you can use any binary information as the key.</span></span> <span data-ttu-id="b1fca-503">Minél hosszabb azonban a kulcs, a tárolás során annál több helyet foglal, és annál hosszabb ideig tart a keresési műveletek végrehajtása.</span><span class="sxs-lookup"><span data-stu-id="b1fca-503">The longer the key is, however, the more space it will take to store, and the longer it will take to perform lookup operations.</span></span> <span data-ttu-id="b1fca-504">A használhatóság és az egyszerű karbantartás érdekében gondosan tervezze meg a kulcsterületet, és használjon jelentéssel bíró (de ne túl részletes) kulcsokat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-504">For usability and ease of maintenance, design your keyspace carefully and use meaningful (but not verbose) keys.</span></span>

<span data-ttu-id="b1fca-505">Használjon strukturált kulcsokat, amilyen például az „ügyfél:100”, hogy az ügyfélkulcsot a 100-as azonosítóval, ne pedig csak a „100” értékkel jelölje.</span><span class="sxs-lookup"><span data-stu-id="b1fca-505">For example, use structured keys such as "customer:100" to represent the key for the customer with ID 100 rather than simply "100".</span></span> <span data-ttu-id="b1fca-506">Ez a séma lehetővé teszi, hogy egyszerűen megkülönböztethessük a különböző adattípusokat tároló értékeket.</span><span class="sxs-lookup"><span data-stu-id="b1fca-506">This scheme enables you to easily distinguish between values that store different data types.</span></span> <span data-ttu-id="b1fca-507">Használhatja például a „rendelések:100” kulcsot is a 100-as azonosítójú megrendelés kulcsának megjelölésére.</span><span class="sxs-lookup"><span data-stu-id="b1fca-507">For example, you could also use the key "orders:100" to represent the key for the order with ID 100.</span></span>

<span data-ttu-id="b1fca-508">Az egydimenziós bináris sztringekon kívül a Redis kulcs-érték párok értéke strukturáltabb információkat is tartalmazhat, például listákat, (rendezett vagy nem rendezett) készleteket és kivonatokat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-508">Apart from one-dimensional binary strings, a value in a Redis key-value pair can also hold more structured information, including lists, sets (sorted and unsorted), and hashes.</span></span> <span data-ttu-id="b1fca-509">A Redis olyan átfogó parancskészletet biztosít, amely segítségével ezek a típusok módosíthatók, és a parancsok közül a legtöbb elérhető a .NET-keretrendszert használó alkalmazások számára egy ügyfélkódtáron (például a StackExchange-en) keresztül.</span><span class="sxs-lookup"><span data-stu-id="b1fca-509">Redis provides a comprehensive command set that can manipulate these types, and many of these commands are available to .NET Framework applications through a client library such as StackExchange.</span></span> <span data-ttu-id="b1fca-510">A típusokról és a módosításukhoz használható parancsokról részletesebb áttekintést a Redis webhelyén elérhető, [a Redis adattípusait és absztrakt entitásait bemutató](https://redis.io/topics/data-types-intro) oldalon talál.</span><span class="sxs-lookup"><span data-stu-id="b1fca-510">The page [An introduction to Redis data types and abstractions](https://redis.io/topics/data-types-intro) on the Redis website provides a more detailed overview of these types and the commands that you can use to manipulate them.</span></span>

<span data-ttu-id="b1fca-511">Ez a szakasz ezen adattípusok és parancsok néhány gyakori felhasználási esetét foglalja össze.</span><span class="sxs-lookup"><span data-stu-id="b1fca-511">This section summarizes some common use cases for these data types and commands.</span></span>

### <a name="perform-atomic-and-batch-operations"></a><span data-ttu-id="b1fca-512">Atomi és kötegműveletek végrehajtása</span><span class="sxs-lookup"><span data-stu-id="b1fca-512">Perform atomic and batch operations</span></span>

<span data-ttu-id="b1fca-513">A Redis számos „lekérés és beállítás” típusú atomi műveletet támogat, amelyeket sztringértékeken lehet végrehajtani.</span><span class="sxs-lookup"><span data-stu-id="b1fca-513">Redis supports a series of atomic get-and-set operations on string values.</span></span> <span data-ttu-id="b1fca-514">E műveletek segítségével kiküszöbölhetők azok a versengésből származó esetleges veszélyek, amelyek a külön `GET` és `SET` parancsok használatakor előfordulhatnak.</span><span class="sxs-lookup"><span data-stu-id="b1fca-514">These operations remove the possible race hazards that might occur when using separate `GET` and `SET` commands.</span></span> <span data-ttu-id="b1fca-515">A rendelkezésre álló műveletek a következők:</span><span class="sxs-lookup"><span data-stu-id="b1fca-515">The operations that are available include:</span></span>

- <span data-ttu-id="b1fca-516">`INCR`, `INCRBY`, `DECR` és `DECRBY` – ezek atomi növelési és csökkentési műveletek, amelyeket egész számú numerikus adatértékeken lehet végrehajtani.</span><span class="sxs-lookup"><span data-stu-id="b1fca-516">`INCR`, `INCRBY`, `DECR`, and `DECRBY`, which perform atomic increment and decrement operations on integer numeric data values.</span></span> <span data-ttu-id="b1fca-517">A StackExchange-kódtár biztosítja az `IDatabase.StringIncrementAsync` és `IDatabase.StringDecrementAsync` metódusok túlterhelt verzióit a fenti műveletek elvégzéséhez, és a gyorsítótárban tárolt eredményt adja vissza.</span><span class="sxs-lookup"><span data-stu-id="b1fca-517">The StackExchange library provides overloaded versions of the `IDatabase.StringIncrementAsync` and `IDatabase.StringDecrementAsync` methods to perform these operations and return the resulting value that is stored in the cache.</span></span> <span data-ttu-id="b1fca-518">A következő kódrészlet ezen metódusok használatát mutatja be:</span><span class="sxs-lookup"><span data-stu-id="b1fca-518">The following code snippet illustrates how to use these methods:</span></span>

  ```csharp
  ConnectionMultiplexer redisHostConnection = ...;
  IDatabase cache = redisHostConnection.GetDatabase();
  ...
  await cache.StringSetAsync("data:counter", 99);
  ...
  long oldValue = await cache.StringIncrementAsync("data:counter");
  // Increment by 1 (the default)
  // oldValue should be 100
  
  long newValue = await cache.StringDecrementAsync("data:counter", 50);
  // Decrement by 50
  // newValue should be 50
  ```

- <span data-ttu-id="b1fca-519">`GETSET` – lekéri a kulcshoz társított értéket, és egy új értékre módosítja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-519">`GETSET`, which retrieves the value that's associated with a key and changes it to a new value.</span></span> <span data-ttu-id="b1fca-520">A StackExchange-kódtár az `IDatabase.StringGetSetAsync` metóduson keresztül teszi elérhetővé ezt a műveletet.</span><span class="sxs-lookup"><span data-stu-id="b1fca-520">The StackExchange library makes this operation available through the `IDatabase.StringGetSetAsync` method.</span></span> <span data-ttu-id="b1fca-521">Az alábbi kódrészlet erre a metódusra mutat példát.</span><span class="sxs-lookup"><span data-stu-id="b1fca-521">The code snippet below shows an example of this method.</span></span> <span data-ttu-id="b1fca-522">Ez a kód az előző példából származó „data:counter” (adat:számláló) kulcs aktuális értékét adja vissza.</span><span class="sxs-lookup"><span data-stu-id="b1fca-522">This code returns the current value that's associated with the key "data:counter" from the previous example.</span></span> <span data-ttu-id="b1fca-523">Ezt követően nulla értékre állítja vissza a kulcs értékét, mindezt egyazon művelet részeként:</span><span class="sxs-lookup"><span data-stu-id="b1fca-523">Then it resets the value for this key back to zero, all as part of the same operation:</span></span>

  ```csharp
  ConnectionMultiplexer redisHostConnection = ...;
  IDatabase cache = redisHostConnection.GetDatabase();
  ...
  string oldValue = await cache.StringGetSetAsync("data:counter", 0);
  ```

- <span data-ttu-id="b1fca-524">`MGET` és `MSET` – egyetlen műveletként képes visszaadni vagy módosítani sztringértékek egy készletét.</span><span class="sxs-lookup"><span data-stu-id="b1fca-524">`MGET` and `MSET`, which can return or change a set of string values as a single operation.</span></span> <span data-ttu-id="b1fca-525">Az `IDatabase.StringGetAsync` és `IDatabase.StringSetAsync` metódusok túlterheltek ennek a funkciónak a támogatásához, ahogy a következő példában is látható:</span><span class="sxs-lookup"><span data-stu-id="b1fca-525">The `IDatabase.StringGetAsync` and `IDatabase.StringSetAsync` methods are overloaded to support this functionality, as shown in the following example:</span></span>

  ```csharp
  ConnectionMultiplexer redisHostConnection = ...;
  IDatabase cache = redisHostConnection.GetDatabase();
  ...
  // Create a list of key-value pairs
  var keysAndValues =
      new List<KeyValuePair<RedisKey, RedisValue>>()
      {
          new KeyValuePair<RedisKey, RedisValue>("data:key1", "value1"),
          new KeyValuePair<RedisKey, RedisValue>("data:key99", "value2"),
          new KeyValuePair<RedisKey, RedisValue>("data:key322", "value3")
      };
  
  // Store the list of key-value pairs in the cache
  cache.StringSet(keysAndValues.ToArray());
  ...
  // Find all values that match a list of keys
  RedisKey[] keys = { "data:key1", "data:key99", "data:key322"};
  // values should contain { "value1", "value2", "value3" }
  RedisValue[] values = cache.StringGet(keys);

  ```

<span data-ttu-id="b1fca-526">Több műveletet is egyesíthet egyetlen Redis-tranzakcióba, ahogy azt a jelen cikk korábbi, „Redis-tranzakciók és -kötegek” című részében ismertettük.</span><span class="sxs-lookup"><span data-stu-id="b1fca-526">You can also combine multiple operations into a single Redis transaction as described in the Redis transactions and batches section earlier in this article.</span></span> <span data-ttu-id="b1fca-527">A StackExchange-kódtár az `ITransaction` illesztőn keresztül biztosít támogatást a tranzakciók számára.</span><span class="sxs-lookup"><span data-stu-id="b1fca-527">The StackExchange library provides support for transactions through the `ITransaction` interface.</span></span>

<span data-ttu-id="b1fca-528">Az `ITransaction` objektumok létrehozása az `IDatabase.CreateTransaction` metódussal történik.</span><span class="sxs-lookup"><span data-stu-id="b1fca-528">You create an `ITransaction` object by using the `IDatabase.CreateTransaction` method.</span></span> <span data-ttu-id="b1fca-529">Az `ITransaction` objektum által biztosított metódusokkal hívhat meg parancsokat a tranzakcióhoz.</span><span class="sxs-lookup"><span data-stu-id="b1fca-529">You invoke commands to the transaction by using the methods provided by the `ITransaction` object.</span></span>

<span data-ttu-id="b1fca-530">Az `ITransaction` illesztő metódusok olyan készletéhez biztosít hozzáférést, amely hasonló az `IDatabase` illesztőn keresztül elérhetőhöz, de ezek mindegyike aszinkron metódus.</span><span class="sxs-lookup"><span data-stu-id="b1fca-530">The `ITransaction` interface provides access to a set of methods that's similar to those accessed by the `IDatabase` interface, except that all the methods are asynchronous.</span></span> <span data-ttu-id="b1fca-531">Ez azt jelenti, hogy a végrehajtásukra csak az `ITransaction.Execute` metódus meghívásakor kerül sor.</span><span class="sxs-lookup"><span data-stu-id="b1fca-531">This means that they are only performed when the `ITransaction.Execute` method is invoked.</span></span> <span data-ttu-id="b1fca-532">Az `ITransaction.Execute` metódus által visszaadott érték azt jelzi, hogy a tranzakció sikeresen létrejött-e (igaz) vagy sem (hamis).</span><span class="sxs-lookup"><span data-stu-id="b1fca-532">The value that's returned by the `ITransaction.Execute` method indicates whether the transaction was created successfully (true) or if it failed (false).</span></span>

<span data-ttu-id="b1fca-533">Az alábbi kódrészlet két számláló ugyanazon tranzakció részeként történő növelésére és csökkentésére mutat példát:</span><span class="sxs-lookup"><span data-stu-id="b1fca-533">The following code snippet shows an example that increments and decrements two counters as part of the same transaction:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
ITransaction transaction = cache.CreateTransaction();
var tx1 = transaction.StringIncrementAsync("data:counter1");
var tx2 = transaction.StringDecrementAsync("data:counter2");
bool result = transaction.Execute();
Console.WriteLine("Transaction {0}", result ? "succeeded" : "failed");
Console.WriteLine("Result of increment: {0}", tx1.Result);
Console.WriteLine("Result of decrement: {0}", tx2.Result);
```

<span data-ttu-id="b1fca-534">Ne feledje, hogy a Redis-tranzakciók eltérnek a relációs adatbázisok tranzakcióitól.</span><span class="sxs-lookup"><span data-stu-id="b1fca-534">Remember that Redis transactions are unlike transactions in relational databases.</span></span> <span data-ttu-id="b1fca-535">Az `Execute` metódus egyszerűen sorba állítja a futtatni kívánt tranzakció összes parancsát, és ha ezek közül bármelyik hibás formátumú, akkor leállítja a tranzakciót.</span><span class="sxs-lookup"><span data-stu-id="b1fca-535">The `Execute` method simply queues all the commands that comprise the transaction to be run, and if any of them is malformed then the transaction is stopped.</span></span> <span data-ttu-id="b1fca-536">Ha minden parancs sikeresen sorba lett állítva, akkor a futtatásuk aszinkron módon történik.</span><span class="sxs-lookup"><span data-stu-id="b1fca-536">If all the commands have been queued successfully, each command runs asynchronously.</span></span>

<span data-ttu-id="b1fca-537">Ha egy parancs végrehajtása meghiúsul, a többi parancs feldolgozása tovább folytatódik.</span><span class="sxs-lookup"><span data-stu-id="b1fca-537">If any command fails, the others still continue processing.</span></span> <span data-ttu-id="b1fca-538">Ha ellenőriznie kell, hogy egy parancs sikeresen befejeződött-e, akkor a kapcsolódó művelet **Result** (Eredmény) tulajdonsága segítségével kell lekérnie a parancs eredményét, ahogy az a fenti példában látható.</span><span class="sxs-lookup"><span data-stu-id="b1fca-538">If you need to verify that a command has completed successfully, you must fetch the results of the command by using the **Result** property of the corresponding task, as shown in the example above.</span></span> <span data-ttu-id="b1fca-539">A **Result** tulajdonság olvasásakor a rendszer a feladat bejezéséig blokkolja a hívó szálat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-539">Reading the **Result** property will block the calling thread until the task has completed.</span></span>

<span data-ttu-id="b1fca-540">További információkért lásd: [Redis-tranzakciókkal](https://stackexchange.github.io/StackExchange.Redis/Transactions).</span><span class="sxs-lookup"><span data-stu-id="b1fca-540">For more information, see [Transactions in Redis](https://stackexchange.github.io/StackExchange.Redis/Transactions).</span></span>

<span data-ttu-id="b1fca-541">Kötegműveletek végrehajtásához a StackExchange-kódtár `IBatch` illesztőjét használhatja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-541">When performing batch operations, you can use the `IBatch` interface of the StackExchange library.</span></span> <span data-ttu-id="b1fca-542">Ez az illesztő metódusok olyan készletéhez biztosít hozzáférést, amely hasonló az `IDatabase` illesztőn keresztül elérhetőhöz, de ezek mindegyike aszinkron metódus.</span><span class="sxs-lookup"><span data-stu-id="b1fca-542">This interface provides access to a set of methods similar to those accessed by the `IDatabase` interface, except that all the methods are asynchronous.</span></span>

<span data-ttu-id="b1fca-543">Az `IBatch` objektumok létrehozása az `IDatabase.CreateBatch` metódussal történik, majd az `IBatch.Execute` metódussal futtathatja a köteget, ahogy az alábbi példában látható.</span><span class="sxs-lookup"><span data-stu-id="b1fca-543">You create an `IBatch` object by using the `IDatabase.CreateBatch` method, and then run the batch by using the `IBatch.Execute` method, as shown in the following example.</span></span> <span data-ttu-id="b1fca-544">Ez a kód egyszerűen beállít egy sztringértéket, növeli és csökkenti az előző példában is használt számlálókat, és megjeleníti az eredményeket:</span><span class="sxs-lookup"><span data-stu-id="b1fca-544">This code simply sets a string value, increments and decrements the same counters used in the previous example, and displays the results:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
IBatch batch = cache.CreateBatch();
batch.StringSetAsync("data:key1", 11);
var t1 = batch.StringIncrementAsync("data:counter1");
var t2 = batch.StringDecrementAsync("data:counter2");
batch.Execute();
Console.WriteLine("{0}", t1.Result);
Console.WriteLine("{0}", t2.Result);
```

<span data-ttu-id="b1fca-545">Ne feledje: ha egy kötegbeli parancs hibás formátum miatt meghiúsul, a többi parancs futtatása – a tranzakcióktól eltérően – továbbra is lehetséges marad.</span><span class="sxs-lookup"><span data-stu-id="b1fca-545">It is important to understand that unlike a transaction, if a command in a batch fails because it is malformed, the other commands might still run.</span></span> <span data-ttu-id="b1fca-546">Az `IBatch.Execute` metódus nem jelzi, hogy a végrehajtás sikeres vagy sikertelen-e.</span><span class="sxs-lookup"><span data-stu-id="b1fca-546">The `IBatch.Execute` method does not return any indication of success or failure.</span></span>

### <a name="perform-fire-and-forget-cache-operations"></a><span data-ttu-id="b1fca-547">Nem követendő gyorsítótár-műveletek végrehajtása</span><span class="sxs-lookup"><span data-stu-id="b1fca-547">Perform fire and forget cache operations</span></span>

<span data-ttu-id="b1fca-548">A Redis parancsjelzők használatával támogatja a nem követendő műveleteket.</span><span class="sxs-lookup"><span data-stu-id="b1fca-548">Redis supports fire and forget operations by using command flags.</span></span> <span data-ttu-id="b1fca-549">Az ilyen műveleteket az ügyfél kezdeményezi, de nem érdekli az eredmény, és nem várja meg a parancs befejeződését.</span><span class="sxs-lookup"><span data-stu-id="b1fca-549">In this situation, the client simply initiates an operation but has no interest in the result and does not wait for the command to be completed.</span></span> <span data-ttu-id="b1fca-550">Az alábbi példa egy INCR-parancs nem követendő műveletként való végrehajtását mutatja be:</span><span class="sxs-lookup"><span data-stu-id="b1fca-550">The example below shows how to perform the INCR command as a fire and forget operation:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
await cache.StringSetAsync("data:key1", 99);
...
cache.StringIncrement("data:key1", flags: CommandFlags.FireAndForget);
```

### <a name="specify-automatically-expiring-keys"></a><span data-ttu-id="b1fca-551">Automatikusan lejáró kulcsok megadása</span><span class="sxs-lookup"><span data-stu-id="b1fca-551">Specify automatically expiring keys</span></span>

<span data-ttu-id="b1fca-552">A Redis-gyorsítótárban tárolt elemekhez megadhat egy időtúllépési értéket is, amelynek lejáratát követően a rendszer automatikusan eltávolítja az adott elemet a gyorsítótárból.</span><span class="sxs-lookup"><span data-stu-id="b1fca-552">When you store an item in a Redis cache, you can specify a timeout after which the item will be automatically removed from the cache.</span></span> <span data-ttu-id="b1fca-553">A `TTL` paranccsal lekérdezheti, hogy mennyi idő van még hátra a kulcs lejártáig.</span><span class="sxs-lookup"><span data-stu-id="b1fca-553">You can also query how much more time a key has before it expires by using the `TTL` command.</span></span> <span data-ttu-id="b1fca-554">Ezt a parancsot a StackExchange-alkalmazások az `IDatabase.KeyTimeToLive` metódussal érhetik el.</span><span class="sxs-lookup"><span data-stu-id="b1fca-554">This command is available to StackExchange applications by using the `IDatabase.KeyTimeToLive` method.</span></span>

<span data-ttu-id="b1fca-555">A következő kódrészlet egy 20 másodperces kulcslejárati idő beállítását és a kulcs hátralévő idejének lekérdezését mutatja be:</span><span class="sxs-lookup"><span data-stu-id="b1fca-555">The following code snippet shows how to set an expiration time of 20 seconds on a key, and query the remaining lifetime of the key:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
// Add a key with an expiration time of 20 seconds
await cache.StringSetAsync("data:key1", 99, TimeSpan.FromSeconds(20));
...
// Query how much time a key has left to live
// If the key has already expired, the KeyTimeToLive function returns a null
TimeSpan? expiry = cache.KeyTimeToLive("data:key1");
```

<span data-ttu-id="b1fca-556">Az EXPIRE parancs használatával a lejárati időt egy meghatározott dátumra és időre is beállíthatja. Ez a parancs a StackExchange-kódtárban érhető el, mint `KeyExpireAsync` metódus:</span><span class="sxs-lookup"><span data-stu-id="b1fca-556">You can also set the expiration time to a specific date and time by using the EXPIRE command, which is available in the StackExchange library as the `KeyExpireAsync` method:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
// Add a key with an expiration date of midnight on 1st January 2015
await cache.StringSetAsync("data:key1", 99);
await cache.KeyExpireAsync("data:key1",
    new DateTime(2015, 1, 1, 0, 0, 0, DateTimeKind.Utc));
...
```

> [!TIP]
> <span data-ttu-id="b1fca-557">A DEL parancs használatával bármely elemet eltávolíthat a gyorsítótárból. Ez a parancs a StackExchange kódtárban `IDatabase.KeyDeleteAsync` metódusként érhető el.</span><span class="sxs-lookup"><span data-stu-id="b1fca-557">You can manually remove an item from the cache by using the DEL command, which is available through the StackExchange library as the `IDatabase.KeyDeleteAsync` method.</span></span>

### <a name="use-tags-to-cross-correlate-cached-items"></a><span data-ttu-id="b1fca-558">Címkék használata a gyorsítótárazott elemek összevetéséhez</span><span class="sxs-lookup"><span data-stu-id="b1fca-558">Use tags to cross-correlate cached items</span></span>

<span data-ttu-id="b1fca-559">A Redis-készlet olyan elemek gyűjteménye, amelyek ugyanazt a kulcsot használják.</span><span class="sxs-lookup"><span data-stu-id="b1fca-559">A Redis set is a collection of multiple items that share a single key.</span></span> <span data-ttu-id="b1fca-560">A készletek az SADD paranccsal hozhatók létre.</span><span class="sxs-lookup"><span data-stu-id="b1fca-560">You can create a set by using the SADD command.</span></span> <span data-ttu-id="b1fca-561">Az adott készletben lévő elemek az SMEMBERS paranccsal kérhetők le.</span><span class="sxs-lookup"><span data-stu-id="b1fca-561">You can retrieve the items in a set by using the SMEMBERS command.</span></span> <span data-ttu-id="b1fca-562">A StackExchange-kódtár az SADD parancsot az `IDatabase.SetAddAsync`, az SMEMBERS parancsot pedig az `IDatabase.SetMembersAsync` metódussal hajtja végre.</span><span class="sxs-lookup"><span data-stu-id="b1fca-562">The StackExchange library implements the SADD command with the `IDatabase.SetAddAsync` method, and the SMEMBERS command with the `IDatabase.SetMembersAsync` method.</span></span>

<span data-ttu-id="b1fca-563">A meglévő készleteket új készletek létrehozásához az SDIFF (különbség beállítása), az SINTER (metszet beállítása) és az SUNION (unió beállítása) parancsok használatával egyesítheti.</span><span class="sxs-lookup"><span data-stu-id="b1fca-563">You can also combine existing sets to create new sets by using the SDIFF (set difference), SINTER (set intersection), and SUNION (set union) commands.</span></span> <span data-ttu-id="b1fca-564">A StackExchange-kódtár ezeket a műveleteket az `IDatabase.SetCombineAsync` metódusban egyesíti.</span><span class="sxs-lookup"><span data-stu-id="b1fca-564">The StackExchange library unifies these operations in the `IDatabase.SetCombineAsync` method.</span></span> <span data-ttu-id="b1fca-565">A metódus első paramétere az elvégzendő műveletet határozza meg.</span><span class="sxs-lookup"><span data-stu-id="b1fca-565">The first parameter to this method specifies the set operation to perform.</span></span>

<span data-ttu-id="b1fca-566">Az alábbi kódrészletek azt mutatják be, hogyan alkalmazhatók a készletek a kapcsolódó elemek gyűjteményének gyors tárolására és lekérdezésére.</span><span class="sxs-lookup"><span data-stu-id="b1fca-566">The following code snippets show how sets can be useful for quickly storing and retrieving collections of related items.</span></span> <span data-ttu-id="b1fca-567">A kód által használt `BlogPost` típust a jelen cikk korábbi, „Redis gyorsítótár-ügyfélalkalmazások megvalósítása” című szakaszában mutattuk be.</span><span class="sxs-lookup"><span data-stu-id="b1fca-567">This code uses the `BlogPost` type that was described in the section Implement Redis Cache Client Applications earlier in this article.</span></span>

<span data-ttu-id="b1fca-568">A `BlogPost` objektum tartalmazza a négy mezőt &mdash; azonosító, cím, rangsorolási pontszám és címkék gyűjteménye.</span><span class="sxs-lookup"><span data-stu-id="b1fca-568">A `BlogPost` object contains four fields &mdash; an ID, a title, a ranking score, and a collection of tags.</span></span> <span data-ttu-id="b1fca-569">Az alábbi első kódrészlet azokat a mintaadatokat mutatja be, amelyeket a rendszer a `BlogPost` objektumok C# listájának feltöltéséhez használ:</span><span class="sxs-lookup"><span data-stu-id="b1fca-569">The first code snippet below shows the sample data that's used for populating a C# list of `BlogPost` objects:</span></span>

```csharp
List<string[]> tags = new List<string[]>
{
    new[] { "iot","csharp" },
    new[] { "iot","azure","csharp" },
    new[] { "csharp","git","big data" },
    new[] { "iot","git","database" },
    new[] { "database","git" },
    new[] { "csharp","database" },
    new[] { "iot" },
    new[] { "iot","database","git" },
    new[] { "azure","database","big data","git","csharp" },
    new[] { "azure" }
};

List<BlogPost> posts = new List<BlogPost>();
int blogKey = 1;
int numberOfPosts = 20;
Random random = new Random();
for (int i = 0; i < numberOfPosts; i++)
{
    blogKey++;
    posts.Add(new BlogPost(
        blogKey,                  // Blog post ID
        string.Format(CultureInfo.InvariantCulture, "Blog Post #{0}",
            blogKey),             // Blog post title
        random.Next(100, 10000),  // Ranking score
        tags[i % tags.Count]));   // Tags--assigned from a collection
                                  // in the tags list
}
```

<span data-ttu-id="b1fca-570">Az egyes `BlogPost` objektumokhoz tartozó címkéket tárolhatja készletként egy Redis-gyorsítótárban, és minden egyes készlethez hozzárendelheti a `BlogPost` azonosítóját.</span><span class="sxs-lookup"><span data-stu-id="b1fca-570">You can store the tags for each `BlogPost` object as a set in a Redis cache and associate each set with the ID of the `BlogPost`.</span></span> <span data-ttu-id="b1fca-571">Ez teszi lehetővé az alkalmazások számára, hogy gyorsan megtalálják az adott blogbejegyzéshez tartozó összes címkét.</span><span class="sxs-lookup"><span data-stu-id="b1fca-571">This enables an application to quickly find all the tags that belong to a specific blog post.</span></span> <span data-ttu-id="b1fca-572">Az ellenkező irányban végzett keresés engedélyezéséhez és egy adott címkével ellátott összes blogbejegyzés megkereséséhez létrehozhat egy másik készletet, amely a kulcsban található címkeazonosítóra hivatkozó blogbejegyzéseket tartalmazza:</span><span class="sxs-lookup"><span data-stu-id="b1fca-572">To enable searching in the opposite direction and find all blog posts that share a specific tag, you can create another set that holds the blog posts referencing the tag ID in the key:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
// Tags are easily represented as Redis Sets
foreach (BlogPost post in posts)
{
    string redisKey = string.Format(CultureInfo.InvariantCulture,
        "blog:posts:{0}:tags", post.Id);
    // Add tags to the blog post in Redis
    await cache.SetAddAsync(
        redisKey, post.Tags.Select(s => (RedisValue)s).ToArray());

    // Now do the inverse so we can figure out which blog posts have a given tag
    foreach (var tag in post.Tags)
    {
        await cache.SetAddAsync(string.Format(CultureInfo.InvariantCulture,
            "tag:{0}:blog:posts", tag), post.Id);
    }
}
```

<span data-ttu-id="b1fca-573">Ezzel a struktúrával sok gyakori lekérdezés nagyon hatékonyan végrehajtható.</span><span class="sxs-lookup"><span data-stu-id="b1fca-573">These structures enable you to perform many common queries very efficiently.</span></span> <span data-ttu-id="b1fca-574">Megkeresheti és megjelenítheti például az 1. blogbejegyzés összes címkéjét, a következőhöz hasonlóan:</span><span class="sxs-lookup"><span data-stu-id="b1fca-574">For example, you can find and display all of the tags for blog post 1 like this:</span></span>

```csharp
// Show the tags for blog post #1
foreach (var value in await cache.SetMembersAsync("blog:posts:1:tags"))
{
    Console.WriteLine(value);
}
```

<span data-ttu-id="b1fca-575">Az 1. és a 2. blogbejegyzés közös címkéit a következő, metszést beállító művelettel keresheti meg:</span><span class="sxs-lookup"><span data-stu-id="b1fca-575">You can find all tags that are common to blog post 1 and blog post 2 by performing a set intersection operation, as follows:</span></span>

```csharp
// Show the tags in common for blog posts #1 and #2
foreach (var value in await cache.SetCombineAsync(SetOperation.Intersect, new RedisKey[]
    { "blog:posts:1:tags", "blog:posts:2:tags" }))
{
    Console.WriteLine(value);
}
```

<span data-ttu-id="b1fca-576">Így pedig megkereshet minden olyan blogbejegyzést, amely egy adott címkét tartalmaz:</span><span class="sxs-lookup"><span data-stu-id="b1fca-576">And you can find all blog posts that contain a specific tag:</span></span>

```csharp
// Show the ids of the blog posts that have the tag "iot".
foreach (var value in await cache.SetMembersAsync("tag:iot:blog:posts"))
{
    Console.WriteLine(value);
}
```

### <a name="find-recently-accessed-items"></a><span data-ttu-id="b1fca-577">Legutóbb elért elemek megkeresése</span><span class="sxs-lookup"><span data-stu-id="b1fca-577">Find recently accessed items</span></span>

<span data-ttu-id="b1fca-578">Számos alkalmazás esetében szükség van a legutóbb elért elemek megkeresésére.</span><span class="sxs-lookup"><span data-stu-id="b1fca-578">A common task required of many applications is to find the most recently accessed items.</span></span> <span data-ttu-id="b1fca-579">Előfordulhat például, hogy egy blog információkat szeretne megjeleníteni a legutóbb olvasott blogbejegyzésekről.</span><span class="sxs-lookup"><span data-stu-id="b1fca-579">For example, a blogging site might want to display information about the most recently read blog posts.</span></span>

<span data-ttu-id="b1fca-580">Ez a feladat egy Redis-lista segítségével hajtható végre.</span><span class="sxs-lookup"><span data-stu-id="b1fca-580">You can implement this functionality by using a Redis list.</span></span> <span data-ttu-id="b1fca-581">A Redis-lista olyan elemeket tartalmaz, amelyek ugyanazt a kulcsot használják.</span><span class="sxs-lookup"><span data-stu-id="b1fca-581">A Redis list contains multiple items that share the same key.</span></span> <span data-ttu-id="b1fca-582">A lista kétvégű üzenetsorként működik.</span><span class="sxs-lookup"><span data-stu-id="b1fca-582">The list acts as a double-ended queue.</span></span> <span data-ttu-id="b1fca-583">Az elemeket a lista bármelyik végére leküldheti az LPUSH (leküldés balra) és az RPUSH (leküldés jobbra) paranccsal.</span><span class="sxs-lookup"><span data-stu-id="b1fca-583">You can push items to either end of the list by using the LPUSH (left push) and RPUSH (right push) commands.</span></span> <span data-ttu-id="b1fca-584">Az elemeket a lista bármelyik végéről lekérdezheti az LPOP és az RPOP paranccsal.</span><span class="sxs-lookup"><span data-stu-id="b1fca-584">You can retrieve items from either end of the list by using the LPOP and RPOP commands.</span></span> <span data-ttu-id="b1fca-585">Elemkészlet is visszaadható az LRANGE és RRANGE parancsokkal.</span><span class="sxs-lookup"><span data-stu-id="b1fca-585">You can also return a set of elements by using the LRANGE and RRANGE commands.</span></span>

<span data-ttu-id="b1fca-586">Az alábbi kódrészletek azt mutatják be, hogyan végezhetők el ezek a műveletek a StackExchange-kódtár használatával.</span><span class="sxs-lookup"><span data-stu-id="b1fca-586">The code snippets below show how you can perform these operations by using the StackExchange library.</span></span> <span data-ttu-id="b1fca-587">Ez a kód az előző példa `BlogPost` típusát használja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-587">This code uses the `BlogPost` type from the previous examples.</span></span> <span data-ttu-id="b1fca-588">Mivel a blogbejegyzéseket felhasználók olvassák, az `IDatabase.ListLeftPushAsync` metódus a blogbejegyzés címét egy olyan listára küldi le, amely a Redis-gyorsítótárban lévő „blog: recent_posts” kulcshoz van társítva.</span><span class="sxs-lookup"><span data-stu-id="b1fca-588">As a blog post is read by a user, the `IDatabase.ListLeftPushAsync` method pushes the title of the blog post onto a list that's associated with the key "blog:recent_posts" in the Redis cache.</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
string redisKey = "blog:recent_posts";
BlogPost blogPost = ...; // Reference to the blog post that has just been read
await cache.ListLeftPushAsync(
    redisKey, blogPost.Title); // Push the blog post onto the list
```

<span data-ttu-id="b1fca-589">Ahogy a felhasználók további blogbejegyzéseket olvasnak el, azok címeit is ugyanarra a listára küldi le a rendszer.</span><span class="sxs-lookup"><span data-stu-id="b1fca-589">As more blog posts are read, their titles are pushed onto the same list.</span></span> <span data-ttu-id="b1fca-590">A lista rendezésére a címek hozzáadási sorrendjében kerül sor.</span><span class="sxs-lookup"><span data-stu-id="b1fca-590">The list is ordered by the sequence in which the titles have been added.</span></span> <span data-ttu-id="b1fca-591">A legutóbb olvasott blogbejegyzések a lista bal oldalán jelennek meg.</span><span class="sxs-lookup"><span data-stu-id="b1fca-591">The most recently read blog posts are towards the left end of the list.</span></span> <span data-ttu-id="b1fca-592">(Ha ugyanazt a blogbejegyzést többször is olvasták, több bejegyzésben is szerepel a listában.)</span><span class="sxs-lookup"><span data-stu-id="b1fca-592">(If the same blog post is read more than once, it will have multiple entries in the list.)</span></span>

<span data-ttu-id="b1fca-593">A legutóbb olvasott bejegyzések címeit az `IDatabase.ListRange` metódussal jelenítheti meg.</span><span class="sxs-lookup"><span data-stu-id="b1fca-593">You can display the titles of the most recently read posts by using the `IDatabase.ListRange` method.</span></span> <span data-ttu-id="b1fca-594">Ez a metódus a listát alkotó kulcsot, valamint a kiindulási és a végpontot használja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-594">This method takes the key that contains the list, a starting point, and an ending point.</span></span> <span data-ttu-id="b1fca-595">A következő kód 10 blogbejegyzés címét (0–9. elem) kérdezi le a lista bal oldali végéről:</span><span class="sxs-lookup"><span data-stu-id="b1fca-595">The following code retrieves the titles of the 10 blog posts (items from 0 to 9) at the left-most end of the list:</span></span>

```csharp
// Show latest ten posts
foreach (string postTitle in await cache.ListRangeAsync(redisKey, 0, 9))
{
    Console.WriteLine(postTitle);
}
```

<span data-ttu-id="b1fca-596">Vegye figyelembe, hogy a `ListRangeAsync` metódus nem távolít el elemeket a listáról.</span><span class="sxs-lookup"><span data-stu-id="b1fca-596">Note that the `ListRangeAsync` method does not remove items from the list.</span></span> <span data-ttu-id="b1fca-597">Erre az `IDatabase.ListLeftPopAsync` és `IDatabase.ListRightPopAsync` metódusokat használhatja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-597">To do this, you can use the `IDatabase.ListLeftPopAsync` and `IDatabase.ListRightPopAsync` methods.</span></span>

<span data-ttu-id="b1fca-598">Ha nem szeretné, hogy a lista folyamatosan egyre hosszabb legyen, rendszeres időközönként kiselejtezhet elemeket a listáról.</span><span class="sxs-lookup"><span data-stu-id="b1fca-598">To prevent the list from growing indefinitely, you can periodically cull items by trimming the list.</span></span> <span data-ttu-id="b1fca-599">Az alábbi kódrészlet azt mutatja be, hogyan távolítható el az összes elem a listáról az öt bal szélső elem kivételével:</span><span class="sxs-lookup"><span data-stu-id="b1fca-599">The code snippet below shows you how to remove all but the five left-most items from the list:</span></span>

```csharp
await cache.ListTrimAsync(redisKey, 0, 5);
```

### <a name="implement-a-leader-board"></a><span data-ttu-id="b1fca-600">Ranglista létrehozása</span><span class="sxs-lookup"><span data-stu-id="b1fca-600">Implement a leader board</span></span>

<span data-ttu-id="b1fca-601">Alapértelmezett esetben a készletekben lévő elemek nincsenek meghatározott sorrendbe állítva.</span><span class="sxs-lookup"><span data-stu-id="b1fca-601">By default, the items in a set are not held in any specific order.</span></span> <span data-ttu-id="b1fca-602">A készleteket a ZADD paranccsal (a StackExchange-kódtár `IDatabase.SortedSetAdd` metódusával) rendszerezheti.</span><span class="sxs-lookup"><span data-stu-id="b1fca-602">You can create an ordered set by using the ZADD command (the `IDatabase.SortedSetAdd` method in the StackExchange library).</span></span> <span data-ttu-id="b1fca-603">A tételek rendezése egy pontszámnak nevezett numerikus érték használatával történik, amelyet paraméterként adunk meg a parancs számára.</span><span class="sxs-lookup"><span data-stu-id="b1fca-603">The items are ordered by using a numeric value called a score, which is provided as a parameter to the command.</span></span>

<span data-ttu-id="b1fca-604">Az alábbi kódrészlet egy blogbejegyzés címét adja hozzá egy rendezett listához.</span><span class="sxs-lookup"><span data-stu-id="b1fca-604">The following code snippet adds the title of a blog post to an ordered list.</span></span> <span data-ttu-id="b1fca-605">Ebben a példában mindegyik blogbejegyzéshez tartozik egy-egy pontszám mező is, amely a blogbejegyzés rangsorolását tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="b1fca-605">In this example, each blog post also has a score field that contains the ranking of the blog post.</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
string redisKey = "blog:post_rankings";
BlogPost blogPost = ...; // Reference to a blog post that has just been rated
await cache.SortedSetAddAsync(redisKey, blogPost.Title, blogPost.Score);
```

<span data-ttu-id="b1fca-606">A blogbejegyzések címeit és pontszámait növekvő sorrendben az `IDatabase.SortedSetRangeByRankWithScores` metódussal lehet lekérdezni:</span><span class="sxs-lookup"><span data-stu-id="b1fca-606">You can retrieve the blog post titles and scores in ascending score order by using the `IDatabase.SortedSetRangeByRankWithScores` method:</span></span>

```csharp
foreach (var post in await cache.SortedSetRangeByRankWithScoresAsync(redisKey))
{
    Console.WriteLine(post);
}
```

> [!NOTE]
> <span data-ttu-id="b1fca-607">A StackExchange-kódtár az `IDatabase.SortedSetRangeByRankAsync` metódust is biztosítja, amely az eredményeket pontszám szerinti sorrendben adja vissza, de nem adja vissza a pontszámokat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-607">The StackExchange library also provides the `IDatabase.SortedSetRangeByRankAsync` method, which returns the data in score order, but does not return the scores.</span></span>

<span data-ttu-id="b1fca-608">Az elemek csökkenő pontszám szerinti sorrendben is lekérdezhetők, illetve korlátozható a visszaadott elemek száma, ha további paramétereket adunk meg az `IDatabase.SortedSetRangeByRankWithScoresAsync` metódusnak.</span><span class="sxs-lookup"><span data-stu-id="b1fca-608">You can also retrieve items in descending order of scores, and limit the number of items that are returned by providing additional parameters to the `IDatabase.SortedSetRangeByRankWithScoresAsync` method.</span></span> <span data-ttu-id="b1fca-609">A következő példa a 10 legmagasabb pontszámmal rendelkező blogbejegyzés címét és pontszámát jeleníti meg:</span><span class="sxs-lookup"><span data-stu-id="b1fca-609">The next example displays the titles and scores of the top 10 ranked blog posts:</span></span>

```csharp
foreach (var post in await cache.SortedSetRangeByRankWithScoresAsync(
                               redisKey, 0, 9, Order.Descending))
{
    Console.WriteLine(post);
}
```

<span data-ttu-id="b1fca-610">A következő példa az `IDatabase.SortedSetRangeByScoreWithScoresAsync` metódust használja, amellyel egy adott pontszámtartományra korlátozható a visszaadott elemek köre:</span><span class="sxs-lookup"><span data-stu-id="b1fca-610">The next example uses the `IDatabase.SortedSetRangeByScoreWithScoresAsync` method, which you can use to limit the items that are returned to those that fall within a given score range:</span></span>

```csharp
// Blog posts with scores between 5000 and 100000
foreach (var post in await cache.SortedSetRangeByScoreWithScoresAsync(
                               redisKey, 5000, 100000))
{
    Console.WriteLine(post);
}
```

### <a name="message-by-using-channels"></a><span data-ttu-id="b1fca-611">Üzenetküldés csatornák használatával</span><span class="sxs-lookup"><span data-stu-id="b1fca-611">Message by using channels</span></span>

<span data-ttu-id="b1fca-612">Amellett, hogy gyorsítótárként működnek, a Redis-kiszolgálók nagy teljesítményű közzétevői/előfizetői mechanizmuson alapuló üzenetküldésre is használhatók.</span><span class="sxs-lookup"><span data-stu-id="b1fca-612">Apart from acting as a data cache, a Redis server provides messaging through a high-performance publisher/subscriber mechanism.</span></span> <span data-ttu-id="b1fca-613">Az ügyfélalkalmazások előfizethetnek egy csatornára, amelyen más alkalmazások vagy szolgáltatások üzeneteket tudnak közzétenni.</span><span class="sxs-lookup"><span data-stu-id="b1fca-613">Client applications can subscribe to a channel, and other applications or services can publish messages to the channel.</span></span> <span data-ttu-id="b1fca-614">Az előfizetéssel rendelkező alkalmazások megkapják ezeket az üzeneteket, és fel tudják őket dolgozni.</span><span class="sxs-lookup"><span data-stu-id="b1fca-614">Subscribing applications will then receive these messages and can process them.</span></span>

<span data-ttu-id="b1fca-615">A Redis a SUBSCRIBE parancsot biztosítja az ügyfélalkalmazások számára a csatornákra való előfizetéshez.</span><span class="sxs-lookup"><span data-stu-id="b1fca-615">Redis provides the SUBSCRIBE command for client applications to use to subscribe to channels.</span></span> <span data-ttu-id="b1fca-616">Ez a parancs egy vagy több olyan csatorna nevét várja, amelyen az alkalmazás fogadja az üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="b1fca-616">This command expects the name of one or more channels on which the application will accept messages.</span></span> <span data-ttu-id="b1fca-617">A StackExchange-kódtár tartalmazza az `ISubscription` illesztőt, amely lehetővé teszi a .NET-keretrendszert használó alkalmazások számára a csatornákra való előfizetést és a rajtuk történő közzétételt.</span><span class="sxs-lookup"><span data-stu-id="b1fca-617">The StackExchange library includes the `ISubscription` interface, which enables a .NET Framework application to subscribe and publish to channels.</span></span>

<span data-ttu-id="b1fca-618">Az `ISubscription`-objektumot a Redis-kiszolgálóhoz történő kapcsolódás `GetSubscriber` metódusával lehet létrehozni.</span><span class="sxs-lookup"><span data-stu-id="b1fca-618">You create an `ISubscription` object by using the `GetSubscriber` method of the connection to the Redis server.</span></span> <span data-ttu-id="b1fca-619">Ezt követően a csatorna üzeneteit ennek az objektumnak a `SubscribeAsync` metódusával figyelheti.</span><span class="sxs-lookup"><span data-stu-id="b1fca-619">Then you listen for messages on a channel by using the `SubscribeAsync` method of this object.</span></span> <span data-ttu-id="b1fca-620">A következő példakód azt mutatja be, hogyan lehet előfizetni a „messages:blogPosts” nevű csatornára:</span><span class="sxs-lookup"><span data-stu-id="b1fca-620">The following code example shows how to subscribe to a channel named "messages:blogPosts":</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
ISubscriber subscriber = redisHostConnection.GetSubscriber();
...
await subscriber.SubscribeAsync("messages:blogPosts", (channel, message) => Console.WriteLine("Title is: {0}", message));
```

<span data-ttu-id="b1fca-621">A `Subscribe` metódus számára megadott első paraméter a csatorna neve.</span><span class="sxs-lookup"><span data-stu-id="b1fca-621">The first parameter to the `Subscribe` method is the name of the channel.</span></span> <span data-ttu-id="b1fca-622">Erre a névre ugyanazok a konvenciók vonatkoznak, mint a gyorsítótár kulcsaira.</span><span class="sxs-lookup"><span data-stu-id="b1fca-622">This name follows the same conventions that are used by keys in the cache.</span></span> <span data-ttu-id="b1fca-623">A név tartalmazhat bármilyen bináris adatot, bár ajánlott viszonylag rövid, jelentéssel bíró sztringekat használni a megfelelő teljesítmény és karbantarthatóság érdekében.</span><span class="sxs-lookup"><span data-stu-id="b1fca-623">The name can contain any binary data, although it is advisable to use relatively short, meaningful strings to help ensure good performance and maintainability.</span></span>

<span data-ttu-id="b1fca-624">Vegye figyelembe azt is, hogy a csatornák által használt névtér el van választva a kulcsok által használt névtértől.</span><span class="sxs-lookup"><span data-stu-id="b1fca-624">Note also that the namespace used by channels is separate from that used by keys.</span></span> <span data-ttu-id="b1fca-625">Ez azt jelenti, hogy azonos nevű csatornák és kulcsok is előfordulhatnak, bár ez megnehezítheti az alkalmazáskód karbantartását.</span><span class="sxs-lookup"><span data-stu-id="b1fca-625">This means you can have channels and keys that have the same name, although this may make your application code more difficult to maintain.</span></span>

<span data-ttu-id="b1fca-626">A második paraméter egy Művelet delegált.</span><span class="sxs-lookup"><span data-stu-id="b1fca-626">The second parameter is an Action delegate.</span></span> <span data-ttu-id="b1fca-627">Ezt a delegáltat a rendszer aszinkron módon lefuttatja, amikor egy új üzenet jelenik meg a csatornán.</span><span class="sxs-lookup"><span data-stu-id="b1fca-627">This delegate runs asynchronously whenever a new message appears on the channel.</span></span> <span data-ttu-id="b1fca-628">Ebben a példában az üzenet egyszerűen megjelenik a konzolon (az üzenet tartalmazza a blogbejegyzés címét).</span><span class="sxs-lookup"><span data-stu-id="b1fca-628">This example simply displays the message on the console (the message will contain the title of a blog post).</span></span>

<span data-ttu-id="b1fca-629">A csatornán történő közzétételéhez az alkalmazások a Redis PUBLISH parancsát használják.</span><span class="sxs-lookup"><span data-stu-id="b1fca-629">To publish to a channel, an application can use the Redis PUBLISH command.</span></span> <span data-ttu-id="b1fca-630">Ezen művelet végrehajtásához a StackExchange-kódtár az `IServer.PublishAsync` metódust biztosítja.</span><span class="sxs-lookup"><span data-stu-id="b1fca-630">The StackExchange library provides the `IServer.PublishAsync` method to perform this operation.</span></span> <span data-ttu-id="b1fca-631">A következő kódrészlet azt mutatja be, hogyan lehet üzenetet közzétenni a „messages:blogPosts” nevű csatornán:</span><span class="sxs-lookup"><span data-stu-id="b1fca-631">The next code snippet shows how to publish a message to the "messages:blogPosts" channel:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
ISubscriber subscriber = redisHostConnection.GetSubscriber();
...
BlogPost blogPost = ...;
subscriber.PublishAsync("messages:blogPosts", blogPost.Title);
```

<span data-ttu-id="b1fca-632">A közzétevői/előfizetői mechanizmus fontos jellemzői:</span><span class="sxs-lookup"><span data-stu-id="b1fca-632">There are several points you should understand about the publish/subscribe mechanism:</span></span>

- <span data-ttu-id="b1fca-633">Több előfizető is feliratkozhat ugyanarra a csatornára, és mindegyik megkapja az adott csatornán közzétett üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="b1fca-633">Multiple subscribers can subscribe to the same channel, and they will all receive the messages that are published to that channel.</span></span>
- <span data-ttu-id="b1fca-634">Az előfizetők csak azokat az üzeneteket kapják meg, amelyeket az előfizetés időpontját követően tettek közzé.</span><span class="sxs-lookup"><span data-stu-id="b1fca-634">Subscribers only receive messages that have been published after they have subscribed.</span></span> <span data-ttu-id="b1fca-635">A csatornák nem puffereltek, és az üzenet közzétételét követően a Redis-infrastruktúra minden egyes előfizetőnek leküldi az üzenetet, majd eltávolítja azt.</span><span class="sxs-lookup"><span data-stu-id="b1fca-635">Channels are not buffered, and once a message is published, the Redis infrastructure pushes the message to each subscriber and then removes it.</span></span>
- <span data-ttu-id="b1fca-636">Alapértelmezés szerint az előfizetők az üzeneteket az elküldés sorrendjében kapják meg.</span><span class="sxs-lookup"><span data-stu-id="b1fca-636">By default, messages are received by subscribers in the order in which they are sent.</span></span> <span data-ttu-id="b1fca-637">Nagy aktivitást mutató, nagy számú üzenettel, illetve sok előfizetővel és közzétevővel rendelkező rendszerek esetében az üzenetek garantáltan sorrendben történő kézbesítése csökkentheti a rendszer teljesítményét.</span><span class="sxs-lookup"><span data-stu-id="b1fca-637">In a highly active system with a large number of messages and many subscribers and publishers, guaranteed sequential delivery of messages can slow performance of the system.</span></span> <span data-ttu-id="b1fca-638">Ha az üzenetek egymástól függetlenek, és a sorrendjük nem lényeges, engedélyezheti a Redis-rendszer számára az egyidejű feldolgozást, amely révén javítható a válaszképesség.</span><span class="sxs-lookup"><span data-stu-id="b1fca-638">If each message is independent and the order is unimportant, you can enable concurrent processing by the Redis system, which can help to improve responsiveness.</span></span> <span data-ttu-id="b1fca-639">Ez egy StackExchange-ügyfélben úgy valósítható meg, hogy az előfizető által használt kapcsolat PreserveAsyncOrder paraméternél a „hamis” értéket adja meg:</span><span class="sxs-lookup"><span data-stu-id="b1fca-639">You can achieve this in a StackExchange client by setting the PreserveAsyncOrder of the connection used by the subscriber to false:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
redisHostConnection.PreserveAsyncOrder = false;
ISubscriber subscriber = redisHostConnection.GetSubscriber();
```

### <a name="serialization-considerations"></a><span data-ttu-id="b1fca-640">Szerializálási szempontok</span><span class="sxs-lookup"><span data-stu-id="b1fca-640">Serialization considerations</span></span>

<span data-ttu-id="b1fca-641">Amikor kiválaszt egy szerializálási formátumot, fontolja meg a teljesítmény, az együttműködési lehetőségek, a verziókezelés, a meglévő rendszerekkel fennálló kompatibilitás, az adatok tömörítése és a memóriaterhelés terén érvényesíthető kompromisszumokat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-641">When you choose a serialization format, consider tradeoffs between performance, interoperability, versioning, compatibility with existing systems, data compression, and memory overhead.</span></span> <span data-ttu-id="b1fca-642">A teljesítmény kiértékelése során ne feledje, hogy a referenciaértékek nagymértékben függnek a környezettől.</span><span class="sxs-lookup"><span data-stu-id="b1fca-642">When you are evaluating performance, remember that benchmarks are highly dependent on context.</span></span> <span data-ttu-id="b1fca-643">Előfordulhat, hogy nem tükrözik a tényleges számítási feladatok hatását, és nem feltétlenül veszik figyelembe az újabb kódtárakat vagy verziókat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-643">They may not reflect your actual workload, and may not consider newer libraries or versions.</span></span> <span data-ttu-id="b1fca-644">Különböző alkalmazási helyzetekben különböző szerializálók bizonyulhatnak a leghatékonyabbnak.</span><span class="sxs-lookup"><span data-stu-id="b1fca-644">There is no single "fastest" serializer for all scenarios.</span></span>

<span data-ttu-id="b1fca-645">Szóba jöhető lehetőségek:</span><span class="sxs-lookup"><span data-stu-id="b1fca-645">Some options to consider include:</span></span>

- <span data-ttu-id="b1fca-646">[Protokollpufferek](https://github.com/google/protobuf) (más néven protopuf): a Google által kifejlesztett szerializációs formátum a strukturált adatok hatékony szerializálásához.</span><span class="sxs-lookup"><span data-stu-id="b1fca-646">[Protocol Buffers](https://github.com/google/protobuf) (also called protobuf) is a serialization format developed by Google for serializing structured data efficiently.</span></span> <span data-ttu-id="b1fca-647">Ez a módszer az üzenetstruktúrák meghatározásához szigorú típusmegadású definíciós fájlokat használ.</span><span class="sxs-lookup"><span data-stu-id="b1fca-647">It uses strongly-typed definition files to define message structures.</span></span> <span data-ttu-id="b1fca-648">A rendszer a későbbiekben ezekből a definíciós fájlokból állít össze egy nyelvspecifikus kódot az üzenetek szerializálásához és deszerializálásához.</span><span class="sxs-lookup"><span data-stu-id="b1fca-648">These definition files are then compiled to language-specific code for serializing and deserializing messages.</span></span> <span data-ttu-id="b1fca-649">A protopuf a meglévő RPC-mechanizmusokhoz is használható, de egy új RPC-szolgáltatást is létre tud hozni.</span><span class="sxs-lookup"><span data-stu-id="b1fca-649">Protobuf can be used over existing RPC mechanisms, or it can generate an RPC service.</span></span>

- <span data-ttu-id="b1fca-650">Az [Apache Thrift](https://thrift.apache.org/) hasonló megközelítést alkalmaz, szigorú típusmegadású definíciós fájlokkal és egy fordítási lépéssel a szerializálási kód és az RPC-szolgáltatások létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="b1fca-650">[Apache Thrift](https://thrift.apache.org/) uses a similar approach, with strongly typed definition files and a compilation step to generate the serialization code and RPC services.</span></span>

- <span data-ttu-id="b1fca-651">Az [Apache Avro](https://avro.apache.org/) funkciói hasonlóak a protokollpufferekhez és a Thrifthez, de hiányzik belőle a fordítási lépés.</span><span class="sxs-lookup"><span data-stu-id="b1fca-651">[Apache Avro](https://avro.apache.org/) provides similar functionality to Protocol Buffers and Thrift, but there is no compilation step.</span></span> <span data-ttu-id="b1fca-652">Ehelyett a szerializált adatok mindig tartalmaznak egy olyan sémát, amelyek leírják a struktúrát.</span><span class="sxs-lookup"><span data-stu-id="b1fca-652">Instead, serialized data always includes a schema that describes the structure.</span></span>

- <span data-ttu-id="b1fca-653">A [JSON](https://json.org/) egy felhasználók számára olvasható szövegmezőket használó nyílt szabvány,</span><span class="sxs-lookup"><span data-stu-id="b1fca-653">[JSON](https://json.org/) is an open standard that uses human-readable text fields.</span></span> <span data-ttu-id="b1fca-654">amely széleskörű, platformfüggetlen támogatást biztosít.</span><span class="sxs-lookup"><span data-stu-id="b1fca-654">It has broad cross-platform support.</span></span> <span data-ttu-id="b1fca-655">A JSON nem használ üzenetsémákat.</span><span class="sxs-lookup"><span data-stu-id="b1fca-655">JSON does not use message schemas.</span></span> <span data-ttu-id="b1fca-656">Mivel szöveges formátumról van szó, a hálózaton keresztüli továbbítása nem túl hatékony.</span><span class="sxs-lookup"><span data-stu-id="b1fca-656">Being a text-based format, it is not very efficient over the wire.</span></span> <span data-ttu-id="b1fca-657">Bizonyos esetekben azonban előfordulhat, hogy a gyorsítótárazott elemeket HTTP-kapcsolaton keresztül küldi vissza közvetlenül az ügyfélnek, amely esetben a JSON formátumban történő tárolással megtakarítható a más formátumról történő deszerializálás, majd a JSON formátumra való szerializálás költsége.</span><span class="sxs-lookup"><span data-stu-id="b1fca-657">In some cases, however, you may be returning cached items directly to a client via HTTP, in which case storing JSON could save the cost of deserializing from another format and then serializing to JSON.</span></span>

- <span data-ttu-id="b1fca-658">A [BSON](http://bsonspec.org/) egy, a JSON-hoz hasonló struktúrát használó, bináris szerializálási formátum.</span><span class="sxs-lookup"><span data-stu-id="b1fca-658">[BSON](http://bsonspec.org/) is a binary serialization format that uses a structure similar to JSON.</span></span> <span data-ttu-id="b1fca-659">A BSON formátum kialakítása során a cél az volt, hogy a JSON-hoz képest kisebb méretű, könnyebben beolvasható, gyorsabban szerializálható és deszerializálható legyen.</span><span class="sxs-lookup"><span data-stu-id="b1fca-659">BSON was designed to be lightweight, easy to scan, and fast to serialize and deserialize, relative to JSON.</span></span> <span data-ttu-id="b1fca-660">A hasznos adatok mérete a JSON-éhoz hasonló.</span><span class="sxs-lookup"><span data-stu-id="b1fca-660">Payloads are comparable in size to JSON.</span></span> <span data-ttu-id="b1fca-661">Az adatoktól függően a BSON hasznos adatainak mérete kisebb vagy nagyobb is lehet a JSON-énál.</span><span class="sxs-lookup"><span data-stu-id="b1fca-661">Depending on the data, a BSON payload may be smaller or larger than a JSON payload.</span></span> <span data-ttu-id="b1fca-662">A BSON rendelkezik néhány olyan adattípussal, amelyek nem érhetők el a JSON-ban. Ilyen például a BinData (bájttömbökhöz) és a Date (Dátum).</span><span class="sxs-lookup"><span data-stu-id="b1fca-662">BSON has some additional data types that are not available in JSON, notably BinData (for byte arrays) and Date.</span></span>

- <span data-ttu-id="b1fca-663">A [MessagePack](https://msgpack.org/) egy olyan bináris szerializálási formátum, amely kellőképpen kis méretű a hálózaton keresztüli átvitelhez.</span><span class="sxs-lookup"><span data-stu-id="b1fca-663">[MessagePack](https://msgpack.org/) is a binary serialization format that is designed to be compact for transmission over the wire.</span></span> <span data-ttu-id="b1fca-664">A MessagePack nem alkalmaz üzenetsémákat vagy üzenettípus-ellenőrzést.</span><span class="sxs-lookup"><span data-stu-id="b1fca-664">There are no message schemas or message type checking.</span></span>

- <span data-ttu-id="b1fca-665">A [Bond](https://microsoft.github.io/bond/) egy olyan platformfüggetlen keretrendszer, amely sematikus adatok kezelésére lett kifejlesztve.</span><span class="sxs-lookup"><span data-stu-id="b1fca-665">[Bond](https://microsoft.github.io/bond/) is a cross-platform framework for working with schematized data.</span></span> <span data-ttu-id="b1fca-666">A Bond támogatja a nyelvek közötti szerializálást és deszerializálást.</span><span class="sxs-lookup"><span data-stu-id="b1fca-666">It supports cross-language serialization and deserialization.</span></span> <span data-ttu-id="b1fca-667">Az itt felsorolt egyéb rendszerekhez képest jelentősebb eltérés, hogy támogatja az öröklést, a típusaliasokat és az általánosítást.</span><span class="sxs-lookup"><span data-stu-id="b1fca-667">Notable differences from other systems listed here are support for inheritance, type aliases, and generics.</span></span>

- <span data-ttu-id="b1fca-668">A [gRPC](https://www.grpc.io/) egy nyílt forráskódú, a Google által kifejlesztett RPC-rendszer.</span><span class="sxs-lookup"><span data-stu-id="b1fca-668">[gRPC](https://www.grpc.io/) is an open source RPC system developed by Google.</span></span> <span data-ttu-id="b1fca-669">A gRPC alapértelmezés szerint protokollpuffereket használ definíciós nyelvként és az alapul szolgáló üzenetváltási formátumként.</span><span class="sxs-lookup"><span data-stu-id="b1fca-669">By default, it uses Protocol Buffers as its definition language and underlying message interchange format.</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="b1fca-670">Kapcsolódó minták és útmutatók</span><span class="sxs-lookup"><span data-stu-id="b1fca-670">Related patterns and guidance</span></span>

<span data-ttu-id="b1fca-671">A következő minták is lehet a forgatókönyvre vonatkozó, amikor az alkalmazások a gyorsítótárazást:</span><span class="sxs-lookup"><span data-stu-id="b1fca-671">The following patterns might also be relevant to your scenario when you implement caching in your applications:</span></span>

- <span data-ttu-id="b1fca-672">[Gyorsítótár-feltöltési minta](../patterns/cache-aside.md): Ez a minta ismerteti, hogyan lehet adatokat igény szerint tölthet be egy gyorsítótárba egy adattárolóból.</span><span class="sxs-lookup"><span data-stu-id="b1fca-672">[Cache-aside pattern](../patterns/cache-aside.md): This pattern describes how to load data on demand into a cache from a data store.</span></span> <span data-ttu-id="b1fca-673">Segítségével arról is gondoskodni lehet, hogy a gyorsítótárban tárolt és az eredeti adattárban lévő adatok konzisztensek maradjanak.</span><span class="sxs-lookup"><span data-stu-id="b1fca-673">This pattern also helps to maintain consistency between data that's held in the cache and the data in the original data store.</span></span>

- <span data-ttu-id="b1fca-674">A [horizontális skálázási minta](../patterns/sharding.md) információkat biztosít a vízszintes particionálás megvalósításáról a méretezhetőség javításához, amikor nagy adatmennyiségeket kell tárolni és hozzáférhetővé tenni.</span><span class="sxs-lookup"><span data-stu-id="b1fca-674">The [Sharding pattern](../patterns/sharding.md) provides information about implementing horizontal partitioning to help improve scalability when storing and accessing large volumes of data.</span></span>

## <a name="more-information"></a><span data-ttu-id="b1fca-675">További információ</span><span class="sxs-lookup"><span data-stu-id="b1fca-675">More information</span></span>

- [<span data-ttu-id="b1fca-676">Az Azure Redis Cache dokumentációja</span><span class="sxs-lookup"><span data-stu-id="b1fca-676">Azure Redis Cache documentation</span></span>](/azure/azure-cache-for-redis/)
- [<span data-ttu-id="b1fca-677">Az Azure Redis Cache – gyakori kérdések</span><span class="sxs-lookup"><span data-stu-id="b1fca-677">Azure Redis Cache FAQ</span></span>](/azure/redis-cache/cache-faq)
- [<span data-ttu-id="b1fca-678">Feladatalapú aszinkron minta</span><span class="sxs-lookup"><span data-stu-id="b1fca-678">Task-based Asynchronous pattern</span></span>](/dotnet/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap)
- [<span data-ttu-id="b1fca-679">Redis Cache dokumentációja</span><span class="sxs-lookup"><span data-stu-id="b1fca-679">Redis documentation</span></span>](https://redis.io/documentation)
- [<span data-ttu-id="b1fca-680">StackExchange.Redis</span><span class="sxs-lookup"><span data-stu-id="b1fca-680">StackExchange.Redis</span></span>](https://stackexchange.github.io/StackExchange.Redis/)
- [<span data-ttu-id="b1fca-681">Adatparticionálási útmutató</span><span class="sxs-lookup"><span data-stu-id="b1fca-681">Data partitioning guide</span></span>](https://msdn.microsoft.com/library/dn589795.aspx)
