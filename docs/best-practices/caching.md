---
title: "Gyorsítótárazási útmutató"
description: "A jobb teljesítmény és méretezhetőség gyorsítótárazás útmutatást."
author: dragon119
ms.date: 05/24/2017
pnp.series.title: Best Practices
ms.openlocfilehash: f8bc25ef10847e8308e830b745e87a176438d200
ms.sourcegitcommit: b0482d49aab0526be386837702e7724c61232c60
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 11/14/2017
---
# <a name="caching"></a><span data-ttu-id="2e942-103">Gyorsítótárazás</span><span class="sxs-lookup"><span data-stu-id="2e942-103">Caching</span></span>

<span data-ttu-id="2e942-104">Gyorsítótárazás a közös technika, amely a célja, hogy a jobb teljesítmény és méretezhetőség, a rendszer.</span><span class="sxs-lookup"><span data-stu-id="2e942-104">Caching is a common technique that aims to improve the performance and scalability of a system.</span></span> <span data-ttu-id="2e942-105">Ennek érdekében ideiglenesen másolása gyakran használt adatok gyors tárolók használata közeli található az alkalmazás.</span><span class="sxs-lookup"><span data-stu-id="2e942-105">It does this by temporarily copying frequently accessed data to fast storage that's located close to the application.</span></span> <span data-ttu-id="2e942-106">Ha az adatok gyors tároló közelebb található, mint az eredeti forrás az alkalmazáshoz, majd gyorsítótárazás jelentősen növelheti ügyfél alkalmazások válaszidejének előrejelzését adatok gyorsabban megtartásával.</span><span class="sxs-lookup"><span data-stu-id="2e942-106">If this fast data storage is located closer to the application than the original source, then caching can significantly improve response times for client applications by serving data more quickly.</span></span>

<span data-ttu-id="2e942-107">Gyorsítótárazás esetén leghatékonyabb egy ügyfél példány ismételten olvassa be ugyanazokat az adatokat, különösen akkor, ha az eredeti adattárolóban alkalmazása a következő feltételeket:</span><span class="sxs-lookup"><span data-stu-id="2e942-107">Caching is most effective when a client instance repeatedly reads the same data, especially if all the following conditions apply to the original data store:</span></span>

* <span data-ttu-id="2e942-108">Viszonylag statikus marad.</span><span class="sxs-lookup"><span data-stu-id="2e942-108">It remains relatively static.</span></span>
* <span data-ttu-id="2e942-109">Lassú a gyorsítótár képest.</span><span class="sxs-lookup"><span data-stu-id="2e942-109">It's slow compared to the speed of the cache.</span></span>
* <span data-ttu-id="2e942-110">Azt az versengés magas szintű.</span><span class="sxs-lookup"><span data-stu-id="2e942-110">It's subject to a high level of contention.</span></span>
* <span data-ttu-id="2e942-111">Az esetén távolságra hálózati késést okozhat, lassú a hozzáférést.</span><span class="sxs-lookup"><span data-stu-id="2e942-111">It's far away when network latency can cause access to be slow.</span></span>

## <a name="caching-in-distributed-applications"></a><span data-ttu-id="2e942-112">Az elosztott alkalmazások gyorsítótárazása</span><span class="sxs-lookup"><span data-stu-id="2e942-112">Caching in distributed applications</span></span>
<span data-ttu-id="2e942-113">Elosztott alkalmazások általában megvalósítási valamelyike vagy mindegyike a következő stratégiák az adatokat:</span><span class="sxs-lookup"><span data-stu-id="2e942-113">Distributed applications typically implement either or both of the following strategies when caching data:</span></span>

* <span data-ttu-id="2e942-114">Használatával egy titkos gyorsítótárral, az adatok tárolási helye helyileg egy alkalmazás vagy szolgáltatás egy példányát futtató számítógépen.</span><span class="sxs-lookup"><span data-stu-id="2e942-114">Using a private cache, where data is held locally on the computer that's running an instance of an application or service.</span></span>
* <span data-ttu-id="2e942-115">Megosztott gyorsítótárával, ami is elérhető, több folyamatok és/vagy gépek közös forrásként szolgáló használatával.</span><span class="sxs-lookup"><span data-stu-id="2e942-115">Using a shared cache, serving as a common source which can be accessed by multiple processes and/or machines.</span></span>

<span data-ttu-id="2e942-116">Mindkét esetben gyorsítótárazás hajtható végre az ügyféloldali és/vagy a kiszolgálóoldali.</span><span class="sxs-lookup"><span data-stu-id="2e942-116">In both cases, caching can be performed client-side and/or server-side.</span></span> <span data-ttu-id="2e942-117">A folyamat, amely a felhasználói felületet biztosít a rendszerén, például egy webes böngésző vagy asztali alkalmazás ügyféloldali gyorsítótárazás történik.</span><span class="sxs-lookup"><span data-stu-id="2e942-117">Client-side caching is done by the process that provides the user interface for a system, such as a web browser or desktop application.</span></span>
<span data-ttu-id="2e942-118">A kiszolgálóoldali gyorsítótár végezhető el, hogy távolról futó üzleti szolgáltatásokat biztosít a folyamatot.</span><span class="sxs-lookup"><span data-stu-id="2e942-118">Server-side caching is done by the process that provides the business services that are running remotely.</span></span>

### <a name="private-caching"></a><span data-ttu-id="2e942-119">Személyes gyorsítótárazása</span><span class="sxs-lookup"><span data-stu-id="2e942-119">Private caching</span></span>
<span data-ttu-id="2e942-120">A legalapvetőbb a gyorsítótár típus egy memórián belüli tároló.</span><span class="sxs-lookup"><span data-stu-id="2e942-120">The most basic type of cache is an in-memory store.</span></span> <span data-ttu-id="2e942-121">Egyetlen folyamat címterében használatban van, közvetlenül a kódot, a folyamat futó érhetők el.</span><span class="sxs-lookup"><span data-stu-id="2e942-121">It's held in the address space of a single process and accessed directly by the code that runs in that process.</span></span> <span data-ttu-id="2e942-122">Ez a gyorsítótár típus rendkívül gyors eléréséhez.</span><span class="sxs-lookup"><span data-stu-id="2e942-122">This type of cache is very quick to access.</span></span> <span data-ttu-id="2e942-123">Mérsékelt mennyiségű statikus adatok tárolásához, mert a gyorsítótár méretének általában a folyamatot futtató gépen rendelkezésre álló memória mennyisége korlátozza egy rendkívül hatékony eszközöket is biztosítható.</span><span class="sxs-lookup"><span data-stu-id="2e942-123">It can also provide an extremely effective means for storing modest amounts of static data, since the size of a cache is typically constrained by the volume of memory that's available on the machine hosting the process.</span></span>

<span data-ttu-id="2e942-124">Ha fizikailag lehet a memóriában, több információt gyorsítótárazzanak van szüksége, a helyi fájlrendszerben írhat a gyorsítótárazott adatokat.</span><span class="sxs-lookup"><span data-stu-id="2e942-124">If you need to cache more information than is physically possible in memory, you can write cached data to the local file system.</span></span> <span data-ttu-id="2e942-125">A lassabb, mint a memóriában tartott adatok eléréséhez, de továbbra is kell gyorsabb és megbízhatóbb, mint az adatok beolvasása a hálózaton keresztül.</span><span class="sxs-lookup"><span data-stu-id="2e942-125">This will be slower to access than data that's held in-memory, but should still be faster and more reliable than retrieving data across a network.</span></span>

<span data-ttu-id="2e942-126">Ha ez a modell egyidejűleg használó alkalmazás több példánya van, minden alkalmazáspéldány rendelkezik saját független gyorsítótár okozó saját az adatok másolatát.</span><span class="sxs-lookup"><span data-stu-id="2e942-126">If you have multiple instances of an application that uses this model running concurrently, each application instance has its own independent cache holding its own copy of the data.</span></span>

<span data-ttu-id="2e942-127">Gondoljon egy gyorsítótár a múltban valamikor az eredeti adatok pillanatképként.</span><span class="sxs-lookup"><span data-stu-id="2e942-127">Think of a cache as a snapshot of the original data at some point in the past.</span></span> <span data-ttu-id="2e942-128">Ha ezek az adatok nem statikus, valószínű, hogy a különböző alkalmazáspéldányok különböző verzióit a data tartsa a gyorsítótárak az.</span><span class="sxs-lookup"><span data-stu-id="2e942-128">If this data is not static, it is likely that different application instances hold different versions of the data in their caches.</span></span> <span data-ttu-id="2e942-129">Ezért ezek a példányok által végzett ugyanabban a lekérdezésben adhat vissza eltérő eredményeket, az 1. ábrán látható módon.</span><span class="sxs-lookup"><span data-stu-id="2e942-129">Therefore, the same query performed by these instances can return different results, as shown in Figure 1.</span></span>

![Egy memórián belüli gyorsítótárral, az alkalmazás különböző példányai használatával](./images/caching/Figure1.png)

<span data-ttu-id="2e942-131">*1. ábra: Az alkalmazás különböző példányát egy memórián belüli gyorsítótárral használatával*</span><span class="sxs-lookup"><span data-stu-id="2e942-131">*Figure 1: Using an in-memory cache in different instances of an application*</span></span>

### <a name="shared-caching"></a><span data-ttu-id="2e942-132">Megosztott gyorsítótárazása</span><span class="sxs-lookup"><span data-stu-id="2e942-132">Shared caching</span></span>
<span data-ttu-id="2e942-133">Megosztott gyorsítótárával használata segíthet enyhítse vonatkozik, hogy adatokat az egyes gyorsítótárát, amely akkor fordulhat elő, a memórián belüli gyorsítótárazáshoz eltérőek lehetnek.</span><span class="sxs-lookup"><span data-stu-id="2e942-133">Using a shared cache can help alleviate concerns that data might differ in each cache, which can occur with in-memory caching.</span></span> <span data-ttu-id="2e942-134">Megosztott gyorsítótárazás biztosítja, hogy különböző alkalmazáspéldányok tekintse meg a gyorsítótárazott adatokat nézetét.</span><span class="sxs-lookup"><span data-stu-id="2e942-134">Shared caching ensures that different application instances see the same view of cached data.</span></span> <span data-ttu-id="2e942-135">Ennek érdekében a gyorsítótár helyének egy külön helyen, általában egy külön szolgáltatás részeként futó, a 2. ábrán látható módon.</span><span class="sxs-lookup"><span data-stu-id="2e942-135">It does this by locating the cache in a separate location, typically hosted as part of a separate service, as shown in Figure 2.</span></span>

![Megosztott gyorsítótárával használatával](./images/caching/Figure2.png)

<span data-ttu-id="2e942-137">*2. ábra: Megosztott gyorsítótárával használatával*</span><span class="sxs-lookup"><span data-stu-id="2e942-137">*Figure 2: Using a shared cache*</span></span>

<span data-ttu-id="2e942-138">Egy megosztott gyorsítótárazási megközelítés fontos előnye a méretezhetőséget biztosít.</span><span class="sxs-lookup"><span data-stu-id="2e942-138">An important benefit of the shared caching approach is the scalability it provides.</span></span> <span data-ttu-id="2e942-139">Számos megosztott gyorsítótár szolgáltatás kiszolgálófürtöt használatával lehet megvalósítani, és a szoftver, amely az adatok elosztja a fürt átlátható módon felhasználását.</span><span class="sxs-lookup"><span data-stu-id="2e942-139">Many shared cache services are implemented by using a cluster of servers, and utilize software that distributes the data across the cluster in a transparent manner.</span></span> <span data-ttu-id="2e942-140">Az alkalmazáspéldány egyszerűen küld a cache service.</span><span class="sxs-lookup"><span data-stu-id="2e942-140">An application instance simply sends a request to the cache service.</span></span>
<span data-ttu-id="2e942-141">Az alkalmazás mögötti infrastruktúra felelős a gyorsítótárazott adatokat a fürt helyének meghatározása.</span><span class="sxs-lookup"><span data-stu-id="2e942-141">The underlying infrastructure is responsible for determining the location of the cached data in the cluster.</span></span> <span data-ttu-id="2e942-142">A gyorsítótár további kiszolgálók hozzáadásával könnyedén méretezhető.</span><span class="sxs-lookup"><span data-stu-id="2e942-142">You can easily scale the cache by adding more servers.</span></span>

<span data-ttu-id="2e942-143">Két fő hátrányai a megosztott gyorsítótárazási megközelítés van:</span><span class="sxs-lookup"><span data-stu-id="2e942-143">There are two main disadvantages of the shared caching approach:</span></span>

* <span data-ttu-id="2e942-144">A gyorsítótár lassabb, mert azt már nem tartják helyileg alkalmazás-példányokhoz eléréséhez.</span><span class="sxs-lookup"><span data-stu-id="2e942-144">The cache is slower to access because it is no longer held locally to each application instance.</span></span>
* <span data-ttu-id="2e942-145">A követelmény egy külön gyorsítótár szolgáltatás megvalósításához a megoldás lehet, hogy összetettebbé.</span><span class="sxs-lookup"><span data-stu-id="2e942-145">The requirement to implement a separate cache service might add complexity to the solution.</span></span>

## <a name="considerations-for-using-caching"></a><span data-ttu-id="2e942-146">Gyorsítótár használatának szempontjai</span><span class="sxs-lookup"><span data-stu-id="2e942-146">Considerations for using caching</span></span>
<span data-ttu-id="2e942-147">A következő szakaszok ismertetik részletesebben tervezéséről és a gyorsítótár használatával kapcsolatos szempontokat.</span><span class="sxs-lookup"><span data-stu-id="2e942-147">The following sections describe in more detail the considerations for designing and using a cache.</span></span>

### <a name="decide-when-to-cache-data"></a><span data-ttu-id="2e942-148">Döntse el, ha adatok gyorsítótárazása</span><span class="sxs-lookup"><span data-stu-id="2e942-148">Decide when to cache data</span></span>
<span data-ttu-id="2e942-149">Gyorsítótárazás jelentősen javíthatja a teljesítményt, a méretezhetőség és a rendelkezésre állási.</span><span class="sxs-lookup"><span data-stu-id="2e942-149">Caching can dramatically improve performance, scalability, and availability.</span></span> <span data-ttu-id="2e942-150">A további adatok és a felhasználókat a nagyobb számú elérje ezeket az adatokat, annál nagyobb lesz a gyorsítótárazás előnyeit.</span><span class="sxs-lookup"><span data-stu-id="2e942-150">The more data that you have and the larger the number of users that need to access this data, the greater the benefits of caching become.</span></span> <span data-ttu-id="2e942-151">Ennek oka az, gyorsítótárazás csökkenti a késést és nagy mennyiségű, az eredeti adattárolóban egyidejű kérelmek kezelése társított versengés.</span><span class="sxs-lookup"><span data-stu-id="2e942-151">That's because caching reduces the latency and contention that's associated with handling large volumes of concurrent requests in the original data store.</span></span>

<span data-ttu-id="2e942-152">Például egy adatbázis támogathatja az egyidejű kapcsolatok korlátozott számú.</span><span class="sxs-lookup"><span data-stu-id="2e942-152">For example, a database might support a limited number of concurrent connections.</span></span> <span data-ttu-id="2e942-153">Adatok megosztott gyorsítótárával beolvasása, azonban ahelyett, hogy az alapul szolgáló adatbázis lehetővé teszi elérje ezeket az adatokat, akkor is, ha a rendelkezésre álló kapcsolatok száma jelenleg nagyon gyorsan kimerítették ügyfélalkalmazást.</span><span class="sxs-lookup"><span data-stu-id="2e942-153">Retrieving data from a shared cache, however, rather than the underlying database, makes it possible for a client application to access this data even if the number of available connections is currently exhausted.</span></span> <span data-ttu-id="2e942-154">Továbbá ha az adatbázis nem érhető el, ügyfélalkalmazások lehet folytatja a gyorsítótárban tartott adatok felhasználásával.</span><span class="sxs-lookup"><span data-stu-id="2e942-154">Additionally, if the database becomes unavailable, client applications might be able to continue by using the data that's held in the cache.</span></span>

<span data-ttu-id="2e942-155">Fontolja meg a ritkán (például az adatok, amelyek nagyobb arányban az olvasási műveletek, mint az írási műveletek) módosított, de gyakran beolvasott adatokat.</span><span class="sxs-lookup"><span data-stu-id="2e942-155">Consider caching data that is read frequently but modified infrequently (for example, data that has a higher proportion of read operations than write operations).</span></span> <span data-ttu-id="2e942-156">Azonban nem ajánlott a mérvadó kritikus adatot tárol, a gyorsítótár használatát.</span><span class="sxs-lookup"><span data-stu-id="2e942-156">However, we don't recommend that you use the cache as the authoritative store of critical information.</span></span> <span data-ttu-id="2e942-157">Ehelyett győződjön meg arról, hogy a módosításokat, hogy az alkalmazás nem biztosít elveszítik mindig menti egy állandó adattárolóhoz.</span><span class="sxs-lookup"><span data-stu-id="2e942-157">Instead, ensure that all changes that your application cannot afford to lose are always saved to a persistent data store.</span></span> <span data-ttu-id="2e942-158">Ez azt jelenti, hogy ha a gyorsítótár nem érhető el, az alkalmazás továbbra is az adattár használatával, és nem vesznek el fontos információkat.</span><span class="sxs-lookup"><span data-stu-id="2e942-158">This means that if the cache is unavailable, your application can still continue to operate by using the data store, and you won't lose important information.</span></span>

### <a name="determine-how-to-cache-data-effectively"></a><span data-ttu-id="2e942-159">Határozza meg, hogyan hatékonyan gyorsítótárazza az adatokat</span><span class="sxs-lookup"><span data-stu-id="2e942-159">Determine how to cache data effectively</span></span>
<span data-ttu-id="2e942-160">A kulcsot a használatával hatékonyan gyorsítótárat gyorsítótárhoz leginkább megfelelő adatok meghatározásakor, és a megfelelő időben, gyorsítótárazás értékű.</span><span class="sxs-lookup"><span data-stu-id="2e942-160">The key to using a cache effectively lies in determining the most appropriate data to cache, and caching it at the appropriate time.</span></span> <span data-ttu-id="2e942-161">Az adatok az igény szerinti először az alkalmazás lekéri azt a gyorsítótárba lehet hozzáadni.</span><span class="sxs-lookup"><span data-stu-id="2e942-161">The data can be added to the cache on demand the first time it is retrieved by an application.</span></span> <span data-ttu-id="2e942-162">Ez azt jelenti, hogy az alkalmazás csak egyszer az adatok beolvasása a a tárolót, és, hogy később elérhetők a gyorsítótár használatával lehet teljesíteni.</span><span class="sxs-lookup"><span data-stu-id="2e942-162">This means that the application needs to fetch the data only once from the data store, and that subsequent access can be satisfied by using the cache.</span></span>

<span data-ttu-id="2e942-163">Azt is megteheti a gyorsítótár részlegesen vagy teljesen feltölthetők adatok előre, általában az alkalmazás indításakor (összehangolása néven ismert megközelítés).</span><span class="sxs-lookup"><span data-stu-id="2e942-163">Alternatively, a cache can be partially or fully populated with data in advance, typically when the application starts (an approach known as seeding).</span></span> <span data-ttu-id="2e942-164">Azonban nem feltétlenül ajánlott megvalósításához nagy gyorsítótár összehangolása, mert ez a megközelítés adhat az eredeti adattárolóban hirtelen és nagy terhelése, amikor az alkalmazás elindul.</span><span class="sxs-lookup"><span data-stu-id="2e942-164">However, it might not be advisable to implement seeding for a large cache because this approach can impose a sudden, high load on the original data store when the application starts running.</span></span>

<span data-ttu-id="2e942-165">Gyakran használati minták elemzésének segítségével határozza meg, hogy teljesen vagy részben feltöltse a gyorsítótárba, és a gyorsítótár kívánt adatok kiválasztásához.</span><span class="sxs-lookup"><span data-stu-id="2e942-165">Often an analysis of usage patterns can help you decide whether to fully or partially prepopulate a cache, and to choose the data to cache.</span></span> <span data-ttu-id="2e942-166">Például hasznos lehet a gyorsítótár a statikus felhasználói profil adatokkal rendezi az ügyfelek, akik használják az alkalmazást rendszeresen (lehet, hogy minden nap), de nem az ügyfelek, akik használják az alkalmazást csak hetente.</span><span class="sxs-lookup"><span data-stu-id="2e942-166">For example, it can be useful to seed the cache with the static user profile data for customers who use the application regularly (perhaps every day), but not for customers who use the application only once a week.</span></span>

<span data-ttu-id="2e942-167">Gyorsítótárazás általában jól működik, amely nem módosítható, vagy ritkán végzett módosítások adatok.</span><span class="sxs-lookup"><span data-stu-id="2e942-167">Caching typically works well with data that is immutable or that changes infrequently.</span></span> <span data-ttu-id="2e942-168">Például referencia jellegű információt, például a termék és díjszabási információkat e-kereskedelmi alkalmazás vagy a megosztott statikus erőforrásokat, amelyek költséges összeállításához.</span><span class="sxs-lookup"><span data-stu-id="2e942-168">Examples include reference information such as product and pricing information in an e-commerce application, or shared static resources that are costly to construct.</span></span> <span data-ttu-id="2e942-169">Néhány vagy az adatok tölthetők be a gyorsítótárba alkalmazások indításakor erőforrásainak terhelését a minimalizálása érdekében, és a teljesítmény javítása érdekében.</span><span class="sxs-lookup"><span data-stu-id="2e942-169">Some or all of this data can be loaded into the cache at application startup to minimize demand on resources and to improve performance.</span></span> <span data-ttu-id="2e942-170">Azt is megfelelő lehet egy olyan háttér folyamat, amely rendszeres időközönként frissíti az útmutató azt a gyorsítótárban lévő adatok folyamatosan naprakész adatokat tartalmazzon, vagy a gyorsítótárat frissíti, amely amikor referenciaadatok módosításokat.</span><span class="sxs-lookup"><span data-stu-id="2e942-170">It might also be appropriate to have a background process that periodically updates reference data in the cache to ensure it is up to date, or that refreshes the cache when reference data changes.</span></span>

<span data-ttu-id="2e942-171">Gyorsítótárazás érdemes kisebb dinamikus adatokat, habár van néhány kivétel ez szempont a (lásd a szakasz magas dinamikus adatok gyorsítótárazása a cikk későbbi részében olvashat).</span><span class="sxs-lookup"><span data-stu-id="2e942-171">Caching is less useful for dynamic data, although there are some exceptions to this consideration (see the section Cache highly dynamic data later in this article for more information).</span></span> <span data-ttu-id="2e942-172">Ha az eredeti adatok rendszeresen vált, a gyorsítótárban lévő adatokkal elévülés nagyon gyorsan vagy növeli a gyorsítótár az eredeti adattárolóban való szinkronizálása a csökkenti a gyorsítótár hatékonyságát.</span><span class="sxs-lookup"><span data-stu-id="2e942-172">When the original data changes regularly, either the cached information becomes stale very quickly or the overhead of synchronizing the cache with the original data store reduces the effectiveness of caching.</span></span>

<span data-ttu-id="2e942-173">Ne feledje, hogy a gyorsítótár nem tartalmazza a teljes adatait, hogy egy entitás.</span><span class="sxs-lookup"><span data-stu-id="2e942-173">Note that a cache does not have to include the complete data for an entity.</span></span> <span data-ttu-id="2e942-174">Például ha adatelemet egy többértékű objektumot, például egy olyan nevét, címét és egyenleg banki ügyfél határozza meg, ezek közül néhány maradhat statikus (például a nevét és címét), mások (például az egyenleg) dinamikusabb lehetnek.</span><span class="sxs-lookup"><span data-stu-id="2e942-174">For example, if a data item represents a multivalued object such as a bank customer with a name, address, and account balance, some of these elements might remain static (such as the name and address), while others (such as the account balance) might be more dynamic.</span></span> <span data-ttu-id="2e942-175">Ezekben az esetekben hasznos lehet az adatok statikus részének gyorsítótárazza, és csak a fennmaradó adatok beolvasása (vagy kiszámításához) szükség.</span><span class="sxs-lookup"><span data-stu-id="2e942-175">In these situations, it can be useful to cache the static portions of the data and retrieve (or calculate) only the remaining information when it is required.</span></span>

<span data-ttu-id="2e942-176">Azt javasoljuk, hogy hajtsa végre a tesztelés és a használati Teljesítményelemzés előzetes feltöltési vagy igény szerinti betöltését, vagy mindkettőt, a gyorsítótár megfelelő meghatározásához.</span><span class="sxs-lookup"><span data-stu-id="2e942-176">We recommend that you carry out performance testing and usage analysis to determine whether pre-population or on-demand loading of the cache, or a combination of both, is appropriate.</span></span> <span data-ttu-id="2e942-177">A döntéshez illékonyság és az adatok használati módja.</span><span class="sxs-lookup"><span data-stu-id="2e942-177">The decision should be based on the volatility and usage pattern of the data.</span></span> <span data-ttu-id="2e942-178">Gyorsítótár-használat és Teljesítményelemzés különösen fontos az alkalmazásokat, amelyek nagy előforduló, és kiválóan méretezhető kell lennie.</span><span class="sxs-lookup"><span data-stu-id="2e942-178">Cache utilization and performance analysis is particularly important in applications that encounter heavy loads and must be highly scalable.</span></span> <span data-ttu-id="2e942-179">Például magas szinten méretezhető esetekben ésszerű rendezi a gyorsítótár csúcsidőben az adattár terhelésének csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="2e942-179">For example, in highly scalable scenarios it might make sense to seed the cache to reduce the load on the data store at peak times.</span></span>

<span data-ttu-id="2e942-180">Gyorsítótárazás is segítségével kerülniük számítások az alkalmazás futása közben.</span><span class="sxs-lookup"><span data-stu-id="2e942-180">Caching can also be used to avoid repeating computations while the application is running.</span></span> <span data-ttu-id="2e942-181">Ha egy művelet átalakítja az adatokat, vagy összetett végez, akkor a művelet eredményét a gyorsítótár mentheti.</span><span class="sxs-lookup"><span data-stu-id="2e942-181">If an operation transforms data or performs a complicated calculation, it can save the results of the operation in the cache.</span></span> <span data-ttu-id="2e942-182">Ha ugyanazt a számítást ezt követően szükség, az alkalmazás képes egyszerűen az eredmények visszakeresésére a gyorsítótárból.</span><span class="sxs-lookup"><span data-stu-id="2e942-182">If the same calculation is required afterward, the application can simply retrieve the results from the cache.</span></span>

<span data-ttu-id="2e942-183">Egy alkalmazás módosíthatja az adatokat, a gyorsítótár használatban van.</span><span class="sxs-lookup"><span data-stu-id="2e942-183">An application can modify data that's held in a cache.</span></span> <span data-ttu-id="2e942-184">Javasoljuk azonban a gyorsítótár adattárként átmeneti, tetszőleges időpontban tudta eltűnnek szokták érteni.</span><span class="sxs-lookup"><span data-stu-id="2e942-184">However, we recommend thinking of the cache as a transient data store that could disappear at any time.</span></span> <span data-ttu-id="2e942-185">Nem értékes adatok tárolása a gyorsítótár csak; Ügyeljen arra, hogy az információk, valamint az eredeti adattárolóban.</span><span class="sxs-lookup"><span data-stu-id="2e942-185">Do not store valuable data in the cache only; make sure that you maintain the information in the original data store as well.</span></span> <span data-ttu-id="2e942-186">Ez azt jelenti, hogy a gyorsítótár nem érhető el, ha minimálisra csökkenthető az adatvesztés esélyét.</span><span class="sxs-lookup"><span data-stu-id="2e942-186">This means that if the cache becomes unavailable, you minimize the chance of losing data.</span></span>

### <a name="cache-highly-dynamic-data"></a><span data-ttu-id="2e942-187">Magas dinamikus adatok gyorsítótárazása</span><span class="sxs-lookup"><span data-stu-id="2e942-187">Cache highly dynamic data</span></span>
<span data-ttu-id="2e942-188">Ha gyorsan változó információkat a állandó tárolóban vannak tárolva, azt a rendszer egy terhelésének adhat meg.</span><span class="sxs-lookup"><span data-stu-id="2e942-188">When you store rapidly-changing information in a persistent data store, it can impose an overhead on the system.</span></span> <span data-ttu-id="2e942-189">Vegye figyelembe például olyan eszköz, amely folyamatosan a állapota vagy valamilyen egyéb mérési jelez.</span><span class="sxs-lookup"><span data-stu-id="2e942-189">For example, consider a device that continually reports status or some other measurement.</span></span> <span data-ttu-id="2e942-190">Ha egy alkalmazás nem gyorsítótárazza az adatokat az alapján, hogy a gyorsítótárban lévő adatokkal szinte mindig lesz elavult, az azonos szempont igaz, amikor tárolja, és ez az információ lekérése az adattár lehet.</span><span class="sxs-lookup"><span data-stu-id="2e942-190">If an application chooses not to cache this data on the basis that the cached information will nearly always be outdated, then the same consideration could be true when storing and retrieving this information from the data store.</span></span> <span data-ttu-id="2e942-191">A mentéséhez, és ezek az adatok lehívása szükséges idő az módosulhatott.</span><span class="sxs-lookup"><span data-stu-id="2e942-191">In the time it takes to save and fetch this data, it might have changed.</span></span>

<span data-ttu-id="2e942-192">Például ez esetben fontolja meg a dinamikus adatokat közvetlenül az állandó adattárban ahelyett, hogy a gyorsítótárban tárolja a előnyeit.</span><span class="sxs-lookup"><span data-stu-id="2e942-192">In a situation such as this, consider the benefits of storing the dynamic information directly in the cache instead of in the persistent data store.</span></span> <span data-ttu-id="2e942-193">Ha az adatok nem kritikus, és nem igényli a naplózás, majd nem számít, ha a alkalmi módosítás elvész.</span><span class="sxs-lookup"><span data-stu-id="2e942-193">If the data is non-critical and does not require auditing, then it doesn't matter if the occasional change is lost.</span></span>

### <a name="manage-data-expiration-in-a-cache"></a><span data-ttu-id="2e942-194">A gyorsítótár adatok lejártának kezelése</span><span class="sxs-lookup"><span data-stu-id="2e942-194">Manage data expiration in a cache</span></span>
<span data-ttu-id="2e942-195">A legtöbb esetben egy gyorsítótárban tartott adata, amely használatban van az eredeti adattárolóban adatok másolatát.</span><span class="sxs-lookup"><span data-stu-id="2e942-195">In most cases, data that's held in a cache is a copy of data that's held in the original data store.</span></span> <span data-ttu-id="2e942-196">Az eredeti adattárolóban lévő adatokat előfordulhat, hogy módosítása után az került a gyorsítótárba, így az a gyorsítótárazott adatok elavult.</span><span class="sxs-lookup"><span data-stu-id="2e942-196">The data in the original data store might change after it was cached, causing the cached data to become stale.</span></span> <span data-ttu-id="2e942-197">Számos gyorsítótárazási rendszer lehetővé teszi a gyorsítótár adatok lejárnak, és csökkenteni a időszakot, amelynek adatai pontatlanok lehetnek elavult konfigurálása.</span><span class="sxs-lookup"><span data-stu-id="2e942-197">Many caching systems enable you to configure the cache to expire data and reduce the period for which data may be out of date.</span></span>

<span data-ttu-id="2e942-198">Amikor gyorsítótárba helyezett adatok lejárnak, a rendszer eltávolítja a gyorsítótárban, és az alkalmazás kell lekérik az adatokat az eredeti adattárolóban (ezzel kockáztatja a újonnan lehívott adatokat vissza gyorsítótárba).</span><span class="sxs-lookup"><span data-stu-id="2e942-198">When cached data expires, it's removed from the cache, and the application must retrieve the data from the original data store (it can put the newly-fetched information back into cache).</span></span> <span data-ttu-id="2e942-199">Alapértelmezett lejárati házirendet állíthat be, amikor konfigurálja a gyorsítótárban.</span><span class="sxs-lookup"><span data-stu-id="2e942-199">You can set a default expiration policy when you configure the cache.</span></span> <span data-ttu-id="2e942-200">Sok gyorsítótár szolgáltatásokban akkor is is határozzák meg a lejárati időt, az egyes objektumok Ha tárolja őket programozott módon a gyorsítótárban.</span><span class="sxs-lookup"><span data-stu-id="2e942-200">In many cache services, you can also stipulate the expiration period for individual objects when you store them programmatically in the cache.</span></span>
<span data-ttu-id="2e942-201">Néhány gyorsítótárak lehetővé teszik a lejárati időt megadni, abszolút értéke, vagy egy mozgó érték, melynek következtében az elem a gyorsítótárból eltávolított, ha nem érhető el a megadott időn belül.</span><span class="sxs-lookup"><span data-stu-id="2e942-201">Some caches enable you to specify the expiration period as an absolute value, or as a sliding value that causes the item to be removed from the cache if it is not accessed within the specified time.</span></span> <span data-ttu-id="2e942-202">Ez a beállítás felülbírálja a gyorsítótár kiterjedő elévülési szabályzatának, de csak a megadott objektum.</span><span class="sxs-lookup"><span data-stu-id="2e942-202">This setting overrides any cache-wide expiration policy, but only for the specified objects.</span></span>

> [!NOTE]
> <span data-ttu-id="2e942-203">Fontolja meg a lejárati időt, a gyorsítótár és a benne található gondosan objektumok.</span><span class="sxs-lookup"><span data-stu-id="2e942-203">Consider the expiration period for the cache and the objects that it contains carefully.</span></span> <span data-ttu-id="2e942-204">Ha azt túl rövid, objektumok túl gyorsan lejár, és csökkenti a gyorsítótár használatának előnyeit.</span><span class="sxs-lookup"><span data-stu-id="2e942-204">If you make it too short, objects will expire too quickly and you will reduce the benefits of using the cache.</span></span> <span data-ttu-id="2e942-205">Ha az időszakban túl hosszú, azzal az adatok elévültek kockáztatja.</span><span class="sxs-lookup"><span data-stu-id="2e942-205">If you make the period too long, you risk the data becoming stale.</span></span>
> 
> 

<span data-ttu-id="2e942-206">Lehetőség arra is, hogy a gyorsítótár előfordulhat, hogy megtelnek Ha adatokat hosszú ideig rezidens továbbra is engedélyezett.</span><span class="sxs-lookup"><span data-stu-id="2e942-206">It's also possible that the cache might fill up if data is allowed to remain resident for a long time.</span></span> <span data-ttu-id="2e942-207">Ebben az esetben minden kérést új elemek hozzáadására a gyorsítótár okozhat egyes elemek kiürítés néven ismert folyamat kényszerített módon el kell távolítani.</span><span class="sxs-lookup"><span data-stu-id="2e942-207">In this case, any requests to add new items to the cache might cause some items to be forcibly removed in a process known as eviction.</span></span> <span data-ttu-id="2e942-208">Gyorsítótár-szolgáltatások általában kizárása adatok (LRU) legkevésbé legutóbb használt időközönként, de általában ez a házirend felülbírálása és eltávolítandó elemek megakadályozása.</span><span class="sxs-lookup"><span data-stu-id="2e942-208">Cache services typically evict data on a least-recently-used (LRU) basis, but you can usually override this policy and prevent items from being evicted.</span></span> <span data-ttu-id="2e942-209">Azonban ha elfogadni ezt a módszert használja, akkor kockáztatja meghaladja a gyorsítótár a rendelkezésre álló memória.</span><span class="sxs-lookup"><span data-stu-id="2e942-209">However, if you adopt this approach, you risk exceeding the memory that's available in the cache.</span></span> <span data-ttu-id="2e942-210">Egy alkalmazás, amely megpróbálja vegyen fel egy elemet a gyorsítótár sikertelen lesz, és kivételt.</span><span class="sxs-lookup"><span data-stu-id="2e942-210">An application that attempts to add an item to the cache will fail with an exception.</span></span>

<span data-ttu-id="2e942-211">Egyes gyorsítótárazási megvalósítások előfordulhat, hogy olyan további kiürítés szabályzatokat.</span><span class="sxs-lookup"><span data-stu-id="2e942-211">Some caching implementations might provide additional eviction policies.</span></span> <span data-ttu-id="2e942-212">Többféle kiürítés házirendek.</span><span class="sxs-lookup"><span data-stu-id="2e942-212">There are several types of eviction policies.</span></span> <span data-ttu-id="2e942-213">Ezek a következők:</span><span class="sxs-lookup"><span data-stu-id="2e942-213">These include:</span></span>

* <span data-ttu-id="2e942-214">A legutóbb használt-szabályzat (az általános gyakorlat, hogy az adatokat nem szükséges ismét lesz).</span><span class="sxs-lookup"><span data-stu-id="2e942-214">A most-recently-used policy (in the expectation that the data will not be required again).</span></span>
* <span data-ttu-id="2e942-215">Egy első-first out házirend (legrégebbi adatokat először kizárt).</span><span class="sxs-lookup"><span data-stu-id="2e942-215">A first-in-first-out policy (oldest data is evicted first).</span></span>
* <span data-ttu-id="2e942-216">Az explicit eltávolító házirendalapú (például a módosított adatok) kiváltott esemény.</span><span class="sxs-lookup"><span data-stu-id="2e942-216">An explicit removal policy based on a triggered event (such as the data being modified).</span></span>

### <a name="invalidate-data-in-a-client-side-cache"></a><span data-ttu-id="2e942-217">Egy ügyféloldali gyorsítótárban lévő adatok érvénytelenné válnak</span><span class="sxs-lookup"><span data-stu-id="2e942-217">Invalidate data in a client-side cache</span></span>
<span data-ttu-id="2e942-218">Használatban van egy ügyféloldali gyorsítótár adatokat általában tekinthető, amely adatokat szolgáltat az ügyfélnek a szolgáltatás felügyelete kívül.</span><span class="sxs-lookup"><span data-stu-id="2e942-218">Data that's held in a client-side cache is generally considered to be outside the auspices of the service that provides the data to the client.</span></span> <span data-ttu-id="2e942-219">A szolgáltatás közvetlenül nem kényszerítheti ki egy ügyfél hozzáadásához vagy eltávolításához információk ügyféloldali gyorsítótárában.</span><span class="sxs-lookup"><span data-stu-id="2e942-219">A service cannot directly force a client to add or remove information from a client-side cache.</span></span>

<span data-ttu-id="2e942-220">Ez azt jelenti, hogy a rosszul konfigurált gyorsítótár továbbra is használja az elavult adatokat használó ügyfél.</span><span class="sxs-lookup"><span data-stu-id="2e942-220">This means that it's possible for a client that uses a poorly configured cache to continue using outdated information.</span></span> <span data-ttu-id="2e942-221">Például a gyorsítótár lejárati házirendje nem szabályszerű ügyfél elavult adatokat, amelyek a helyi gyorsítótárba helyezi az adatokat az eredeti adatforrás lapindexének változása után használhatja.</span><span class="sxs-lookup"><span data-stu-id="2e942-221">For example, if the expiration policies of the cache aren't properly implemented, a client might use outdated information that's cached locally when the information in the original data source has changed.</span></span>

<span data-ttu-id="2e942-222">Ha a webes alkalmazás, amely adatokat szolgáltat a HTTP-kapcsolaton keresztül, implicit módon kényszerítheti a webes ügyfél (például egy böngésző vagy webproxyn) beolvasni a legfrissebb információkat.</span><span class="sxs-lookup"><span data-stu-id="2e942-222">If you are building a web application that serves data over an HTTP connection, you can implicitly force a web client (such as a browser or web proxy) to fetch the most recent information.</span></span> <span data-ttu-id="2e942-223">Ehhez az erőforrás URI megváltozása erőforrás frissítése.</span><span class="sxs-lookup"><span data-stu-id="2e942-223">You can do this if a resource is updated by a change in the URI of that resource.</span></span> <span data-ttu-id="2e942-224">A webes ügyfelek általában az erőforrás URI az ügyféloldali gyorsítótár kulcsként használatához, ha megváltoztatja az URI Azonosítót, a webes ügyfél figyelmen kívül hagyja-e minden korábban erőforrás verziói a gyorsítótárban, és ehelyett beolvassa az új verziót.</span><span class="sxs-lookup"><span data-stu-id="2e942-224">Web clients typically use the URI of a resource as the key in the client-side cache, so if the URI changes, the web client ignores any previously cached versions of a resource and fetches the new version instead.</span></span>

## <a name="managing-concurrency-in-a-cache"></a><span data-ttu-id="2e942-225">A gyorsítótár egyidejűségi kezelése</span><span class="sxs-lookup"><span data-stu-id="2e942-225">Managing concurrency in a cache</span></span>
<span data-ttu-id="2e942-226">Gyorsítótárak gyakran tervezték, hogy egy alkalmazás több példánya is van osztva.</span><span class="sxs-lookup"><span data-stu-id="2e942-226">Caches are often designed to be shared by multiple instances of an application.</span></span> <span data-ttu-id="2e942-227">Minden egyes alkalmazáspéldány olvashatják és módosíthatják az adatokat a gyorsítótárban.</span><span class="sxs-lookup"><span data-stu-id="2e942-227">Each application instance can read and modify data in the cache.</span></span> <span data-ttu-id="2e942-228">Az azonos egyidejűségi problémák merülnek fel, az összes megosztott tároló következésképpen is érvényesek a gyorsítótárba.</span><span class="sxs-lookup"><span data-stu-id="2e942-228">Consequently, the same concurrency issues that arise with any shared data store also apply to a cache.</span></span> <span data-ttu-id="2e942-229">Olyan helyzet, amikor egy alkalmazást kell módosítani a gyorsítótárban tartott adatait szükség lehet győződjön meg arról, hogy az alkalmazás egy példánya által végzett frissítések nem írja felül a másik példány által végzett módosításokat.</span><span class="sxs-lookup"><span data-stu-id="2e942-229">In a situation where an application needs to modify data that's held in the cache, you might need to ensure that updates made by one instance of the application do not overwrite the changes made by another instance.</span></span>

<span data-ttu-id="2e942-230">Attól függően, hogy az adatok természetét és ütközések valószínűségét is elfogadja párhuzamossági két módszer egyikét:</span><span class="sxs-lookup"><span data-stu-id="2e942-230">Depending on the nature of the data and the likelihood of collisions, you can adopt one of two approaches to concurrency:</span></span>

* <span data-ttu-id="2e942-231">**Az optimista.**</span><span class="sxs-lookup"><span data-stu-id="2e942-231">**Optimistic.**</span></span> <span data-ttu-id="2e942-232">Azonnal előtt frissíti az adatokat, az alkalmazás ellenőrzi a gyorsítótárban lévő adatok módosulásának lekérdezés óta.</span><span class="sxs-lookup"><span data-stu-id="2e942-232">Immediately prior to updating the data, the application checks to see whether the data in the cache has changed since it was retrieved.</span></span> <span data-ttu-id="2e942-233">Ha az adatok továbbra is azonos, a módosítás hajtható végre.</span><span class="sxs-lookup"><span data-stu-id="2e942-233">If the data is still the same, the change can be made.</span></span> <span data-ttu-id="2e942-234">Ellenkező esetben az alkalmazásnak van határozza meg, hogy a frissítést.</span><span class="sxs-lookup"><span data-stu-id="2e942-234">Otherwise, the application has to decide whether to update it.</span></span> <span data-ttu-id="2e942-235">(Az üzleti logika, amely ehhez a döntéshez meghajtók lesz az alkalmazás-specifikus.) Ezt a módszert alkalmas a helyzetekben, ahol frissítések alkalomszerű, vagy ha ütközések nem valószínű, hogy mi történjen.</span><span class="sxs-lookup"><span data-stu-id="2e942-235">(The business logic that drives this decision will be application-specific.) This approach is suitable for situations where updates are infrequent, or where collisions are unlikely to occur.</span></span>
* <span data-ttu-id="2e942-236">**Pesszimista.**</span><span class="sxs-lookup"><span data-stu-id="2e942-236">**Pessimistic.**</span></span> <span data-ttu-id="2e942-237">Amikor lekérdezi az adatokat, az alkalmazás zárolja a gyorsítótárban, megakadályozhatja, hogy egy másik példány a módosítás.</span><span class="sxs-lookup"><span data-stu-id="2e942-237">When it retrieves the data, the application locks it in the cache to prevent another instance from changing it.</span></span> <span data-ttu-id="2e942-238">Ez a folyamat biztosítja, hogy ütközések nem fordulhat elő, de blokkolására is képesek más esetekben kell feldolgozni ugyanazokat az adatokat.</span><span class="sxs-lookup"><span data-stu-id="2e942-238">This process ensures that collisions cannot occur, but they can also block other instances that need to process the same data.</span></span> <span data-ttu-id="2e942-239">Pesszimista feldolgozási hatással lehet a megoldás a méretezhetőséget, és csak rövid élettartamú műveletek ajánlott.</span><span class="sxs-lookup"><span data-stu-id="2e942-239">Pessimistic concurrency can affect the scalability of a solution and is recommended only for short-lived operations.</span></span> <span data-ttu-id="2e942-240">Ezt a módszert akkor lehet hasznos olyan esetekben, ahol ütközések valószínűbb, különösen akkor, ha egy alkalmazás több elem gyorsítótárában frissíti, és győződjön meg arról, hogy ezek a változások következetesen alkalmazzák.</span><span class="sxs-lookup"><span data-stu-id="2e942-240">This approach might be appropriate for situations where collisions are more likely, especially if an application updates multiple items in the cache and must ensure that these changes are applied consistently.</span></span>

### <a name="implement-high-availability-and-scalability-and-improve-performance"></a><span data-ttu-id="2e942-241">Magas rendelkezésre állás és méretezhetőség megvalósítása, és a teljesítmény javítása</span><span class="sxs-lookup"><span data-stu-id="2e942-241">Implement high availability and scalability, and improve performance</span></span>
<span data-ttu-id="2e942-242">Kerülje a gyorsítótár elsődleges tárházaként adatok; Ez az a szerepe az eredeti adattárolóban, amelyből a rendszer a gyorsítótárból tölti fel.</span><span class="sxs-lookup"><span data-stu-id="2e942-242">Avoid using a cache as the primary repository of data; this is the role of the original data store from which the cache is populated.</span></span> <span data-ttu-id="2e942-243">Az eredeti adattárolóban a megőrzése biztosításáért felelős.</span><span class="sxs-lookup"><span data-stu-id="2e942-243">The original data store is responsible for ensuring the persistence of the data.</span></span>

<span data-ttu-id="2e942-244">Ügyeljen arra, hogy a megoldás megosztott gyorsítótár szolgáltatás rendelkezésre állását a kritikus függőségeket bevezetéséhez.</span><span class="sxs-lookup"><span data-stu-id="2e942-244">Be careful not to introduce critical dependencies on the availability of a shared cache service into your solutions.</span></span> <span data-ttu-id="2e942-245">Egy alkalmazás tudják is működjenek, ha a szolgáltatás, amely a megosztott gyorsítótár nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="2e942-245">An application should be able to continue functioning if the service that provides the shared cache is unavailable.</span></span> <span data-ttu-id="2e942-246">Az alkalmazás nem kell lefagy vagy miközben a rendszer a gyorsítótár-szolgáltatást a sikertelen.</span><span class="sxs-lookup"><span data-stu-id="2e942-246">The application should not hang or fail while waiting for the cache service to resume.</span></span>

<span data-ttu-id="2e942-247">Ezért az alkalmazás ismeri fel a gyorsítótár-szolgáltatás rendelkezésre állását, és térhet vissza az eredeti adattárolóban, ha a gyorsítótár nem érhető el kell készíteni.</span><span class="sxs-lookup"><span data-stu-id="2e942-247">Therefore, the application must be prepared to detect the availability of the cache service and fall back to the original data store if the cache is inaccessible.</span></span> <span data-ttu-id="2e942-248">A [megszakító mintát](http://msdn.microsoft.com/library/dn589784.aspx) akkor hasznos, ha ez a forgatókönyv kezelésére.</span><span class="sxs-lookup"><span data-stu-id="2e942-248">The [Circuit-Breaker pattern](http://msdn.microsoft.com/library/dn589784.aspx) is useful for handling this scenario.</span></span> <span data-ttu-id="2e942-249">A szolgáltatás, amely a gyorsítótár állíthatók helyre, és amint elérhetővé válik, a gyorsítótár tölteni, adatolvasás az eredeti adattárolóban, például a következő stratégia kialakításához, a [gyorsítótár-tartalékoljon mintát](http://msdn.microsoft.com/library/dn589799.aspx).</span><span class="sxs-lookup"><span data-stu-id="2e942-249">The service that provides the cache can be recovered, and once it becomes available, the cache can be repopulated as data is read form the original data store, following a strategy such as the [Cache-aside pattern](http://msdn.microsoft.com/library/dn589799.aspx).</span></span>

<span data-ttu-id="2e942-250">Azonban előfordulhat, a méretezhetőség hatása a rendszer, ha az alkalmazás visszaáll az eredeti adattárolóban átmenetileg nem érhető el a gyorsítótár esetén.</span><span class="sxs-lookup"><span data-stu-id="2e942-250">However, there might be a scalability impact on the system if the application falls back to the original data store when the cache is temporarily unavailable.</span></span>
<span data-ttu-id="2e942-251">Az adattár helyreállítás alatt álló, amíg az eredeti adattárolóban sikerült kell swamped adatokat, és így a időtúllépések kérések, és nem sikerült a kapcsolat.</span><span class="sxs-lookup"><span data-stu-id="2e942-251">While the data store is being recovered, the original data store could be swamped with requests for data, resulting in timeouts and failed connections.</span></span>

<span data-ttu-id="2e942-252">Vegye fontolóra egy helyi, saját gyorsítótár irányuló kérelem a megosztott gyorsítótár-et elérő összes alkalmazáspéldányok minden egyes példányában.</span><span class="sxs-lookup"><span data-stu-id="2e942-252">Consider implementing a local, private cache in each instance of an application, together with the shared cache that all application instances access.</span></span> <span data-ttu-id="2e942-253">Amikor az alkalmazás egy elemet kér le, azt is ellenőrzi először a saját gyorsítótárába, majd a megosztott a gyorsítótárba, és végül az eredeti adatok tárolásához.</span><span class="sxs-lookup"><span data-stu-id="2e942-253">When the application retrieves an item, it can check first in its local cache, then in the shared cache, and finally in the original data store.</span></span> <span data-ttu-id="2e942-254">A helyi gyorsítótár adatok felhasználásával vagy a megosztott gyorsítótárban, vagy az adatbázis nem érhető el a megosztott gyorsítótárával esetén lehet megadni.</span><span class="sxs-lookup"><span data-stu-id="2e942-254">The local cache can be populated using the data in either the shared cache, or in the database if the shared cache is unavailable.</span></span>

<span data-ttu-id="2e942-255">Ez a megközelítés megakadályozhatja, hogy a helyi gyorsítótárat a túl elévültek tekintetében a megosztott gyorsítótárával gondos konfigurációt igényel.</span><span class="sxs-lookup"><span data-stu-id="2e942-255">This approach requires careful configuration to prevent the local cache from becoming too stale with respect to the shared cache.</span></span> <span data-ttu-id="2e942-256">Azonban a helyi gyorsítótár pufferként a Ha a megosztott gyorsítótár nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="2e942-256">However, the local cache acts as a buffer if the shared cache is unreachable.</span></span> <span data-ttu-id="2e942-257">3. ábrán látható, ez a struktúra.</span><span class="sxs-lookup"><span data-stu-id="2e942-257">Figure 3 shows this structure.</span></span>

<span data-ttu-id="2e942-258">![Egy helyi, saját gyorsítótár használata megosztott gyorsítótárával](./images/caching/Caching3.png)
*3. ábra: a helyi, saját gyorsítótár használata megosztott gyorsítótárával*</span><span class="sxs-lookup"><span data-stu-id="2e942-258">![Using a local, private cache with a shared cache](./images/caching/Caching3.png)
*Figure 3: Using a local, private cache with a shared cache*</span></span>

<span data-ttu-id="2e942-259">Nagy méretű gyorsítótárak, amely viszonylag hosszú élettartamú adatok tárolására támogatása érdekében néhány gyorsítótár biztosítanak egy magas rendelkezésre állású lehetőség, amely megvalósítja az automatikus feladatátvételt, ha a gyorsítótár nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="2e942-259">To support large caches that hold relatively long-lived data, some cache services provide a high-availability option that implements automatic failover if the cache becomes unavailable.</span></span> <span data-ttu-id="2e942-260">Ez általában a megközelítés a gyorsítótárazott adatokat, hogy egy elsődleges gyorsítótár-kiszolgáló egy másodlagos gyorsítótár-kiszolgáló replikálása, és átvált a másodlagos kiszolgáló az elsődleges kiszolgáló meghibásodása esetén, vagy a kapcsolat elvész.</span><span class="sxs-lookup"><span data-stu-id="2e942-260">This approach typically involves replicating the cached data that's stored on a primary cache server to a secondary cache server, and switching to the secondary server if the primary server fails or connectivity is lost.</span></span>

<span data-ttu-id="2e942-261">A több célhoz rendelt írása társított késés csökkentése érdekében a másodlagos kiszolgáló replikációs aszinkron módon során felmerülő adatot ír a gyorsítótár az elsődleges kiszolgálón.</span><span class="sxs-lookup"><span data-stu-id="2e942-261">To reduce the latency that's associated with writing to multiple destinations, the replication to the secondary server might occur asynchronously when data is written to the cache on the primary server.</span></span> <span data-ttu-id="2e942-262">Ezt a megközelítést vezet a lehetősége, hogy néhány gyorsítótárazott adatok elvesztésével járhat meghibásodása van, de ezek az adatok arányának kis képest a gyorsítótár méretét.</span><span class="sxs-lookup"><span data-stu-id="2e942-262">This approach leads to the possibility that some cached information might be lost in the event of a failure, but the proportion of this data should be small compared to the overall size of the cache.</span></span>

<span data-ttu-id="2e942-263">Ha megosztott gyorsítótárával túl nagy, előnyös a gyorsítótárazott adatokat particionálásához esélyét csökkentheti a versengés, és a méretezhetőség javítása csomópontjai között lehet.</span><span class="sxs-lookup"><span data-stu-id="2e942-263">If a shared cache is large, it might be beneficial to partition the cached data across nodes to reduce the chances of contention and improve scalability.</span></span> <span data-ttu-id="2e942-264">Sok megosztott gyorsítótárak is támogatja a dinamikus hozzáadása (és eltávolítása) csomópontot, és az adatok egyensúlyba partíciók között.</span><span class="sxs-lookup"><span data-stu-id="2e942-264">Many shared caches support the ability to dynamically add (and remove) nodes and rebalance the data across partitions.</span></span> <span data-ttu-id="2e942-265">Ez a megközelítés előfordulhat, hogy tartalmaz, amely Fürtszolgáltatás, amely csomópontok gyűjteménye áll rendelkezésre ügyfélalkalmazások, zökkenőmentes, egyetlen gyorsítótár.</span><span class="sxs-lookup"><span data-stu-id="2e942-265">This approach might involve clustering, in which the collection of nodes is presented to client applications as a seamless, single cache.</span></span> <span data-ttu-id="2e942-266">Belsőleg azonban az adatok megvédheti a következő előre meghatározott telepítési stratégiát, amely egyenlően osztja szét csomópontok között.</span><span class="sxs-lookup"><span data-stu-id="2e942-266">Internally, however, the data is dispersed between nodes following a predefined distribution strategy that balances the load evenly.</span></span> <span data-ttu-id="2e942-267">A [adatok particionálási útmutató](http://msdn.microsoft.com/library/dn589795.aspx) a Microsoft webhelyén particionálási stratégia lehet további információt nyújt.</span><span class="sxs-lookup"><span data-stu-id="2e942-267">The [Data partitioning guidance document](http://msdn.microsoft.com/library/dn589795.aspx) on the Microsoft website provides more information about possible partitioning strategies.</span></span>

<span data-ttu-id="2e942-268">Fürtszolgáltatás növelje a gyorsítótár rendelkezésre állását.</span><span class="sxs-lookup"><span data-stu-id="2e942-268">Clustering can also increase the availability of the cache.</span></span> <span data-ttu-id="2e942-269">Ha egy csomópont meghibásodik, a gyorsítótár fennmaradó továbbra is elérhetők maradnak.</span><span class="sxs-lookup"><span data-stu-id="2e942-269">If a node fails, the remainder of the cache is still accessible.</span></span>
<span data-ttu-id="2e942-270">Fürtszolgáltatás gyakran használt replikációs és feladatátvételi együtt.</span><span class="sxs-lookup"><span data-stu-id="2e942-270">Clustering is frequently used in conjunction with replication and failover.</span></span> <span data-ttu-id="2e942-271">Minden csomópont replikálható, és a replika gyorsan online állapotba helyezhetők a csomópont meghibásodásakor.</span><span class="sxs-lookup"><span data-stu-id="2e942-271">Each node can be replicated, and the replica can be quickly brought online if the node fails.</span></span>

<span data-ttu-id="2e942-272">Sok olvasási és írási műveletek valószínűleg egyetlen adatértékek vagy objektumokat.</span><span class="sxs-lookup"><span data-stu-id="2e942-272">Many read and write operations are likely to involve single data values or objects.</span></span> <span data-ttu-id="2e942-273">Azonban néha szükség lehet tárolja, vagy a nagy adatmennyiségek gyors beolvasása.</span><span class="sxs-lookup"><span data-stu-id="2e942-273">However, at times it might be necessary to store or retrieve large volumes of data quickly.</span></span>
<span data-ttu-id="2e942-274">Például a gyorsítótár összehangolása magukban foglalhatják több száz vagy ezer cikkek írása a gyorsítótárba.</span><span class="sxs-lookup"><span data-stu-id="2e942-274">For example, seeding a cache could involve writing hundreds or thousands of items to the cache.</span></span> <span data-ttu-id="2e942-275">Az alkalmazás számos kapcsolódó elemek beolvasása a gyorsítótárból a kérésben részeként is módosítania kell.</span><span class="sxs-lookup"><span data-stu-id="2e942-275">An application might also need to retrieve a large number of related items from the cache as part of the same request.</span></span>

<span data-ttu-id="2e942-276">Sok nagy méretű gyorsítótárak kötegműveletek ezekből a célokból adja meg.</span><span class="sxs-lookup"><span data-stu-id="2e942-276">Many large-scale caches provide batch operations for these purposes.</span></span> <span data-ttu-id="2e942-277">Ez lehetővé teszi, hogy az egy kérelemhez elemek nagy mennyiségű becsomagolhatja ügyfélalkalmazást, és csökkenti a nagyszámú kis kérések végrehajtásához társított.</span><span class="sxs-lookup"><span data-stu-id="2e942-277">This enables a client application to package up a large volume of items into a single request and reduces the overhead that's associated with performing a large number of small requests.</span></span>

## <a name="caching-and-eventual-consistency"></a><span data-ttu-id="2e942-278">Gyorsítótárazás és a végleges konzisztencia</span><span class="sxs-lookup"><span data-stu-id="2e942-278">Caching and eventual consistency</span></span>
<span data-ttu-id="2e942-279">A gyorsítótár-tartalékoljon minta működjön az alkalmazás, amely a gyorsítótárból tölti fel az példányát kell férnie a legtöbb legutóbbi és konzisztens legyen az adatok verziója.</span><span class="sxs-lookup"><span data-stu-id="2e942-279">For the cache-aside pattern to work, the instance of the application that populates the cache must have access to the most recent and consistent version of the data.</span></span> <span data-ttu-id="2e942-280">A rendszer, amely megvalósítja a végleges konzisztencia (például a replikált adatokat tároló) az nem lehet az eset.</span><span class="sxs-lookup"><span data-stu-id="2e942-280">In a system that implements eventual consistency (such as a replicated data store) this might not be the case.</span></span>

<span data-ttu-id="2e942-281">Egy alkalmazás egy példánya nem sikerült módosítani egy adatelemet, és érvénytelenné válnak a gyorsítótárazott verzió elem.</span><span class="sxs-lookup"><span data-stu-id="2e942-281">One instance of an application could modify a data item and invalidate the cached version of that item.</span></span> <span data-ttu-id="2e942-282">Előfordulhat, hogy az alkalmazás egy másik példánya megpróbálja olvassa el ezt az elemet a gyorsítótárból, aminek következtében a gyorsítótár-tévesztési, hogy azok az adatokat olvas a tárolót, és hozzáadja azt a gyorsítótárban.</span><span class="sxs-lookup"><span data-stu-id="2e942-282">Another instance of the application might attempt to read this item from a cache, which causes a cache-miss, so it reads the data from the data store and adds it to the cache.</span></span> <span data-ttu-id="2e942-283">Ha az adattár nem lett teljesen szinkronban a más replikával, az alkalmazáspéldány sikerült olvasni, és a gyorsítótár, a régi értékű.</span><span class="sxs-lookup"><span data-stu-id="2e942-283">However, if the data store has not been fully synchronized with the other replicas, the application instance could read and populate the cache with the old value.</span></span>

<span data-ttu-id="2e942-284">Az adatok konzisztenciájának kezelésére vonatkozó további információkért lásd: a [adatok konzisztencia ismertetése](http://msdn.microsoft.com/library/dn589800.aspx).</span><span class="sxs-lookup"><span data-stu-id="2e942-284">For more information about handling data consistency, see the [Data consistency primer](http://msdn.microsoft.com/library/dn589800.aspx).</span></span>

### <a name="protect-cached-data"></a><span data-ttu-id="2e942-285">A gyorsítótárazott adatok védelme</span><span class="sxs-lookup"><span data-stu-id="2e942-285">Protect cached data</span></span>
<span data-ttu-id="2e942-286">A cache service függetlenül használja, fontolja meg, hogyan védi az adatokat a jogosulatlan hozzáféréstől gyorsítótárban tartott.</span><span class="sxs-lookup"><span data-stu-id="2e942-286">Irrespective of the cache service you use, consider how to protect the data that's held in the cache from unauthorized access.</span></span> <span data-ttu-id="2e942-287">Nincsenek két fő vonatkozik:</span><span class="sxs-lookup"><span data-stu-id="2e942-287">There are two main concerns:</span></span>

* <span data-ttu-id="2e942-288">A gyorsítótárban lévő adatok adatvédelmet.</span><span class="sxs-lookup"><span data-stu-id="2e942-288">The privacy of the data in the cache.</span></span>
* <span data-ttu-id="2e942-289">Az adatok védelme, mert a gyorsítótár és az alkalmazás által használt a gyorsítótár között zajló kommunikációról.</span><span class="sxs-lookup"><span data-stu-id="2e942-289">The privacy of data as it flows between the cache and the application that's using the cache.</span></span>

<span data-ttu-id="2e942-290">A gyorsítótárban lévő adatok védelme érdekében a cache service bevezetheti olyan hitelesítési mechanizmus, amely megköveteli, hogy alkalmazásokat adja meg az alábbiakat:</span><span class="sxs-lookup"><span data-stu-id="2e942-290">To protect data in the cache, the cache service might implement an authentication mechanism that requires that applications specify the following:</span></span>

* <span data-ttu-id="2e942-291">Mely identitások férhetnek hozzá a gyorsítótárban lévő adatok.</span><span class="sxs-lookup"><span data-stu-id="2e942-291">Which identities can access data in the cache.</span></span>
* <span data-ttu-id="2e942-292">Milyen műveletek (olvasási és írási), amelyek az identitások elvégzéséhez jogosultak.</span><span class="sxs-lookup"><span data-stu-id="2e942-292">Which operations (read and write) that these identities are allowed to perform.</span></span>

<span data-ttu-id="2e942-293">Amely terhelés csökkentése érdekében van társítva olvasott és írt adatok követően identitás írási vagy olvasási hozzáférés a gyorsítótárhoz, hogy identitás használhatja-e az adatokat a gyorsítótárban.</span><span class="sxs-lookup"><span data-stu-id="2e942-293">To reduce overhead that's associated with reading and writing data, after an identity has been granted write and/or read access to the cache, that identity can use any data in the cache.</span></span>

<span data-ttu-id="2e942-294">Korlátozza a hozzáférést a gyorsítótárazott adatok megfelelő részhalmazát kell, ha a következők valamelyikét teheti:</span><span class="sxs-lookup"><span data-stu-id="2e942-294">If you need to restrict access to subsets of the cached data, you can do one of the following:</span></span>

* <span data-ttu-id="2e942-295">A gyorsítótár felosztása partíciók (különböző gyorsítótár-kiszolgálók használatával), és csak hozzáférést identitások a partíciók, amelyek használatához engedélyezni kell.</span><span class="sxs-lookup"><span data-stu-id="2e942-295">Split the cache into partitions (by using different cache servers) and only grant access to identities for the partitions that they should be allowed to use.</span></span>
* <span data-ttu-id="2e942-296">Titkosíthatja az adatokat, minden egyes részhalmazban különböző kulcsokkal, és adja meg a titkosítási kulcsok csak identitásokat tartalmaz, amelyek rendelkezzenek hozzáféréssel az egyes részhalmaza.</span><span class="sxs-lookup"><span data-stu-id="2e942-296">Encrypt the data in each subset by using different keys, and provide the encryption keys only to identities that should have access to each subset.</span></span> <span data-ttu-id="2e942-297">Egy ügyfélalkalmazás továbbra is lehet beolvasni az összes adatot a gyorsítótárban, de csak lesz képes visszafejteni az adatokat, amelynek a kulcsokat tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="2e942-297">A client application might still be able to retrieve all of the data in the cache, but it will only be able to decrypt the data for which it has the keys.</span></span>

<span data-ttu-id="2e942-298">Az adatok védelme kell azt tranzakciós átviteléhez is.</span><span class="sxs-lookup"><span data-stu-id="2e942-298">You must also protect the data as it flows in and out of the cache.</span></span> <span data-ttu-id="2e942-299">Ehhez az szükséges, hogy a biztonsági szolgáltatásoktól függő a hálózati infrastruktúra, amely a gyorsítótárban való csatlakozáskor használandó ügyfélalkalmazások által biztosított.</span><span class="sxs-lookup"><span data-stu-id="2e942-299">To do this, you depend on the security features provided by the network infrastructure that client applications use to connect to the cache.</span></span> <span data-ttu-id="2e942-300">Ha a gyorsítótár megvalósítása a szervezeten belül helyszíni kiszolgáló használata, amely futtatja az ügyfélalkalmazások számára, majd a hálózat elkülönítését nem szükség lehet további lépéseket kell tennie.</span><span class="sxs-lookup"><span data-stu-id="2e942-300">If the cache is implemented using an on-site server within the same organization that hosts the client applications, then the isolation of the network itself might not require you to take  additional steps.</span></span> <span data-ttu-id="2e942-301">Ha a gyorsítótárban található távolról, és a TCP- vagy HTTP-kapcsolatot igényel (például az internethez) nyilvános hálózaton keresztül, vegye fontolóra SSL.</span><span class="sxs-lookup"><span data-stu-id="2e942-301">If the cache is located remotely and requires a TCP or HTTP connection over a public network (such as the Internet), consider implementing SSL.</span></span>

## <a name="considerations-for-implementing-caching-with-microsoft-azure"></a><span data-ttu-id="2e942-302">Szempontok a gyorsítótárazást, ha a Microsoft Azure</span><span class="sxs-lookup"><span data-stu-id="2e942-302">Considerations for implementing caching with Microsoft Azure</span></span>
<span data-ttu-id="2e942-303">Azure biztosít az Azure Redis Cache.</span><span class="sxs-lookup"><span data-stu-id="2e942-303">Azure provides the Azure Redis Cache.</span></span> <span data-ttu-id="2e942-304">Ez a Redis gyorsítótár, amely egy Azure-adatközpontban szolgáltatásként fut nyílt forráskódú megvalósítása.</span><span class="sxs-lookup"><span data-stu-id="2e942-304">This is an implementation of the open source Redis cache that runs as a service in an Azure datacenter.</span></span> <span data-ttu-id="2e942-305">A gyorsítótárazási szolgáltatás, amely elérhető az összes Azure-alkalmazást, hogy az alkalmazás egy felhőalapú szolgáltatás, a webhely, vagy egy Azure virtuális gépen belüli biztosít.</span><span class="sxs-lookup"><span data-stu-id="2e942-305">It provides a caching service that can be accessed from any Azure application, whether the application is implemented as a cloud service, a website, or inside an Azure virtual machine.</span></span> <span data-ttu-id="2e942-306">Gyorsítótárak megoszthatók ügyfélalkalmazások, amelyek rendelkeznek a megfelelő hozzáférési kulcsot.</span><span class="sxs-lookup"><span data-stu-id="2e942-306">Caches can be shared by client applications that have the appropriate access key.</span></span>

<span data-ttu-id="2e942-307">Azure Redis Cache egy olyan nagy teljesítményű gyorsítótárazási megoldás, amely rendelkezésre állását, méretezhetőségét és biztonsági biztosít.</span><span class="sxs-lookup"><span data-stu-id="2e942-307">Azure Redis Cache is a high-performance caching solution that provides availability, scalability and security.</span></span> <span data-ttu-id="2e942-308">Ez általában szolgáltatásként fut egy vagy több dedikált gépek elosztva.</span><span class="sxs-lookup"><span data-stu-id="2e942-308">It typically runs as a service spread across one or more dedicated machines.</span></span> <span data-ttu-id="2e942-309">Megkísérli mértékű tárolása a memóriában gyors hozzáférés biztosítására használhatja.</span><span class="sxs-lookup"><span data-stu-id="2e942-309">It attempts to store as much information as it can in memory to ensure fast access.</span></span> <span data-ttu-id="2e942-310">Ez az architektúra készült biztosít alacsony késéssel és magas teljesítmény ami csökkenti a lassú i/o-műveletek végrehajtásához.</span><span class="sxs-lookup"><span data-stu-id="2e942-310">This architecture is intended to provide low latency and high throughput by reducing the need to perform slow I/O operations.</span></span>

 <span data-ttu-id="2e942-311">Azure Redis Cache összeegyeztethető számos olyan ügyfél-alkalmazások által használt különböző API-k.</span><span class="sxs-lookup"><span data-stu-id="2e942-311">Azure Redis Cache is compatible with many of the various APIs that are used by client applications.</span></span> <span data-ttu-id="2e942-312">Ha meglévő alkalmazásokat, amelyek már az Azure Redis Cache helyileg futó, az Azure Redis Cache kapcsolatot biztosít gyors áttelepítés gyorsítótárazás a felhőben.</span><span class="sxs-lookup"><span data-stu-id="2e942-312">If you have existing applications that already use Azure Redis Cache running on-premises, the Azure Redis Cache provides a quick migration path to caching in the cloud.</span></span>

> [!NOTE]
> <span data-ttu-id="2e942-313">Azure Managed Cache Service is biztosít.</span><span class="sxs-lookup"><span data-stu-id="2e942-313">Azure also provides the Managed Cache Service.</span></span> <span data-ttu-id="2e942-314">Ez a szolgáltatás az Azure Service Fabric gyorsítótár motor alapul.</span><span class="sxs-lookup"><span data-stu-id="2e942-314">This service is based on the Azure Service Fabric Cache engine.</span></span> <span data-ttu-id="2e942-315">Ez lehetővé teszi, hogy hozzon létre egy elosztott gyorsítótár, amely a lazán alkalmazások megoszthatók.</span><span class="sxs-lookup"><span data-stu-id="2e942-315">It enables you to create a distributed cache that can be shared by loosely-coupled applications.</span></span> <span data-ttu-id="2e942-316">A gyorsítótár van kiszolgálókon található nagy teljesítményű egy Azure-adatközpontban található.</span><span class="sxs-lookup"><span data-stu-id="2e942-316">The cache is hosted on high-performance servers running in an Azure datacenter.</span></span>
> <span data-ttu-id="2e942-317">Azonban ez a beállítás már nem ajánlott, és csak megadott meglévő alkalmazások készített történő használatát támogatja.</span><span class="sxs-lookup"><span data-stu-id="2e942-317">However, this option is no longer recommended and is only provided to support existing applications that have been built to use it.</span></span> <span data-ttu-id="2e942-318">Minden új fejlesztésekhez inkább Azure Redis Cache.</span><span class="sxs-lookup"><span data-stu-id="2e942-318">For all new development, use Azure Redis Cache instead.</span></span>
> 
> <span data-ttu-id="2e942-319">Ezenkívül az Azure támogatja szerepköralapú gyorsítótár.</span><span class="sxs-lookup"><span data-stu-id="2e942-319">Additionally, Azure supports in-role caching.</span></span> <span data-ttu-id="2e942-320">Ez a funkció lehetővé teszi a gyorsítótár adott egy felhőalapú szolgáltatás létrehozása.</span><span class="sxs-lookup"><span data-stu-id="2e942-320">This feature enables you to create a cache that's specific to a cloud service.</span></span>
> <span data-ttu-id="2e942-321">A gyorsítótár egy webes vagy feldolgozói szerepkör példánya üzemelteti, és csak az azonos felhőalapú szolgáltatás telepítési egység részeként működő szerepkörök érhető el.</span><span class="sxs-lookup"><span data-stu-id="2e942-321">The cache is hosted by instances of a web or worker role, and can only be accessed by roles that are operating as part of the same cloud service deployment unit.</span></span> <span data-ttu-id="2e942-322">(Egy központi telepítési egység egy adott területre felhő alapú szolgáltatásként telepített szerepkör-példányokat.) A gyorsítótár fürtözve van, és minden példánya a belül az azonos telepítési egység, amelyen a gyorsítótár gyorsítótár ugyanazon fürt részét képezik.</span><span class="sxs-lookup"><span data-stu-id="2e942-322">(A deployment unit is the set of role instances that are deployed as a cloud service to a specific region.) The cache is clustered, and all instances of the role within the same deployment unit that hosts the cache become part of the same cache cluster.</span></span> <span data-ttu-id="2e942-323">Azonban ez a beállítás már nem ajánlott, és csak megadott meglévő alkalmazások készített történő használatát támogatja.</span><span class="sxs-lookup"><span data-stu-id="2e942-323">However, this option is no longer recommended and is only provided to support existing applications that have been built to use it.</span></span> <span data-ttu-id="2e942-324">Minden új fejlesztésekhez inkább Azure Redis Cache.</span><span class="sxs-lookup"><span data-stu-id="2e942-324">For all new development, use Azure Redis Cache instead.</span></span>
> 
> <span data-ttu-id="2e942-325">Mind az Azure Managed Cache Service, mind az Azure szerepköralapú gyorsítótár vannak jelenleg nyár kerül piacra használatból való kivonást 2016 November 16.</span><span class="sxs-lookup"><span data-stu-id="2e942-325">Both Azure Managed Cache Service and Azure In-Role Cache are currently slated for retirement on November 16th, 2016.</span></span>
> <span data-ttu-id="2e942-326">Javasoljuk, hogy át Azure Redis Cache a használatból való kivonást előkészítésekor.</span><span class="sxs-lookup"><span data-stu-id="2e942-326">It is recommended that you migrate to Azure Redis Cache in preparation for this retirement.</span></span> <span data-ttu-id="2e942-327">További információkért lásd: [Mi az Azure Redis Cache-ajánlatot és milyen méretet használjam?](/azure/redis-cache/cache-faq#what-redis-cache-offering-and-size-should-i-use).</span><span class="sxs-lookup"><span data-stu-id="2e942-327">For more information, see [What is Azure Redis Cache offering and what size should I use?](/azure/redis-cache/cache-faq#what-redis-cache-offering-and-size-should-i-use).</span></span>
> 
> 

### <a name="features-of-redis"></a><span data-ttu-id="2e942-328">A Redis jellemzői</span><span class="sxs-lookup"><span data-stu-id="2e942-328">Features of Redis</span></span>
 <span data-ttu-id="2e942-329">A redis több mint egy egyszerű gyorsítótár-kiszolgálót.</span><span class="sxs-lookup"><span data-stu-id="2e942-329">Redis is more than a simple cache server.</span></span> <span data-ttu-id="2e942-330">Memóriában elosztott adatbázist biztosít olyan széles körű parancs-készletet, számos gyakori forgatókönyveket támogat.</span><span class="sxs-lookup"><span data-stu-id="2e942-330">It provides a distributed in-memory database with an extensive command set that supports many common scenarios.</span></span> <span data-ttu-id="2e942-331">Ezek a jelen dokumentum szakasz használata a Redis gyorsítótárazás ismerteti.</span><span class="sxs-lookup"><span data-stu-id="2e942-331">These are described later in this document, in the section Using  Redis caching.</span></span> <span data-ttu-id="2e942-332">Ez a szakasz néhány fő funkciója Redis biztosító foglalja össze.</span><span class="sxs-lookup"><span data-stu-id="2e942-332">This section summarizes some of the key features that Redis provides.</span></span>

### <a name="redis-as-an-in-memory-database"></a><span data-ttu-id="2e942-333">A memóriában adatbázisként redis</span><span class="sxs-lookup"><span data-stu-id="2e942-333">Redis as an in-memory database</span></span>
<span data-ttu-id="2e942-334">A redis egyaránt támogat olvasási és írási műveletet.</span><span class="sxs-lookup"><span data-stu-id="2e942-334">Redis supports both read and write operations.</span></span> <span data-ttu-id="2e942-335">A Redis írások védelme a rendszerhiba vagy rendszeresen tárolása egy helyi pillanatfelvétel fájlban vagy egy csak append naplófájlban.</span><span class="sxs-lookup"><span data-stu-id="2e942-335">In Redis, writes can be protected from system failure either by being stored  periodically in a local snapshot file or in an append-only log file.</span></span> <span data-ttu-id="2e942-336">Ez nem a helyzet a sok gyorsítótárak (amelyet átmeneti adattároló).</span><span class="sxs-lookup"><span data-stu-id="2e942-336">This is not the case in many caches (which should be considered  transitory data stores).</span></span>

 <span data-ttu-id="2e942-337">Összes írt aszinkron, és nem blokkolja az ügynökök adatok írásakor vagy olvasásakor.</span><span class="sxs-lookup"><span data-stu-id="2e942-337">All writes are asynchronous and do not block clients from reading and writing data.</span></span> <span data-ttu-id="2e942-338">Ha Redis elkezd futni, az adatokat olvas a pillanatkép- vagy naplófájl fájlt, és használ a memóriabeli gyorsítótár összeállításához.</span><span class="sxs-lookup"><span data-stu-id="2e942-338">When Redis starts running, it reads the data from the snapshot or log file and uses it to construct the in-memory cache.</span></span> <span data-ttu-id="2e942-339">További információkért lásd: [Redis-adatmegőrzés](http://redis.io/topics/persistence) a Redis-webhelyen.</span><span class="sxs-lookup"><span data-stu-id="2e942-339">For more information, see [Redis persistence](http://redis.io/topics/persistence) on the Redis website.</span></span>

> [!NOTE]
> <span data-ttu-id="2e942-340">A redis nem garantálja, hogy minden írási műveleteket a rendszer menti a katasztrofális hibája esetén, de a legrosszabb csak néhány másodperc érdemes adatok elveszhetnek.</span><span class="sxs-lookup"><span data-stu-id="2e942-340">Redis does not guarantee that all writes will be saved in the event of a catastrophic failure, but at worst you might lose only a few seconds worth of data.</span></span> <span data-ttu-id="2e942-341">Ne feledje, hogy a gyorsítótár nem célja a mérvadó adatforrásként működni, és az alkalmazások, a gyorsítótár segítségével győződjön meg arról, hogy kritikus mentett adatok sikeresen egy megfelelő adattároló feladata.</span><span class="sxs-lookup"><span data-stu-id="2e942-341">Remember that a cache is not intended to act as an authoritative data source, and it is the responsibility of the applications using the cache to ensure that critical data is saved successfully to an appropriate data store.</span></span> <span data-ttu-id="2e942-342">További információkért lásd: a [gyorsítótár-tartalékoljon mintát](http://msdn.microsoft.com/library/dn589799.aspx).</span><span class="sxs-lookup"><span data-stu-id="2e942-342">For more information, see the [cache-aside pattern](http://msdn.microsoft.com/library/dn589799.aspx).</span></span>
> 
> 

#### <a name="redis-data-types"></a><span data-ttu-id="2e942-343">Redis-adattípusok</span><span class="sxs-lookup"><span data-stu-id="2e942-343">Redis data types</span></span>
<span data-ttu-id="2e942-344">A redis egy kulcs-érték tároló, ahol értékek tartalmazhatnak egyszerű típusú vagy összetett adatszerkezetek, például a kivonatok, listák, és állítja be.</span><span class="sxs-lookup"><span data-stu-id="2e942-344">Redis is a key-value store, where values can contain simple types or complex data structures such as hashes, lists, and sets.</span></span> <span data-ttu-id="2e942-345">Ezek az adattípusok atomi műveletek készlete támogatja.</span><span class="sxs-lookup"><span data-stu-id="2e942-345">It supports a set of atomic operations on these data types.</span></span> <span data-ttu-id="2e942-346">Kulcsok végleges vagy címkézett idő élettartamát, ekkor automatikusan eltávolított a gyorsítótárból a kulcs és a megfelelő értéket korlátozott lehet.</span><span class="sxs-lookup"><span data-stu-id="2e942-346">Keys can be permanent or tagged with a limited time-to-live, at which point the key and its corresponding value are automatically removed from the cache.</span></span> <span data-ttu-id="2e942-347">Redis kulcsok és értékek kapcsolatos további információkért látogasson el a lap [Redis az adattípusokat és az absztrakt entitással egészült ki bemutatását](http://redis.io/topics/data-types-intro) a Redis-webhelyen.</span><span class="sxs-lookup"><span data-stu-id="2e942-347">For more information about Redis keys and values, visit the page [An introduction to Redis data types and abstractions](http://redis.io/topics/data-types-intro) on the Redis website.</span></span>

#### <a name="redis-replication-and-clustering"></a><span data-ttu-id="2e942-348">A redis replikációhoz és fürtözéshez</span><span class="sxs-lookup"><span data-stu-id="2e942-348">Redis replication and clustering</span></span>
<span data-ttu-id="2e942-349">A redis támogatja a fő-és alárendelt replikációs rendelkezésre állásának és átviteli karbantartása.</span><span class="sxs-lookup"><span data-stu-id="2e942-349">Redis supports master/subordinate replication to help ensure availability and maintain throughput.</span></span> <span data-ttu-id="2e942-350">Az írási műveletek Redis fő csomópont egy vagy több alárendelt csomóponton előfordul replikálódnak.</span><span class="sxs-lookup"><span data-stu-id="2e942-350">Write operations to a Redis master node are replicated to one or more subordinate nodes.</span></span> <span data-ttu-id="2e942-351">Olvasási műveletek a fő vagy a beosztottak bármelyikét szolgálhatók ki.</span><span class="sxs-lookup"><span data-stu-id="2e942-351">Read operations can be served by the master or any of the subordinates.</span></span>

<span data-ttu-id="2e942-352">Esetén a hálózati partíció beosztottak továbbra is szolgál az adatok, és majd transzparens módon való újraszinkronizálás a master, ha a kapcsolat helyreállt.</span><span class="sxs-lookup"><span data-stu-id="2e942-352">In the event of a network partition, subordinates can continue to serve data and then transparently resynchronize with the master when the connection is reestablished.</span></span> <span data-ttu-id="2e942-353">További részletekért látogasson el a [replikációs](http://redis.io/topics/replication) lap a Redis-webhelyen.</span><span class="sxs-lookup"><span data-stu-id="2e942-353">For further details, visit the [Replication](http://redis.io/topics/replication) page on the Redis website.</span></span>

<span data-ttu-id="2e942-354">Redis is biztosít a fürtözés, amely lehetővé teszi a transzparens módon adatok particionálása a szilánkok kiszolgáló között, és a betöltés terjednek.</span><span class="sxs-lookup"><span data-stu-id="2e942-354">Redis also provides clustering, which enables  you to transparently partition data into shards across servers and spread the load.</span></span> <span data-ttu-id="2e942-355">Ez a funkció, javul a méretezhetőség, mert új Redis-kiszolgálók is hozzáadhatók, és az adatokat, mint a gyorsítótár méretének particionálni növeli.</span><span class="sxs-lookup"><span data-stu-id="2e942-355">This feature improves scalability, because new Redis servers can be added and the data repartitioned as the size of the cache increases.</span></span>

<span data-ttu-id="2e942-356">Továbbá a fürt egyes kiszolgálóin fő-és alárendelt replikációval replikálható.</span><span class="sxs-lookup"><span data-stu-id="2e942-356">Furthermore, each server in the cluster can be replicated by using master/subordinate replication.</span></span> <span data-ttu-id="2e942-357">Ez biztosítja a rendelkezésre állási a fürt minden csomópontja között.</span><span class="sxs-lookup"><span data-stu-id="2e942-357">This ensures availability across each node in the cluster.</span></span> <span data-ttu-id="2e942-358">Fürtszolgáltatás és horizontális kapcsolatos további információkért látogasson el a [Redis-fürt oktatóprogram lap](http://redis.io/topics/cluster-tutorial) a Redis-webhelyen.</span><span class="sxs-lookup"><span data-stu-id="2e942-358">For more information about clustering and sharding, visit the [Redis cluster tutorial page](http://redis.io/topics/cluster-tutorial) on the Redis website.</span></span>

### <a name="redis-memory-use"></a><span data-ttu-id="2e942-359">Redis memória használata</span><span class="sxs-lookup"><span data-stu-id="2e942-359">Redis memory use</span></span>
<span data-ttu-id="2e942-360">A Redis gyorsítótár korlátja véges, amely a gazdagépen rendelkezésre álló erőforrások függ.</span><span class="sxs-lookup"><span data-stu-id="2e942-360">A Redis cache has a finite size that depends on the resources available on the host computer.</span></span> <span data-ttu-id="2e942-361">Egy Redis-kiszolgáló konfigurálásához, telepítheti a memória maximális mennyisége is megadhat.</span><span class="sxs-lookup"><span data-stu-id="2e942-361">When you configure a Redis server, you can specify the maximum amount of memory it can use.</span></span> <span data-ttu-id="2e942-362">Egy Redis gyorsítótár lejárati időt, amely után automatikusan eltávolítja a gyorsítótárból is konfigurálhatja egy kulcsot.</span><span class="sxs-lookup"><span data-stu-id="2e942-362">You can also configure a key in a Redis cache to have an expiration time, after which it is automatically removed from the cache.</span></span> <span data-ttu-id="2e942-363">Ez a funkció is megakadályozzák a memóriabeli gyorsítótár való régi vagy elavult adatokat.</span><span class="sxs-lookup"><span data-stu-id="2e942-363">This feature can help prevent the in-memory cache from filling with old or stale data.</span></span>

<span data-ttu-id="2e942-364">Memória kitölti-e, mint a Redis esetén automatikusan kizárása kulcsokkal és értékekkel házirendek száma következő.</span><span class="sxs-lookup"><span data-stu-id="2e942-364">As memory fills up, Redis can automatically evict keys and their values by following a number of policies.</span></span> <span data-ttu-id="2e942-365">Az alapértelmezett érték LRU (legrégebben használt), de egyéb házirendek, például a kulcsok véletlenszerű kizárása vagy a kiürítési teljesen kikapcsolása (a elemek hozzáadására a gyorsítótár sikertelen lesz, ha betelt, mely eset kísérlet) is megadhat.</span><span class="sxs-lookup"><span data-stu-id="2e942-365">The default is LRU (least recently used), but you can also select other policies such as evicting keys at random or turning off eviction altogether (in which, case attempts to add items to the cache fail if it is full).</span></span> <span data-ttu-id="2e942-366">A lap [használatával Redis, mint egy LRU gyorsítótár](http://redis.io/topics/lru-cache) nyújt részletesebb információt.</span><span class="sxs-lookup"><span data-stu-id="2e942-366">The page [Using Redis as an LRU cache](http://redis.io/topics/lru-cache) provides more information.</span></span>

### <a name="redis-transactions-and-batches"></a><span data-ttu-id="2e942-367">Redis tranzakciók és kötegek</span><span class="sxs-lookup"><span data-stu-id="2e942-367">Redis transactions and batches</span></span>
<span data-ttu-id="2e942-368">A redis lehetővé teszi, hogy egy ügyfél-alkalmazás olvasása és írása az adatokat a gyorsítótárban, mint egy atomi tranzakciós műveletek sorozata elküldeni.</span><span class="sxs-lookup"><span data-stu-id="2e942-368">Redis enables a client application to submit a series of operations that read and write data in the cache as an atomic transaction.</span></span> <span data-ttu-id="2e942-369">A tranzakció a parancsok garantáltan egymás után futnak, és nincs más egyidejű ügyfelek által kiadott parancs fog interwoven, közöttük.</span><span class="sxs-lookup"><span data-stu-id="2e942-369">All the commands in the transaction are guaranteed to run sequentially, and no commands issued by other concurrent clients will be interwoven between them.</span></span>

<span data-ttu-id="2e942-370">Azonban ezek nincsenek igaz tranzakciók, egy relációs adatbázisban hajtaná végre őket.</span><span class="sxs-lookup"><span data-stu-id="2e942-370">However, these are not true transactions as a relational database would perform them.</span></span> <span data-ttu-id="2e942-371">Tranzakció-feldolgozást két szakaszból--áll az első akkor, ha a parancsok sorba, és a második pedig a parancsok futtatásakor.</span><span class="sxs-lookup"><span data-stu-id="2e942-371">Transaction processing consists of two stages--the first is when the commands are queued, and the second is when the commands are run.</span></span> <span data-ttu-id="2e942-372">A parancsok a tranzakció alkotó parancs üzenetsor-kezelési szakaszában, az ügyfél által benyújtott.</span><span class="sxs-lookup"><span data-stu-id="2e942-372">During the command queuing stage, the commands that comprise the transaction are submitted by the client.</span></span> <span data-ttu-id="2e942-373">Ha valamilyen hiba akkor fordul elő, ezen a ponton (például szintaktikai hibát, vagy helytelen számú paraméterrel) majd Redis elutasítja a teljes tranzakció feldolgozása és figyelmen kívül hagyja azt.</span><span class="sxs-lookup"><span data-stu-id="2e942-373">If some sort of error occurs at this point (such as a syntax error, or the wrong number of parameters) then Redis refuses to process the entire transaction and discards it.</span></span>

<span data-ttu-id="2e942-374">A futtatási fázis során Redis sorrendben minden egyes sorban álló parancs végrehajtása.</span><span class="sxs-lookup"><span data-stu-id="2e942-374">During the run phase, Redis performs each queued command in sequence.</span></span> <span data-ttu-id="2e942-375">Ebben a fázisban a parancs sikertelen lesz, ha a Redis továbbra is fennáll, a következő sorba állított parancs, és nem állítja vissza már futó parancsok hatásait.</span><span class="sxs-lookup"><span data-stu-id="2e942-375">If a command fails during this phase, Redis continues with the next queued command and does not roll back the effects of any commands that have already been run.</span></span> <span data-ttu-id="2e942-376">A tranzakció egyszerűsített képernyőn segít a teljesítmény megőrzése, és a versengés által okozott problémák elkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="2e942-376">This simplified form of transaction helps to maintain performance and avoid performance problems that are caused by contention.</span></span>

<span data-ttu-id="2e942-377">A redis valósítja meg a konzisztencia fenntartása támogatására optimista zárolási űrlap.</span><span class="sxs-lookup"><span data-stu-id="2e942-377">Redis does implement a form of optimistic locking to assist in maintaining consistency.</span></span> <span data-ttu-id="2e942-378">Tranzakciók és a redis gyorsítótárral zárolása kapcsolatos részletes információkért látogasson el a [tranzakciók lap](http://redis.io/topics/transactions) a Redis-webhelyen.</span><span class="sxs-lookup"><span data-stu-id="2e942-378">For detailed information about transactions and locking with Redis, visit the [Transactions page](http://redis.io/topics/transactions) on the Redis website.</span></span>

<span data-ttu-id="2e942-379">A redis is támogatja a kérelem nem tranzakciós kötegelés.</span><span class="sxs-lookup"><span data-stu-id="2e942-379">Redis also supports non-transactional batching of requests.</span></span> <span data-ttu-id="2e942-380">A Redis-protokollt használó ügyfelek számára parancsainak elküldését a Redis-kiszolgáló lehetővé teszi az ügyfél küld a kérésben részeként műveleteket.</span><span class="sxs-lookup"><span data-stu-id="2e942-380">The Redis protocol that clients use to send commands to a Redis server enables a client to send a series of operations as part of the same request.</span></span> <span data-ttu-id="2e942-381">Ez segít a hálózati csomag töredezettségének csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="2e942-381">This can help to reduce packet fragmentation on the network.</span></span> <span data-ttu-id="2e942-382">A köteg feldolgozása után minden parancs történik.</span><span class="sxs-lookup"><span data-stu-id="2e942-382">When the batch is processed, each command is performed.</span></span> <span data-ttu-id="2e942-383">Ha ezen parancsok bármelyikéhez az helytelen formátumú, akkor a program elutasítja (ami nem kerül sor a tranzakciók), de történik, a többi parancs.</span><span class="sxs-lookup"><span data-stu-id="2e942-383">If any of these commands are malformed, they will be rejected (which doesn't happen with a transaction), but the remaining commands will be performed.</span></span> <span data-ttu-id="2e942-384">Még nincs garancia kapcsolatos a sorrendben, amelyben a kötegben parancsokat dolgoz fel.</span><span class="sxs-lookup"><span data-stu-id="2e942-384">There is also no guarantee about the order in which the commands in the batch will be processed.</span></span>

### <a name="redis-security"></a><span data-ttu-id="2e942-385">Biztonsági redis</span><span class="sxs-lookup"><span data-stu-id="2e942-385">Redis security</span></span>
<span data-ttu-id="2e942-386">A redis összpontosít tisztán adatok gyors hozzáférést biztosító, és célja, hogy csak megbízható ügyfelek által elérhető megbízható környezet futhat.</span><span class="sxs-lookup"><span data-stu-id="2e942-386">Redis is focused purely on providing fast access to data, and is designed to run inside a trusted environment that can be accessed only by trusted clients.</span></span> <span data-ttu-id="2e942-387">A redis egy jelszó-hitelesítés alapján korlátozott biztonsági modellt támogatja.</span><span class="sxs-lookup"><span data-stu-id="2e942-387">Redis supports a limited security model based on password authentication.</span></span> <span data-ttu-id="2e942-388">(Is lehet távolítsa el a hitelesítés teljesen, bár nem ajánlott ennek.)</span><span class="sxs-lookup"><span data-stu-id="2e942-388">(It is possible to remove authentication completely, although we don't recommend this.)</span></span>

<span data-ttu-id="2e942-389">Az összes hitelesített ügyfelek megosztása globális ugyanazt a jelszót, és elérheti az erőforrásokhoz.</span><span class="sxs-lookup"><span data-stu-id="2e942-389">All authenticated clients share the same global password and have access to the same resources.</span></span> <span data-ttu-id="2e942-390">Ha átfogóbb bejelentkezési biztonságra van szüksége, meg kell valósítani a saját biztonsági réteg a Redis-kiszolgáló elé, és az összes ügyfélkéréseket kell érintenie a réteget.</span><span class="sxs-lookup"><span data-stu-id="2e942-390">If you need more comprehensive sign-in security, you must implement your own security layer in front of the Redis server, and all client requests should pass through this additional layer.</span></span> <span data-ttu-id="2e942-391">A redis nem számára nem megbízható és nem hitelesített ügyfeleket közvetlenül elérhetővé tehető.</span><span class="sxs-lookup"><span data-stu-id="2e942-391">Redis should not be directly exposed to untrusted or unauthenticated clients.</span></span>

<span data-ttu-id="2e942-392">Tiltsa le őket, vagy azokat átnevezése (és jogosultsággal rendelkező ügyfelek csak az új névvel rendelkező megadásával) korlátozzuk parancsok.</span><span class="sxs-lookup"><span data-stu-id="2e942-392">You can restrict access to commands by disabling them or renaming them (and by providing only privileged clients with the new names).</span></span>

<span data-ttu-id="2e942-393">Redis közvetlenül nem támogatja bármely formájára vonatkozó adatok titkosítása, így minden kódolás ügyfélalkalmazások kell végrehajtani.</span><span class="sxs-lookup"><span data-stu-id="2e942-393">Redis does not directly support any form of data encryption, so all encoding must be performed by client applications.</span></span> <span data-ttu-id="2e942-394">Továbbá a Redis nem adja meg a transport security bármilyen.</span><span class="sxs-lookup"><span data-stu-id="2e942-394">Additionally, Redis does not provide any form of transport security.</span></span> <span data-ttu-id="2e942-395">Ha kell azt a hálózaton keresztül zajlik védheti az adatokat, ajánlott végrehajtási egy SSL-proxy.</span><span class="sxs-lookup"><span data-stu-id="2e942-395">If you need to protect data as it flows across the network, we recommend implementing an SSL proxy.</span></span>

<span data-ttu-id="2e942-396">További tudnivalókért keresse fel a [biztonsági Redis](http://redis.io/topics/security) lap a Redis-webhelyen.</span><span class="sxs-lookup"><span data-stu-id="2e942-396">For more information, visit the [Redis security](http://redis.io/topics/security) page on the Redis website.</span></span>

> [!NOTE]
> <span data-ttu-id="2e942-397">Azure Redis Cache nyújt a saját biztonsági réteg, amelyekkel az ügyfelek kapcsolódnak.</span><span class="sxs-lookup"><span data-stu-id="2e942-397">Azure Redis Cache provides its own security layer through which clients connect.</span></span> <span data-ttu-id="2e942-398">Az alapul szolgáló Redis-kiszolgálók nem érhetők el a nyilvános hálózathoz.</span><span class="sxs-lookup"><span data-stu-id="2e942-398">The underlying Redis servers are not exposed to the public network.</span></span>
> 
> 

### <a name="azure-redis-cache"></a><span data-ttu-id="2e942-399">Az Azure Redis cache</span><span class="sxs-lookup"><span data-stu-id="2e942-399">Azure Redis cache</span></span>
<span data-ttu-id="2e942-400">Azure Redis Cache Redis-kiszolgálók az Azure adatközpontjában futó hozzáférést biztosít.</span><span class="sxs-lookup"><span data-stu-id="2e942-400">Azure Redis Cache provides access to Redis servers that are hosted at an Azure datacenter.</span></span> <span data-ttu-id="2e942-401">A hozzáférés-vezérlés és adatvédelmet homlokzati funkcionál.</span><span class="sxs-lookup"><span data-stu-id="2e942-401">It acts as a façade that provides access control and security.</span></span> <span data-ttu-id="2e942-402">A gyorsítótár az Azure portál használatával építhető ki.</span><span class="sxs-lookup"><span data-stu-id="2e942-402">You can provision a cache by using the Azure  portal.</span></span>

<span data-ttu-id="2e942-403">A portál számos előre definiált konfigurációkat.</span><span class="sxs-lookup"><span data-stu-id="2e942-403">The portal provides a number of predefined configurations.</span></span> <span data-ttu-id="2e942-404">A tartomány egy dedikált futtató 53 GB gyorsítótárában, hogy támogatja az SSL-kommunikáció (adatvédelmi) és a szolgáltatás fő-és alárendelt replikációt szolgáltatásiszint-szerződésben garantált 99,9 %-os rendelkezésre állás érdekében nélkül (nincs rendelkezésre állási garanciák) replikációs 250 MB méretű gyorsítótárat le a futó megosztott hardver.</span><span class="sxs-lookup"><span data-stu-id="2e942-404">These range from a 53 GB cache running as a dedicated service that supports SSL communications (for privacy) and master/subordinate replication with an SLA of 99.9% availability, down to a 250 MB cache without replication (no availability guarantees) running on shared hardware.</span></span>

<span data-ttu-id="2e942-405">Az Azure portál használatával, akkor is konfigurálja a kiürítés házirendet, a gyorsítótár, és a szerepköröket, meghatározott felhasználók hozzáadásával a gyorsítótárban való hozzáférést.</span><span class="sxs-lookup"><span data-stu-id="2e942-405">Using the Azure portal, you can also configure the eviction policy of the cache, and control access to the cache by adding users to the roles provided.</span></span>  <span data-ttu-id="2e942-406">Ezeket a szerepköröket, amelyek meghatározzák a műveletek a tagok hajthat végre, a tulajdonos, közreműködő, és ahhoz való olvasóra tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="2e942-406">These roles, which  define the operations that members can perform, include Owner, Contributor, and Reader.</span></span> <span data-ttu-id="2e942-407">Például a tulajdonos szerepkör tagjai rendelkeznek a teljes felügyeletet gyakorolhat a gyorsítótárban (beleértve a biztonsági) és annak tartalmát, a közreműködői szerepkör tagjai és információt írhat a gyorsítótárban, és az Olvasó szerepkör tagjai is csak lekérdezni lehet adatokat a gyorsítótárból.</span><span class="sxs-lookup"><span data-stu-id="2e942-407">For example, members of the Owner role have complete control over the cache (including security) and its contents, members of the Contributor role can read and write information in the cache, and members of the Reader role can only retrieve data from the cache.</span></span>

<span data-ttu-id="2e942-408">A legtöbb felügyeleti feladatok végrehajtására kerül sor, az Azure portálon keresztül.</span><span class="sxs-lookup"><span data-stu-id="2e942-408">Most administrative tasks are performed through the Azure portal.</span></span> <span data-ttu-id="2e942-409">Emiatt a Redis szabványos verziójában elérhető felügyeleti parancsok közül sok nem érhető el, beleértve a programozott módon módosítsa a konfigurációt, állítsa le a Redis-kiszolgáló, további beosztottak konfigurálása vagy Kényszerített mentés adatok lemezre.</span><span class="sxs-lookup"><span data-stu-id="2e942-409">For this reason, many of the administrative commands that are available in the standard version of Redis are not available, including the ability to modify the configuration programmatically, shut down the Redis server, configure additional subordinates, or forcibly save data to disk.</span></span>

<span data-ttu-id="2e942-410">Az Azure-portál tartalmaz egy kényelmes grafikus megjelenítését, amely lehetővé teszi, hogy a gyorsítótár teljesítményének figyeléséhez.</span><span class="sxs-lookup"><span data-stu-id="2e942-410">The Azure portal includes a convenient graphical display that enables you to monitor the performance of the cache.</span></span> <span data-ttu-id="2e942-411">Például tekintheti meg és gyorsítótárbeli találatok száma és végeznek, a végrehajtás alatt álló kérelmek száma, az olvasási és írási, az adatmennyiség kapcsolatok száma.</span><span class="sxs-lookup"><span data-stu-id="2e942-411">For example, you can view the number of connections being made, the number of requests being performed, the volume of reads and writes, and the number of cache hits versus cache misses.</span></span> <span data-ttu-id="2e942-412">Ezen információk alapján is határozza meg a gyorsítótár hatékonyságát, és ha szükséges, váltani ettől eltérő konfigurációt, vagy módosítsa a kiürítés házirendet.</span><span class="sxs-lookup"><span data-stu-id="2e942-412">Using this information, you can determine the effectiveness of the cache and if necessary, switch to a different configuration or change the eviction policy.</span></span>

<span data-ttu-id="2e942-413">Emellett hozhat létre riasztásokat, amelyek egy e-mailek küldésére, ha egy vagy több kritikus metrikák egy várt tartományon kívül esnek.</span><span class="sxs-lookup"><span data-stu-id="2e942-413">Additionally, you can create alerts that send email messages to an administrator if one or more critical metrics fall outside of an expected range.</span></span> <span data-ttu-id="2e942-414">Például előfordulhat, hogy szeretne riasztást a rendszergazda Ha gyorsítótárbeli száma meghaladja a megadott érték az elmúlt órában, mert az azt jelenti, előfordulhat, hogy a gyorsítótár túl kicsi, vagy adatokat előfordulhat, hogy éppen dobható túl gyorsan.</span><span class="sxs-lookup"><span data-stu-id="2e942-414">For example, you might want to alert an administrator if the number of cache misses exceeds a specified value in the last hour, because it means the cache might be too small or data might be being evicted too quickly.</span></span>

<span data-ttu-id="2e942-415">A Processzor, memória és a gyorsítótár hálózathasználatáról is figyelheti.</span><span class="sxs-lookup"><span data-stu-id="2e942-415">You can also monitor the CPU, memory, and network usage for the cache.</span></span>

<span data-ttu-id="2e942-416">További információt és példákat bemutatja, hogyan hozza létre és konfigurálja az Azure Redis Cache, látogasson el a [körül Azure Redis Cache Lap](https://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/) meg az Azure blog.</span><span class="sxs-lookup"><span data-stu-id="2e942-416">For further information and examples showing how to create and configure an Azure Redis Cache, visit the page [Lap around Azure Redis Cache](https://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/) on the Azure blog.</span></span>

## <a name="caching-session-state-and-html-output"></a><span data-ttu-id="2e942-417">Gyorsítótárazás munkamenet-állapot és a HTML-kimenetében</span><span class="sxs-lookup"><span data-stu-id="2e942-417">Caching session state and HTML output</span></span>
<span data-ttu-id="2e942-418">Ha most felépítése ASP.NET webes alkalmazásokhoz, hogy az Azure webes szerepkörök használatával futtassa, mentheti munkamenet állapot információkat és az Azure Redis Cache HTML-kimenetet.</span><span class="sxs-lookup"><span data-stu-id="2e942-418">If you're building ASP.NET web applications that run by using Azure web roles, you can save session state information and HTML output in an Azure Redis Cache.</span></span> <span data-ttu-id="2e942-419">Az Azure Redis Cache a munkamenetállapot-szolgáltatóját lehetővé teszi az ASP.NET webalkalmazások különböző példányai között munkamenet az információkat, és nagyon hasznos a webkiszolgáló farm olyan helyzetekben, ahol ügyfél-kiszolgáló kapcsolatot nem érhető el és gyorsítótárazási munkamenetadatok a memóriában nem lenne megfelelő.</span><span class="sxs-lookup"><span data-stu-id="2e942-419">The session state provider for Azure Redis Cache enables you to share session information between different instances of an ASP.NET web application, and is very useful in web farm situations where client-server affinity is not available and caching session data in-memory would not be appropriate.</span></span>

<span data-ttu-id="2e942-420">Használata a munkamenetállapot-szolgáltatóját Azure Redis Cache kézbesíti számos előnnyel jár, beleértve:</span><span class="sxs-lookup"><span data-stu-id="2e942-420">Using the session state provider with Azure Redis Cache delivers several benefits, including:</span></span>

* <span data-ttu-id="2e942-421">A nagy mennyiségű példánnyal ASP.NET webalkalmazás munkamenet-állapot megosztása.</span><span class="sxs-lookup"><span data-stu-id="2e942-421">Sharing session state with a large number of instances of ASP.NET web applications.</span></span>
* <span data-ttu-id="2e942-422">Továbbfejlesztett méretezhetőség biztosítása.</span><span class="sxs-lookup"><span data-stu-id="2e942-422">Providing improved scalability.</span></span>
* <span data-ttu-id="2e942-423">Az azonos munkamenet-állapot adatainak ellenőrzése alatt, egyidejű hozzáférést támogató több olvasók és egyetlen írót.</span><span class="sxs-lookup"><span data-stu-id="2e942-423">Supporting controlled, concurrent access to the same session state data for multiple readers and a single writer.</span></span>
* <span data-ttu-id="2e942-424">Tömörítés segítségével a memóriahasználat és a hálózati teljesítmény javításához.</span><span class="sxs-lookup"><span data-stu-id="2e942-424">Using compression to save memory and improve network performance.</span></span>

<span data-ttu-id="2e942-425">További információkért lásd: [ASP.NET munkamenetállapot-szolgáltatóját az Azure Redis Cache](/azure/redis-cache/cache-aspnet-session-state-provider/).</span><span class="sxs-lookup"><span data-stu-id="2e942-425">For more information, see [ASP.NET session state provider for Azure Redis Cache](/azure/redis-cache/cache-aspnet-session-state-provider/).</span></span>

> [!NOTE]
> <span data-ttu-id="2e942-426">Nem használatos a munkamenetállapot-szolgáltatóját Azure Redis Cache az ASP.NET-alkalmazások az Azure-alapú környezetben futtatható.</span><span class="sxs-lookup"><span data-stu-id="2e942-426">Do not use the session state provider for Azure Redis Cache with ASP.NET applications that run outside of the Azure environment.</span></span> <span data-ttu-id="2e942-427">A várakozási a gyorsítótárból, az Azure-on kívüli elérésének megszüntetheti által nyújtott az adatokat.</span><span class="sxs-lookup"><span data-stu-id="2e942-427">The latency of accessing the cache from outside of Azure can eliminate the performance benefits of caching data.</span></span>
> 
> 

<span data-ttu-id="2e942-428">Hasonlóképpen a kimeneti gyorsítótár-szolgáltató az Azure Redis Cache lehetővé teszi a HTTP-válaszokat az ASP.NET webes alkalmazások által generált mentését.</span><span class="sxs-lookup"><span data-stu-id="2e942-428">Similarly, the output cache provider for Azure Redis Cache enables you to save the HTTP responses generated by an ASP.NET web application.</span></span> <span data-ttu-id="2e942-429">A kimeneti gyorsítótár-szolgáltató használata Azure Redis Cache javíthatja a leképezési összetett HTML-kimenetében alkalmazások válaszidejét.</span><span class="sxs-lookup"><span data-stu-id="2e942-429">Using the output cache provider with Azure Redis Cache can improve the response times of applications that render complex HTML output.</span></span> <span data-ttu-id="2e942-430">Alkalmazáspéldányok hasonló választ eredményező teheti a megosztott kimeneti töredék ez után a kimeneti HTML generálása helyett a gyorsítótár használatát.</span><span class="sxs-lookup"><span data-stu-id="2e942-430">Application instances that generate similar responses can make use of the shared output fragments in the cache rather than generating this HTML output afresh.</span></span> <span data-ttu-id="2e942-431">További információkért lásd: [az ASP.NET kimeneti gyorsítótár-szolgáltató Azure Redis Cache](/azure/redis-cache/cache-aspnet-output-cache-provider/).</span><span class="sxs-lookup"><span data-stu-id="2e942-431">For more information, see [ASP.NET output cache provider for Azure Redis Cache](/azure/redis-cache/cache-aspnet-output-cache-provider/).</span></span>

## <a name="building-a-custom-redis-cache"></a><span data-ttu-id="2e942-432">Egy egyéni Redis gyorsítótár létrehozása</span><span class="sxs-lookup"><span data-stu-id="2e942-432">Building a custom Redis cache</span></span>
<span data-ttu-id="2e942-433">Azure Redis Cache szolgáltatásba, illetve egy homlokzati az alapul szolgáló Redis-kiszolgálókra.</span><span class="sxs-lookup"><span data-stu-id="2e942-433">Azure Redis Cache acts as a façade to the underlying Redis servers.</span></span> <span data-ttu-id="2e942-434">Jelenleg konfigurációk készletét támogatja, de nem biztosít a Redis-fürtszolgáltatáshoz.</span><span class="sxs-lookup"><span data-stu-id="2e942-434">Currently it supports a fixed set of configurations but does not provide for Redis clustering.</span></span> <span data-ttu-id="2e942-435">Ha szüksége van, amely nem mutatja be az Azure Redis cache-(például a gyorsítótár 53 GB-nál nagyobb) speciális konfiguráció hozza létre, és a saját Redis állomáskiszolgáló Azure virtuális gépek használatával.</span><span class="sxs-lookup"><span data-stu-id="2e942-435">If you require an advanced configuration that is not covered by the Azure Redis cache (such as a cache bigger than 53 GB) you can build and host your own Redis servers by using Azure virtual machines.</span></span>

<span data-ttu-id="2e942-436">Ez a potenciálisan összetett folyamat, mert a több virtuális gépek alárendelt és csomópontok meghatalmazottjaként járhatnak el, ha azt szeretné, többszörözésére létrehozásához szükség lehet.</span><span class="sxs-lookup"><span data-stu-id="2e942-436">This is a potentially complex process because you might need to create several VMs to act as master and subordinate nodes if you want to implement replication.</span></span> <span data-ttu-id="2e942-437">Továbbá ha létre szeretne hozni egy fürtöt, akkor szüksége több főkiszolgálók és alárendelt kiszolgálók.</span><span class="sxs-lookup"><span data-stu-id="2e942-437">Furthermore, if you wish to create a cluster, then you need multiple masters and subordinate servers.</span></span> <span data-ttu-id="2e942-438">A minimális fürtözött topológiát, amely magas szintű rendelkezésre állást és méretezhetőséget biztosít a három fő-és alárendelt kiszolgálók (fürt tartalmaznia kell legalább három fő csomópontok) értékpár formájában rendszerezett legalább hat virtuális gépek foglalja magában.</span><span class="sxs-lookup"><span data-stu-id="2e942-438">A minimal clustered replication topology that provides a high degree of availability and scalability comprises at least six VMs organized as three pairs of master/subordinate servers (a cluster must contain at least three master nodes).</span></span>

<span data-ttu-id="2e942-439">Minden fő-és alárendelt párt együtt zárja be a késés csökkentése érdekében érdemes kell elhelyezkedniük.</span><span class="sxs-lookup"><span data-stu-id="2e942-439">Each master/subordinate pair should be located close together to minimize latency.</span></span> <span data-ttu-id="2e942-440">Azonban minden álló párok csoportja futhat az különböző régiókban található különböző Azure adatközpontjaiban, ha közel az alkalmazásokat, amelyek valószínűleg használni a gyorsítótárazott adatok kereséséhez.</span><span class="sxs-lookup"><span data-stu-id="2e942-440">However, each set of pairs can be running in different Azure datacenters located in different regions, if you wish to locate cached data close to the applications that are most likely to use it.</span></span>  <span data-ttu-id="2e942-441">Például egy létrehozása és konfigurálása a Redis-csomópont egy Azure virtuális gépként fut, lásd: [a CentOS Linux virtuális gép az Azure-ban futó Redis](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx).</span><span class="sxs-lookup"><span data-stu-id="2e942-441">For an example of building and configuring a Redis node running as an Azure VM, see [Running Redis on a CentOS Linux VM in Azure](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx).</span></span>

> [!NOTE]
> <span data-ttu-id="2e942-442">Vegye figyelembe, hogy a saját Redis gyorsítótár ily módon alkalmazza, ha Ön felelősséggel tartozik figyeléséhez, kezeléséhez és a szolgáltatás biztonságossá tétele.</span><span class="sxs-lookup"><span data-stu-id="2e942-442">Please note that if you implement your own Redis cache in this way, you are responsible for monitoring, managing, and securing the service.</span></span>
> 

## <a name="partitioning-a-redis-cache"></a><span data-ttu-id="2e942-443">A Redis gyorsítótár particionálás</span><span class="sxs-lookup"><span data-stu-id="2e942-443">Partitioning a Redis cache</span></span>
<span data-ttu-id="2e942-444">A gyorsítótár particionálás magában foglalja a gyorsítótár felosztása több számítógép között.</span><span class="sxs-lookup"><span data-stu-id="2e942-444">Partitioning the cache involves splitting the cache across multiple computers.</span></span> <span data-ttu-id="2e942-445">Ez a struktúra lehetővé teszi számos előnnyel egyetlen kiszolgálóval, beleértve:</span><span class="sxs-lookup"><span data-stu-id="2e942-445">This structure gives you several advantages over using a single cache server, including:</span></span>

* <span data-ttu-id="2e942-446">Olyan gyorsítótár létrehozását is nagyobb, mint egy kiszolgálón is tárolhatók.</span><span class="sxs-lookup"><span data-stu-id="2e942-446">Creating a cache that is much bigger than can be stored on a single server.</span></span>
* <span data-ttu-id="2e942-447">Osztja el az adatok között a kiszolgálók rendelkezésre állás javítása.</span><span class="sxs-lookup"><span data-stu-id="2e942-447">Distributing data across servers, improving availability.</span></span> <span data-ttu-id="2e942-448">Ha egy kiszolgáló meghibásodik vagy elérhetetlenné válik, az adatokat, amely tárolja nem érhető el, de a többi kiszolgálón továbbra is elérhető.</span><span class="sxs-lookup"><span data-stu-id="2e942-448">If one server fails or becomes inaccessible, the data that it holds is unavailable, but the data on the remaining servers can still be accessed.</span></span> <span data-ttu-id="2e942-449">A gyorsítótár ennek oka nem kritikus fontosságú a gyorsítótárazott adatokat csak átmeneti az adatok másolatát, amely az adatbázis használatban van.</span><span class="sxs-lookup"><span data-stu-id="2e942-449">For a cache, this is not crucial because the cached data is only a transient copy of the data that's held in a database.</span></span> <span data-ttu-id="2e942-450">Egy olyan kiszolgálón, elérhetetlenné válik a gyorsítótárazott adatok helyette gyorsítótárazható egy másik kiszolgálón.</span><span class="sxs-lookup"><span data-stu-id="2e942-450">Cached data on a server that becomes inaccessible can be cached on a different server instead.</span></span>
* <span data-ttu-id="2e942-451">A terhelés terjednek kiszolgáló, így javul a teljesítmény és méretezhetőség között.</span><span class="sxs-lookup"><span data-stu-id="2e942-451">Spreading the load across servers, thereby improving performance and scalability.</span></span>
* <span data-ttu-id="2e942-452">A felhasználók számára, amelyek férni, így csökkenti a késéseket lezárja Geolocating adatok.</span><span class="sxs-lookup"><span data-stu-id="2e942-452">Geolocating data close to the users that access it, thus reducing latency.</span></span>

<span data-ttu-id="2e942-453">A gyorsítótár a leggyakrabban használt particionálás formátuma horizontális.</span><span class="sxs-lookup"><span data-stu-id="2e942-453">For a cache, the most common form of partitioning is sharding.</span></span> <span data-ttu-id="2e942-454">Ezt a stratégiát minden partíció (és horizontális skálázás) a Redis gyorsítótár önálló.</span><span class="sxs-lookup"><span data-stu-id="2e942-454">In this strategy, each partition (or shard) is a Redis cache in its own right.</span></span> <span data-ttu-id="2e942-455">Adatok horizontális logika, amely használatával megközelítés különböző terjesztheti az adatok segítségével egy adott partícióra van átirányítva.</span><span class="sxs-lookup"><span data-stu-id="2e942-455">Data is directed to a specific partition by using sharding logic, which can use a variety of approaches to distribute the data.</span></span> <span data-ttu-id="2e942-456">A [horizontális mintát](http://msdn.microsoft.com/library/dn589797.aspx) horizontális alkalmazásával kapcsolatos további információkat biztosít.</span><span class="sxs-lookup"><span data-stu-id="2e942-456">The [Sharding pattern](http://msdn.microsoft.com/library/dn589797.aspx) provides more information about implementing sharding.</span></span>

<span data-ttu-id="2e942-457">A Redis gyorsítótár particionálás alkalmazásához hajthatók végre a következő módszerek egyikét:</span><span class="sxs-lookup"><span data-stu-id="2e942-457">To implement partitioning in a Redis cache, you can take one of the following approaches:</span></span>

* <span data-ttu-id="2e942-458">*Kiszolgálóoldali lekérdezés útválasztást.*</span><span class="sxs-lookup"><span data-stu-id="2e942-458">*Server-side query routing.*</span></span> <span data-ttu-id="2e942-459">Ezzel a technikával az ügyfélalkalmazás egy kérést küld a Redis-kiszolgáló a gyorsítótárban (valószínűleg a legközelebbi kiszolgálót) alkotó.</span><span class="sxs-lookup"><span data-stu-id="2e942-459">In this technique, a client application sends a request to any of the Redis servers that comprise the cache (probably the closest server).</span></span> <span data-ttu-id="2e942-460">Minden egyes Redis-kiszolgáló tárolja, amely leírja, hogy azt tartalmazza, és információkat arról, hogy mely partíciók található más kiszolgálókon is tartalmaz a partíciós metaadatok.</span><span class="sxs-lookup"><span data-stu-id="2e942-460">Each Redis server stores metadata that describes the partition that it holds, and also contains information about which partitions are located on other servers.</span></span> <span data-ttu-id="2e942-461">A Redis-kiszolgáló megvizsgálja az ügyfélkérés.</span><span class="sxs-lookup"><span data-stu-id="2e942-461">The Redis server examines the client request.</span></span> <span data-ttu-id="2e942-462">Ha helyileg feloldható, hajtja végre a kért műveletet.</span><span class="sxs-lookup"><span data-stu-id="2e942-462">If it can be resolved locally, it will perform the requested operation.</span></span> <span data-ttu-id="2e942-463">Ellenkező esetben azt továbbítja a kérelmet be a megfelelő kiszolgálóra.</span><span class="sxs-lookup"><span data-stu-id="2e942-463">Otherwise it will forward the request on to the appropriate server.</span></span> <span data-ttu-id="2e942-464">Ez a modell fürtszolgáltatás Redis valósul meg, és további részletes leírását lásd a a [Redis-fürt oktatóanyag](http://redis.io/topics/cluster-tutorial) lap a Redis-webhelyen.</span><span class="sxs-lookup"><span data-stu-id="2e942-464">This model is implemented by Redis clustering, and is described in more detail on the [Redis cluster tutorial](http://redis.io/topics/cluster-tutorial) page on the Redis website.</span></span> <span data-ttu-id="2e942-465">A redis-fürtszolgáltatás ügyfélalkalmazások számára átlátható, és további Redis-kiszolgálók is hozzáadhatók a fürtöt (és az adatok újbóli particionálása) anélkül, hogy be újra az ügyfeleket.</span><span class="sxs-lookup"><span data-stu-id="2e942-465">Redis clustering is transparent to client applications, and additional Redis servers can be added to the cluster (and the data re-partitioned) without requiring that you reconfigure the clients.</span></span>
* <span data-ttu-id="2e942-466">*Ügyféloldali particionálást.*</span><span class="sxs-lookup"><span data-stu-id="2e942-466">*Client-side partitioning.*</span></span> <span data-ttu-id="2e942-467">Ebben a modellben az ügyfélalkalmazás logikája (valószínűleg a szalagtár formájában), amely kérelmek tartalmazza a megfelelő Redis-kiszolgálóhoz.</span><span class="sxs-lookup"><span data-stu-id="2e942-467">In this model, the client application contains logic (possibly in the form of a library) that routes requests to the appropriate Redis server.</span></span> <span data-ttu-id="2e942-468">Ez a megközelítés Azure Redis Cache használható.</span><span class="sxs-lookup"><span data-stu-id="2e942-468">This approach can be used with Azure Redis Cache.</span></span> <span data-ttu-id="2e942-469">Hozzon létre több Azure Redis Cache-gyorsítótárak (egy mindegyik adatok partíció), és az ügyféloldali logika, amely a kéréseket a megfelelő gyorsítótárba végrehajtása.</span><span class="sxs-lookup"><span data-stu-id="2e942-469">Create multiple Azure Redis Caches (one for each data partition) and implement the client-side logic that routes the requests to the correct cache.</span></span> <span data-ttu-id="2e942-470">Ha a particionálási sémát (Ha további Azure Redis Cache-gyorsítótárak jönnek létre, például) változik, ügyfélalkalmazások módosítania kell újra kell konfigurálni.</span><span class="sxs-lookup"><span data-stu-id="2e942-470">If the partitioning scheme changes (if additional Azure Redis Caches are created, for example), client applications might need to be reconfigured.</span></span>
* <span data-ttu-id="2e942-471">*Proxy támogatott particionálást.*</span><span class="sxs-lookup"><span data-stu-id="2e942-471">*Proxy-assisted partitioning.*</span></span> <span data-ttu-id="2e942-472">A séma alkalmazások küldési kérelmek egy közbülső proxy szolgáltatás, amely tisztában van azzal, hogy az adatok particionálása, és ezután továbbítja a kérést a megfelelő ügyfél Redis kiszolgáló.</span><span class="sxs-lookup"><span data-stu-id="2e942-472">In this scheme, client applications send requests to an intermediary proxy service which understands how the data is partitioned and then routes the request to the appropriate Redis server.</span></span> <span data-ttu-id="2e942-473">Ez a módszer is használható az Azure Redis Cache; a proxy szolgáltatás Azure felhőalapú szolgáltatásként valósítható meg.</span><span class="sxs-lookup"><span data-stu-id="2e942-473">This approach can also be used with Azure Redis Cache; the proxy service can be implemented as an Azure cloud service.</span></span> <span data-ttu-id="2e942-474">Ez a megközelítés szükséges egy további szintű összetettség valósíthatja meg a szolgáltatást, és kérelmek hajtsa végre az ügyféloldali particionálást használnak, mint a hosszabb ideig is tarthat.</span><span class="sxs-lookup"><span data-stu-id="2e942-474">This approach requires an additional level of complexity to implement the service, and requests might take longer to perform than using client-side partitioning.</span></span>

<span data-ttu-id="2e942-475">A lap [particionálására: hogyan adatok több Redis-példány között](http://redis.io/topics/partitioning) a Redis a webhely további információkat nyújt azokról a redis gyorsítótárral particionálás végrehajtására.</span><span class="sxs-lookup"><span data-stu-id="2e942-475">The page [Partitioning: how to split data among multiple Redis instances](http://redis.io/topics/partitioning) on the Redis website provides further information about implementing partitioning with Redis.</span></span>

### <a name="implement-redis-cache-client-applications"></a><span data-ttu-id="2e942-476">Redis gyorsítótár ügyfélalkalmazások megvalósítása</span><span class="sxs-lookup"><span data-stu-id="2e942-476">Implement Redis cache client applications</span></span>
<span data-ttu-id="2e942-477">Számos programozási nyelven támogatása ügyfélalkalmazások redis.</span><span class="sxs-lookup"><span data-stu-id="2e942-477">Redis supports client applications written in numerous programming languages.</span></span> <span data-ttu-id="2e942-478">Ha a .NET-keretrendszer használatával hoz létre új alkalmazásokat, az ajánlott módszer a StackExchange.Redis ügyféloldali kódtár használata.</span><span class="sxs-lookup"><span data-stu-id="2e942-478">If you are building new applications by using the .NET Framework, the recommended approach is to use the StackExchange.Redis client library.</span></span> <span data-ttu-id="2e942-479">Ebben a könyvtárban, amely a Redis-kiszolgálóhoz való kapcsolódás, parancsok küldése és fogadása válaszok részletes kivonatolja .NET-keretrendszer objektum modellt biztosít.</span><span class="sxs-lookup"><span data-stu-id="2e942-479">This library provides a .NET Framework object model that abstracts the details for connecting to a Redis server, sending commands, and receiving responses.</span></span> <span data-ttu-id="2e942-480">Érhető el a Visual Studio NuGet-csomagként.</span><span class="sxs-lookup"><span data-stu-id="2e942-480">It is available in Visual Studio as a NuGet package.</span></span> <span data-ttu-id="2e942-481">Az Azure Redis Cache, vagy egy egyéni Redis gyorsítótár, a virtuális gép üzemeltetett való csatlakozáshoz használhatja ugyanazt a szalagtárat.</span><span class="sxs-lookup"><span data-stu-id="2e942-481">You can use this same library to connect to an Azure Redis Cache, or a custom Redis cache hosted on a VM.</span></span>

<span data-ttu-id="2e942-482">Egy Redis-kiszolgálóhoz való csatlakozáshoz használhat a statikus `Connect` metódusában a `ConnectionMultiplexer` osztály.</span><span class="sxs-lookup"><span data-stu-id="2e942-482">To connect to a Redis server you use the static `Connect` method of the `ConnectionMultiplexer` class.</span></span> <span data-ttu-id="2e942-483">Ezzel a módszerrel hoz létre a kapcsolat az ügyfélalkalmazás élettartama során használandó készült, és több egyidejű szálat használhatja ugyanazt a kapcsolatot.</span><span class="sxs-lookup"><span data-stu-id="2e942-483">The connection that this method creates is designed to be used throughout the lifetime of the client application, and the same connection can be used by multiple concurrent threads.</span></span> <span data-ttu-id="2e942-484">Kapcsolódjon újra, és ne válassza le minden alkalommal, amikor a Redis műveletet hajt végre, mert ez ronthatja a teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="2e942-484">Do not reconnect and disconnect each time you perform a Redis operation because this can degrade performance.</span></span>

<span data-ttu-id="2e942-485">A kapcsolat paraméterek, például a címet a Redis-host és a jelszót is megadhat.</span><span class="sxs-lookup"><span data-stu-id="2e942-485">You can specify the connection parameters, such as the address of the Redis host and the password.</span></span> <span data-ttu-id="2e942-486">Azure Redis Cache használatakor vagy az elsődleges vagy másodlagos kulcsot az Azure felügyeleti portál használatával az Azure Redis Cache létrehozott kell a jelszót.</span><span class="sxs-lookup"><span data-stu-id="2e942-486">If you are using Azure Redis Cache, the password  is either the primary or secondary key that is generated for Azure Redis Cache by using the Azure Management portal.</span></span>

<span data-ttu-id="2e942-487">Miután csatlakozott a Redis-kiszolgáló, az a Redis-adatbázisra, amelyet úgy működik, mint a gyorsítótár leírót ezt úgy szerezheti be.</span><span class="sxs-lookup"><span data-stu-id="2e942-487">After you have connected to the Redis server, you can obtain a handle on the Redis database that acts as the cache.</span></span> <span data-ttu-id="2e942-488">A Redis-kapcsolatot biztosít a `GetDatabase` ehhez metódust.</span><span class="sxs-lookup"><span data-stu-id="2e942-488">The Redis connection provides the `GetDatabase` method to do this.</span></span> <span data-ttu-id="2e942-489">Ezután elemek beolvasása a gyorsítótárból, és a gyorsítótár használatával adatok tárolása a `StringGet` és `StringSet` módszerek.</span><span class="sxs-lookup"><span data-stu-id="2e942-489">You can then retrieve items from the cache and store data in the cache by using the `StringGet` and `StringSet` methods.</span></span> <span data-ttu-id="2e942-490">Ezek a módszerek várt paramétereként egy kulcs, és térjen vissza az elem, vagy a gyorsítótár, amely rendelkezik a megfelelő érték (`StringGet`) vagy az elem felvétele a gyorsítótár a kulcshoz (`StringSet`).</span><span class="sxs-lookup"><span data-stu-id="2e942-490">These methods expect a key as a parameter, and return the item either in the cache that has a matching value (`StringGet`) or add the item to the cache with this key (`StringSet`).</span></span>

<span data-ttu-id="2e942-491">Attól függően, hogy a Redis-kiszolgáló helyét sok művelet lehet, hogy fel Önnek némi késés, amíg a kiszolgáló átkerülnek a kérelmet, és választ küld vissza az ügyfélnek.</span><span class="sxs-lookup"><span data-stu-id="2e942-491">Depending on the location of the Redis server, many operations might incur some latency while a request is transmitted to the server and a response is returned to the client.</span></span> <span data-ttu-id="2e942-492">A StackExchange kódtár biztosít aszinkron verzióinak nagy része a módszereket, amelyek továbbra is válaszol ügyfélalkalmazások segítségével érheti el.</span><span class="sxs-lookup"><span data-stu-id="2e942-492">The StackExchange library provides asynchronous versions of many of the methods that it exposes to help client applications remain responsive.</span></span> <span data-ttu-id="2e942-493">Ezek a módszerek támogatják a [feladatalapú aszinkron mintát](http://msdn.microsoft.com/library/hh873175.aspx) a .NET-keretrendszer.</span><span class="sxs-lookup"><span data-stu-id="2e942-493">These methods support the [Task-based Asynchronous Pattern](http://msdn.microsoft.com/library/hh873175.aspx) in the .NET Framework.</span></span>

<span data-ttu-id="2e942-494">A következő kódrészletet látható nevű metódus `RetrieveItem`.</span><span class="sxs-lookup"><span data-stu-id="2e942-494">The following code snippet shows a method named `RetrieveItem`.</span></span> <span data-ttu-id="2e942-495">Azt mutatja be, a gyorsítótár-tartalékoljon minta alapján Redis és StackExchange szalagtár megvalósítása.</span><span class="sxs-lookup"><span data-stu-id="2e942-495">It illustrates an implementation of the cache-aside pattern based on Redis and the StackExchange library.</span></span> <span data-ttu-id="2e942-496">A metódus karakterlánc-érték vesz igénybe, és megpróbálja beolvasni a megfelelő elem a Redis gyorsítótárt meghívásával a `StringGetAsync` metódus (aszinkron verzióját `StringGet`).</span><span class="sxs-lookup"><span data-stu-id="2e942-496">The method takes a string key value and attempts to retrieve the corresponding item from the Redis cache by calling the `StringGetAsync` method (the asynchronous version of `StringGet`).</span></span>

<span data-ttu-id="2e942-497">Ha az elem nem található, a mögöttes adatok forrás használatával beolvassa a `GetItemFromDataSourceAsync` metódus (amely egy helyi módszert, és nem része a StackExchange könyvtár).</span><span class="sxs-lookup"><span data-stu-id="2e942-497">If the item is not found, it is fetched from the underlying data source using the `GetItemFromDataSourceAsync` method (which is a local method and not part of the StackExchange library).</span></span> <span data-ttu-id="2e942-498">Ezután kerül a gyorsítótárba használatával a `StringSetAsync` , lekérhető gyorsabban legközelebb metódust.</span><span class="sxs-lookup"><span data-stu-id="2e942-498">It's then added to the cache by using the `StringSetAsync` method so it can be retrieved more quickly next time.</span></span>

```csharp
// Connect to the Azure Redis cache
ConfigurationOptions config = new ConfigurationOptions();
config.EndPoints.Add("<your DNS name>.redis.cache.windows.net");
config.Password = "<Redis cache key from management portal>";
ConnectionMultiplexer redisHostConnection = ConnectionMultiplexer.Connect(config);
IDatabase cache = redisHostConnection.GetDatabase();
...
private async Task<string> RetrieveItem(string itemKey)
{
    // Attempt to retrieve the item from the Redis cache
    string itemValue = await cache.StringGetAsync(itemKey);

    // If the value returned is null, the item was not found in the cache
    // So retrieve the item from the data source and add it to the cache
    if (itemValue == null)
    {
        itemValue = await GetItemFromDataSourceAsync(itemKey);
        await cache.StringSetAsync(itemKey, itemValue);
    }

    // Return the item
    return itemValue;
}
```

<span data-ttu-id="2e942-499">A `StringGet` és `StringSet` metódusok nem korlátozódnak lekérése és karakterlánc-értékek tárolásához.</span><span class="sxs-lookup"><span data-stu-id="2e942-499">The `StringGet` and `StringSet` methods are not restricted to retrieving or storing string values.</span></span> <span data-ttu-id="2e942-500">A cikk, mint bájttömb szerializált tarthat.</span><span class="sxs-lookup"><span data-stu-id="2e942-500">They can take any item that is serialized as an array of bytes.</span></span> <span data-ttu-id="2e942-501">.NET-objektum mentése kell, ha szerializálni a byte adatfolyamként, és használja a `StringSet` metódus a gyorsítótárba írni.</span><span class="sxs-lookup"><span data-stu-id="2e942-501">If you need to save a .NET object, you can serialize it as a byte stream and use the `StringSet` method to write it to the cache.</span></span>

<span data-ttu-id="2e942-502">Hasonló módon érheti el egy objektumot a gyorsítótárból használatával a `StringGet` metódus és a .NET objektumként deszerializálása azt.</span><span class="sxs-lookup"><span data-stu-id="2e942-502">Similarly, you can read an object from the cache by using the `StringGet` method and deserializing it as a .NET object.</span></span> <span data-ttu-id="2e942-503">A következő kód bemutatja kiterjesztésmetódusok IDatabase interfész csoportja (a `GetDatabase` Redis kapcsolódási módszert adja vissza egy `IDatabase` objektum), és néhány példakód ezen módszerek írási és olvasási egy `BlogPost` objektum a gyorsítótárban:</span><span class="sxs-lookup"><span data-stu-id="2e942-503">The following code shows a set of extension methods for the IDatabase interface (the `GetDatabase` method of a Redis connection returns an `IDatabase` object),  and some sample code that uses these methods to read and write a `BlogPost` object to the cache:</span></span>

```csharp
public static class RedisCacheExtensions
{
    public static async Task<T> GetAsync<T>(this IDatabase cache, string key)
    {
        return Deserialize<T>(await cache.StringGetAsync(key));
    }

    public static async Task<object> GetAsync(this IDatabase cache, string key)
    {
        return Deserialize<object>(await cache.StringGetAsync(key));
    }

    public static async Task SetAsync(this IDatabase cache, string key, object value)
    {
        await cache.StringSetAsync(key, Serialize(value));
    }

    static byte[] Serialize(object o)
    {
        byte[] objectDataAsStream = null;

        if (o != null)
        {
            BinaryFormatter binaryFormatter = new BinaryFormatter();
            using (MemoryStream memoryStream = new MemoryStream())
            {
                binaryFormatter.Serialize(memoryStream, o);
                objectDataAsStream = memoryStream.ToArray();
            }
        }

        return objectDataAsStream;
    }

    static T Deserialize<T>(byte[] stream)
    {
        T result = default(T);

        if (stream != null)
        {
            BinaryFormatter binaryFormatter = new BinaryFormatter();
            using (MemoryStream memoryStream = new MemoryStream(stream))
            {
                result = (T)binaryFormatter.Deserialize(memoryStream);
            }
        }

        return result;
    }
}
```

<span data-ttu-id="2e942-504">Az alábbi kód bemutatja nevű metódus `RetrieveBlogPost` használó ezek kiterjesztésmetódusok írási és olvasási egy szerializálható `BlogPost` a gyorsítótár, a gyorsítótár-tartalékoljon mintát a következő objektumot:</span><span class="sxs-lookup"><span data-stu-id="2e942-504">The following code illustrates a method named `RetrieveBlogPost` that uses these extension methods to read and write a serializable `BlogPost` object to the cache following the cache-aside pattern:</span></span>

```csharp
// The BlogPost type
[Serializable]
public class BlogPost
{
    private HashSet<string> tags;

    public BlogPost(int id, string title, int score, IEnumerable<string> tags)
    {
        this.Id = id;
        this.Title = title;
        this.Score = score;
        this.tags = new HashSet<string>(tags);
    }

    public int Id { get; set; }
    public string Title { get; set; }
    public int Score { get; set; }
    public ICollection<string> Tags => this.tags;
}
...
private async Task<BlogPost> RetrieveBlogPost(string blogPostKey)
{
    BlogPost blogPost = await cache.GetAsync<BlogPost>(blogPostKey);
    if (blogPost == null)
    {
        blogPost = await GetBlogPostFromDataSourceAsync(blogPostKey);
        await cache.SetAsync(blogPostKey, blogPost);
    }

    return blogPost;
}
```

<span data-ttu-id="2e942-505">Redis támogatja az parancs futószalagos, ha egy ügyfél alkalmazás több aszinkron kérést küld.</span><span class="sxs-lookup"><span data-stu-id="2e942-505">Redis supports command pipelining if a client application sends multiple asynchronous requests.</span></span> <span data-ttu-id="2e942-506">A redis is vált a kérelmek ugyanazt a kapcsolatot használja helyett fogadására és válaszol a parancsok szigorú sorrendben.</span><span class="sxs-lookup"><span data-stu-id="2e942-506">Redis can multiplex the requests using the same connection rather than receiving and responding to commands in a strict sequence.</span></span>

<span data-ttu-id="2e942-507">Ez a megközelítés segít azáltal, hogy hatékonyabb használatát a hálózati késés csökkentésére.</span><span class="sxs-lookup"><span data-stu-id="2e942-507">This approach helps to reduce latency by making more efficient use of the network.</span></span> <span data-ttu-id="2e942-508">A következő kódrészletet mutat be, amely lekéri egyidejűleg két ügyfelek részleteit.</span><span class="sxs-lookup"><span data-stu-id="2e942-508">The following code snippet shows an example that retrieves the details of two customers concurrently.</span></span> <span data-ttu-id="2e942-509">A kód elküldi a két kérelmet, és néhány más feldolgozás (nincs ábrázolva) vár az eredmények előtt hajtja végre.</span><span class="sxs-lookup"><span data-stu-id="2e942-509">The code submits two requests and then performs some other processing (not shown) before waiting to receive the results.</span></span> <span data-ttu-id="2e942-510">A `Wait` a gyorsítótár-objektumának módszer hasonló a .NET-keretrendszer `Task.Wait` módszert:</span><span class="sxs-lookup"><span data-stu-id="2e942-510">The `Wait` method of the cache object is similar to the .NET Framework `Task.Wait` method:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
var task1 = cache.StringGetAsync("customer:1");
var task2 = cache.StringGetAsync("customer:2");
...
var customer1 = cache.Wait(task1);
var customer2 = cache.Wait(task2);
```

<span data-ttu-id="2e942-511">Ügyfélalkalmazások, amelyek az Azure Redis Cache írásáról további információkért lásd: [Azure Redis Cache dokumentáció](https://azure.microsoft.com/documentation/services/cache/).</span><span class="sxs-lookup"><span data-stu-id="2e942-511">For additional information on writing client applications that can the Azure Redis Cache, see [Azure Redis Cache documentation](https://azure.microsoft.com/documentation/services/cache/).</span></span> <span data-ttu-id="2e942-512">További információk is érhető el: [StackExchange.Redis](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md).</span><span class="sxs-lookup"><span data-stu-id="2e942-512">More information is also available at [StackExchange.Redis](https://github.com/StackExchange/StackExchange.Redis/blob/master/Docs/Basics.md).</span></span>

<span data-ttu-id="2e942-513">A lap [folyamatok és multiplexers](https://stackexchange.github.io/StackExchange.Redis/PipelinesMultiplexers) ugyanazt a webhelyet az aszinkron műveletek és a Redis és StackExchange szalagtár futószalagos további információt nyújt.</span><span class="sxs-lookup"><span data-stu-id="2e942-513">The page [Pipelines and multiplexers](https://stackexchange.github.io/StackExchange.Redis/PipelinesMultiplexers) on the same website provides more information about asynchronous operations and pipelining with Redis and the StackExchange library.</span></span>  <span data-ttu-id="2e942-514">Ebben a cikkben a Redis gyorsítótár, a következő szakaszban néhány speciális módszert, amely használatban van a Redis gyorsítótár adatokkal alkalmazható példákat tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="2e942-514">The next section in this article, Using  Redis Caching, provides examples of some of the more advanced techniques that you can apply to data that's held in a Redis cache.</span></span>

## <a name="using-redis-caching"></a><span data-ttu-id="2e942-515">Redis gyorsítótár használata</span><span class="sxs-lookup"><span data-stu-id="2e942-515">Using Redis caching</span></span>
<span data-ttu-id="2e942-516">A legegyszerűbb Redis aggályokat gyorsítótárazás használata kulcs-érték párok ahol az érték egy tetszőleges hosszúságú bináris adatokat tartalmazó nem értelmezett karakterlánc.</span><span class="sxs-lookup"><span data-stu-id="2e942-516">The simplest use of Redis for caching concerns is key-value pairs where the value is an uninterpreted string of arbitrary length that can contain any binary data.</span></span> <span data-ttu-id="2e942-517">(Lényegében bájttömb karakterláncként kezelhető szó).</span><span class="sxs-lookup"><span data-stu-id="2e942-517">(It is essentially  an array of bytes that can be treated as a string).</span></span> <span data-ttu-id="2e942-518">Ebben a forgatókönyvben lett mutatja be a szakasz megvalósítása Redis Cache ügyfélalkalmazások az ebben a cikkben.</span><span class="sxs-lookup"><span data-stu-id="2e942-518">This scenario was illustrated in the section Implement Redis Cache client applications earlier in this article.</span></span>

<span data-ttu-id="2e942-519">Vegye figyelembe, hogy kulcsok nem értelmezett olyan adatokat is tartalmazhat, így minden bináris adatot kulcsként.</span><span class="sxs-lookup"><span data-stu-id="2e942-519">Note that keys also contain uninterpreted data, so you can use any binary information as the key.</span></span> <span data-ttu-id="2e942-520">Minél hosszabb a kulcsot meg kell azonban a több helyet fog tartani, amíg tárolja, és annál tovább fog tartani, amíg keresési műveletek végrehajtásához.</span><span class="sxs-lookup"><span data-stu-id="2e942-520">The longer the key is, however, the more space it will take to store, and the longer it will take to perform lookup operations.</span></span> <span data-ttu-id="2e942-521">A használhatóság és a könnyű karbantartási gondosan tervezése a kulcstérértesítések használatával, és használjon értelmezhető (de nem részletes) kulcsokat.</span><span class="sxs-lookup"><span data-stu-id="2e942-521">For usability and ease of maintenance, design your keyspace carefully and use meaningful (but not verbose) keys.</span></span>

<span data-ttu-id="2e942-522">Például strukturált kulcsok, például a "felhasználói: 100" segítségével egyszerűen "100" helyett azonosító 100 az ügyfél a kulcsot jelöl.</span><span class="sxs-lookup"><span data-stu-id="2e942-522">For example, use structured keys such as "customer:100" to represent the key for the customer with ID 100 rather than simply "100".</span></span> <span data-ttu-id="2e942-523">Ez a séma lehetővé teszi, hogy egyszerűen megkülönböztetni a tároló adattípusa különböző értékeket.</span><span class="sxs-lookup"><span data-stu-id="2e942-523">This scheme enables you to easily distinguish between values that store different data types.</span></span> <span data-ttu-id="2e942-524">A kulcs a azonosító 100 rendelés képviselő például a "rendelések: 100" kulcsot is használhat.</span><span class="sxs-lookup"><span data-stu-id="2e942-524">For example, you could also use the key "orders:100" to represent the key for the order with ID 100.</span></span>

<span data-ttu-id="2e942-525">Egydimenziós bináris karakterláncok, leszámítva egy Redis kulcs-érték párokban szereplő érték is tárolható strukturáltabb információt, beleértve a listákat, és állítja be (rendezve és rendezetlen) csak.</span><span class="sxs-lookup"><span data-stu-id="2e942-525">Apart from one-dimensional binary strings, a value in a Redis key-value pair can also hold more structured information, including lists, sets (sorted and unsorted), and hashes.</span></span> <span data-ttu-id="2e942-526">Redis biztosít átfogó parancsot, hogy ezek a típusok kezelhető, és ezek a parancsok számos StackExchange például egy ügyféloldali kódtára a .NET-keretrendszer alkalmazások.</span><span class="sxs-lookup"><span data-stu-id="2e942-526">Redis provides a comprehensive command set that can manipulate these types, and many of these commands are available to .NET Framework applications through a client library such as StackExchange.</span></span> <span data-ttu-id="2e942-527">A lap [Redis az adattípusokat és az absztrakt entitással egészült ki bemutatását](http://redis.io/topics/data-types-intro) a Redis a webhely részletes áttekintést nyújt az ezek a típusok és a parancsok, amelyek segítségével kezelheti azokat.</span><span class="sxs-lookup"><span data-stu-id="2e942-527">The page [An introduction to Redis data types and abstractions](http://redis.io/topics/data-types-intro) on the Redis website provides a more detailed overview of these types and the commands that you can use to manipulate them.</span></span>

<span data-ttu-id="2e942-528">Ez a szakasz néhány gyakori alkalmazási esetei ezeket az adattípusokat és parancsok foglalja össze.</span><span class="sxs-lookup"><span data-stu-id="2e942-528">This section summarizes some common use cases for these data types and commands.</span></span>

### <a name="perform-atomic-and-batch-operations"></a><span data-ttu-id="2e942-529">Hajtsa végre a atomi és kötegelt műveleteket</span><span class="sxs-lookup"><span data-stu-id="2e942-529">Perform atomic and batch operations</span></span>
<span data-ttu-id="2e942-530">A redis atomi get és set műveletek karakterlánc-értékek több támogatja.</span><span class="sxs-lookup"><span data-stu-id="2e942-530">Redis supports a series of atomic get-and-set operations on string values.</span></span> <span data-ttu-id="2e942-531">Ezeket a műveleteket, távolítsa el a lehetséges versenyhelyzet veszélyek külön használatakor előforduló `GET` és `SET` parancsok.</span><span class="sxs-lookup"><span data-stu-id="2e942-531">These operations remove the possible race hazards that might occur when using separate `GET` and `SET` commands.</span></span> <span data-ttu-id="2e942-532">A rendelkezésre álló műveletek a következők:</span><span class="sxs-lookup"><span data-stu-id="2e942-532">The operations that are available include:</span></span>

* <span data-ttu-id="2e942-533">`INCR`, `INCRBY`, `DECR`, és `DECRBY`, amely műveleteket atomi növekmény és csökkentést egész numerikus értékek.</span><span class="sxs-lookup"><span data-stu-id="2e942-533">`INCR`, `INCRBY`, `DECR`, and `DECRBY`, which perform atomic increment and decrement operations on integer numeric data values.</span></span> <span data-ttu-id="2e942-534">A StackExchange kódtár biztosít túlterhelt verziói a `IDatabase.StringIncrementAsync` és `IDatabase.StringDecrementAsync` módszereket hajtsa végre ezeket a műveleteket, és térjen vissza az eredményül kapott érték, amely a gyorsítótárba.</span><span class="sxs-lookup"><span data-stu-id="2e942-534">The StackExchange library provides overloaded versions of the `IDatabase.StringIncrementAsync` and `IDatabase.StringDecrementAsync` methods to perform these operations and return the resulting value that is stored in the cache.</span></span> <span data-ttu-id="2e942-535">A következő kódrészletet mutatja be az alábbi módszerekkel:</span><span class="sxs-lookup"><span data-stu-id="2e942-535">The following code snippet illustrates how to use these methods:</span></span>
  
  ```csharp
  ConnectionMultiplexer redisHostConnection = ...;
  IDatabase cache = redisHostConnection.GetDatabase();
  ...
  await cache.StringSetAsync("data:counter", 99);
  ...
  long oldValue = await cache.StringIncrementAsync("data:counter");
  // Increment by 1 (the default)
  // oldValue should be 100
  
  long newValue = await cache.StringDecrementAsync("data:counter", 50);
  // Decrement by 50
  // newValue should be 50
  ```
* <span data-ttu-id="2e942-536">`GETSET`, amely lekéri az értéket, amelyet a kulcs van társítva, és nem módosítja azt egy új értékkel.</span><span class="sxs-lookup"><span data-stu-id="2e942-536">`GETSET`, which retrieves the value that's associated with a key and changes it to a new value.</span></span> <span data-ttu-id="2e942-537">A StackExchange könyvtár művelet keresztül elérhetővé teszi a `IDatabase.StringGetSetAsync` metódust.</span><span class="sxs-lookup"><span data-stu-id="2e942-537">The StackExchange library makes this operation available through the `IDatabase.StringGetSetAsync` method.</span></span> <span data-ttu-id="2e942-538">Az alábbi kódrészlet ezt a módszert példáját mutatja be.</span><span class="sxs-lookup"><span data-stu-id="2e942-538">The code snippet below shows an example of this method.</span></span> <span data-ttu-id="2e942-539">Ez a kód a kulcs "adatok: számláló" az előző példából tartozó aktuális értékét adja vissza.</span><span class="sxs-lookup"><span data-stu-id="2e942-539">This code returns the current value that's associated with the key "data:counter" from the previous example.</span></span> <span data-ttu-id="2e942-540">Majd azt visszaállítja a kulcs értéke nulla, az összes azonos művelet részeként:</span><span class="sxs-lookup"><span data-stu-id="2e942-540">Then it resets the value for this key back to zero, all as part of the same operation:</span></span>
  
  ```csharp
  ConnectionMultiplexer redisHostConnection = ...;
  IDatabase cache = redisHostConnection.GetDatabase();
  ...
  string oldValue = await cache.StringGetSetAsync("data:counter", 0);
  ```
* <span data-ttu-id="2e942-541">`MGET`és `MSET`, amelyhez vissza vagy módosítsa egy karakterlánc-értékek beállítása egyetlen műveletben.</span><span class="sxs-lookup"><span data-stu-id="2e942-541">`MGET` and `MSET`, which can return or change a set of string values as a single operation.</span></span> <span data-ttu-id="2e942-542">A `IDatabase.StringGetAsync` és `IDatabase.StringSetAsync` módszerek túlterhelt támogatja ezt a funkciót, hogy a következő példában látható módon:</span><span class="sxs-lookup"><span data-stu-id="2e942-542">The `IDatabase.StringGetAsync` and `IDatabase.StringSetAsync` methods are overloaded to support this functionality, as shown in the following example:</span></span>
  
  ```csharp
  ConnectionMultiplexer redisHostConnection = ...;
  IDatabase cache = redisHostConnection.GetDatabase();
  ...
  // Create a list of key-value pairs
  var keysAndValues =
      new List<KeyValuePair<RedisKey, RedisValue>>()
      {
          new KeyValuePair<RedisKey, RedisValue>("data:key1", "value1"),
          new KeyValuePair<RedisKey, RedisValue>("data:key99", "value2"),
          new KeyValuePair<RedisKey, RedisValue>("data:key322", "value3")
      };
  
  // Store the list of key-value pairs in the cache
  cache.StringSet(keysAndValues.ToArray());
  ...
  // Find all values that match a list of keys
  RedisKey[] keys = { "data:key1", "data:key99", "data:key322"};
  // values should contain { "value1", "value2", "value3" }
  RedisValue[] values = cache.StringGet(keys);

  ```

<span data-ttu-id="2e942-543">A Redis tranzakciók és kötegek szakaszban az ebben a cikkben leírtak Redis egyetlen tranzakció több műveletek is használhatja együttesen.</span><span class="sxs-lookup"><span data-stu-id="2e942-543">You can also combine multiple operations into a single Redis transaction as described in the Redis transactions and batches section earlier in this article.</span></span> <span data-ttu-id="2e942-544">A StackExchange könyvtár támogatást nyújt a tranzakciók keresztül a `ITransaction` felületet.</span><span class="sxs-lookup"><span data-stu-id="2e942-544">The StackExchange library provides support for transactions through the `ITransaction` interface.</span></span>

<span data-ttu-id="2e942-545">Létrehozhat egy `ITransaction` objektum használatával a `IDatabase.CreateTransaction` metódust.</span><span class="sxs-lookup"><span data-stu-id="2e942-545">You create an `ITransaction` object by using the `IDatabase.CreateTransaction` method.</span></span> <span data-ttu-id="2e942-546">A tranzakció parancsok meghívásához által biztosított módszerekkel a `ITransaction` objektum.</span><span class="sxs-lookup"><span data-stu-id="2e942-546">You invoke commands to the transaction by using the methods provided by the `ITransaction` object.</span></span>

<span data-ttu-id="2e942-547">A `ITransaction` felületet biztosít hozzáférést módszerek által elért hasonló a `IDatabase` felület, azzal a különbséggel, hogy a metódusok aszinkron jellegűek.</span><span class="sxs-lookup"><span data-stu-id="2e942-547">The `ITransaction` interface provides access to a set of methods that's similar to those accessed by the `IDatabase` interface, except that all the methods are asynchronous.</span></span> <span data-ttu-id="2e942-548">Ez azt jelenti, hogy ezeket csak végre, ha a `ITransaction.Execute` meghívott metódus.</span><span class="sxs-lookup"><span data-stu-id="2e942-548">This means that they are only performed when the `ITransaction.Execute` method is invoked.</span></span> <span data-ttu-id="2e942-549">A által visszaadott érték a `ITransaction.Execute` módszer azt jelzi, hogy a tranzakció sikeresen létrejött-e (igaz) vagy, ha (hamis) sikertelen volt.</span><span class="sxs-lookup"><span data-stu-id="2e942-549">The value that's returned by the `ITransaction.Execute` method indicates whether the transaction was created successfully (true) or if it failed (false).</span></span>

<span data-ttu-id="2e942-550">A következő kódrészletet példáját mutatja be, hogy lépésekben, és csökkenti két számlálók ugyanabban a tranzakcióban részeként:</span><span class="sxs-lookup"><span data-stu-id="2e942-550">The following code snippet shows an example that increments and decrements two counters as part of the same transaction:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
ITransaction transaction = cache.CreateTransaction();
var tx1 = transaction.StringIncrementAsync("data:counter1");
var tx2 = transaction.StringDecrementAsync("data:counter2");
bool result = transaction.Execute();
Console.WriteLine("Transaction {0}", result ? "succeeded" : "failed");
Console.WriteLine("Result of increment: {0}", tx1.Result);
Console.WriteLine("Result of decrement: {0}", tx2.Result);
```

<span data-ttu-id="2e942-551">Ne feledje, hogy a Redis tranzakciók eltérően a relációs adatbázisok tranzakciók.</span><span class="sxs-lookup"><span data-stu-id="2e942-551">Remember that Redis transactions are unlike transactions in relational databases.</span></span> <span data-ttu-id="2e942-552">A `Execute` metódus egyszerűen várólisták a tranzakció futtatható alkotó összes parancs, és ha valamelyiket rosszul megformázva majd a tranzakció le van állítva.</span><span class="sxs-lookup"><span data-stu-id="2e942-552">The `Execute` method simply queues all the commands that comprise the transaction to be run, and if any of them is malformed then the transaction is stopped.</span></span> <span data-ttu-id="2e942-553">Ha a parancsok sikeresen várólistára, minden parancs aszinkron módon futtatja.</span><span class="sxs-lookup"><span data-stu-id="2e942-553">If all the commands have been queued successfully, each command runs asynchronously.</span></span>

<span data-ttu-id="2e942-554">Ha a parancs sikertelen, a többi feldolgozási továbbra is.</span><span class="sxs-lookup"><span data-stu-id="2e942-554">If any command fails, the others still continue processing.</span></span> <span data-ttu-id="2e942-555">Ha vissza kell igazolnia, hogy a parancs sikeresen befejeződött, kell-e a parancs beolvasása használatával a **eredmény** tulajdonság a megfelelő feladat, mint a fenti példában szereplő.</span><span class="sxs-lookup"><span data-stu-id="2e942-555">If you need to verify that a command has completed successfully, you must fetch the results of the command by using the **Result** property of the corresponding task, as shown in the example above.</span></span> <span data-ttu-id="2e942-556">Olvasás a **eredmény** tulajdonság letiltja a hívó szál, amíg a feladat befejeződött.</span><span class="sxs-lookup"><span data-stu-id="2e942-556">Reading the **Result** property will block the calling thread until the task has completed.</span></span>

<span data-ttu-id="2e942-557">További információkért lásd: a [Redis-tranzakciók](https://stackexchange.github.io/StackExchange.Redis/Transactions) lap a StackExchange.Redis-webhelyen.</span><span class="sxs-lookup"><span data-stu-id="2e942-557">For more information, see the [Transactions in Redis](https://stackexchange.github.io/StackExchange.Redis/Transactions) page on the StackExchange.Redis website.</span></span>

<span data-ttu-id="2e942-558">Kötegelt műveletek végrehajtásához, használhatja a `IBatch` StackExchange függvénytár felületet.</span><span class="sxs-lookup"><span data-stu-id="2e942-558">When performing batch operations, you can use the `IBatch` interface of the StackExchange library.</span></span> <span data-ttu-id="2e942-559">Ez az interfész által elért hasonló módszerek készlete hozzáférést biztosít a `IDatabase` felület, azzal a különbséggel, hogy a metódusok aszinkron jellegűek.</span><span class="sxs-lookup"><span data-stu-id="2e942-559">This interface provides access to a set of methods similar to those accessed by the `IDatabase` interface, except that all the methods are asynchronous.</span></span>

<span data-ttu-id="2e942-560">Létrehozhat egy `IBatch` objektum használatával a `IDatabase.CreateBatch` metódust, és futtassa a kötegelt használatával a `IBatch.Execute` metódust, az alábbi példában látható módon.</span><span class="sxs-lookup"><span data-stu-id="2e942-560">You create an `IBatch` object by using the `IDatabase.CreateBatch` method, and then run the batch by using the `IBatch.Execute` method, as shown in the following example.</span></span> <span data-ttu-id="2e942-561">Ez a kód egyszerűen egy olyan karakterláncértéket, lépésekben és csökkenti az előző példában használt ugyanazokat a számlálókat beállítása, és megjeleníti az eredményeket:</span><span class="sxs-lookup"><span data-stu-id="2e942-561">This code simply sets a string value, increments and decrements the same counters used in the previous example, and displays the results:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
IBatch batch = cache.CreateBatch();
batch.StringSetAsync("data:key1", 11);
var t1 = batch.StringIncrementAsync("data:counter1");
var t2 = batch.StringDecrementAsync("data:counter2");
batch.Execute();
Console.WriteLine("{0}", t1.Result);
Console.WriteLine("{0}", t2.Result);
```

<span data-ttu-id="2e942-562">Fontos megérteni, hogy eltérően a tranzakció kötegben a parancs futása sikertelen, mert az helytelen formátumú, ha a többi parancs előfordulhat, hogy továbbra is futtassa.</span><span class="sxs-lookup"><span data-stu-id="2e942-562">It is important to understand that unlike a transaction, if a command in a batch fails because it is malformed, the other commands might still run.</span></span> <span data-ttu-id="2e942-563">A `IBatch.Execute` metódus nem ad vissza semmilyen arra utal, hogy a sikeres vagy sikertelen volt.</span><span class="sxs-lookup"><span data-stu-id="2e942-563">The `IBatch.Execute` method does not return any indication of success or failure.</span></span>

### <a name="perform-fire-and-forget-cache-operations"></a><span data-ttu-id="2e942-564">Hajtsa végre a tűz és gyorsítótár-műveletekhez elfelejti</span><span class="sxs-lookup"><span data-stu-id="2e942-564">Perform fire and forget cache operations</span></span>
<span data-ttu-id="2e942-565">Támogatja a tűz redis, és műveletek elfelejti jelzők parancs használatával.</span><span class="sxs-lookup"><span data-stu-id="2e942-565">Redis supports fire and forget operations by using command flags.</span></span> <span data-ttu-id="2e942-566">Ebben a helyzetben az ügyfél egyszerűen indít el egy műveletet, de nem áll az eredmény érdekében, és nem várja meg a parancs végrehajtása.</span><span class="sxs-lookup"><span data-stu-id="2e942-566">In this situation, the client simply initiates an operation but has no interest in the result and does not wait for the command to be completed.</span></span> <span data-ttu-id="2e942-567">Az alábbi példa bemutatja, hogyan hajtsa végre a tűz INCR parancsot, és elfelejti műveletet:</span><span class="sxs-lookup"><span data-stu-id="2e942-567">The example below shows how to perform the INCR command as a fire and forget operation:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
await cache.StringSetAsync("data:key1", 99);
...
cache.StringIncrement("data:key1", flags: CommandFlags.FireAndForget);
```

### <a name="specify-automatically-expiring-keys"></a><span data-ttu-id="2e942-568">Adja meg az automatikusan lejáró kulcsok</span><span class="sxs-lookup"><span data-stu-id="2e942-568">Specify automatically expiring keys</span></span>
<span data-ttu-id="2e942-569">Ha egy elemet a Redis gyorsítótár vannak tárolva, amely után az elem automatikusan törlődni fognak a gyorsítótárból időtúllépés is megadhat.</span><span class="sxs-lookup"><span data-stu-id="2e942-569">When you store an item in a Redis cache, you can specify a timeout after which the item will be automatically removed from the cache.</span></span> <span data-ttu-id="2e942-570">Hogyan jóval több időt egy kulcs tartozik a lejárat előtt is lekérdezhet a `TTL` parancsot.</span><span class="sxs-lookup"><span data-stu-id="2e942-570">You can also query how much more time a key has before it expires by using the `TTL` command.</span></span> <span data-ttu-id="2e942-571">Ez a parancs alkalmazásokhoz is elérhető legyen StackExchange használatával a `IDatabase.KeyTimeToLive` metódust.</span><span class="sxs-lookup"><span data-stu-id="2e942-571">This command is available to StackExchange applications by using the `IDatabase.KeyTimeToLive` method.</span></span>

<span data-ttu-id="2e942-572">A következő kódrészletet bemutatja, hogyan 20 másodperc lejárati idő egy kulcs, és a kulcs fennmaradó élettartama lekérdezése:</span><span class="sxs-lookup"><span data-stu-id="2e942-572">The following code snippet shows how to set an expiration time of 20 seconds on a key, and query the remaining lifetime of the key:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
// Add a key with an expiration time of 20 seconds
await cache.StringSetAsync("data:key1", 99, TimeSpan.FromSeconds(20));
...
// Query how much time a key has left to live
// If the key has already expired, the KeyTimeToLive function returns a null
TimeSpan? expiry = cache.KeyTimeToLive("data:key1");
```

<span data-ttu-id="2e942-573">Is is beállíthatja a lejárati idő egy adott dátumot és időpontot a lejárati paranccsal, amelyik elérhető a StackExchange könyvtárban, mint a `KeyExpireAsync` módszert:</span><span class="sxs-lookup"><span data-stu-id="2e942-573">You can also set the expiration time to a specific date and time by using the EXPIRE command, which is available in the StackExchange library as the `KeyExpireAsync` method:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
// Add a key with an expiration date of midnight on 1st January 2015
await cache.StringSetAsync("data:key1", 99);
await cache.KeyExpireAsync("data:key1",
    new DateTime(2015, 1, 1, 0, 0, 0, DateTimeKind.Utc));
...
```

> [!TIP] 
> <span data-ttu-id="2e942-574">Manuálisan eltávolíthat egy elemet a gyorsítótár a StackExchange a könyvtárból érhető DEL parancs használatával a `IDatabase.KeyDeleteAsync` metódust.</span><span class="sxs-lookup"><span data-stu-id="2e942-574">You can manually remove an item from the cache by using the DEL command, which is available through the StackExchange library as the `IDatabase.KeyDeleteAsync` method.</span></span>

### <a name="use-tags-to-cross-correlate-cached-items"></a><span data-ttu-id="2e942-575">Kereszt-korrelálja gyorsítótárazott elemek címkék használata</span><span class="sxs-lookup"><span data-stu-id="2e942-575">Use tags to cross-correlate cached items</span></span>
<span data-ttu-id="2e942-576">Egy Redis-készlet, amely egy kulcs megosztása több elem gyűjteménye.</span><span class="sxs-lookup"><span data-stu-id="2e942-576">A Redis set is a collection of multiple items that share a single key.</span></span> <span data-ttu-id="2e942-577">Egy készlet a SADD paranccsal hozhat létre.</span><span class="sxs-lookup"><span data-stu-id="2e942-577">You can create a set by using the SADD command.</span></span> <span data-ttu-id="2e942-578">A csoportban lévő cikkek a SMEMBERS paranccsal kérheti le.</span><span class="sxs-lookup"><span data-stu-id="2e942-578">You can retrieve the items in a set by using the SMEMBERS command.</span></span> <span data-ttu-id="2e942-579">A StackExchange függvénytár valósítja meg a SADD parancsot a `IDatabase.SetAddAsync` metódust, és a SMEMBERS parancs a `IDatabase.SetMembersAsync` metódust.</span><span class="sxs-lookup"><span data-stu-id="2e942-579">The StackExchange library implements the SADD command with the `IDatabase.SetAddAsync` method, and the SMEMBERS command with the `IDatabase.SetMembersAsync` method.</span></span>

<span data-ttu-id="2e942-580">A SDIFF (set különbség), a SZINTERELŐ (set metszetének) és a SUNION (set union) parancsok segítségével új szalagoptimalizálási készleteket hozhat létre a meglévő készleteket kombinálhatja is.</span><span class="sxs-lookup"><span data-stu-id="2e942-580">You can also combine existing sets to create new sets by using the SDIFF (set difference), SINTER (set intersection), and SUNION (set union) commands.</span></span> <span data-ttu-id="2e942-581">A szolgáltatás ezen műveletek a StackExchange könyvtárban a `IDatabase.SetCombineAsync` metódust.</span><span class="sxs-lookup"><span data-stu-id="2e942-581">The StackExchange library unifies these operations in the `IDatabase.SetCombineAsync` method.</span></span> <span data-ttu-id="2e942-582">A metódusnak az első paraméter határozza meg a beállítási művelet végrehajtásához.</span><span class="sxs-lookup"><span data-stu-id="2e942-582">The first parameter to this method specifies the set operation to perform.</span></span>

<span data-ttu-id="2e942-583">Az alábbi kódtöredékek bemutatják, hogyan beállítása gyorsan tárolja, és beolvassa a kapcsolódó elemek gyűjteményei hasznos lehet.</span><span class="sxs-lookup"><span data-stu-id="2e942-583">The following code snippets show how sets can be useful for quickly storing and retrieving collections of related items.</span></span> <span data-ttu-id="2e942-584">Ezt a kódot használja a `BlogPost` megvalósítása Redis gyorsítótár ügyfélalkalmazások szakaszában az ebben a cikkben ismertetett típusa.</span><span class="sxs-lookup"><span data-stu-id="2e942-584">This code uses the `BlogPost` type that was described in the section Implement Redis Cache Client Applications earlier in this article.</span></span>

<span data-ttu-id="2e942-585">A `BlogPost` objektum négy mezőt tartalmaz – egy Azonosítót, cím, egy rangsorolási pontszám és címkék gyűjteménye.</span><span class="sxs-lookup"><span data-stu-id="2e942-585">A `BlogPost` object contains four fields—an ID, a title, a ranking score, and a collection of tags.</span></span> <span data-ttu-id="2e942-586">Az első kódrészletben látható a mintaadatok a C# listájának feltöltéséhez használt `BlogPost` objektumok:</span><span class="sxs-lookup"><span data-stu-id="2e942-586">The first code snippet below shows the sample data that's used for populating a C# list of `BlogPost` objects:</span></span>

```csharp
List<string[]> tags = new List<string[]>
{
    new[] { "iot","csharp" },
    new[] { "iot","azure","csharp" },
    new[] { "csharp","git","big data" },
    new[] { "iot","git","database" },
    new[] { "database","git" },
    new[] { "csharp","database" },
    new[] { "iot" },
    new[] { "iot","database","git" },
    new[] { "azure","database","big data","git","csharp" },
    new[] { "azure" }
};

List<BlogPost> posts = new List<BlogPost>();
int blogKey = 1;
int numberOfPosts = 20;
Random random = new Random();
for (int i = 0; i < numberOfPosts; i++)
{
    blogKey++;
    posts.Add(new BlogPost(
        blogKey,                  // Blog post ID
        string.Format(CultureInfo.InvariantCulture, "Blog Post #{0}",
            blogKey),             // Blog post title
        random.Next(100, 10000),  // Ranking score
        tags[i % tags.Count]));   // Tags--assigned from a collection
                                  // in the tags list
}
```

<span data-ttu-id="2e942-587">A címkék az egyes tárolhatja `BlogPost` objektum a Redis gyorsítótár készletként, és rendelje hozzá minden Azonosítóját a `BlogPost`.</span><span class="sxs-lookup"><span data-stu-id="2e942-587">You can store the tags for each `BlogPost` object as a set in a Redis cache and associate each set with the ID of the `BlogPost`.</span></span> <span data-ttu-id="2e942-588">Ez lehetővé teszi az alkalmazás gyorsan megtalálhatja a címkék, amelyek egy adott blogbejegyzést.</span><span class="sxs-lookup"><span data-stu-id="2e942-588">This enables an application to quickly find all the tags that belong to a specific blog post.</span></span> <span data-ttu-id="2e942-589">Az ellenkező irányba keresés engedélyezéséhez, és minden blogbejegyzések, amelyek egy adott címke található, létrehozhat egy másik készlet, amely tárolja a blogbejegyzéseket, a kulcs a Címkeazonosító hivatkozik:</span><span class="sxs-lookup"><span data-stu-id="2e942-589">To enable searching in the opposite direction and find all blog posts that share a specific tag, you can create another set that holds the blog posts referencing the tag ID in the key:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
// Tags are easily represented as Redis Sets
foreach (BlogPost post in posts)
{
    string redisKey = string.Format(CultureInfo.InvariantCulture,
        "blog:posts:{0}:tags", post.Id);
    // Add tags to the blog post in Redis
    await cache.SetAddAsync(
        redisKey, post.Tags.Select(s => (RedisValue)s).ToArray());

    // Now do the inverse so we can figure how which blog posts have a given tag
    foreach (var tag in post.Tags)
    {
        await cache.SetAddAsync(string.Format(CultureInfo.InvariantCulture,
            "tag:{0}:blog:posts", tag), post.Id);
    }
}
```

<span data-ttu-id="2e942-590">Ezen szerkezetek lehetővé teszik a nagyon hatékonyan számos gyakori lekérdezések végrehajtásához.</span><span class="sxs-lookup"><span data-stu-id="2e942-590">These structures enable you to perform many common queries very efficiently.</span></span> <span data-ttu-id="2e942-591">Például található, és megjeleníti a blogbejegyzést 1 ilyen címkék:</span><span class="sxs-lookup"><span data-stu-id="2e942-591">For example, you can find and display all of the tags for blog post 1 like this:</span></span>

```csharp
// Show the tags for blog post #1
foreach (var value in await cache.SetMembersAsync("blog:posts:1:tags"))
{
    Console.WriteLine(value);
}
```

<span data-ttu-id="2e942-592">Található, amelyek közösek a blogban található összes kódcímkének 1 és blog post 2 utáni végrehajtásával set metszetének, az alábbiak szerint:</span><span class="sxs-lookup"><span data-stu-id="2e942-592">You can find all tags that are common to blog post 1 and blog post 2 by performing a set intersection operation, as follows:</span></span>

```csharp
// Show the tags in common for blog posts #1 and #2
foreach (var value in await cache.SetCombineAsync(SetOperation.Intersect, new RedisKey[]
    { "blog:posts:1:tags", "blog:posts:2:tags" }))
{
    Console.WriteLine(value);
}
```

<span data-ttu-id="2e942-593">És egy adott címkét tartalmazó összes blogbejegyzések található:</span><span class="sxs-lookup"><span data-stu-id="2e942-593">And you can find all blog posts that contain a specific tag:</span></span>

```csharp
// Show the ids of the blog posts that have the tag "iot".
foreach (var value in await cache.SetMembersAsync("tag:iot:blog:posts"))
{
    Console.WriteLine(value);
}
```

### <a name="find-recently-accessed-items"></a><span data-ttu-id="2e942-594">Keresés a nemrégiben elért elemek</span><span class="sxs-lookup"><span data-stu-id="2e942-594">Find recently accessed items</span></span>
<span data-ttu-id="2e942-595">A közös számos más alkalmazáshoz szükséges feladata a legtöbb nemrégiben elért elemek kereséséhez.</span><span class="sxs-lookup"><span data-stu-id="2e942-595">A common task required of many applications is to find the most recently accessed items.</span></span> <span data-ttu-id="2e942-596">Például egy bloggolás helyet érdemes a közelmúltban olvasási blogbejegyzések kapcsolatos információk megjelenítéséhez.</span><span class="sxs-lookup"><span data-stu-id="2e942-596">For example, a blogging site might want to display information about the most recently read blog posts.</span></span>

<span data-ttu-id="2e942-597">Ez a funkció a Redis lista használatával valósíthatja meg.</span><span class="sxs-lookup"><span data-stu-id="2e942-597">You can implement this functionality by using a Redis list.</span></span> <span data-ttu-id="2e942-598">Egy Redis lista több, azonos kulccsal rendelkező elem tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="2e942-598">A Redis list contains multiple items that share the same key.</span></span> <span data-ttu-id="2e942-599">A listában úgy működik, mint a kettős várólista.</span><span class="sxs-lookup"><span data-stu-id="2e942-599">The list acts as a double-ended queue.</span></span> <span data-ttu-id="2e942-600">Elemek akkor leküldése vagy a lista végére, LPUSH (bal oldali leküldéses) és RPUSH (jobb oldali leküldéses) parancsok használatával.</span><span class="sxs-lookup"><span data-stu-id="2e942-600">You can push items to either end of the list by using the LPUSH (left push) and RPUSH (right push) commands.</span></span> <span data-ttu-id="2e942-601">A lista másik végén elemek beolvasható a LPOP és RPOP parancsokkal.</span><span class="sxs-lookup"><span data-stu-id="2e942-601">You can retrieve items from either end of the list by using the LPOP and RPOP commands.</span></span> <span data-ttu-id="2e942-602">Elemek egy csoportjának a LRANGE és elrendezése paranccsal is vissza.</span><span class="sxs-lookup"><span data-stu-id="2e942-602">You can also return a set of elements by using the LRANGE and RRANGE commands.</span></span>

<span data-ttu-id="2e942-603">Az alábbi kódtöredékek bemutatják, hogyan végezheti el ezeket a műveleteket a StackExchange könyvtár használatával.</span><span class="sxs-lookup"><span data-stu-id="2e942-603">The code snippets below show how you can perform these operations by using the StackExchange library.</span></span> <span data-ttu-id="2e942-604">Ezt a kódot használja a `BlogPost` az előző példákban típusa.</span><span class="sxs-lookup"><span data-stu-id="2e942-604">This code uses the `BlogPost` type from the previous examples.</span></span> <span data-ttu-id="2e942-605">Blogbejegyzés az Olvasás, felhasználó által a `IDatabase.ListLeftPushAsync` metódus leküldéses értesítések a kulcsot a Redis cache "blog:recent_posts" társított listáját, a blogbejegyzés címe.</span><span class="sxs-lookup"><span data-stu-id="2e942-605">As a blog post is read by a user, the `IDatabase.ListLeftPushAsync` method pushes the title of the blog post onto a list that's associated with the key "blog:recent_posts" in the Redis cache.</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
string redisKey = "blog:recent_posts";
BlogPost blogPost = ...; // Reference to the blog post that has just been read
await cache.ListLeftPushAsync(
    redisKey, blogPost.Title); // Push the blog post onto the list
```

<span data-ttu-id="2e942-606">További blogbejegyzések olvasható, mert a címben vannak fejlesztőre ugyanazt a listát.</span><span class="sxs-lookup"><span data-stu-id="2e942-606">As more blog posts are read, their titles are pushed onto the same list.</span></span> <span data-ttu-id="2e942-607">A lista a sorozatot, amely címének lettek hozzáadva van rendezve.</span><span class="sxs-lookup"><span data-stu-id="2e942-607">The list is ordered by the sequence in which the titles have been added.</span></span> <span data-ttu-id="2e942-608">A közelmúltban olvasási blogbejegyzések vannak a listán bal oldali vége felé.</span><span class="sxs-lookup"><span data-stu-id="2e942-608">The most recently read blog posts are towards the left end of the list.</span></span> <span data-ttu-id="2e942-609">(Ha azonos blogbejegyzést csak egyszer olvasható, azt kell több bejegyzést a listában.)</span><span class="sxs-lookup"><span data-stu-id="2e942-609">(If the same blog post is read more than once, it will have multiple entries in the list.)</span></span>

<span data-ttu-id="2e942-610">A címek nemrég olvasási helyek használatával jelenítheti meg a `IDatabase.ListRange` metódust.</span><span class="sxs-lookup"><span data-stu-id="2e942-610">You can display the titles of the most recently read posts by using the `IDatabase.ListRange` method.</span></span> <span data-ttu-id="2e942-611">Ez a módszer a kulcs a listában, egyfajta kiindulópontot és egy záró pontot tartalmazó vesz igénybe.</span><span class="sxs-lookup"><span data-stu-id="2e942-611">This method takes the key that contains the list, a starting point, and an ending point.</span></span> <span data-ttu-id="2e942-612">A következő kód lekéri a 10 blogbejegyzések (elem 0-9) a bal szélső végén a lista címeit:</span><span class="sxs-lookup"><span data-stu-id="2e942-612">The following code retrieves the titles of the 10 blog posts (items from 0 to 9) at the left-most end of the list:</span></span>

```csharp
// Show latest ten posts
foreach (string postTitle in await cache.ListRangeAsync(redisKey, 0, 9))
{
    Console.WriteLine(postTitle);
}
```

<span data-ttu-id="2e942-613">Vegye figyelembe, hogy a `ListRangeAsync` metódus nem elem eltávolítása a listából.</span><span class="sxs-lookup"><span data-stu-id="2e942-613">Note that the `ListRangeAsync` method does not remove items from the list.</span></span> <span data-ttu-id="2e942-614">Ehhez használhatja a `IDatabase.ListLeftPopAsync` és `IDatabase.ListRightPopAsync` módszerek.</span><span class="sxs-lookup"><span data-stu-id="2e942-614">To do this, you can use the `IDatabase.ListLeftPopAsync` and `IDatabase.ListRightPopAsync` methods.</span></span>

<span data-ttu-id="2e942-615">Ha szeretné megakadályozni a lista növekvő határozatlan ideig, rendszeres időközönként a lista segítségével is selejtezett elemeket.</span><span class="sxs-lookup"><span data-stu-id="2e942-615">To prevent the list from growing indefinitely, you can periodically cull items by trimming the list.</span></span> <span data-ttu-id="2e942-616">Az alábbi kódrészlet bemutatja, hogyan távolítsa el az összes, de az öt bal szélső elemet a listából:</span><span class="sxs-lookup"><span data-stu-id="2e942-616">The code snippet below shows you how to remove all but the five left-most items from the list:</span></span>

```csharp
await cache.ListTrimAsync(redisKey, 0, 5);
```

### <a name="implement-a-leader-board"></a><span data-ttu-id="2e942-617">Alkalmazzon olyan vezető kártya</span><span class="sxs-lookup"><span data-stu-id="2e942-617">Implement a leader board</span></span>
<span data-ttu-id="2e942-618">Alapértelmezés szerint a csoportban lévő elemek nem tartják megadott sorrendben.</span><span class="sxs-lookup"><span data-stu-id="2e942-618">By default, the items in a set are not held in any specific order.</span></span> <span data-ttu-id="2e942-619">Egy rendezett sorozata az ZADD paranccsal hozhat létre (a `IDatabase.SortedSetAdd` metódus a StackExchange könyvtárban).</span><span class="sxs-lookup"><span data-stu-id="2e942-619">You can create an ordered set by using the ZADD command (the `IDatabase.SortedSetAdd` method in the StackExchange library).</span></span> <span data-ttu-id="2e942-620">Az elemek egy numerikus érték, egy pontszám, amely egy paramétert a parancshoz nevű használatával vannak rendezve.</span><span class="sxs-lookup"><span data-stu-id="2e942-620">The items are ordered by using a numeric value called a score, which is provided as a parameter to the command.</span></span>

<span data-ttu-id="2e942-621">A következő kódrészletet ad hozzá egy blogbejegyzést címe sorrendbe állított listáját.</span><span class="sxs-lookup"><span data-stu-id="2e942-621">The following code snippet adds the title of a blog post to an ordered list.</span></span> <span data-ttu-id="2e942-622">Ebben a példában minden egyes blogbejegyzést is, amely tartalmazza a prioritást, a blogbejegyzés pontszám mezőt tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="2e942-622">In this example, each blog post also has a score field that contains the ranking of the blog post.</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
IDatabase cache = redisHostConnection.GetDatabase();
...
string redisKey = "blog:post_rankings";
BlogPost blogPost = ...; // Reference to a blog post that has just been rated
await cache.SortedSetAddAsync(redisKey, blogPost.Title, blogPost.Score);
```

<span data-ttu-id="2e942-623">A blog post címét és pontszámok növekvő pontszám sorrendben használatával kérheti le a `IDatabase.SortedSetRangeByRankWithScores` módszert:</span><span class="sxs-lookup"><span data-stu-id="2e942-623">You can retrieve the blog post titles and scores in ascending score order by using the `IDatabase.SortedSetRangeByRankWithScores` method:</span></span>

```csharp
foreach (var post in await cache.SortedSetRangeByRankWithScoresAsync(redisKey))
{
    Console.WriteLine(post);
}
```

> [!NOTE]
> <span data-ttu-id="2e942-624">A StackExchange kódtár is biztosít a `IDatabase.SortedSetRangeByRankAsync` metódus, amely visszaadja az adatokat a pontszám sorrendben, de nem ad vissza a pontszámok.</span><span class="sxs-lookup"><span data-stu-id="2e942-624">The StackExchange library also provides the `IDatabase.SortedSetRangeByRankAsync` method, which returns the data in score order, but does not return the scores.</span></span>
> 
> 

<span data-ttu-id="2e942-625">Is beolvashatja csökkenő sorrendben a pontszámok elemeket, és a további paraméterek megadásával visszaadott tételszámának korlátozása a `IDatabase.SortedSetRangeByRankWithScoresAsync` metódust.</span><span class="sxs-lookup"><span data-stu-id="2e942-625">You can also retrieve items in descending order of scores, and limit the number of items that are returned by providing additional parameters to the `IDatabase.SortedSetRangeByRankWithScoresAsync` method.</span></span> <span data-ttu-id="2e942-626">A következő példában a címek és a felső 10 rangsorolt blogbejegyzések eredményét jeleníti meg:</span><span class="sxs-lookup"><span data-stu-id="2e942-626">The next example displays the titles and scores of the top 10 ranked blog posts:</span></span>

```csharp
foreach (var post in await cache.SortedSetRangeByRankWithScoresAsync(
                               redisKey, 0, 9, Order.Descending))
{
    Console.WriteLine(post);
}
```

<span data-ttu-id="2e942-627">A következő példában a `IDatabase.SortedSetRangeByScoreWithScoresAsync` metódus, amely segítségével a rendszer visszairányítja az alábbiakhoz egy adott pontszám esik cikkek tartomány:</span><span class="sxs-lookup"><span data-stu-id="2e942-627">The next example uses the `IDatabase.SortedSetRangeByScoreWithScoresAsync` method, which you can use to limit the items that are returned to those that fall within a given score range:</span></span>

```csharp
// Blog posts with scores between 5000 and 100000
foreach (var post in await cache.SortedSetRangeByScoreWithScoresAsync(
                               redisKey, 5000, 100000))
{
    Console.WriteLine(post);
}
```

### <a name="message-by-using-channels"></a><span data-ttu-id="2e942-628">Üzenet csatornák használatával</span><span class="sxs-lookup"><span data-stu-id="2e942-628">Message by using channels</span></span>
<span data-ttu-id="2e942-629">Egy adatgyorsítótár működött, leszámítva a Redis-kiszolgáló egy nagy teljesítményű publisher/előfizető mechanizmus üzenetküldést biztosít.</span><span class="sxs-lookup"><span data-stu-id="2e942-629">Apart from acting as a data cache, a Redis server provides messaging through a high-performance publisher/subscriber mechanism.</span></span> <span data-ttu-id="2e942-630">Ügyfélalkalmazások kérhet le egy csatornát, és más alkalmazások vagy szolgáltatások üzenetek közzéteheti a csatornára.</span><span class="sxs-lookup"><span data-stu-id="2e942-630">Client applications can subscribe to a channel, and other applications or services can publish messages to the channel.</span></span> <span data-ttu-id="2e942-631">Alkalmazások előfizetés kapja meg ezeket az üzeneteket, és tud feldolgozni.</span><span class="sxs-lookup"><span data-stu-id="2e942-631">Subscribing applications will then receive these messages and can process them.</span></span>

<span data-ttu-id="2e942-632">Redis biztosít az ügyfélalkalmazások fizet elő csatornák ELŐFIZETÉS parancsot.</span><span class="sxs-lookup"><span data-stu-id="2e942-632">Redis provides the SUBSCRIBE command for client applications to use to subscribe to channels.</span></span> <span data-ttu-id="2e942-633">Ez a parancs egy vagy több csatornát, amikor az alkalmazás fogad üzeneteket neve vár.</span><span class="sxs-lookup"><span data-stu-id="2e942-633">This command expects the name of one or more channels on which the application will accept messages.</span></span> <span data-ttu-id="2e942-634">A StackExchange könyvtár magában foglalja a `ISubscription` felület, amely lehetővé teszi a .NET-keretrendszer alkalmazás előfizetés, és tegye közzé az csatornák.</span><span class="sxs-lookup"><span data-stu-id="2e942-634">The StackExchange library includes the `ISubscription` interface, which enables a .NET Framework application to subscribe and publish to channels.</span></span>

<span data-ttu-id="2e942-635">Létrehozhat egy `ISubscription` objektum használatával a `GetSubscriber` metódus a Redis-kiszolgáló csatlakozik.</span><span class="sxs-lookup"><span data-stu-id="2e942-635">You create an `ISubscription` object by using the `GetSubscriber` method of the connection to the Redis server.</span></span> <span data-ttu-id="2e942-636">Majd a használatával figyelni a csatornán üzenetek a `SubscribeAsync` metódus az objektum.</span><span class="sxs-lookup"><span data-stu-id="2e942-636">Then you listen for messages on a channel by using the `SubscribeAsync` method of this object.</span></span> <span data-ttu-id="2e942-637">Az alábbi példakód bemutatja, hogyan előfizetni a csatorna "üzenetek: blogPosts" nevű:</span><span class="sxs-lookup"><span data-stu-id="2e942-637">The following code example shows how to subscribe to a channel named "messages:blogPosts":</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
ISubscriber subscriber = redisHostConnection.GetSubscriber();
...
await subscriber.SubscribeAsync("messages:blogPosts", (channel, message) => Console.WriteLine("Title is: {0}", message));
```

<span data-ttu-id="2e942-638">Az első paraméterben a `Subscribe` módszer a csatorna nevét.</span><span class="sxs-lookup"><span data-stu-id="2e942-638">The first parameter to the `Subscribe` method is the name of the channel.</span></span> <span data-ttu-id="2e942-639">Ez a név a gyorsítótárban kulcsok által használt azonos szabályokat követi.</span><span class="sxs-lookup"><span data-stu-id="2e942-639">This name follows the same conventions that are used by keys in the cache.</span></span> <span data-ttu-id="2e942-640">A név tartalmazhat bináris adatokat, de ajánlott viszonylag rövid, jelentéssel bíró karakterláncok használatával biztosíthatja a megfelelő teljesítmény és karbantartási követelmények.</span><span class="sxs-lookup"><span data-stu-id="2e942-640">The name can contain any binary data, although it is advisable to use relatively short, meaningful strings to help ensure good performance and maintainability.</span></span>

<span data-ttu-id="2e942-641">Azt is fontos megjegyezni, hogy a csatorna által használt névtér nem csatlakozik, kulcsok használatával.</span><span class="sxs-lookup"><span data-stu-id="2e942-641">Note also that the namespace used by channels is separate from that used by keys.</span></span> <span data-ttu-id="2e942-642">Ez azt jelenti, hogy lehet csatornák és kulcsok, azonos nevű, bár ez lehetséges, hogy az alkalmazás kódjában nehezebb karbantartása.</span><span class="sxs-lookup"><span data-stu-id="2e942-642">This means you can have channels and keys that have the same name, although this may make your application code more difficult to maintain.</span></span>

<span data-ttu-id="2e942-643">A második paraméter nem egy művelet delegált.</span><span class="sxs-lookup"><span data-stu-id="2e942-643">The second parameter is an Action delegate.</span></span> <span data-ttu-id="2e942-644">Ez a delegált aszinkron módon fut, amikor egy új üzenet jelenik meg, a csatornán.</span><span class="sxs-lookup"><span data-stu-id="2e942-644">This delegate runs asynchronously whenever a new message appears on the channel.</span></span> <span data-ttu-id="2e942-645">Ez a példa egyszerűen megjeleníti az üzenet a konzol (az üzenet tartalmaz egy blogbejegyzést címe).</span><span class="sxs-lookup"><span data-stu-id="2e942-645">This example simply displays the message on the console (the message will contain the title of a blog post).</span></span>

<span data-ttu-id="2e942-646">A csatorna való közzétételéhez egy alkalmazás paranccsal a Redis közzététele.</span><span class="sxs-lookup"><span data-stu-id="2e942-646">To publish to a channel, an application can use the Redis PUBLISH command.</span></span> <span data-ttu-id="2e942-647">A StackExchange kódtár biztosít a `IServer.PublishAsync` is végrehajthatja ezt a műveletet.</span><span class="sxs-lookup"><span data-stu-id="2e942-647">The StackExchange library provides the `IServer.PublishAsync` method to perform this operation.</span></span> <span data-ttu-id="2e942-648">A következő kódrészletet a "üzenetek: blogPosts" csatorna közzététele egy üzenetet jeleníti meg:</span><span class="sxs-lookup"><span data-stu-id="2e942-648">The next code snippet shows how to publish a message to the "messages:blogPosts" channel:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
ISubscriber subscriber = redisHostConnection.GetSubscriber();
...
BlogPost blogPost = ...;
subscriber.PublishAsync("messages:blogPosts", blogPost.Title);
```

<span data-ttu-id="2e942-649">Ismerje meg a közzétételi/feliratkozási mechanizmusa kapcsolatos számos olyan pontja van:</span><span class="sxs-lookup"><span data-stu-id="2e942-649">There are several points you should understand about the publish/subscribe mechanism:</span></span>

* <span data-ttu-id="2e942-650">Több előfizető előfizetni, ugyanazt a csatornát, és azok összes üzeneteket fogja kapni az adott csatornán közzétett.</span><span class="sxs-lookup"><span data-stu-id="2e942-650">Multiple subscribers can subscribe to the same channel, and they will all receive the messages that are published to that channel.</span></span>
* <span data-ttu-id="2e942-651">Előfizetők csak után azok előfizetett közzétett üzenetek fogadására.</span><span class="sxs-lookup"><span data-stu-id="2e942-651">Subscribers only receive messages that have been published after they have subscribed.</span></span> <span data-ttu-id="2e942-652">Csatornák nem pufferelt, és miután közzétette az üzenetet, a Redis-infrastruktúra leküldi mindegyik előfizető az üzenetet, és eltávolítja azt.</span><span class="sxs-lookup"><span data-stu-id="2e942-652">Channels are not buffered, and once a message is published, the Redis infrastructure pushes the message to each subscriber and then removes it.</span></span>
* <span data-ttu-id="2e942-653">Alapértelmezés szerint az üzenetek az elküldés vannak előfizetők által fogadott.</span><span class="sxs-lookup"><span data-stu-id="2e942-653">By default, messages are received by subscribers in the order in which they are sent.</span></span> <span data-ttu-id="2e942-654">Egy magas active rendszerben nagy számú üzenetek és sok előfizetők és a közzétevők üzenetek garantált szekvenciális kézbesítését lelassíthatja a rendszer teljesítményét.</span><span class="sxs-lookup"><span data-stu-id="2e942-654">In a highly active system with a large number of messages and many subscribers and publishers, guaranteed sequential delivery of messages can slow performance of the system.</span></span> <span data-ttu-id="2e942-655">Ha minden üzenet független sorrendje nem lényeges, csak, párhuzamos feldolgozása engedélyezheti a Redis rendszer, így válaszkészsége javítása.</span><span class="sxs-lookup"><span data-stu-id="2e942-655">If each message is independent and the order is unimportant, you can enable concurrent processing by the Redis system, which can help to improve responsiveness.</span></span> <span data-ttu-id="2e942-656">Lehet ezt elérni StackExchange ügyfélprogram úgy, hogy a false értékre az előfizető által használt kapcsolat PreserveAsyncOrder:</span><span class="sxs-lookup"><span data-stu-id="2e942-656">You can achieve this in a StackExchange client by setting the PreserveAsyncOrder of the connection used by the subscriber to false:</span></span>

```csharp
ConnectionMultiplexer redisHostConnection = ...;
redisHostConnection.PreserveAsyncOrder = false;
ISubscriber subscriber = redisHostConnection.GetSubscriber();
```

### <a name="serialization-considerations"></a><span data-ttu-id="2e942-657">Szerializálási kapcsolatos szempontok</span><span class="sxs-lookup"><span data-stu-id="2e942-657">Serialization considerations</span></span>

<span data-ttu-id="2e942-658">Ha úgy dönt, a szerializálási formátum, fontolja meg a mellékhatásokkal között teljesítmény, együttműködés, versioning, a meglévő rendszerek, adatok tömörítése és Memóriaterhelést való kompatibilitást.</span><span class="sxs-lookup"><span data-stu-id="2e942-658">When you choose a serialization format, consider tradeoffs between performance, interoperability, versioning, compatibility with existing systems, data compression, and memory overhead.</span></span> <span data-ttu-id="2e942-659">Amikor teljesítmény értékelése, ne feledje, hogy referenciaalapok nagymértékben függ a környezetben.</span><span class="sxs-lookup"><span data-stu-id="2e942-659">When you are evaluating performance, remember that benchmarks are highly dependent on context.</span></span> <span data-ttu-id="2e942-660">A munkaterhelések tényleges nem tükrözik, és újabb függvénytárak vagy a verzió nem tekinti.</span><span class="sxs-lookup"><span data-stu-id="2e942-660">They may not reflect your actual workload, and may not consider newer libraries or versions.</span></span> <span data-ttu-id="2e942-661">Nem minden forgatókönyvben egy "leggyorsabb" szerializálót van.</span><span class="sxs-lookup"><span data-stu-id="2e942-661">There is no single "fastest" serializer for all scenarios.</span></span> 

<span data-ttu-id="2e942-662">Figyelembe kell venni néhány lehetőségek a következők:</span><span class="sxs-lookup"><span data-stu-id="2e942-662">Some options to consider include:</span></span>

- <span data-ttu-id="2e942-663">[Protokoll pufferek](https://github.com/google/protobuf) (is hívott protobuf) a strukturált adatok hatékonyan Google által fejlesztett szerializálási formátum.</span><span class="sxs-lookup"><span data-stu-id="2e942-663">[Protocol Buffers](https://github.com/google/protobuf) (also called protobuf) is a serialization format developed by Google for serializing structured data efficiently.</span></span> <span data-ttu-id="2e942-664">Adja meg az üzenet struktúrák szigorú típusmegadású definíciós fájlokat használja.</span><span class="sxs-lookup"><span data-stu-id="2e942-664">It uses strongly-typed definition files to define message structures.</span></span> <span data-ttu-id="2e942-665">A definíciós fájlok majd összeállítása a szerializálása és deszerializálása üzenetek nyelvspecifikus kódját.</span><span class="sxs-lookup"><span data-stu-id="2e942-665">These definition files are then compiled to language-specific code for serializing and deserializing messages.</span></span> <span data-ttu-id="2e942-666">Protobuf használhatja meglévő RPC mechanizmusok keresztül, vagy hozhat létre a egy RPC szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="2e942-666">Protobuf can be used over existing RPC mechanisms, or it can generate an RPC service.</span></span>

- <span data-ttu-id="2e942-667">[Apache Thrift](https://thrift.apache.org/) használ, egy hasonló módszert használja, szigorú típusmegadású definíciós fájlokat, és egy fordítási lépés a szerializálási kódot és az RPC szolgáltatásokat.</span><span class="sxs-lookup"><span data-stu-id="2e942-667">[Apache Thrift](https://thrift.apache.org/) uses a similar approach, with strongly typed definition files and a compilation step to generate the serialization code and RPC services.</span></span>  

- <span data-ttu-id="2e942-668">[Apache Avro](https://avro.apache.org/) protokoll Buffers és Thrift, hasonló szolgáltatásokat nyújt, de nincs összeállítása lépés.</span><span class="sxs-lookup"><span data-stu-id="2e942-668">[Apache Avro](https://avro.apache.org/) provides similar functionality to Protocol Buffers and Thrift, but there is no compilation step.</span></span> <span data-ttu-id="2e942-669">Ehelyett a szerializált adatok mindig tartalmazza a séma, amely leírja a struktúra.</span><span class="sxs-lookup"><span data-stu-id="2e942-669">Instead, serialized data always includes a schema that describes the structure.</span></span> 

- <span data-ttu-id="2e942-670">[JSON](http://json.org/) emberek számára olvasható szövegmező használó nyílt szabvány.</span><span class="sxs-lookup"><span data-stu-id="2e942-670">[JSON](http://json.org/) is an open standard that uses human-readable text fields.</span></span> <span data-ttu-id="2e942-671">Széles körű többplatformos támogatást tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="2e942-671">It has broad cross-platform support.</span></span> <span data-ttu-id="2e942-672">JSON üzenet sémák nem használja.</span><span class="sxs-lookup"><span data-stu-id="2e942-672">JSON does not use message schemas.</span></span> <span data-ttu-id="2e942-673">Folyamatban egy szöveges formátumú, nincs nagyon hatékony a hálózaton keresztül.</span><span class="sxs-lookup"><span data-stu-id="2e942-673">Being a text-based format, it is not very efficient over the wire.</span></span> <span data-ttu-id="2e942-674">Néhány esetben azonban, előfordulhat, hogy adnak vissza gyorsítótárazott elemek közvetlenül az ügyfél ebben az esetben tárolása JSON mentése volt egy másik formátumból deszerializálása során, és JSON majd szerializálása költsége HTTP-n keresztül.</span><span class="sxs-lookup"><span data-stu-id="2e942-674">In some cases, however, you may be returning cached items directly to a client via HTTP, in which case storing JSON could save the cost of deserializing from another format and then serializing to JSON.</span></span>

- <span data-ttu-id="2e942-675">[BSON](http://bsonspec.org/) JSON hasonló struktúrával használó bináris szerializálási formátum.</span><span class="sxs-lookup"><span data-stu-id="2e942-675">[BSON](http://bsonspec.org/) is a binary serialization format that uses a structure similar to JSON.</span></span> <span data-ttu-id="2e942-676">BSON úgy lett kialakítva, egyszerűsített, hogy könnyen és gyors szerializálása és deszerializálása, JSON viszonyítva kell lennie.</span><span class="sxs-lookup"><span data-stu-id="2e942-676">BSON was designed to be lightweight, easy to scan, and fast to serialize and deserialize, relative to JSON.</span></span> <span data-ttu-id="2e942-677">Hasznos adat található hasonlóak mérete JSON.</span><span class="sxs-lookup"><span data-stu-id="2e942-677">Payloads are comparable in size to JSON.</span></span> <span data-ttu-id="2e942-678">Attól függően, hogy az adatok egy BSON hasznos lehet kisebb vagy nagyobb, mint a JSON hasznos adatok között.</span><span class="sxs-lookup"><span data-stu-id="2e942-678">Depending on the data, a BSON payload may be smaller or larger than a JSON payload.</span></span> <span data-ttu-id="2e942-679">BSON van néhány további adattípusok, amelyek nem érhetők el a JSON-ban, ilyen például a BinData (a byte tömbökben) és a dátum.</span><span class="sxs-lookup"><span data-stu-id="2e942-679">BSON has some additional data types that are not available in JSON, notably BinData (for byte arrays) and Date.</span></span>

- <span data-ttu-id="2e942-680">[MessagePack](http://msgpack.org/) , amely a hálózaton keresztül kell számára az átvitelhez kompakt bináris szerializálási formátum.</span><span class="sxs-lookup"><span data-stu-id="2e942-680">[MessagePack](http://msgpack.org/) is a binary serialization format that is designed to be compact for transmission over the wire.</span></span> <span data-ttu-id="2e942-681">Nincsenek üzenet sémák vagy üzenet típusa ellenőrzése.</span><span class="sxs-lookup"><span data-stu-id="2e942-681">There are no message schemas or message type checking.</span></span>

- <span data-ttu-id="2e942-682">[Kötés](https://microsoft.github.io/bond/) platformfüggetlen keretrendszere, amely sematizált adatok használata.</span><span class="sxs-lookup"><span data-stu-id="2e942-682">[Bond](https://microsoft.github.io/bond/) is a cross-platform framework for working with schematized data.</span></span> <span data-ttu-id="2e942-683">Támogatja a többnyelvű szerializálása és deszerializálása.</span><span class="sxs-lookup"><span data-stu-id="2e942-683">It supports cross-language serialization and deserialization.</span></span> <span data-ttu-id="2e942-684">Figyelmet a jelentősebb eltérések a más rendszerekkel, az itt felsorolt támogatja az öröklési, típus és általánosítási.</span><span class="sxs-lookup"><span data-stu-id="2e942-684">Notable differences from other systems listed here are support for inheritance, type aliases, and generics.</span></span> 

- <span data-ttu-id="2e942-685">[gRPC](http://www.grpc.io/) egy nyílt forráskódú Google által fejlesztett RPC rendszer.</span><span class="sxs-lookup"><span data-stu-id="2e942-685">[gRPC](http://www.grpc.io/) is an open source RPC system developed by Google.</span></span> <span data-ttu-id="2e942-686">Alapértelmezés szerint protokoll pufferek az adatdefiníciós nyelv és az alapjául szolgáló üzenet interchange formátum használ.</span><span class="sxs-lookup"><span data-stu-id="2e942-686">By default, it uses Protocol Buffers as its definition language and underlying message interchange format.</span></span>

## <a name="related-patterns-and-guidance"></a><span data-ttu-id="2e942-687">Útmutató és a kapcsolódó minták</span><span class="sxs-lookup"><span data-stu-id="2e942-687">Related patterns and guidance</span></span>

<span data-ttu-id="2e942-688">A következő mintát is lehet a forgatókönyvhöz kapcsolódó, az alkalmazások gyorsítótárazás bevezetésekor:</span><span class="sxs-lookup"><span data-stu-id="2e942-688">The following pattern might also be relevant to your scenario when you implement caching in your applications:</span></span>

* <span data-ttu-id="2e942-689">[Gyorsítótár-tartalékoljon mintát](http://msdn.microsoft.com/library/dn589799.aspx): Ebben a mintában az igény szerinti adatok betöltése a gyorsítótárba egy adattárból ismerteti.</span><span class="sxs-lookup"><span data-stu-id="2e942-689">[Cache-aside pattern](http://msdn.microsoft.com/library/dn589799.aspx): This pattern describes how to load data on demand into a cache from a data store.</span></span> <span data-ttu-id="2e942-690">Ez a minta biztosítja az egységességet a gyorsítótárban tartott és az adatok az eredeti adattárolóban között is segíti.</span><span class="sxs-lookup"><span data-stu-id="2e942-690">This pattern also helps to maintain consistency between data that's held in the cache and the data in the original data store.</span></span>
* <span data-ttu-id="2e942-691">A [horizontális mintát](http://msdn.microsoft.com/library/dn589797.aspx) vízszintes particionálási tárolásakor méretezhetőség javítása érdekében, és nagy mennyiségű adat elérésekor végrehajtási információt nyújt.</span><span class="sxs-lookup"><span data-stu-id="2e942-691">The [Sharding pattern](http://msdn.microsoft.com/library/dn589797.aspx) provides information about implementing horizontal partitioning to help improve scalability when storing and accessing large volumes of data.</span></span>

## <a name="more-information"></a><span data-ttu-id="2e942-692">További információ</span><span class="sxs-lookup"><span data-stu-id="2e942-692">More information</span></span>
* <span data-ttu-id="2e942-693">A [MemoryCache osztály](http://msdn.microsoft.com/library/system.runtime.caching.memorycache.aspx) oldalon, a Microsoft webhelyén</span><span class="sxs-lookup"><span data-stu-id="2e942-693">The [MemoryCache class](http://msdn.microsoft.com/library/system.runtime.caching.memorycache.aspx) page on the Microsoft website</span></span>
* <span data-ttu-id="2e942-694">A [Azure Redis Cache dokumentáció](https://azure.microsoft.com/documentation/services/cache/) oldalon, a Microsoft webhelyén</span><span class="sxs-lookup"><span data-stu-id="2e942-694">The [Azure Redis Cache documentation](https://azure.microsoft.com/documentation/services/cache/) page on the Microsoft website</span></span>
* <span data-ttu-id="2e942-695">A [Azure Redis Cache – gyakori kérdések](/azure/redis-cache/cache-faq) oldalon, a Microsoft webhelyén</span><span class="sxs-lookup"><span data-stu-id="2e942-695">The [Azure Redis Cache FAQ](/azure/redis-cache/cache-faq) page on the Microsoft website</span></span>
* <span data-ttu-id="2e942-696">A [konfigurációs modell](http://msdn.microsoft.com/library/windowsazure/hh914149.aspx) oldalon, a Microsoft webhelyén</span><span class="sxs-lookup"><span data-stu-id="2e942-696">The [Configuration model](http://msdn.microsoft.com/library/windowsazure/hh914149.aspx) page on the Microsoft website</span></span>
* <span data-ttu-id="2e942-697">A [feladatalapú aszinkron mintát](http://msdn.microsoft.com/library/hh873175.aspx) oldalon, a Microsoft webhelyén</span><span class="sxs-lookup"><span data-stu-id="2e942-697">The [Task-based Asynchronous Pattern](http://msdn.microsoft.com/library/hh873175.aspx) page on the Microsoft website</span></span>
* <span data-ttu-id="2e942-698">A [folyamatok és multiplexers](https://stackexchange.github.io/StackExchange.Redis/PipelinesMultiplexers) oldalon, a StackExchange.Redis GitHub-tárház</span><span class="sxs-lookup"><span data-stu-id="2e942-698">The [Pipelines and multiplexers](https://stackexchange.github.io/StackExchange.Redis/PipelinesMultiplexers) page on the StackExchange.Redis GitHub repo</span></span>
* <span data-ttu-id="2e942-699">A [Redis-adatmegőrzés](http://redis.io/topics/persistence) a Redis-webhelyen lap</span><span class="sxs-lookup"><span data-stu-id="2e942-699">The [Redis persistence](http://redis.io/topics/persistence) page on the Redis website</span></span>
* <span data-ttu-id="2e942-700">A [replikációs lap](http://redis.io/topics/replication) a Redis-webhelyen</span><span class="sxs-lookup"><span data-stu-id="2e942-700">The [Replication page](http://redis.io/topics/replication) on the Redis website</span></span>
* <span data-ttu-id="2e942-701">A [Redis-fürt oktatóanyag](http://redis.io/topics/cluster-tutorial) a Redis-webhelyen lap</span><span class="sxs-lookup"><span data-stu-id="2e942-701">The [Redis cluster tutorial](http://redis.io/topics/cluster-tutorial) page on the Redis website</span></span>
* <span data-ttu-id="2e942-702">A [particionálására: hogyan adatok több Redis-példány között](http://redis.io/topics/partitioning) a Redis-webhelyen lap</span><span class="sxs-lookup"><span data-stu-id="2e942-702">The [Partitioning: how to split data among multiple Redis instances](http://redis.io/topics/partitioning) page on the Redis website</span></span>
* <span data-ttu-id="2e942-703">A [használatával Redis, mint egy LRU gyorsítótár](http://redis.io/topics/lru-cache) a Redis-webhelyen lap</span><span class="sxs-lookup"><span data-stu-id="2e942-703">The [Using Redis as an LRU Cache](http://redis.io/topics/lru-cache) page on the Redis website</span></span>
* <span data-ttu-id="2e942-704">A [tranzakciók](http://redis.io/topics/transactions) a Redis-webhelyen lap</span><span class="sxs-lookup"><span data-stu-id="2e942-704">The [Transactions](http://redis.io/topics/transactions) page on the Redis website</span></span>
* <span data-ttu-id="2e942-705">A [biztonsági Redis](http://redis.io/topics/security) a Redis-webhelyen lap</span><span class="sxs-lookup"><span data-stu-id="2e942-705">The [Redis security](http://redis.io/topics/security) page on the Redis website</span></span>
* <span data-ttu-id="2e942-706">A [körül Azure Redis Cache Lap](https://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/) oldalon, az Azure blog</span><span class="sxs-lookup"><span data-stu-id="2e942-706">The [Lap around Azure Redis Cache](https://azure.microsoft.com/blog/2014/06/04/lap-around-azure-redis-cache-preview/) page on the Azure blog</span></span>
* <span data-ttu-id="2e942-707">A [a CentOS Linux virtuális gép az Azure-ban futó Redis](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx) oldalon, a Microsoft webhelyén</span><span class="sxs-lookup"><span data-stu-id="2e942-707">The [Running Redis on a CentOS Linux VM in Azure](http://blogs.msdn.com/b/tconte/archive/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure.aspx) page on the Microsoft website</span></span>
* <span data-ttu-id="2e942-708">A [ASP.NET munkamenetállapot-szolgáltatóját az Azure Redis Cache](/azure/redis-cache/cache-aspnet-session-state-provider) oldalon, a Microsoft webhelyén</span><span class="sxs-lookup"><span data-stu-id="2e942-708">The [ASP.NET session state provider for Azure Redis Cache](/azure/redis-cache/cache-aspnet-session-state-provider) page on the Microsoft website</span></span>
* <span data-ttu-id="2e942-709">A [az ASP.NET kimeneti gyorsítótár-szolgáltató Azure Redis Cache](/azure/redis-cache/cache-aspnet-output-cache-provider) oldalon, a Microsoft webhelyén</span><span class="sxs-lookup"><span data-stu-id="2e942-709">The [ASP.NET output cache provider for Azure Redis Cache](/azure/redis-cache/cache-aspnet-output-cache-provider) page on the Microsoft website</span></span>
* <span data-ttu-id="2e942-710">A [Redis az adattípusokat és az absztrakt entitások bevezetés](http://redis.io/topics/data-types-intro) a Redis-webhelyen lap</span><span class="sxs-lookup"><span data-stu-id="2e942-710">The [An Introduction to Redis data types and abstractions](http://redis.io/topics/data-types-intro) page on the Redis website</span></span>
* <span data-ttu-id="2e942-711">A [alapvető használati](https://stackexchange.github.io/StackExchange.Redis/Basics) a StackExchange.Redis-webhelyen lap</span><span class="sxs-lookup"><span data-stu-id="2e942-711">The [Basic usage](https://stackexchange.github.io/StackExchange.Redis/Basics) page on the StackExchange.Redis website</span></span>
* <span data-ttu-id="2e942-712">A [Redis-tranzakciók](https://stackexchange.github.io/StackExchange.Redis/Transactions) oldalon, a StackExchange.Redis-tárház</span><span class="sxs-lookup"><span data-stu-id="2e942-712">The [Transactions in Redis](https://stackexchange.github.io/StackExchange.Redis/Transactions) page on the StackExchange.Redis repo</span></span>
* <span data-ttu-id="2e942-713">A [adatok particionálási útmutató](http://msdn.microsoft.com/library/dn589795.aspx) a Microsoft webhelyén</span><span class="sxs-lookup"><span data-stu-id="2e942-713">The [Data partitioning guide](http://msdn.microsoft.com/library/dn589795.aspx) on the Microsoft website</span></span>

