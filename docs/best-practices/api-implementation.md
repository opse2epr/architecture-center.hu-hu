---
title: API-implementálási segédlet
titleSuffix: Best practices for cloud applications
description: Útmutató az API-k megvalósításához.
author: dragon119
ms.date: 07/13/2016
ms.topic: best-practice
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: 7a484aa9e4fde8fd5056608ca5dd98aefbc077b7
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 03/20/2019
ms.locfileid: "58298966"
---
# <a name="api-implementation"></a><span data-ttu-id="c0156-103">API-implementáció</span><span class="sxs-lookup"><span data-stu-id="c0156-103">API implementation</span></span>

<span data-ttu-id="c0156-104">A gondosan megtervezett RESTful webes API-k meghatározzák az ügyfélalkalmazások számára elérhető erőforrásokat, kapcsolatokat és navigációs rendszereket.</span><span class="sxs-lookup"><span data-stu-id="c0156-104">A carefully-designed RESTful web API defines the resources, relationships, and navigation schemes that are accessible to client applications.</span></span> <span data-ttu-id="c0156-105">A webes API-k megvalósításakor és központi telepítésekor a webes API-t futtató környezet fizikai követelményeit és a webes API felépítését kell figyelembe vennie az adatok logikai szerkezete helyett.</span><span class="sxs-lookup"><span data-stu-id="c0156-105">When you implement and deploy a web API, you should consider the physical requirements of the environment hosting the web API and the way in which the web API is constructed rather than the logical structure of the data.</span></span> <span data-ttu-id="c0156-106">Ez az útmutató ajánlott eljárásokat tartalmaz a webes API-k megvalósításához és közzétételéhez, hogy elérhetők legyenek az ügyfélalkalmazások számára.</span><span class="sxs-lookup"><span data-stu-id="c0156-106">This guidance focusses on best practices for implementing a web API and publishing it to make it available to client applications.</span></span> <span data-ttu-id="c0156-107">Részletes információ a webes API-k tervezéséről: [API-tervezési segédlet](/azure/architecture/best-practices/api-design).</span><span class="sxs-lookup"><span data-stu-id="c0156-107">For detailed information about web API design, see [API Design Guidance](/azure/architecture/best-practices/api-design).</span></span>

## <a name="processing-requests"></a><span data-ttu-id="c0156-108">Kérelmek feldolgozása</span><span class="sxs-lookup"><span data-stu-id="c0156-108">Processing requests</span></span>

<span data-ttu-id="c0156-109">A kéréseket kezelő kód megvalósításakor vegye figyelembe az alábbi szempontokat:</span><span class="sxs-lookup"><span data-stu-id="c0156-109">Consider the following points when you implement the code to handle requests.</span></span>

### <a name="get-put-delete-head-and-patch-actions-should-be-idempotent"></a><span data-ttu-id="c0156-110">A GET, PUT, DELETE, HEAD és JAVÍTÁSI műveleteknek idempotensnek kell lenniük</span><span class="sxs-lookup"><span data-stu-id="c0156-110">GET, PUT, DELETE, HEAD, and PATCH actions should be idempotent</span></span>

<span data-ttu-id="c0156-111">A kérelmeket megvalósító kódnak nem lehetnek mellékhatásai.</span><span class="sxs-lookup"><span data-stu-id="c0156-111">The code that implements these requests should not impose any side-effects.</span></span> <span data-ttu-id="c0156-112">Ha egy kérést megismétel ugyanazon az erőforráson, a kérésnek ugyanazt az állapotot kell eredményeznie.</span><span class="sxs-lookup"><span data-stu-id="c0156-112">The same request repeated over the same resource should result in the same state.</span></span> <span data-ttu-id="c0156-113">Például egy adott URI-re küldött több DELETE kérelem eredményének ugyanannak kell lennie, habár a válaszüzenetekben található HTTP-állapotkódok különbözők lehetnek.</span><span class="sxs-lookup"><span data-stu-id="c0156-113">For example, sending multiple DELETE requests to the same URI should have the same effect, although the HTTP status code in the response messages may be different.</span></span> <span data-ttu-id="c0156-114">Lehetséges, hogy az első törlési kérelem a 204 (nincs tartalom) állapotkódot, a további törlési kérelmek pedig a 404 (nem található) állapotkódot adják vissza.</span><span class="sxs-lookup"><span data-stu-id="c0156-114">The first DELETE request might return status code 204 (No Content), while a subsequent DELETE request might return status code 404 (Not Found).</span></span>

> [!NOTE]
> <span data-ttu-id="c0156-115">Jonathan Oliver blogjának [idempotenciamintákról](https://blog.jonathanoliver.com/idempotency-patterns/) szóló cikke áttekintést nyújt idempotenciáról, és hogy az hogyan kapcsolódik az adatkezelési műveletekhez.</span><span class="sxs-lookup"><span data-stu-id="c0156-115">The article [Idempotency Patterns](https://blog.jonathanoliver.com/idempotency-patterns/) on Jonathan Oliver’s blog provides an overview of idempotency and how it relates to data management operations.</span></span>

### <a name="post-actions-that-create-new-resources-should-not-have-unrelated-side-effects"></a><span data-ttu-id="c0156-116">Az új erőforrásokat létrehozó POST műveleteknek nem lehetnek független mellékhatásai</span><span class="sxs-lookup"><span data-stu-id="c0156-116">POST actions that create new resources should not have unrelated side-effects</span></span>

<span data-ttu-id="c0156-117">Ha egy POST kérés célja egy új erőforrás létrehozása, a kérés csak az új erőforrásra lehet hatással (valamint esetleg a közvetlenül kapcsolódó erőforrásokhoz, ha vannak ilyenek). Például egy elektronikus kereskedelmi rendszerben egy ügyfél számára egy új erőforrást létrehozó POST kérés módosíthatja a készletszinteket és létrehozhat számlázási adatokat, de nem módosíthatja a rendeléshez nem közvetlenül kapcsolódó információkat, és nem lehet semmilyen más mellékhatása a rendszer általános állapotára.</span><span class="sxs-lookup"><span data-stu-id="c0156-117">If a POST request is intended to create a new resource, the effects of the request should be limited to the new resource (and possibly any directly related resources if there is some sort of linkage involved) For example, in an ecommerce system, a POST request that creates a new order for a customer might also amend inventory levels and generate billing information, but it should not modify information not directly related to the order or have any other side-effects on the overall state of the system.</span></span>

### <a name="avoid-implementing-chatty-post-put-and-delete-operations"></a><span data-ttu-id="c0156-118">A POST, PUT és DELETE műveletek ne legyenek hosszadalmasak</span><span class="sxs-lookup"><span data-stu-id="c0156-118">Avoid implementing chatty POST, PUT, and DELETE operations</span></span>

<span data-ttu-id="c0156-119">Biztosítson támogatást a POST, PUT és DELETE kérések teljes erőforrás-gyűjteményeken való végrehajtásához.</span><span class="sxs-lookup"><span data-stu-id="c0156-119">Support POST, PUT and DELETE requests over resource collections.</span></span> <span data-ttu-id="c0156-120">Egy POST kérés tartalmazhatja több új erőforrás részleteit is, amelyeket ugyanahhoz a gyűjteményhez ad hozzá. A PUT kérések egy gyűjtemény teljes erőforráskészletét lecserélhetik, míg a DELETE kérések egy teljes gyűjteményt eltávolíthatnak.</span><span class="sxs-lookup"><span data-stu-id="c0156-120">A POST request can contain the details for multiple new resources and add them all to the same collection, a PUT request can replace the entire set of resources in a collection, and a DELETE request can remove an entire collection.</span></span>

<span data-ttu-id="c0156-121">Az ASP.NET Web API 2-ben található OData-támogatás lehetővé teszi a kérések kötegelését.</span><span class="sxs-lookup"><span data-stu-id="c0156-121">The OData support included in ASP.NET Web API 2 provides the ability to batch requests.</span></span> <span data-ttu-id="c0156-122">Az ügyfélalkalmazások becsomagolhatnak több webes API-kérést és egyetlen HTTP-kérésben küldhetik el őket a kiszolgálóra, majd egyetlen HTTP-választ kapnak vissza, amely az összes kérésre vonatkozó választ tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="c0156-122">A client application can package up several web API requests and send them to the server in a single HTTP request, and receive a single HTTP response that contains the replies to each request.</span></span> <span data-ttu-id="c0156-123">További információ: [A kötegelés támogatásának bevezetése a webes API-ban és a webes API ODatában](https://blogs.msdn.microsoft.com/webdev/2013/11/01/introducing-batch-support-in-web-api-and-web-api-odata/).</span><span class="sxs-lookup"><span data-stu-id="c0156-123">For more information, [Introducing Batch Support in Web API and Web API OData](https://blogs.msdn.microsoft.com/webdev/2013/11/01/introducing-batch-support-in-web-api-and-web-api-odata/).</span></span>

### <a name="follow-the-http-specification-when-sending-a-response"></a><span data-ttu-id="c0156-124">Kövesse a HTTP-specifikációkat válasz küldésekor</span><span class="sxs-lookup"><span data-stu-id="c0156-124">Follow the HTTP specification when sending a response</span></span>

<span data-ttu-id="c0156-125">A webes API-nak olyan üzeneteket kell visszaadnia, amelyek tartalmazzák a megfelelő HTTP-állapotkódot, amelyek alapján az ügyfél el tudja dönteni, hogyan kezelje az eredményt. Emellett tartalmazniuk kell még a megfelelő HTTP-fejléceket, hogy az ügyfél értse az eredmény jellegét, valamint egy megfelelően formázott törzset, amely alapján az ügyfél elemezheti az eredményt.</span><span class="sxs-lookup"><span data-stu-id="c0156-125">A web API must return messages that contain the correct HTTP status code to enable the client to determine how to handle the result, the appropriate HTTP headers so that the client understands the nature of the result, and a suitably formatted body to enable the client to parse the result.</span></span>

<span data-ttu-id="c0156-126">Például a POST műveletnek a 201 (Létrehozva) állapotkódot kell visszaadnia, a válaszüzenetnek pedig bele kell foglalnia kell az újonnan létrehozott erőforrás URI-jét a válaszüzenet Location fejlécébe.</span><span class="sxs-lookup"><span data-stu-id="c0156-126">For example, a POST operation should return status code 201 (Created) and the response message should include the URI of the newly created resource in the Location header of the response message.</span></span>

### <a name="support-content-negotiation"></a><span data-ttu-id="c0156-127">A tartalomegyeztetés támogatása</span><span class="sxs-lookup"><span data-stu-id="c0156-127">Support content negotiation</span></span>

<span data-ttu-id="c0156-128">A válaszüzenetek törzse többféle formátumú adatokat tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="c0156-128">The body of a response message may contain data in a variety of formats.</span></span> <span data-ttu-id="c0156-129">Például egy HTTP GET kérés JSON vagy XML formátumú adatokat is visszaadhat.</span><span class="sxs-lookup"><span data-stu-id="c0156-129">For example, an HTTP GET request could return data in JSON, or XML format.</span></span> <span data-ttu-id="c0156-130">Az ügyfél által küldött kérés tartalmazhat egy Accept fejlécet, amelyben megadja, hogy milyen adatformátumokat tud kezelni.</span><span class="sxs-lookup"><span data-stu-id="c0156-130">When the client submits a request, it can include an Accept header that specifies the data formats that it can handle.</span></span> <span data-ttu-id="c0156-131">Ezek a formátumok médiatípusként vannak megadva.</span><span class="sxs-lookup"><span data-stu-id="c0156-131">These formats are specified as media types.</span></span> <span data-ttu-id="c0156-132">Egy ügyfél kibocsát egy képet lekérő GET kérést megadhatja például, egy Accept fejlécet, amely felsorolja az ügyfél képes kezelni, például adathordozó-típusok `image/jpeg, image/gif, image/png`.</span><span class="sxs-lookup"><span data-stu-id="c0156-132">For example, a client that issues a GET request that retrieves an image can specify an Accept header that lists the media types that the client can handle, such as `image/jpeg, image/gif, image/png`.</span></span> <span data-ttu-id="c0156-133">Amikor a webes API visszaadja az eredményt, az adatokat a felsorolt médiatípusok egyikével kell formáznia, és meg kell adnia a formátumot a válasz Content-Type fejlécében.</span><span class="sxs-lookup"><span data-stu-id="c0156-133">When the web API returns the result, it should format the data by using one of these media types and specify the format in the Content-Type header of the response.</span></span>

<span data-ttu-id="c0156-134">Ha az ügyfél nem adott meg Accept fejlécet, akkor az API egy kézenfekvő alapértelmezett formátumot használ a választörzsben.</span><span class="sxs-lookup"><span data-stu-id="c0156-134">If the client does not specify an Accept header, then use a sensible default format for the response body.</span></span> <span data-ttu-id="c0156-135">Az ASP.NET webes API-keretrendszer például alapértelmezés szerint a JSON formátumot használja a szöveges adatokhoz.</span><span class="sxs-lookup"><span data-stu-id="c0156-135">As an example, the ASP.NET Web API framework defaults to JSON for text-based data.</span></span>

### <a name="provide-links-to-support-hateoas-style-navigation-and-discovery-of-resources"></a><span data-ttu-id="c0156-136">Adjon meg hivatkozásokat a HATEOAS stílusú navigáció és az erőforrás-felderítés támogatásához</span><span class="sxs-lookup"><span data-stu-id="c0156-136">Provide links to support HATEOAS-style navigation and discovery of resources</span></span>

<span data-ttu-id="c0156-137">A HATEOAS módszer lehetővé teszi az ügyfelek számára, hogy egy kezdeti kiindulási pontról navigáljanak és derítsék fel az erőforrásokat.</span><span class="sxs-lookup"><span data-stu-id="c0156-137">The HATEOAS approach enables a client to navigate and discover resources from an initial starting point.</span></span> <span data-ttu-id="c0156-138">Ez URI-ket tartalmazó hivatkozásokkal történik. Amikor egy ügyfél kiad egy HTTP GET kérést egy erőforrás beszerzéséhez, akkor a válasznak tartalmaznia olyan URI-kat kell tartalmaznia, amelyekkel az ügyfélalkalmazás gyorsan megtalálhat bármilyen közvetlenül kapcsolódó erőforrást.</span><span class="sxs-lookup"><span data-stu-id="c0156-138">This is achieved by using links containing URIs; when a client issues an HTTP GET request to obtain a resource, the response should contain URIs that enable a client application to quickly locate any directly related resources.</span></span> <span data-ttu-id="c0156-139">Például vegyünk egy elektronikus kereskedelmi megoldást támogató webes API-t, amelyben egy ügyfél számos megrendelést adott le.</span><span class="sxs-lookup"><span data-stu-id="c0156-139">For example, in a web API that supports an e-commerce solution, a customer may have placed many orders.</span></span> <span data-ttu-id="c0156-140">Amikor egy ügyfélalkalmazás lekéri az ügyfél adatait, a válasznak olyan hivatkozásokat kell tartalmaznia, amelyek alapján az ügyfélalkalmazás el tudja küldeni a HTTP GET kéréseket a rendelés lekéréséhez.</span><span class="sxs-lookup"><span data-stu-id="c0156-140">When a client application retrieves the details for a customer, the response should include links that enable the client application to send HTTP GET requests that can retrieve these orders.</span></span> <span data-ttu-id="c0156-141">Emellett a kérések végrehajtásához HATEOAS stílusú hivatkozásokkal le kell írnia az egyes hivatkozott erőforrások által támogatott egyéb műveleteket (POST, PUT, DELETE stb.) a megfelelő URI-kkel.</span><span class="sxs-lookup"><span data-stu-id="c0156-141">Additionally, HATEOAS-style links should describe the other operations (POST, PUT, DELETE, and so on) that each linked resource supports together with the corresponding URI to perform each request.</span></span> <span data-ttu-id="c0156-142">A módszer részletesebb leírását lásd: [API-tervezés][api-design].</span><span class="sxs-lookup"><span data-stu-id="c0156-142">This approach is described in more detail in [API Design][api-design].</span></span>

<span data-ttu-id="c0156-143">Jelenleg nincsenek a HATEOAS megvalósítására vonatkozó szabványok, de a következő példa bemutat egy lehetséges módszert.</span><span class="sxs-lookup"><span data-stu-id="c0156-143">Currently there are no standards that govern the implementation of HATEOAS, but the following example illustrates one possible approach.</span></span> <span data-ttu-id="c0156-144">Ebben a példában egy HTTP GET kérés, amely megkeresi az ügyfél adatait, egy olyan választ ad vissza, amely az ügyfél rendeléseire mutató HATEOAS-hivatkozásokat tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="c0156-144">In this example, an HTTP GET request that finds the details for a customer returns a response that include HATEOAS links that reference the orders for that customer:</span></span>

```HTTP
GET https://adventure-works.com/customers/2 HTTP/1.1
Accept: text/json
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"CustomerID":2,"CustomerName":"Bert","Links":[
    {"rel":"self",
    "href":"https://adventure-works.com/customers/2",
    "action":"GET",
    "types":["text/xml","application/json"]},
    {"rel":"self",
    "href":"https://adventure-works.com/customers/2",
    "action":"PUT",
    "types":["application/x-www-form-urlencoded"]},
    {"rel":"self",
    "href":"https://adventure-works.com/customers/2",
    "action":"DELETE",
    "types":[]},
    {"rel":"orders",
    "href":"https://adventure-works.com/customers/2/orders",
    "action":"GET",
    "types":["text/xml","application/json"]},
    {"rel":"orders",
    "href":"https://adventure-works.com/customers/2/orders",
    "action":"POST",
    "types":["application/x-www-form-urlencoded"]}
]}
```

<span data-ttu-id="c0156-145">Ebben a példában a felhasználói adatokat a `Customer` osztály jelöli a következő kódrészletben.</span><span class="sxs-lookup"><span data-stu-id="c0156-145">In this example, the customer data is represented by the `Customer` class shown in the following code snippet.</span></span> <span data-ttu-id="c0156-146">A HATEOAS-hivatkozásokat a `Links` gyűjteménytulajdonság tartalmazza:</span><span class="sxs-lookup"><span data-stu-id="c0156-146">The HATEOAS links are held in the `Links` collection property:</span></span>

```csharp
public class Customer
{
    public int CustomerID { get; set; }
    public string CustomerName { get; set; }
    public List<Link> Links { get; set; }
    ...
}

public class Link
{
    public string Rel { get; set; }
    public string Href { get; set; }
    public string Action { get; set; }
    public string [] Types { get; set; }
}
```

<span data-ttu-id="c0156-147">A HTTP GET művelet lekérdezi a felhasználói adatokat a tárolóból, és létrehoz egy `Customer` objektumot, majd feltölti a `Links` gyűjteményt.</span><span class="sxs-lookup"><span data-stu-id="c0156-147">The HTTP GET operation retrieves the customer data from storage and constructs a `Customer` object, and then populates the `Links` collection.</span></span> <span data-ttu-id="c0156-148">Az eredményt egy JSON-válaszüzenet formájában adja vissza a rendszer.</span><span class="sxs-lookup"><span data-stu-id="c0156-148">The result is formatted as a JSON response message.</span></span> <span data-ttu-id="c0156-149">Mindegyik hivatkozás a következő mezőket tartalmazza:</span><span class="sxs-lookup"><span data-stu-id="c0156-149">Each link comprises the following fields:</span></span>

- <span data-ttu-id="c0156-150">A visszaadott objektum és hivatkozásban leírt objektum közötti kapcsolat.</span><span class="sxs-lookup"><span data-stu-id="c0156-150">The relationship between the object being returned and the object described by the link.</span></span> <span data-ttu-id="c0156-151">Ebben az esetben `self` azt jelzi, hogy a hivatkozás magára az objektumra egy hivatkozást (hasonlóan egy `this` számos objektumorientált nyelv mutatójához), és `orders` a kapcsolódó rendelési adatokat tartalmazó gyűjtemény neve.</span><span class="sxs-lookup"><span data-stu-id="c0156-151">In this case `self` indicates that the link is a reference back to the object itself (similar to a `this` pointer in many object-oriented languages), and `orders` is the name of a collection containing the related order information.</span></span>
- <span data-ttu-id="c0156-152">A hivatkozás által leírt objektum hiperhivatkozása (`Href`) egy URI formájában.</span><span class="sxs-lookup"><span data-stu-id="c0156-152">The hyperlink (`Href`) for the object being described by the link in the form of a URI.</span></span>
- <span data-ttu-id="c0156-153">Az URI felé küldhető HTTP-kérelem típusa (`Action`).</span><span class="sxs-lookup"><span data-stu-id="c0156-153">The type of HTTP request (`Action`) that can be sent to this URI.</span></span>
- <span data-ttu-id="c0156-154">Azon adatok formátuma (`Types`), amelyeket meg kell adni a HTTP-kérelemben, vagy amelyeket a válasz visszaadhat, a kérelem típusától függően.</span><span class="sxs-lookup"><span data-stu-id="c0156-154">The format of any data (`Types`) that should be provided in the HTTP request or that can be returned in the response, depending on the type of the request.</span></span>

<span data-ttu-id="c0156-155">A példa HTTP-válaszban található HATEOAS-hivatkozások azt jelzik, hogy egy ügyfélalkalmazás a következő műveleteket hajthatja végre:</span><span class="sxs-lookup"><span data-stu-id="c0156-155">The HATEOAS links shown in the example HTTP response indicate that a client application can perform the following operations:</span></span>

- <span data-ttu-id="c0156-156">Egy HTTP GET kérelem a `https://adventure-works.com/customers/2` URI felé, amely (újra) lekéri az ügyfél adatait.</span><span class="sxs-lookup"><span data-stu-id="c0156-156">An HTTP GET request to the URI `https://adventure-works.com/customers/2` to fetch the details of the customer (again).</span></span> <span data-ttu-id="c0156-157">Ezek az adatok XML vagy JSON formátumban adhatók vissza.</span><span class="sxs-lookup"><span data-stu-id="c0156-157">The data can be returned as XML or JSON.</span></span>
- <span data-ttu-id="c0156-158">Egy HTTP PUT kérelem a `https://adventure-works.com/customers/2` URI felé, amely módosítja az ügyfél adatait.</span><span class="sxs-lookup"><span data-stu-id="c0156-158">An HTTP PUT request to the URI `https://adventure-works.com/customers/2` to modify the details of the customer.</span></span> <span data-ttu-id="c0156-159">Az új adatokat a kérésüzenetben x-www-form-urlencoded formátumban kell megadni.</span><span class="sxs-lookup"><span data-stu-id="c0156-159">The new data must be provided in the request message in x-www-form-urlencoded format.</span></span>
- <span data-ttu-id="c0156-160">Egy HTTP DELETE kérelem a `https://adventure-works.com/customers/2` URI felé, amely törli az ügyfelet.</span><span class="sxs-lookup"><span data-stu-id="c0156-160">An HTTP DELETE request to the URI `https://adventure-works.com/customers/2` to delete the customer.</span></span> <span data-ttu-id="c0156-161">A kérelem nem vár semmilyen további információt, és nem ad vissza semmilyen adatot a válaszüzenet törzsében.</span><span class="sxs-lookup"><span data-stu-id="c0156-161">The request does not expect any additional information or return data in the response message body.</span></span>
- <span data-ttu-id="c0156-162">Egy HTTP GET kérelem a `https://adventure-works.com/customers/2/orders` URI felé, amely lekéri az ügyfél összes rendelését.</span><span class="sxs-lookup"><span data-stu-id="c0156-162">An HTTP GET request to the URI `https://adventure-works.com/customers/2/orders` to find all the orders for the customer.</span></span> <span data-ttu-id="c0156-163">Ezek az adatok XML vagy JSON formátumban adhatók vissza.</span><span class="sxs-lookup"><span data-stu-id="c0156-163">The data can be returned as XML or JSON.</span></span>
- <span data-ttu-id="c0156-164">Egy HTTP PUT kérelem a `https://adventure-works.com/customers/2/orders` URI felé, amely létrehoz egy új rendelést az ügyfélhez.</span><span class="sxs-lookup"><span data-stu-id="c0156-164">An HTTP PUT request to the URI `https://adventure-works.com/customers/2/orders` to create a new order for this customer.</span></span> <span data-ttu-id="c0156-165">Az adatokat a kérésüzenetben x-www-form-urlencoded formátumban kell megadni.</span><span class="sxs-lookup"><span data-stu-id="c0156-165">The data must be provided in the request message in x-www-form-urlencoded format.</span></span>

## <a name="handling-exceptions"></a><span data-ttu-id="c0156-166">Kivételek kezelése</span><span class="sxs-lookup"><span data-stu-id="c0156-166">Handling exceptions</span></span>

<span data-ttu-id="c0156-167">Ha egy művelet nem kezelt kivételt jelez, vegye figyelembe a következő szempontokat.</span><span class="sxs-lookup"><span data-stu-id="c0156-167">Consider the following points if an operation throws an uncaught exception.</span></span>

### <a name="capture-exceptions-and-return-a-meaningful-response-to-clients"></a><span data-ttu-id="c0156-168">Kivételek rögzítése és jelentéssel bíró válasz visszaadása az ügyfeleknek</span><span class="sxs-lookup"><span data-stu-id="c0156-168">Capture exceptions and return a meaningful response to clients</span></span>

<span data-ttu-id="c0156-169">A HTTP-műveleteket megvalósító kódnak átfogó kivételkezelést kell biztosítania ahelyett, hogy engedné a nem kezelt kivételek propagálását a keretrendszerbe.</span><span class="sxs-lookup"><span data-stu-id="c0156-169">The code that implements an HTTP operation should provide comprehensive exception handling rather than letting uncaught exceptions propagate to the framework.</span></span> <span data-ttu-id="c0156-170">Ha egy kivétel megakadályozza a művelet sikeres elvégzését, a kivétel visszaadható a válaszüzenetben, de ez esetben jelentéssel bíró leírást is kell adnia a kivételt okozó hibáról.</span><span class="sxs-lookup"><span data-stu-id="c0156-170">If an exception makes it impossible to complete the operation successfully, the exception can be passed back in the response message, but it should include a meaningful description of the error that caused the exception.</span></span> <span data-ttu-id="c0156-171">A kivételnek tartalmaznia a megfelelő HTTP-állapotkódot is ahelyett, hogy minden esetben egyszerűen az 500-as állapotkódot adná vissza.</span><span class="sxs-lookup"><span data-stu-id="c0156-171">The exception should also include the appropriate HTTP status code rather than simply returning status code 500 for every situation.</span></span> <span data-ttu-id="c0156-172">Ha például egy felhasználó kérés egy olyan frissítést vált ki, amely megsért egy korlátozást (például megkísérel törölni egy nyitott rendelésekkel rendelkező ügyfelet), akkor a 409 (Ütközés) állapotkódot kell visszaadni, valamint az üzenet törzsében jelezni kell ütközés okát.</span><span class="sxs-lookup"><span data-stu-id="c0156-172">For example, if a user request causes a database update that violates a constraint (such as attempting to delete a customer that has outstanding orders), you should return status code 409 (Conflict) and a message body indicating the reason for the conflict.</span></span> <span data-ttu-id="c0156-173">Ha valamilyen más körülmény akadályozza a kérés teljesítését, akkor a 400 (Hibás kérelem) állapotkód is visszaadható.</span><span class="sxs-lookup"><span data-stu-id="c0156-173">If some other condition renders the request unachievable, you can return status code 400 (Bad Request).</span></span> <span data-ttu-id="c0156-174">A HTTP-állapotkódok teljes listáját megtalálhatja a W3C webhely [Állapotkódok definíciói](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) lapján.</span><span class="sxs-lookup"><span data-stu-id="c0156-174">You can find a full list of HTTP status codes on the [Status Code Definitions](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) page on the W3C website.</span></span>

<span data-ttu-id="c0156-175">A kódpélda rögzíti a különböző körülményeket, és megfelelő választ ad vissza.</span><span class="sxs-lookup"><span data-stu-id="c0156-175">The code example traps different conditions and returns an appropriate response.</span></span>

```csharp
[HttpDelete]
[Route("customers/{id:int}")]
public IHttpActionResult DeleteCustomer(int id)
{
    try
    {
        // Find the customer to be deleted in the repository
        var customerToDelete = repository.GetCustomer(id);

        // If there is no such customer, return an error response
        // with status code 404 (Not Found)
        if (customerToDelete == null)
        {
                return NotFound();
        }

        // Remove the customer from the repository
        // The DeleteCustomer method returns true if the customer
        // was successfully deleted
        if (repository.DeleteCustomer(id))
        {
            // Return a response message with status code 204 (No Content)
            // To indicate that the operation was successful
            return StatusCode(HttpStatusCode.NoContent);
        }
        else
        {
            // Otherwise return a 400 (Bad Request) error response
            return BadRequest(Strings.CustomerNotDeleted);
        }
    }
    catch
    {
        // If an uncaught exception occurs, return an error response
        // with status code 500 (Internal Server Error)
        return InternalServerError();
    }
}
```

> [!TIP]
> <span data-ttu-id="c0156-176">Ne adjon meg olyan információt, amelyet egy támadó felhasználhat az API-ba való behatoláshoz.</span><span class="sxs-lookup"><span data-stu-id="c0156-176">Do not include information that could be useful to an attacker attempting to penetrate your API.</span></span>
  
<span data-ttu-id="c0156-177">Sok webkiszolgáló maga rögzíti a hibák körülményeit, mielőtt a hibák elérnék a webes API-t.</span><span class="sxs-lookup"><span data-stu-id="c0156-177">Many web servers trap error conditions themselves before they reach the web API.</span></span> <span data-ttu-id="c0156-178">Ha például egy webhelyen hitelesítés van konfigurálva, és a felhasználó nem adja meg a megfelelő hitelesítési adatokat, a webkiszolgálónak a 401 (Nem engedélyezett) állapotkódot kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="c0156-178">For example, if you configure authentication for a web site and the user fails to provide the correct authentication information, the web server should respond with status code 401 (Unauthorized).</span></span> <span data-ttu-id="c0156-179">Az ügyfél hitelesítése után a kód a saját ellenőrzéseivel győződhet meg róla, hogy az ügyfélnek hozzáféréssel kell rendelkeznie a kért erőforráshoz.</span><span class="sxs-lookup"><span data-stu-id="c0156-179">Once a client has been authenticated, your code can perform its own checks to verify that the client should be able access the requested resource.</span></span> <span data-ttu-id="c0156-180">Ha a hitelesítés sikertelen, a 403 (Tiltott) állapotkódot kell visszaadni.</span><span class="sxs-lookup"><span data-stu-id="c0156-180">If this authorization fails, you should return status code 403 (Forbidden).</span></span>

### <a name="handle-exceptions-consistently-and-log-information-about-errors"></a><span data-ttu-id="c0156-181">A kivételek egységes kezelése és a hibákkal kapcsolatos adatok naplózása</span><span class="sxs-lookup"><span data-stu-id="c0156-181">Handle exceptions consistently and log information about errors</span></span>

<span data-ttu-id="c0156-182">A kivételek egységes kezelése érdekében érdemes egy globális hibakezelési stratégiát bevezetnie a teljes webes API-n.</span><span class="sxs-lookup"><span data-stu-id="c0156-182">To handle exceptions in a consistent manner, consider implementing a global error handling strategy across the entire web API.</span></span> <span data-ttu-id="c0156-183">Emellett érdemes hibanaplózással rögzítenie az egyes kivételek összes részletét. A hibanapló bármilyen részletes információt tartalmazhat azzal a feltétellel, hogy az ügyfelek a weben keresztül nem férhetnek hozzá.</span><span class="sxs-lookup"><span data-stu-id="c0156-183">You should also incorporate error logging which captures the full details of each exception; this error log can contain detailed information as long as it is not made accessible over the web to clients.</span></span>

### <a name="distinguish-between-client-side-errors-and-server-side-errors"></a><span data-ttu-id="c0156-184">Az ügyféloldali és kiszolgálóoldali hibák megkülönböztetése</span><span class="sxs-lookup"><span data-stu-id="c0156-184">Distinguish between client-side errors and server-side errors</span></span>

<span data-ttu-id="c0156-185">A HTTP-protokoll megkülönbözteti az ügyfélalkalmazás által okozott (HTTP 4xx állapotkódú) és a kiszolgáló hibái miatt előforduló (HTTP 5xx állapotkódú) hibákat.</span><span class="sxs-lookup"><span data-stu-id="c0156-185">The HTTP protocol distinguishes between errors that occur due to the client application (the HTTP 4xx status codes), and errors that are caused by a mishap on the server (the HTTP 5xx status codes).</span></span> <span data-ttu-id="c0156-186">Ügyeljen arra, hogy a hibákkal kapcsolatos válaszüzenetekben betartsa ezt a konvenciót.</span><span class="sxs-lookup"><span data-stu-id="c0156-186">Make sure that you respect this convention in any error response messages.</span></span>

## <a name="optimizing-client-side-data-access"></a><span data-ttu-id="c0156-187">Ügyféloldali adatelérés optimalizálása</span><span class="sxs-lookup"><span data-stu-id="c0156-187">Optimizing client-side data access</span></span>

<span data-ttu-id="c0156-188">Az elosztott környezetekben, például amelyekben egy webkiszolgáló és ügyfélalkalmazások találhatók, az egyik elsődleges hibaforrás a hálózat.</span><span class="sxs-lookup"><span data-stu-id="c0156-188">In a distributed environment such as that involving a web server and client applications, one of the primary sources of concern is the network.</span></span> <span data-ttu-id="c0156-189">Ez jelentős szűk keresztmetszeteket okozhat, különösen akkor, ha egy ügyfélalkalmazás gyakran küld kérelmeket vagy fogad adatokat.</span><span class="sxs-lookup"><span data-stu-id="c0156-189">This can act as a considerable bottleneck, especially if a client application is frequently sending requests or receiving data.</span></span> <span data-ttu-id="c0156-190">Ezért törekedni kell a hálózaton keresztül zajló forgalom minimalizálására.</span><span class="sxs-lookup"><span data-stu-id="c0156-190">Therefore you should aim to minimize the amount of traffic that flows across the network.</span></span> <span data-ttu-id="c0156-191">Az adatok lekérését és karbantartását kezelő kód megvalósításakor vegye figyelembe az alábbi szempontokat:</span><span class="sxs-lookup"><span data-stu-id="c0156-191">Consider the following points when you implement the code to retrieve and maintain data:</span></span>

### <a name="support-client-side-caching"></a><span data-ttu-id="c0156-192">Az ügyféloldali gyorsítótárazás támogatása</span><span class="sxs-lookup"><span data-stu-id="c0156-192">Support client-side caching</span></span>

<span data-ttu-id="c0156-193">A HTTP 1.1 protokoll támogatja a gyorsítótárazást az ügyfeleken és köztes kiszolgálókon, amelyeken egy Cache-Control fejléc irányítja a kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="c0156-193">The HTTP 1.1 protocol supports caching in clients and intermediate servers through which a request is routed by the use of the Cache-Control header.</span></span> <span data-ttu-id="c0156-194">Amikor egy ügyfélalkalmazás egy HTTP GET kérést küld a webes API-nak, a válasz tartalmazhat egy Cache-Control fejlécet, amely jelzi, hogy a válasz törzsében található adatok biztonságosan gyorsítótárazhatók-e az ügyfélnél vagy egy köztes kiszolgálón, amelyen a kérelem áthaladt, valamint megadja, hogy az adatok mennyi idő után járnak le és válnak elavulttá.</span><span class="sxs-lookup"><span data-stu-id="c0156-194">When a client application sends an HTTP GET request to the web API, the response can include a Cache-Control header that indicates whether the data in the body of the response can be safely cached by the client or an intermediate server through which the request has been routed, and for how long before it should expire and be considered out-of-date.</span></span> <span data-ttu-id="c0156-195">A következő példa bemutat egy HTTP GET kérelmet és a rá adott választ, amely tartalmaz egy Cache-Control fejlécet:</span><span class="sxs-lookup"><span data-stu-id="c0156-195">The following example shows an HTTP GET request and the corresponding response that includes a Cache-Control header:</span></span>

```HTTP
GET https://adventure-works.com/orders/2 HTTP/1.1
```

```HTTP
HTTP/1.1 200 OK
...
Cache-Control: max-age=600, private
Content-Type: text/json; charset=utf-8
Content-Length: ...
{"orderID":2,"productID":4,"quantity":2,"orderValue":10.00}
```

<span data-ttu-id="c0156-196">Ebben a példában a Cache-Control fejléc megadja, hogy a visszaadott adatok 600 másodperc után járnak le, csak egyetlen ügyfél számára megfelelők és tilos őket más ügyfelek által is használt megosztott gyorsítótárakban tárolni (vagyis *private* (bizalmas) adatokról van szó).</span><span class="sxs-lookup"><span data-stu-id="c0156-196">In this example, the Cache-Control header specifies that the data returned should be expired after 600 seconds, and is only suitable for a single client and must not be stored in a shared cache used by other clients (it is *private*).</span></span> <span data-ttu-id="c0156-197">A Cache-Control fejléc a *private* helyett megadhat *public* (nyilvános) beállítást is, amely esetben az adatok tárolhatók egy megosztott gyorsítótárban, vagy megadhatja a *no-store* (nincs tárolás) értéket, amely esetben az adatok **nem** gyorsítótárazhatók az ügyfélben.</span><span class="sxs-lookup"><span data-stu-id="c0156-197">The Cache-Control header could specify *public* rather than *private* in which case the data can be stored in a shared cache, or it could specify *no-store* in which case the data must **not** be cached by the client.</span></span> <span data-ttu-id="c0156-198">Az alábbi példakód bemutatja, hogyan hozható létre egy Cache-Control fejléc a válaszüzenetben:</span><span class="sxs-lookup"><span data-stu-id="c0156-198">The following code example shows how to construct a Cache-Control header in a response message:</span></span>

```csharp
public class OrdersController : ApiController
{
    ...
    [Route("api/orders/{id:int:min(0)}")]
    [HttpGet]
    public IHttpActionResult FindOrderByID(int id)
    {
        // Find the matching order
        Order order = ...;
        ...
        // Create a Cache-Control header for the response
        var cacheControlHeader = new CacheControlHeaderValue();
        cacheControlHeader.Private = true;
        cacheControlHeader.MaxAge = new TimeSpan(0, 10, 0);
        ...

        // Return a response message containing the order and the cache control header
        OkResultWithCaching<Order> response = new OkResultWithCaching<Order>(order, this)
        {
            CacheControlHeader = cacheControlHeader
        };
        return response;
    }
    ...
}
```

<span data-ttu-id="c0156-199">Ez a kód egy `OkResultWithCaching` nevű egyéni `IHttpActionResult` osztályt használ.</span><span class="sxs-lookup"><span data-stu-id="c0156-199">This code makes use of a custom `IHttpActionResult` class named `OkResultWithCaching`.</span></span> <span data-ttu-id="c0156-200">Ez az osztály lehetővé teszi a vezérlőnek a gyorsítótárfejléc tartalmának beállítását:</span><span class="sxs-lookup"><span data-stu-id="c0156-200">This class enables the controller to set the cache header contents:</span></span>

```csharp
public class OkResultWithCaching<T> : OkNegotiatedContentResult<T>
{
    public OkResultWithCaching(T content, ApiController controller)
        : base(content, controller) { }

    public OkResultWithCaching(T content, IContentNegotiator contentNegotiator, HttpRequestMessage request, IEnumerable<MediaTypeFormatter> formatters)
        : base(content, contentNegotiator, request, formatters) { }

    public CacheControlHeaderValue CacheControlHeader { get; set; }
    public EntityTagHeaderValue ETag { get; set; }

    public override async Task<HttpResponseMessage> ExecuteAsync(CancellationToken cancellationToken)
    {
        HttpResponseMessage response;
        try
        {
            response = await base.ExecuteAsync(cancellationToken);
            response.Headers.CacheControl = this.CacheControlHeader;
            response.Headers.ETag = ETag;
        }
        catch (OperationCanceledException)
        {
            response = new HttpResponseMessage(HttpStatusCode.Conflict) {ReasonPhrase = "Operation was cancelled"};
        }
        return response;
    }
}
```

> [!NOTE]
> <span data-ttu-id="c0156-201">A HTTP-protokoll a *no-cache* direktívát is meghatározza a Cache-Control fejléchez.</span><span class="sxs-lookup"><span data-stu-id="c0156-201">The HTTP protocol also defines the *no-cache* directive for the Cache-Control header.</span></span> <span data-ttu-id="c0156-202">Megtévesztő módon ez nem azt jelenti, hogy az adatokat nem lehet gyorsítótárazni, hanem hogy a gyorsítótárazott adatokat ellenőriztetni kell a kiszolgálóval a visszaadás előtt – tehát az adatok gyorsítótárazhatók, de minden használatkor ellenőrizni kell, hogy még aktuálisak-e.</span><span class="sxs-lookup"><span data-stu-id="c0156-202">Rather confusingly, this directive does not mean "do not cache" but rather "revalidate the cached information with the server before returning it"; the data can still be cached, but it is checked each time it is used to ensure that it is still current.</span></span>

<span data-ttu-id="c0156-203">A gyorsítótár kezelése az ügyfélalkalmazás vagy a köztes kiszolgáló feladata, de ha megfelelően van megvalósítva, akkor a használatával sávszélesség takarítható meg és növelhető a teljesítmény, mivel nincs szükség a már beszerzett adatok újbóli lekérésére.</span><span class="sxs-lookup"><span data-stu-id="c0156-203">Cache management is the responsibility of the client application or intermediate server, but if properly implemented it can save bandwidth and improve performance by removing the need to fetch data that has already been recently retrieved.</span></span>

<span data-ttu-id="c0156-204">A Cache-Control fejléc *max-age* (maximális kor) értéke csak tájékoztató jellegű, és nem garantálja, hogy a vonatkozó adatok időközben nem változnak.</span><span class="sxs-lookup"><span data-stu-id="c0156-204">The *max-age* value in the Cache-Control header is only a guide and not a guarantee that the corresponding data won't change during the specified time.</span></span> <span data-ttu-id="c0156-205">A webes API-nak úgy kell beállítania a max-age értékét, hogy tükrözze az adatok várható érvényességét.</span><span class="sxs-lookup"><span data-stu-id="c0156-205">The web API should set the max-age to a suitable value depending on the expected volatility of the data.</span></span> <span data-ttu-id="c0156-206">Ha ez az időszak lejár, az ügyfélnek törölnie kell az objektumot a gyorsítótárból.</span><span class="sxs-lookup"><span data-stu-id="c0156-206">When this period expires, the client should discard the object from the cache.</span></span>

> [!NOTE]
> <span data-ttu-id="c0156-207">A legtöbb modern böngésző támogatja az ügyféloldali gyorsítótárazást azáltal, hogy az ismertetett módon gyorsítótár-vezérlő fejléceket ad hozzá a kérelmekhez, és megvizsgálja az eredmények fejlécét.</span><span class="sxs-lookup"><span data-stu-id="c0156-207">Most modern web browsers support client-side caching by adding the appropriate cache-control headers to requests and examining the headers of the results, as described.</span></span> <span data-ttu-id="c0156-208">Egyes régebbi böngészők azonban nem gyorsítótárazzák az olyan URL-címekről visszakapott adatokat, amelyek lekérdezési sztringet tartalmaznak.</span><span class="sxs-lookup"><span data-stu-id="c0156-208">However, some older browsers will not cache the values returned from a URL that includes a query string.</span></span> <span data-ttu-id="c0156-209">Ez általában nem okoz problémát az olyan egyéni ügyfélalkalmazások számára, amelyek az itt tárgyalt protokollon alapuló saját gyorsítótár-kezelési stratégiával rendelkeznek.</span><span class="sxs-lookup"><span data-stu-id="c0156-209">This is not usually an issue for custom client applications which implement their own cache management strategy based on the protocol discussed here.</span></span>
>
> <span data-ttu-id="c0156-210">Egyes régebbi proxyk ugyanígy viselkednek, és lehetséges, hogy nem gyorsítótárazzák a lekérdezési sztringekat tartalmazó URL-címeken alapuló kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="c0156-210">Some older proxies exhibit the same behavior and might not cache requests based on URLs with query strings.</span></span> <span data-ttu-id="c0156-211">Ez az olyan egyedi ügyfélalkalmazások számára jelenthet problémát, amelyek egy ilyen proxyn keresztül csatlakoznak egy webkiszolgálóhoz.</span><span class="sxs-lookup"><span data-stu-id="c0156-211">This could be an issue for custom client applications that connect to a web server through such a proxy.</span></span>

### <a name="provide-etags-to-optimize-query-processing"></a><span data-ttu-id="c0156-212">A lekérdezés feldolgozásának optimalizálása ETagek megadásával</span><span class="sxs-lookup"><span data-stu-id="c0156-212">Provide ETags to optimize query processing</span></span>

<span data-ttu-id="c0156-213">Amikor egy ügyfélalkalmazás lekér egy objektumot, a válaszüzenet egy *ETaget* (entitáscímkét) is tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="c0156-213">When a client application retrieves an object, the response message can also include an *ETag* (Entity Tag).</span></span> <span data-ttu-id="c0156-214">Az ETag egy olyan átlátszatlan sztring, amely egy erőforrás verzióját jelzi, és az erőforrás minden változásakor módosul.</span><span class="sxs-lookup"><span data-stu-id="c0156-214">An ETag is an opaque string that indicates the version of a resource; each time a resource changes the Etag is also modified.</span></span> <span data-ttu-id="c0156-215">Az ügyfélalkalmazásnak az adatokkal együtt az ETaget is gyorsítótáraznia kell.</span><span class="sxs-lookup"><span data-stu-id="c0156-215">This ETag should be cached as part of the data by the client application.</span></span> <span data-ttu-id="c0156-216">Az alábbi példakód bemutatja, hogyan lehet hozzáadni egy ETaget egy HTTP GET kérelemre adott válaszhoz.</span><span class="sxs-lookup"><span data-stu-id="c0156-216">The following code example shows how to add an ETag as part of the response to an HTTP GET request.</span></span> <span data-ttu-id="c0156-217">Ez a kód a `GetHashCode` metódussal létrehoz egy numerikus értéket, amely azonosítja az objektumot (ha szükséges, felülírhatja ezt a metódust, és létrehozhat egy saját kivonatot az MD5 vagy más algoritmus segítségével):</span><span class="sxs-lookup"><span data-stu-id="c0156-217">This code uses the `GetHashCode` method of an object to generate a numeric value that identifies the object (you can override this method if necessary and generate your own hash using an algorithm such as MD5) :</span></span>

```csharp
public class OrdersController : ApiController
{
    ...
    public IHttpActionResult FindOrderByID(int id)
    {
        // Find the matching order
        Order order = ...;
        ...

        var hashedOrder = order.GetHashCode();
        string hashedOrderEtag = $"\"{hashedOrder}\"";
        var eTag = new EntityTagHeaderValue(hashedOrderEtag);

        // Return a response message containing the order and the cache control header
        OkResultWithCaching<Order> response = new OkResultWithCaching<Order>(order, this)
        {
            ...,
            ETag = eTag
        };
        return response;
    }
    ...
}
```

<span data-ttu-id="c0156-218">A webes API által közzétett válaszüzenet így néz ki:</span><span class="sxs-lookup"><span data-stu-id="c0156-218">The response message posted by the web API looks like this:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Cache-Control: max-age=600, private
Content-Type: text/json; charset=utf-8
ETag: "2147483648"
Content-Length: ...
{"orderID":2,"productID":4,"quantity":2,"orderValue":10.00}
```

> [!TIP]
> <span data-ttu-id="c0156-219">Biztonsági okokból ne engedélyezze a bizalmas adatok és a hitelesített (HTTPS-) kapcsolaton keresztül visszaadott adatok gyorsítótárazását.</span><span class="sxs-lookup"><span data-stu-id="c0156-219">For security reasons, do not allow sensitive data or data returned over an authenticated (HTTPS) connection to be cached.</span></span>

<span data-ttu-id="c0156-220">Egy ügyfélalkalmazás egy újabb GET kéréssel bármikor újra lekérheti ugyanazt az erőforrást, és ha az erőforrás változott (ha más az ETagje), akkor a gyorsítótárazott verziót el kell távolítani, és az új verziót kell hozzáadni a gyorsítótárhoz.</span><span class="sxs-lookup"><span data-stu-id="c0156-220">A client application can issue a subsequent GET request to retrieve the same resource at any time, and if the resource has changed (it has a different ETag) the cached version should be discarded and the new version added to the cache.</span></span> <span data-ttu-id="c0156-221">Ha egy erőforrás nagy méretű, és az ügyfélnek való visszaküldése jelentős sávszélességet igényel, akkor nem hatékony több kérelmet küldeni ugyanannak az adatnak a lekérése céljából.</span><span class="sxs-lookup"><span data-stu-id="c0156-221">If a resource is large and requires a significant amount of bandwidth to transmit back to the client, repeated requests to fetch the same data can become inefficient.</span></span> <span data-ttu-id="c0156-222">A HTTP-protokoll ennek elkerülése érdekében a következő folyamatot határozza meg a GET kérelmek optimalizálásához, amelyet a webes API-knak támogatniuk kell:</span><span class="sxs-lookup"><span data-stu-id="c0156-222">To combat this, the HTTP protocol defines the following process for optimizing GET requests that you should support in a web API:</span></span>

- <span data-ttu-id="c0156-223">Az ügyfél létrehoz egy GET kérelmet, amely az erőforrás jelenleg gyorsítótárazott verziójának ETagjét tartalmazza, és egy If-None-Match HTTP-fejlécben hivatkozik rá:</span><span class="sxs-lookup"><span data-stu-id="c0156-223">The client constructs a GET request containing the ETag for the currently cached version of the resource referenced in an If-None-Match HTTP header:</span></span>

    ```HTTP
    GET https://adventure-works.com/orders/2 HTTP/1.1
    If-None-Match: "2147483648"
    ```

- <span data-ttu-id="c0156-224">A webes API GET művelete lekéri a kért adatok jelenlegi ETag címkéjét (2. rendelés a fenti példában), és összehasonlítja az értéket az If-None-Match fejlécben találhatóval.</span><span class="sxs-lookup"><span data-stu-id="c0156-224">The GET operation in the web API obtains the current ETag for the requested data (order 2 in the above example), and compares it to the value in the If-None-Match header.</span></span>

- <span data-ttu-id="c0156-225">Ha a kért adatok jelenlegi ETagje megegyezik a kérés által megadott ETaggel, akkor az erőforrás nem változott, és a webes API-nak a HTTP-válaszban egy üres üzenettörzset és a 304 (Nem módosított) állapotkódot kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="c0156-225">If the current ETag for the requested data matches the ETag provided by the request, the resource has not changed and the web API should return an HTTP response with an empty message body and a status code of 304 (Not Modified).</span></span>

- <span data-ttu-id="c0156-226">Ha a kért adatok jelenlegi ETagje nem egyezik a kérés által megadott ETaggel, akkor az adatok változtak, és a webes API-nak a HTTP-válaszban az üzenettörzsben meg kell adnia az új adatokat és a 200 (OK) állapotkódot.</span><span class="sxs-lookup"><span data-stu-id="c0156-226">If the current ETag for the requested data does not match the ETag provided by the request, then the data has changed and the web API should return an HTTP response with the new data in the message body and a status code of 200 (OK).</span></span>

- <span data-ttu-id="c0156-227">Ha a kért adatok már nem léteznek, akkor a webes API-nak egy 404 (Nem található) állapotkódú HTTP-választ kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="c0156-227">If the requested data no longer exists then the web API should return an HTTP response with the status code of 404 (Not Found).</span></span>

- <span data-ttu-id="c0156-228">Az ügyfél az állapotkódot használja a gyorsítótár karbantartásához.</span><span class="sxs-lookup"><span data-stu-id="c0156-228">The client uses the status code to maintain the cache.</span></span> <span data-ttu-id="c0156-229">Ha az adatok nem változtak (304-es állapotkód), akkor az objektum a gyorsítótárban maradhat, és ügyfélalkalmazás tovább használhatja az objektum jelenlegi verzióját.</span><span class="sxs-lookup"><span data-stu-id="c0156-229">If the data has not changed (status code 304) then the object can remain cached and the client application should continue to use this version of the object.</span></span> <span data-ttu-id="c0156-230">Ha az adatok megváltoztak (200-as állapotkód), akkor a gyorsítótárazott objektumot el kell távolítani, és egy újat kell beszúrni helyette.</span><span class="sxs-lookup"><span data-stu-id="c0156-230">If the data has changed (status code 200) then the cached object should be discarded and the new one inserted.</span></span> <span data-ttu-id="c0156-231">Ha az adatok már nem érhetők el (404-es állapotkód), akkor az objektumot el kell távolítani a gyorsítótárból.</span><span class="sxs-lookup"><span data-stu-id="c0156-231">If the data is no longer available (status code 404) then the object should be removed from the cache.</span></span>

> [!NOTE]
> <span data-ttu-id="c0156-232">Ha a válasz fejléce a no-store Cache-Control fejlécet tartalmazza, akkor az objektumot mindenképp el kell távolítani a gyorsítótárból, a HTTP-állapotkódtól függetlenül.</span><span class="sxs-lookup"><span data-stu-id="c0156-232">If the response header contains the Cache-Control header no-store then the object should always be removed from the cache regardless of the HTTP status code.</span></span>

<span data-ttu-id="c0156-233">Az alábbi kód az If-None-Match fejléc támogatásához kibővített `FindOrderByID` metódust mutatja.</span><span class="sxs-lookup"><span data-stu-id="c0156-233">The code below shows the `FindOrderByID` method extended to support the If-None-Match header.</span></span> <span data-ttu-id="c0156-234">Figyelje meg, hogy ha az If-None-Match fejléc hiányzik, a rendszer mindig lekéri a megadott rendelést:</span><span class="sxs-lookup"><span data-stu-id="c0156-234">Notice that if the If-None-Match header is omitted, the specified order is always retrieved:</span></span>

```csharp
public class OrdersController : ApiController
{
    [Route("api/orders/{id:int:min(0)}")]
    [HttpGet]
    public IHttpActionResult FindOrderByID(int id)
    {
        try
        {
            // Find the matching order
            Order order = ...;

            // If there is no such order then return NotFound
            if (order == null)
            {
                return NotFound();
            }

            // Generate the ETag for the order
            var hashedOrder = order.GetHashCode();
            string hashedOrderEtag = $"\"{hashedOrder}\"";

            // Create the Cache-Control and ETag headers for the response
            IHttpActionResult response;
            var cacheControlHeader = new CacheControlHeaderValue();
            cacheControlHeader.Public = true;
            cacheControlHeader.MaxAge = new TimeSpan(0, 10, 0);
            var eTag = new EntityTagHeaderValue(hashedOrderEtag);

            // Retrieve the If-None-Match header from the request (if it exists)
            var nonMatchEtags = Request.Headers.IfNoneMatch;

            // If there is an ETag in the If-None-Match header and
            // this ETag matches that of the order just retrieved,
            // then create a Not Modified response message
            if (nonMatchEtags.Count > 0 &&
                String.CompareOrdinal(nonMatchEtags.First().Tag, hashedOrderEtag) == 0)
            {
                response = new EmptyResultWithCaching()
                {
                    StatusCode = HttpStatusCode.NotModified,
                    CacheControlHeader = cacheControlHeader,
                    ETag = eTag
                };
            }
            // Otherwise create a response message that contains the order details
            else
            {
                response = new OkResultWithCaching<Order>(order, this)
                {
                    CacheControlHeader = cacheControlHeader,
                    ETag = eTag
                };
            }

            return response;
        }
        catch
        {
            return InternalServerError();
        }
    }
...
}
```

<span data-ttu-id="c0156-235">Ebben a példában egy `EmptyResultWithCaching` nevű másik egyéni `IHttpActionResult` osztály is található.</span><span class="sxs-lookup"><span data-stu-id="c0156-235">This example incorporates an additional custom `IHttpActionResult` class named `EmptyResultWithCaching`.</span></span> <span data-ttu-id="c0156-236">Ez az osztály egyszerű csomagolásként szolgál egy `HttpResponseMessage` objektum körül, amely nem tartalmaz választörzset:</span><span class="sxs-lookup"><span data-stu-id="c0156-236">This class simply acts as a wrapper around an `HttpResponseMessage` object that does not contain a response body:</span></span>

```csharp
public class EmptyResultWithCaching : IHttpActionResult
{
    public CacheControlHeaderValue CacheControlHeader { get; set; }
    public EntityTagHeaderValue ETag { get; set; }
    public HttpStatusCode StatusCode { get; set; }
    public Uri Location { get; set; }

    public async Task<HttpResponseMessage> ExecuteAsync(CancellationToken cancellationToken)
    {
        HttpResponseMessage response = new HttpResponseMessage(StatusCode);
        response.Headers.CacheControl = this.CacheControlHeader;
        response.Headers.ETag = this.ETag;
        response.Headers.Location = this.Location;
        return response;
    }
}
```

> [!TIP]
> <span data-ttu-id="c0156-237">Ebben a példában az adatok ETagje az alapul szolgáló adatforrásból lekért adatok kivonatolásával jön létre.</span><span class="sxs-lookup"><span data-stu-id="c0156-237">In this example, the ETag for the data is generated by hashing the data retrieved from the underlying data source.</span></span> <span data-ttu-id="c0156-238">Ha az ETag más módon is kiszámítható, akkor a folyamat tovább optimalizálható, és az adatokat csak akkor kell lekérni az adatforrásból, ha változtak.</span><span class="sxs-lookup"><span data-stu-id="c0156-238">If the ETag can be computed in some other way, then the process can be optimized further and the data only needs to be fetched from the data source if it has changed.</span></span> <span data-ttu-id="c0156-239">Ez a módszer különösen hasznos, ha az adatok mérete nagy, vagy az adatforrás elérése jelentős késést eredményezhet (például ha az adatforrás egy távoli adatbázis).</span><span class="sxs-lookup"><span data-stu-id="c0156-239">This approach is especially useful if the data is large or accessing the data source can result in significant latency (for example, if the data source is a remote database).</span></span>

### <a name="use-etags-to-support-optimistic-concurrency"></a><span data-ttu-id="c0156-240">Optimista párhuzamosság támogatása ETagek használatával</span><span class="sxs-lookup"><span data-stu-id="c0156-240">Use ETags to Support Optimistic Concurrency</span></span>

<span data-ttu-id="c0156-241">A korábban gyorsítótárazott adatok frissítésének engedélyezéséhez a HTTP-protokoll támogat egy optimista párhuzamossági stratégiát.</span><span class="sxs-lookup"><span data-stu-id="c0156-241">To enable updates over previously cached data, the HTTP protocol supports an optimistic concurrency strategy.</span></span> <span data-ttu-id="c0156-242">Ha egy erőforrás beolvasása és gyorsítótárazása után az ügyfélalkalmazás elküld egy PUT vagy DELETE kérést az erőforrás módosítása vagy eltávolítása céljából, akkor a kérésnek tartalmaznia kell az ETagre hivatkozó If-Match fejlécet.</span><span class="sxs-lookup"><span data-stu-id="c0156-242">If, after fetching and caching a resource, the client application subsequently sends a PUT or DELETE request to change or remove the resource, it should include in If-Match header that references the ETag.</span></span> <span data-ttu-id="c0156-243">A webes API ezen információk alapján határozza meg, hogy az erőforrást a lekérése óta módosította-e egy másik felhasználó, majd az alábbiak szerint visszaküldi a megfelelő választ az ügyfélalkalmazásnak:</span><span class="sxs-lookup"><span data-stu-id="c0156-243">The web API can then use this information to determine whether the resource has already been changed by another user since it was retrieved and send an appropriate response back to the client application as follows:</span></span>

- <span data-ttu-id="c0156-244">Az ügyfél létrehoz egy PUT kérelmet, amely tartalmazza az erőforrás új adatait és az erőforrás jelenleg gyorsítótárazott verziójának ETagjét, amelyre egy If-Match HTTP-fejléc hivatkozik.</span><span class="sxs-lookup"><span data-stu-id="c0156-244">The client constructs a PUT request containing the new details for the resource and the ETag for the currently cached version of the resource referenced in an If-Match HTTP header.</span></span> <span data-ttu-id="c0156-245">A következő példa egy rendelést frissítő PUT kérelmet mutat be:</span><span class="sxs-lookup"><span data-stu-id="c0156-245">The following example shows a PUT request that updates an order:</span></span>

    ```HTTP
    PUT https://adventure-works.com/orders/1 HTTP/1.1
    If-Match: "2282343857"
    Content-Type: application/x-www-form-urlencoded
    Content-Length: ...
    productID=3&quantity=5&orderValue=250
    ```

- <span data-ttu-id="c0156-246">A webes API PUT művelete lekéri a kért adatok jelenlegi ETag címkéjét (1. rendelés a fenti példában), és összehasonlítja az értéket az If-Match fejlécben találhatóval.</span><span class="sxs-lookup"><span data-stu-id="c0156-246">The PUT operation in the web API obtains the current ETag for the requested data (order 1 in the above example), and compares it to the value in the If-Match header.</span></span>

- <span data-ttu-id="c0156-247">Ha a kért adatok jelenlegi ETagje megegyezik a kérés által megadott ETaggel, akkor az erőforrás nem változott, és a webes API-nak el kell végeznie a frissítést, majd a sikeres frissítés után egy 204 (Nem módosított) HTTP-állapotkódú üzenetet kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="c0156-247">If the current ETag for the requested data matches the ETag provided by the request, the resource has not changed and the web API should perform the update, returning a message with HTTP status code 204 (No Content) if it is successful.</span></span> <span data-ttu-id="c0156-248">A válasz tartalmazhatja az erőforrás frissített verziójának Cache-Control és ETag fejléceit.</span><span class="sxs-lookup"><span data-stu-id="c0156-248">The response can include Cache-Control and ETag headers for the updated version of the resource.</span></span> <span data-ttu-id="c0156-249">A válasznak mindig tartalmaznia kell a Location fejlécet, amely az újonnan frissített erőforrás URI-jére hivatkozik.</span><span class="sxs-lookup"><span data-stu-id="c0156-249">The response should always include the Location header that references the URI of the newly updated resource.</span></span>

- <span data-ttu-id="c0156-250">Ha a kért adatok jelenlegi ETagje nem egyezik a kérés által megadott ETaggel, akkor a lekérés óta egy másik felhasználó módosította az adatokat, a webes API-nak pedig a HTTP-válaszban egy üres üzenettörzset és a 412 (Nem teljesül az előfeltétel) állapotkódot kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="c0156-250">If the current ETag for the requested data does not match the ETag provided by the request, then the data has been changed by another user since it was fetched and the web API should return an HTTP response with an empty message body and a status code of 412 (Precondition Failed).</span></span>

- <span data-ttu-id="c0156-251">Ha a frissítendő erőforrás már nem létezik, akkor a webes API-nak egy 404 (Nem található) állapotkódú HTTP-választ kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="c0156-251">If the resource to be updated no longer exists then the web API should return an HTTP response with the status code of 404 (Not Found).</span></span>

- <span data-ttu-id="c0156-252">Az ügyfél az állapotkóddal és a válaszfejlécekkel tartja karban a gyorsítótárat.</span><span class="sxs-lookup"><span data-stu-id="c0156-252">The client uses the status code and response headers to maintain the cache.</span></span> <span data-ttu-id="c0156-253">Ha az adatok frissültek (204-es állapotkód), akkor az objektum maradhat a gyorsítótárban (amennyiben a Cache-Control fejléc nem a no-store értéket tartalmazza), de az ETaget frissíteni kell.</span><span class="sxs-lookup"><span data-stu-id="c0156-253">If the data has been updated (status code 204) then the object can remain cached (as long as the Cache-Control header does not specify no-store) but the ETag should be updated.</span></span> <span data-ttu-id="c0156-254">Ha az adatokat egy másik felhasználó módosította (412-es állapotkód) vagy nem találhatók (404-es állapotkód), akkor a gyorsítótárazott objektumot el kell vetni.</span><span class="sxs-lookup"><span data-stu-id="c0156-254">If the data was changed by another user changed (status code 412) or not found (status code 404) then the cached object should be discarded.</span></span>

<span data-ttu-id="c0156-255">A következő példakód az Orders vezérlő PUT műveletének megvalósítását mutatja be:</span><span class="sxs-lookup"><span data-stu-id="c0156-255">The next code example shows an implementation of the PUT operation for the Orders controller:</span></span>

```csharp
public class OrdersController : ApiController
{
    [HttpPut]
    [Route("api/orders/{id:int}")]
    public IHttpActionResult UpdateExistingOrder(int id, DTOOrder order)
    {
        try
        {
            var baseUri = Constants.GetUriFromConfig();
            var orderToUpdate = this.ordersRepository.GetOrder(id);
            if (orderToUpdate == null)
            {
                return NotFound();
            }

            var hashedOrder = orderToUpdate.GetHashCode();
            string hashedOrderEtag = $"\"{hashedOrder}\"";

            // Retrieve the If-Match header from the request (if it exists)
            var matchEtags = Request.Headers.IfMatch;

            // If there is an Etag in the If-Match header and
            // this etag matches that of the order just retrieved,
            // or if there is no etag, then update the Order
            if (((matchEtags.Count > 0 &&
                String.CompareOrdinal(matchEtags.First().Tag, hashedOrderEtag) == 0)) ||
                matchEtags.Count == 0)
            {
                // Modify the order
                orderToUpdate.OrderValue = order.OrderValue;
                orderToUpdate.ProductID = order.ProductID;
                orderToUpdate.Quantity = order.Quantity;

                // Save the order back to the data store
                // ...

                // Create the No Content response with Cache-Control, ETag, and Location headers
                var cacheControlHeader = new CacheControlHeaderValue();
                cacheControlHeader.Private = true;
                cacheControlHeader.MaxAge = new TimeSpan(0, 10, 0);

                hashedOrder = order.GetHashCode();
                hashedOrderEtag = $"\"{hashedOrder}\"";
                var eTag = new EntityTagHeaderValue(hashedOrderEtag);

                var location = new Uri($"{baseUri}/{Constants.ORDERS}/{id}");
                var response = new EmptyResultWithCaching()
                {
                    StatusCode = HttpStatusCode.NoContent,
                    CacheControlHeader = cacheControlHeader,
                    ETag = eTag,
                    Location = location
                };

                return response;
            }

            // Otherwise return a Precondition Failed response
            return StatusCode(HttpStatusCode.PreconditionFailed);
        }
        catch
        {
            return InternalServerError();
        }
    }
    ...
}
```

> [!TIP]
> <span data-ttu-id="c0156-256">Az If-Match fejléc használata teljesen választható, és ha elhagyja, a webes API mindig megpróbálja frissíteni a megadott rendelést, akár vakon felülírva egy másik felhasználó által végrehajtott frissítést.</span><span class="sxs-lookup"><span data-stu-id="c0156-256">Use of the If-Match header is entirely optional, and if it is omitted the web API will always attempt to update the specified order, possibly blindly overwriting an update made by another user.</span></span> <span data-ttu-id="c0156-257">Az elveszett frissítések miatti problémák elkerüléséhez mindig adjon meg egy If-Match fejlécet.</span><span class="sxs-lookup"><span data-stu-id="c0156-257">To avoid problems due to lost updates, always provide an If-Match header.</span></span>

## <a name="handling-large-requests-and-responses"></a><span data-ttu-id="c0156-258">Nagyméretű kérelmek és válaszok kezelése</span><span class="sxs-lookup"><span data-stu-id="c0156-258">Handling large requests and responses</span></span>

<span data-ttu-id="c0156-259">Előfordulhat, hogy egy ügyfélalkalmazásnak olyan kérelmeket kell kiállítania vagy olyan adatokat kell fogadnia, amelyek mérete több MB (vagy még nagyobb).</span><span class="sxs-lookup"><span data-stu-id="c0156-259">There may be occasions when a client application needs to issue requests that send or receive data that may be several megabytes (or bigger) in size.</span></span> <span data-ttu-id="c0156-260">Ha az ügyfélalkalmazás ekkora mennyiségű adat átvitelére várakozik, előfordulhat, hogy nem válaszol.</span><span class="sxs-lookup"><span data-stu-id="c0156-260">Waiting while this amount of data is transmitted could cause the client application to become unresponsive.</span></span> <span data-ttu-id="c0156-261">Ha jelentős mennyiségű adatot tartalmazó kérelmeket kezel, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="c0156-261">Consider the following points when you need to handle requests that include significant amounts of data:</span></span>

### <a name="optimize-requests-and-responses-that-involve-large-objects"></a><span data-ttu-id="c0156-262">Nagyméretű objektumokat tartalmazó kérelmek és válaszok optimalizálása</span><span class="sxs-lookup"><span data-stu-id="c0156-262">Optimize requests and responses that involve large objects</span></span>

<span data-ttu-id="c0156-263">Bizonyos erőforrások nagyméretű objektumok lehetnek, vagy nagy mezőket, például képeket vagy más típusú bináris adatokat tartalmazhatnak.</span><span class="sxs-lookup"><span data-stu-id="c0156-263">Some resources may be large objects or include large fields, such as graphics images or other types of binary data.</span></span> <span data-ttu-id="c0156-264">A webes API-nak támogatnia kell a streamelést az ilyen erőforrások fel- és letöltésének optimalizálásához.</span><span class="sxs-lookup"><span data-stu-id="c0156-264">A web API should support streaming to enable optimized uploading and downloading of these resources.</span></span>

<span data-ttu-id="c0156-265">A HTTP-protokoll biztosítja a darabolásos átvitel kódolási mechanizmusát, amellyel a nagyméretű adatobjektumok visszastreamelhetők egy ügyfélhez.</span><span class="sxs-lookup"><span data-stu-id="c0156-265">The HTTP protocol provides the chunked transfer encoding mechanism to stream large data objects back to a client.</span></span> <span data-ttu-id="c0156-266">Amikor az ügyfél elküld egy nagy objektumra vonatkozó HTTP GET kérést, a webes API képes a választ darabonkénti *adattömbök* formájában visszaküldeni egy HTTP-kapcsolaton keresztül.</span><span class="sxs-lookup"><span data-stu-id="c0156-266">When the client sends an HTTP GET request for a large object, the web API can send the reply back in piecemeal *chunks* over an HTTP connection.</span></span> <span data-ttu-id="c0156-267">A válaszban található adatok hossza előfordulhat, hogy kezdetben ismeretlen lehet (Előfordulhat, hogy lehet létrehozott), így a webes API-t futtató kiszolgáló küldjön egy válaszüzenetet az egyes adattömbök, amely meghatározza a Transfer-Encoding: Darabolásos fejléc helyett egy Content-Length fejlécet.</span><span class="sxs-lookup"><span data-stu-id="c0156-267">The length of the data in the reply may not be known initially (it might be generated), so the server hosting the web API should send a response message with each chunk that specifies the Transfer-Encoding: Chunked header rather than a Content-Length header.</span></span> <span data-ttu-id="c0156-268">Az ügyfélalkalmazás egymás után kaphatja meg az egyes adattömböket, amelyekből felépíti a teljes választ.</span><span class="sxs-lookup"><span data-stu-id="c0156-268">The client application can receive each chunk in turn to build up the complete response.</span></span> <span data-ttu-id="c0156-269">Az adatok átvitele akkor ér véget, amikor a kiszolgáló visszaküld egy nulla méretű végső tömböt.</span><span class="sxs-lookup"><span data-stu-id="c0156-269">The data transfer completes when the server sends back a final chunk with zero size.</span></span>

<span data-ttu-id="c0156-270">Egyetlen kérelem is eredményezhet egy olyan nagyméretű objektumot, amely jelentős erőforrásokat használ fel.</span><span class="sxs-lookup"><span data-stu-id="c0156-270">A single request could conceivably result in a massive object that consumes considerable resources.</span></span> <span data-ttu-id="c0156-271">Ha a streamelési folyamat során a webes API azt állapítja meg, hogy egy kérelem adatmennyisége túllép valamilyen elfogadható korlátot, akkor megszakíthatja a műveletet, és visszaadhat egy válaszüzenetet a 413 (A kérelemegység túl nagy) állapotkóddal.</span><span class="sxs-lookup"><span data-stu-id="c0156-271">If, during the streaming process, the web API determines that the amount of data in a request has exceeded some acceptable bounds, it can abort the operation and return a response message with status code 413 (Request Entity Too Large).</span></span>

<span data-ttu-id="c0156-272">A hálózaton keresztül továbbított nagyméretű objektumok mérete HTTP-tömörítéssel minimalizálható.</span><span class="sxs-lookup"><span data-stu-id="c0156-272">You can minimize the size of large objects transmitted over the network by using HTTP compression.</span></span> <span data-ttu-id="c0156-273">Ez a módszer segít csökkenteni a hálózati forgalmat és a kapcsolódó hálózati késést, viszont az ügyfélnek és a webes API-t futtató kiszolgálónak egyaránt további feldolgozást kell végeznie.</span><span class="sxs-lookup"><span data-stu-id="c0156-273">This approach helps to reduce the amount of network traffic and the associated network latency, but at the cost of requiring additional processing at the client and the server hosting the web API.</span></span> <span data-ttu-id="c0156-274">Például egy tömörített adatok fogadását váró ügyfélalkalmazás belefoglalhat a kérésébe egy „Accept-Encoding: gzip” fejlécet (más adattömörítési algoritmusok is megadhatók).</span><span class="sxs-lookup"><span data-stu-id="c0156-274">For example, a client application that expects to receive compressed data can include an Accept-Encoding: gzip request header (other data compression algorithms can also be specified).</span></span> <span data-ttu-id="c0156-275">Ha a kiszolgáló támogatja a tömörítést, akkor a válaszban meg kell adnia a gzip formátumú tartalmat az üzenettörzsben, valamint az „Accept-Encoding: gzip” válaszfejlécet.</span><span class="sxs-lookup"><span data-stu-id="c0156-275">If the server supports compression it should respond with the content held in gzip format in the message body and the Content-Encoding: gzip response header.</span></span>

<span data-ttu-id="c0156-276">A tömörítés kombinálható a streameléssel: a streamelés előtt tömörítse az adatokat, és adja meg a gzip tartalomkódolást és a darabolt átviteli kódolást az üzenetfejlécekben.</span><span class="sxs-lookup"><span data-stu-id="c0156-276">You can combine encoded compression with streaming; compress the data first before streaming it, and specify the gzip content encoding and chunked transfer encoding in the message headers.</span></span> <span data-ttu-id="c0156-277">Vegye figyelembe, hogy egyes webkiszolgálók (például az Internet Information Server) beállíthatók úgy, hogy automatikusan tömörítsék a HTTP-válaszokat, függetlenül attól, hogy a webes API tömöríti-e az adatokat.</span><span class="sxs-lookup"><span data-stu-id="c0156-277">Also note that some web servers (such as Internet Information Server) can be configured to automatically compress HTTP responses regardless of whether the web API compresses the data or not.</span></span>

### <a name="implement-partial-responses-for-clients-that-do-not-support-asynchronous-operations"></a><span data-ttu-id="c0156-278">Részleges válaszok megvalósítása az aszinkron műveleteket nem támogató ügyfelek felé</span><span class="sxs-lookup"><span data-stu-id="c0156-278">Implement partial responses for clients that do not support asynchronous operations</span></span>

<span data-ttu-id="c0156-279">Az aszinkron streamelés alternatívájaként az ügyfélalkalmazás explicit módon megadhatja, hogy a nagy objektumok esetében tömbökben kéri az adatokat. Ezeket a tömböket részleges válaszoknak hívják.</span><span class="sxs-lookup"><span data-stu-id="c0156-279">As an alternative to asynchronous streaming, a client application can explicitly request data for large objects in chunks, known as partial responses.</span></span> <span data-ttu-id="c0156-280">Az ügyfélalkalmazás egy HTTP HEAD kérést küld az objektum adatainak lekéréséhez.</span><span class="sxs-lookup"><span data-stu-id="c0156-280">The client application sends an HTTP HEAD request to obtain information about the object.</span></span> <span data-ttu-id="c0156-281">Ha a webes API támogatja a részleges válaszokat, akkor a HEAD kérésre adott válaszüzenetének tartalmaznia kell egy Accept-Ranges fejlécet és egy Content-Length fejlécet, amely az objektum teljes méretét jelzi, de üzenet törzsének üresnek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="c0156-281">If the web API supports partial responses if should respond to the HEAD request with a response message that contains an Accept-Ranges header and a Content-Length header that indicates the total size of the object, but the body of the message should be empty.</span></span> <span data-ttu-id="c0156-282">Az ügyfélalkalmazás ezen információk alapján hoz létre több GET kérést, amelyekben megadja a fogadni kívánt bájttartományt.</span><span class="sxs-lookup"><span data-stu-id="c0156-282">The client application can use this information to construct a series of GET requests that specify a range of bytes to receive.</span></span> <span data-ttu-id="c0156-283">A webes API válaszüzenetének tartalmaznia kell a 206 (Részleges tartalom) HTTP-állapotkódot; egy Content-Length fejlécet, amely meghatározza, hogy a válaszüzenet törzsében mennyi adat található, valamint egy Content-Range fejlécet, amely jelzi, hogy az adatok az objektum mely részét képezik (például a 4000. bájttól a 8000. bájtig).</span><span class="sxs-lookup"><span data-stu-id="c0156-283">The web API should return a response message with HTTP status 206 (Partial Content), a Content-Length header that specifies the actual amount of data included in the body of the response message, and a Content-Range header that indicates which part (such as bytes 4000 to 8000) of the object this data represents.</span></span>

<span data-ttu-id="c0156-284">A HTTP HEAD-kérelmek és a részleges válaszok bővebb leírása: [API-tervezés][api-design].</span><span class="sxs-lookup"><span data-stu-id="c0156-284">HTTP HEAD requests and partial responses are described in more detail in [API Design][api-design].</span></span>

### <a name="avoid-sending-unnecessary-100-continue-status-messages-in-client-applications"></a><span data-ttu-id="c0156-285">Kerülje a szükségtelen 100-Continue állapotüzenetek küldését az ügyfélalkalmazásban</span><span class="sxs-lookup"><span data-stu-id="c0156-285">Avoid sending unnecessary 100-Continue status messages in client applications</span></span>

<span data-ttu-id="c0156-286">Ha egy ügyfélalkalmazás nagy mennyiségű adatot készül küldeni egy kiszolgálóra, akkor először megállapíthatja, hogy a kiszolgáló egyáltalán hajlandó-e fogadni a kérést.</span><span class="sxs-lookup"><span data-stu-id="c0156-286">A client application that is about to send a large amount of data to a server may determine first whether the server is actually willing to accept the request.</span></span> <span data-ttu-id="c0156-287">Az adatküldés előtt az ügyfélalkalmazás elküldhet egy várt a HTTP-kérelem: 100-fejléc, egy Content-Length fejlécet, amely azt jelzi, hogy az adatokat, de az üzenettörzse üres mérete továbbra is.</span><span class="sxs-lookup"><span data-stu-id="c0156-287">Prior to sending the data, the client application can submit an HTTP request with an Expect: 100-Continue header, a Content-Length header that indicates the size of the data, but an empty message body.</span></span> <span data-ttu-id="c0156-288">Ha a kiszolgáló hajlandó kezelni a kérést, akkor a válaszüzenetében a 100 (Folytatás) HTTP-állapotkódot kell megadnia.</span><span class="sxs-lookup"><span data-stu-id="c0156-288">If the server is willing to handle the request, it should respond with a message that specifies the HTTP status 100 (Continue).</span></span> <span data-ttu-id="c0156-289">Az ügyfélalkalmazás ezután elküldheti a teljes kérést, az üzenet törzsében megadott adatokkal.</span><span class="sxs-lookup"><span data-stu-id="c0156-289">The client application can then proceed and send the complete request including the data in the message body.</span></span>

<span data-ttu-id="c0156-290">Az IIS használatával üzemeltetett szolgáltatás, a HTTP.sys illesztő automatikusan észleli, és kezeli a várt: 100-továbbra is fejléceket, mielőtt továbbítaná a kéréseket a webalkalmazásnak.</span><span class="sxs-lookup"><span data-stu-id="c0156-290">If you are hosting a service by using IIS, the HTTP.sys driver automatically detects and handles Expect: 100-Continue headers before passing requests to your web application.</span></span> <span data-ttu-id="c0156-291">Ez azt jelenti, hogy az alkalmazás kódjában valószínűleg nem lesznek láthatók ezek a fejlécek, és feltételezhető, hogy az IIS már kiszűrte az olyan üzeneteket, amelyeket nem megfelelőnek vagy túl nagynak talált.</span><span class="sxs-lookup"><span data-stu-id="c0156-291">This means that you are unlikely to see these headers in your application code, and you can assume that IIS has already filtered any messages that it deems to be unfit or too large.</span></span>

<span data-ttu-id="c0156-292">A .NET-keretrendszer használatával hoz létre ügyfélalkalmazásokat, ha minden POST és PUT üzeneteket fogja először elküldheti az üzeneteket a várt: 100-továbbra is a fejlécek alapértelmezés szerint.</span><span class="sxs-lookup"><span data-stu-id="c0156-292">If you are building client applications by using the .NET Framework, then all POST and PUT messages will first send messages with Expect: 100-Continue headers by default.</span></span> <span data-ttu-id="c0156-293">A kiszolgálóoldalhoz hasonlóan a .NET-keretrendszer transzparens módon kezeli a folyamatot.</span><span class="sxs-lookup"><span data-stu-id="c0156-293">As with the server-side, the process is handled transparently by the .NET Framework.</span></span> <span data-ttu-id="c0156-294">Ez a folyamat azonban azzal jár, hogy minden POST és PUT kérés teljesítése két üzenetváltást igényel a kiszolgálóval, még a kis méretű kérések is.</span><span class="sxs-lookup"><span data-stu-id="c0156-294">However, this process results in each POST and PUT request causing two round-trips to the server, even for small requests.</span></span> <span data-ttu-id="c0156-295">Ha az alkalmazás nem küld nagy mennyiségű adatot tartalmazó kérelmeket, akkor letilthatja ezt a funkciót, ha a `ServicePointManager` osztállyal hoz létre `ServicePoint` objektumokat az ügyfélalkalmazásban.</span><span class="sxs-lookup"><span data-stu-id="c0156-295">If your application is not sending requests with large amounts of data, you can disable this feature by using the `ServicePointManager` class to create `ServicePoint` objects in the client application.</span></span> <span data-ttu-id="c0156-296">A `ServicePoint` objektum a kiszolgálón lévő erőforrásokat azonosító URI-k séma- és gazdagéptöredékei alapján kezeli az ügyfél által a kiszolgálóval létrehozott kapcsolatokat.</span><span class="sxs-lookup"><span data-stu-id="c0156-296">A `ServicePoint` object handles the connections that the client makes to a server based on the scheme and host fragments of URIs that identify resources on the server.</span></span> <span data-ttu-id="c0156-297">Ezután a `ServicePoint` objektum `Expect100Continue` tulajdonságát false (hamis) értékre állíthatja.</span><span class="sxs-lookup"><span data-stu-id="c0156-297">You can then set the `Expect100Continue` property of the `ServicePoint` object to false.</span></span> <span data-ttu-id="c0156-298">A séma- és gazdagéptöredékeivel megegyező URI-keresztül az ügyfél által végrehajtott minden későbbi POST és PUT kérés a `ServicePoint` objektumot várt nélkül lesz elküldve: 100-fejlécek továbbra is.</span><span class="sxs-lookup"><span data-stu-id="c0156-298">All subsequent POST and PUT requests made by the client through a URI that matches the scheme and host fragments of the `ServicePoint` object will be sent without Expect: 100-Continue headers.</span></span> <span data-ttu-id="c0156-299">A következő kód bemutatja, hogyan konfigurálható egy `ServicePoint` objektum, amely az URI-knek küldött összes kérést `http` sémával és `www.contoso.com` gazdagéppel konfigurálja.</span><span class="sxs-lookup"><span data-stu-id="c0156-299">The following code shows how to configure a `ServicePoint` object that configures all requests sent to URIs with a scheme of `http` and a host of `www.contoso.com`.</span></span>

```csharp
Uri uri = new Uri("https://www.contoso.com/");
ServicePoint sp = ServicePointManager.FindServicePoint(uri);
sp.Expect100Continue = false;
```

<span data-ttu-id="c0156-300">Is beállíthat a statikus `Expect100Continue` tulajdonságát a `ServicePointManager` osztály az alapértelmezett érték a tulajdonság adja meg minden ezután létrehozott [ServicePoint](/dotnet/api/system.net.servicepoint) objektumokat.</span><span class="sxs-lookup"><span data-stu-id="c0156-300">You can also set the static `Expect100Continue` property of the `ServicePointManager` class to specify the default value of this property for all subsequently created [ServicePoint](/dotnet/api/system.net.servicepoint) objects.</span></span>

### <a name="support-pagination-for-requests-that-may-return-large-numbers-of-objects"></a><span data-ttu-id="c0156-301">Tördelés támogatása olyan kéréseknél, amelyek esetlegesen nagy számú objektumot adhatnak vissza</span><span class="sxs-lookup"><span data-stu-id="c0156-301">Support pagination for requests that may return large numbers of objects</span></span>

<span data-ttu-id="c0156-302">Ha egy gyűjtemény sok erőforrást tartalmaz, egy GET kérés eljuttatása a megfelelő URI-hez jelentős mértékű feldolgozást igényelhet a webes API-t üzemeltető kiszolgálón, ami hatással lehet a teljesítményre és nagy mennyiségű hálózati forgalommal járhat, ez pedig a késések növekedéséhez vezet.</span><span class="sxs-lookup"><span data-stu-id="c0156-302">If a collection contains a large number of resources, issuing a GET request to the corresponding URI could result in significant processing on the server hosting the web API affecting performance, and generate a significant amount of network traffic resulting in increased latency.</span></span>

<span data-ttu-id="c0156-303">Az ilyen esetek kezeléséhez a webes API-nak támogatnia kell az olyan lekérdezési sztringekat, amelyek lehetővé teszik, hogy az ügyfélalkalmazás pontosítsa a kérelmeket, vagy könnyebben kezelhető, különálló blokkokra (vagy lapokra) tagolva kérje le az adatokat.</span><span class="sxs-lookup"><span data-stu-id="c0156-303">To handle these cases, the web API should support query strings that enable the client application to refine requests or fetch data in more manageable, discrete blocks (or pages).</span></span> <span data-ttu-id="c0156-304">Az alábbi kód az `Orders` vezérlő `GetAllOrders` metódusát mutatja be.</span><span class="sxs-lookup"><span data-stu-id="c0156-304">The code below shows the `GetAllOrders` method in the `Orders` controller.</span></span> <span data-ttu-id="c0156-305">Ez a metódus a rendelések részleteit kéri le.</span><span class="sxs-lookup"><span data-stu-id="c0156-305">This method retrieves the details of orders.</span></span> <span data-ttu-id="c0156-306">Ha a metódus korlátozás nélküli lenne, előfordulhat, hogy nagy mennyiségű adatot adna vissza.</span><span class="sxs-lookup"><span data-stu-id="c0156-306">If this method was unconstrained, it could conceivably return a large amount of data.</span></span> <span data-ttu-id="c0156-307">A `limit` és az `offset` paraméter célja, hogy az adatok mennyiségét egy kisebb részhalmazra csökkentse, ebben az esetben alapértelmezés szerint csak az első 10 rendelésre:</span><span class="sxs-lookup"><span data-stu-id="c0156-307">The `limit` and `offset` parameters are intended to reduce the volume of data to a smaller subset, in this case only the first 10 orders by default:</span></span>

```csharp
public class OrdersController : ApiController
{
    ...
    [Route("api/orders")]
    [HttpGet]
    public IEnumerable<Order> GetAllOrders(int limit=10, int offset=0)
    {
        // Find the number of orders specified by the limit parameter
        // starting with the order specified by the offset parameter
        var orders = ...
        return orders;
    }
    ...
}
```

<span data-ttu-id="c0156-308">Egy ügyfélalkalmazás kiadhat olyan kérelmet, amely 30 rendelést kér le 50-es eltolástól kezdve a `https://www.adventure-works.com/api/orders?limit=30&offset=50` URI használatával.</span><span class="sxs-lookup"><span data-stu-id="c0156-308">A client application can issue a request to retrieve 30 orders starting at offset 50 by using the URI `https://www.adventure-works.com/api/orders?limit=30&offset=50`.</span></span>

> [!TIP]
> <span data-ttu-id="c0156-309">Ne engedélyezze az ügyfélalkalmazásoknak olyan lekérdezési sztringek megadását, amelyek 2000 karakternél hosszabb URI-t eredményeznek.</span><span class="sxs-lookup"><span data-stu-id="c0156-309">Avoid enabling client applications to specify query strings that result in a URI that is more than 2000 characters long.</span></span> <span data-ttu-id="c0156-310">Számos webes ügyfél és kiszolgáló nem tudja kezelni az ilyen hosszú URI-kat.</span><span class="sxs-lookup"><span data-stu-id="c0156-310">Many web clients and servers cannot handle URIs that are this long.</span></span>

## <a name="maintaining-responsiveness-scalability-and-availability"></a><span data-ttu-id="c0156-311">A válaszképesség, a skálázhatóság és a rendelkezésre állás fenntartása</span><span class="sxs-lookup"><span data-stu-id="c0156-311">Maintaining responsiveness, scalability, and availability</span></span>

<span data-ttu-id="c0156-312">Egy webes API számos ügyfélalkalmazás bárhol a világon használhatják.</span><span class="sxs-lookup"><span data-stu-id="c0156-312">The same web API might be used by many client applications running anywhere in the world.</span></span> <span data-ttu-id="c0156-313">Fontos, hogy a webes API úgy legyen megvalósítva, hogy válaszképes legyen nagy mértékű terhelés alatt is, hogy skálázható legyen a nagymértékben ingadozó számítási feladatok kezeléséhez, és hogy garantáltan rendelkezésre álljon az üzleti szempontból kulcsfontosságú műveleteket végző ügyfelek számára.</span><span class="sxs-lookup"><span data-stu-id="c0156-313">It is important to ensure that the web API is implemented to maintain responsiveness under a heavy load, to be scalable to support a highly varying workload, and to guarantee availability for clients that perform business-critical operations.</span></span> <span data-ttu-id="c0156-314">Mindezen követelmények teljesítése érdekében vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="c0156-314">Consider the following points when determining how to meet these requirements:</span></span>

### <a name="provide-asynchronous-support-for-long-running-requests"></a><span data-ttu-id="c0156-315">A hosszan futó kérelmek aszinkron támogatásának biztosítása</span><span class="sxs-lookup"><span data-stu-id="c0156-315">Provide asynchronous support for long-running requests</span></span>

<span data-ttu-id="c0156-316">Az olyan kérelmeket, amelyek feldolgozása hosszú időbe telhet, a kérelmet küldő ügyfél blokkolása nélkül kell feldolgozni.</span><span class="sxs-lookup"><span data-stu-id="c0156-316">A request that might take a long time to process should be performed without blocking the client that submitted the request.</span></span> <span data-ttu-id="c0156-317">A webes API elvégezhet néhány kezdeti ellenőrzést a kérelem érvényesítéséhez, elindíthat egy külön feladatot a munka elvégzéséhez, majd visszaadhat egy 202 (Elfogadva) HTTP-kódú válaszüzenetet.</span><span class="sxs-lookup"><span data-stu-id="c0156-317">The web API can perform some initial checking to validate the request, initiate a separate task to perform the work, and then return a response message with HTTP code 202 (Accepted).</span></span> <span data-ttu-id="c0156-318">A feladat futhat aszinkron módon a webes API feldolgozófolyamatának részeként, vagy kiszervezhető egy háttérfeladatba.</span><span class="sxs-lookup"><span data-stu-id="c0156-318">The task could run asynchronously as part of the web API processing, or it could be offloaded to a background task.</span></span>

<span data-ttu-id="c0156-319">A webes API-nak emellett biztosítania kell egy mechanizmust, amely visszaadja a feldolgozás eredményét az ügyfélalkalmazásnak.</span><span class="sxs-lookup"><span data-stu-id="c0156-319">The web API should also provide a mechanism to return the results of the processing to the client application.</span></span> <span data-ttu-id="c0156-320">Ennek érdekében megadhat az ügyfélalkalmazásoknak egy lekérdezési mechanizmust, amellyel időnként lekérdezhetik, hogy a feldolgozás befejeződött-e, és lekérhetik az eredményt, vagy engedélyezhetjük, hogy a webes API egy értesítést küldjön a művelet befejezése után.</span><span class="sxs-lookup"><span data-stu-id="c0156-320">You can achieve this by providing a polling mechanism for client applications to periodically query whether the processing has finished and obtain the result, or enabling the web API to send a notification when the operation has completed.</span></span>

<span data-ttu-id="c0156-321">Egyszerűen megvalósíthat egy lekérdezési mechanizmust, ha a következőképpen megad egy virtuális erőforrásként szolgáló *lekérdezési* URI-t:</span><span class="sxs-lookup"><span data-stu-id="c0156-321">You can implement a simple polling mechanism by providing a *polling* URI that acts as a virtual resource using the following approach:</span></span>

1. <span data-ttu-id="c0156-322">Az ügyfélalkalmazás elküldi a kezdeti kérelmet a webes API-nak.</span><span class="sxs-lookup"><span data-stu-id="c0156-322">The client application sends the initial request to the web API.</span></span>
2. <span data-ttu-id="c0156-323">A webes API tárolja a kérelemmel kapcsolatos információkat egy táblatárolóban vagy a Microsoft Azure Cache-ben tárolt táblában, és létrehoz egy egyedi kulcsot a bejegyzéshez, valószínűleg egy GUID formájában.</span><span class="sxs-lookup"><span data-stu-id="c0156-323">The web API stores information about the request in a table held in table storage or Microsoft Azure Cache, and generates a unique key for this entry, possibly in the form of a GUID.</span></span>
3. <span data-ttu-id="c0156-324">A webes API elindítja a feldolgozást egy külön feladatként.</span><span class="sxs-lookup"><span data-stu-id="c0156-324">The web API initiates the processing as a separate task.</span></span> <span data-ttu-id="c0156-325">A webes API a táblában a feladat állapotát *Fut* értékre állítja.</span><span class="sxs-lookup"><span data-stu-id="c0156-325">The web API records the state of the task in the table as *Running*.</span></span>
4. <span data-ttu-id="c0156-326">A webes API visszaad egy válaszüzenetet a 202 (Elfogadva) HTTP-állapotkóddal és az üzenet törzsében a táblabejegyzés GUID-azonosítójával.</span><span class="sxs-lookup"><span data-stu-id="c0156-326">The web API returns a response message with HTTP status code 202 (Accepted), and the GUID of the table entry in the body of the message.</span></span>
5. <span data-ttu-id="c0156-327">A feladat befejezése után a webes API tárolja az eredményeket a táblában, és a feladat állapotát *Befejezve* értékre állítja.</span><span class="sxs-lookup"><span data-stu-id="c0156-327">When the task has completed, the web API stores the results in the table, and sets the state of the task to *Complete*.</span></span> <span data-ttu-id="c0156-328">Vegye figyelembe, hogy ha a feladat meghiúsul, a webes API a sikertelenségről is tárolhat információkat, az állapotot pedig *Sikertelen* értékre állíthatja.</span><span class="sxs-lookup"><span data-stu-id="c0156-328">Note that if the task fails, the web API could also store information about the failure and set the status to *Failed*.</span></span>
6. <span data-ttu-id="c0156-329">A feladat futása közben az ügyfél továbbra is végezhet saját feldolgozást.</span><span class="sxs-lookup"><span data-stu-id="c0156-329">While the task is running, the client can continue performing its own processing.</span></span> <span data-ttu-id="c0156-330">Eközben időközönként elküldhet egy kérelmet a */polling/{guid}* URI-nek, ahol a *{guid}* az a globálisan egyedi azonosító, amelyet a webes API a 202-es válaszüzenetben visszaadott.</span><span class="sxs-lookup"><span data-stu-id="c0156-330">It can periodically send a request to the URI */polling/{guid}* where *{guid}* is the GUID returned in the 202 response message by the web API.</span></span>
7. <span data-ttu-id="c0156-331">A */polling/{guid}* URI-hez tartozó webes API lekérdezi a vonatkozó feladat állapotát a táblából, és visszaad egy válaszüzenetet a 200 (OK) HTTP-állapotkóddal és az állapottal (*Fut*, *Befejezve* vagy *Sikertelen*).</span><span class="sxs-lookup"><span data-stu-id="c0156-331">The web API at the */polling/{guid}* URI queries the state of the corresponding task in the table and returns a response message with HTTP status code 200 (OK) containing this state (*Running*, *Complete*, or *Failed*).</span></span> <span data-ttu-id="c0156-332">Ha a feladat befejeződött vagy meghiúsult, a válaszüzenet tartalmazhatja a feldolgozás eredményét vagy a sikertelenség okával kapcsolatban elérhető információkat is.</span><span class="sxs-lookup"><span data-stu-id="c0156-332">If the task has completed or failed, the response message can also include the results of the processing or any information available about the reason for the failure.</span></span>

<span data-ttu-id="c0156-333">Az értesítések megvalósításának lehetőségei a következők:</span><span class="sxs-lookup"><span data-stu-id="c0156-333">Options for implementing notifications include:</span></span>

- <span data-ttu-id="c0156-334">Aszinkron válaszok leküldése az ügyfélalkalmazásoknak az Azure Notification Hub használatával.</span><span class="sxs-lookup"><span data-stu-id="c0156-334">Using an Azure Notification Hub to push asynchronous responses to client applications.</span></span> <span data-ttu-id="c0156-335">További információ: [Azure Notification Hubs – felhasználók értesítése](/azure/notification-hubs/notification-hubs-aspnet-backend-windows-dotnet-wns-notification/).</span><span class="sxs-lookup"><span data-stu-id="c0156-335">For more information, see [Azure Notification Hubs Notify Users](/azure/notification-hubs/notification-hubs-aspnet-backend-windows-dotnet-wns-notification/).</span></span>
- <span data-ttu-id="c0156-336">A Comet modell használata egy állandó hálózati kapcsolat fenntartásához az ügyfél és a webes API-t üzemeltető kiszolgáló között, és a kapcsolat használata a kiszolgálóról az ügyfélhez visszaküldött üzenetek leküldéséhez.</span><span class="sxs-lookup"><span data-stu-id="c0156-336">Using the Comet model to retain a persistent network connection between the client and the server hosting the web API, and using this connection to push messages from the server back to the client.</span></span> <span data-ttu-id="c0156-337">Ehhez az MSDN magazin [Egyszerű Comet-alkalmazás Microsoft .NET-keretrendszerben való létrehozását](https://msdn.microsoft.com/magazine/jj891053.aspx) ismertető cikkében talál egy példát.</span><span class="sxs-lookup"><span data-stu-id="c0156-337">The MSDN magazine article [Building a Simple Comet Application in the Microsoft .NET Framework](https://msdn.microsoft.com/magazine/jj891053.aspx) describes an example solution.</span></span>
- <span data-ttu-id="c0156-338">Adatok valós idejű leküldése a kiszolgálóról az ügyfél felé állandó kapcsolaton keresztül a SignalR használatával.</span><span class="sxs-lookup"><span data-stu-id="c0156-338">Using SignalR to push data in real-time from the web server to the client over a persistent network connection.</span></span> <span data-ttu-id="c0156-339">A SignalR az ASP.NET-webalkalmazásokhoz NuGet-csomagként érhető el.</span><span class="sxs-lookup"><span data-stu-id="c0156-339">SignalR is available for ASP.NET web applications as a NuGet package.</span></span> <span data-ttu-id="c0156-340">További információt az [ASP.NET SignalR](https://www.asp.net/signalr) webhelyen talál.</span><span class="sxs-lookup"><span data-stu-id="c0156-340">You can find more information on the [ASP.NET SignalR](https://www.asp.net/signalr) website.</span></span>

### <a name="ensure-that-each-request-is-stateless"></a><span data-ttu-id="c0156-341">Az egyes kérelmek állapotnélküliségének biztosítása</span><span class="sxs-lookup"><span data-stu-id="c0156-341">Ensure that each request is stateless</span></span>

<span data-ttu-id="c0156-342">Minden egyes kérelmet atominak kell tekinteni.</span><span class="sxs-lookup"><span data-stu-id="c0156-342">Each request should be considered atomic.</span></span> <span data-ttu-id="c0156-343">Egy ügyfélalkalmazás különböző időpontokban elküldött kérelmei között nem állhatnak fenn függőségek.</span><span class="sxs-lookup"><span data-stu-id="c0156-343">There should be no dependencies between one request made by a client application and any subsequent requests submitted by the same client.</span></span> <span data-ttu-id="c0156-344">Ez a módszer segíti a méretezhetőséget, és a webszolgáltatás példányai több kiszolgálóra is telepíthetők.</span><span class="sxs-lookup"><span data-stu-id="c0156-344">This approach assists in scalability; instances of the web service can be deployed on a number of servers.</span></span> <span data-ttu-id="c0156-345">Az ügyfélkérések bármelyik példányhoz irányíthatók, és az eredmények mindig azonosak.</span><span class="sxs-lookup"><span data-stu-id="c0156-345">Client requests can be directed at any of these instances and the results should always be the same.</span></span> <span data-ttu-id="c0156-346">A megoldás hasonlóképpen javítja a rendelkezésre állást is: ha egy webkiszolgáló meghibásodik, a kérések átirányíthatók egy másik példányhoz az Azure Traffic Managerrel, amíg a kiszolgáló újraindul, és mindez semmilyen negatív hatással nincs az ügyfélalkalmazásra.</span><span class="sxs-lookup"><span data-stu-id="c0156-346">It also improves availability for a similar reason; if a web server fails requests can be routed to another instance (by using Azure Traffic Manager) while the server is restarted with no ill effects on client applications.</span></span>

### <a name="track-clients-and-implement-throttling-to-reduce-the-chances-of-dos-attacks"></a><span data-ttu-id="c0156-347">Ügyfelek nyomon követése és szabályozás alkalmazása a szolgáltatásmegtagadási támadások esélyének csökkentése érdekében</span><span class="sxs-lookup"><span data-stu-id="c0156-347">Track clients and implement throttling to reduce the chances of DOS attacks</span></span>

<span data-ttu-id="c0156-348">Ha egy adott ügyfél nagy számú kérést küld egy adott időn belül, előfordulhat, hogy kisajátítja a szolgáltatást, és befolyásolja a további ügyfelek teljesítményét.</span><span class="sxs-lookup"><span data-stu-id="c0156-348">If a specific client makes a large number of requests within a given period of time it might monopolize the service and affect the performance of other clients.</span></span> <span data-ttu-id="c0156-349">Ennek elkerülése érdekében a webes API monitorozhatja az ügyfélalkalmazások hívásait. Ez az összes bejövő kérelem IP-címének rögzítésével vagy az összes hitelesített hozzáférés naplózásával is történhet.</span><span class="sxs-lookup"><span data-stu-id="c0156-349">To mitigate this issue, a web API can monitor calls from client applications either by tracking the IP address of all incoming requests or by logging each authenticated access.</span></span> <span data-ttu-id="c0156-350">Ezen adatok alapján korlátozható az erőforrásokhoz való hozzáférés.</span><span class="sxs-lookup"><span data-stu-id="c0156-350">You can use this information to limit resource access.</span></span> <span data-ttu-id="c0156-351">Ha egy ügyfél túllép egy adott korlátozását, a webes API visszaadhat egy válaszüzenetet az 503 (A szolgáltatás nem érhető el) állapotkóddal és egy Retry-After fejléccel, amelyben megadja, hogy az ügyfél mikor küldheti el a következő kérelmet anélkül, hogy a rendszer elutasítaná.</span><span class="sxs-lookup"><span data-stu-id="c0156-351">If a client exceeds a defined limit, the web API can return a response message with status 503 (Service Unavailable) and include a Retry-After header that specifies when the client can send the next request without it being declined.</span></span> <span data-ttu-id="c0156-352">Ez a stratégia segíthet megakadályozni, hogy bizonyos ügyfelek szolgáltatásmegtagadásos (DOS) támadásokkal akadályozzák a rendszer működését.</span><span class="sxs-lookup"><span data-stu-id="c0156-352">This strategy can help to reduce the chances of a Denial Of Service (DOS) attack from a set of clients stalling the system.</span></span>

### <a name="manage-persistent-http-connections-carefully"></a><span data-ttu-id="c0156-353">Állandó HTTP-kapcsolatok gondos kezelése</span><span class="sxs-lookup"><span data-stu-id="c0156-353">Manage persistent HTTP connections carefully</span></span>

<span data-ttu-id="c0156-354">A HTTP-protokoll támogatja az állandó HTTP-kapcsolatokat, ahol elérhetők.</span><span class="sxs-lookup"><span data-stu-id="c0156-354">The HTTP protocol supports persistent HTTP connections where they are available.</span></span> <span data-ttu-id="c0156-355">A HTTP 1.0 specifikáció bevezette a „Connection:Keep-Alive” fejlécet, amellyel az ügyfélalkalmazások jelezhetik a kiszolgálónak, hogy a későbbi kérelmeket ugyanazon a kapcsolaton keresztül is el tudják küldeni új kapcsolatok megnyitása helyett.</span><span class="sxs-lookup"><span data-stu-id="c0156-355">The HTTP 1.0 specificiation added the Connection:Keep-Alive header that enables a client application to indicate to the server that it can use the same connection to send subsequent requests rather than opening new ones.</span></span> <span data-ttu-id="c0156-356">A kapcsolat automatikusan lezárul, ha az ügyfél nem használja újra egy bizonyos időtartamon belül, amelyet a gazdagép határoz meg.</span><span class="sxs-lookup"><span data-stu-id="c0156-356">The connection closes automatically if the client does not reuse the connection within a period defined by the host.</span></span> <span data-ttu-id="c0156-357">Ez az Azure-szolgáltatások által használt HTTP 1.1 alapértelmezett viselkedése, így az üzenetekbe nem szükséges Keep-Alive fejléceket belefoglalni.</span><span class="sxs-lookup"><span data-stu-id="c0156-357">This behavior is the default in HTTP 1.1 as used by Azure services, so there is no need to include Keep-Alive headers in messages.</span></span>

<span data-ttu-id="c0156-358">A kapcsolat nyitva tartása segíthet növelni a válaszkészséget a késés és a hálózati torlódás csökkentésével, de gyengítheti a skálázhatóságot, mivel a szükségtelen kapcsolatok felesleges nyitva tartása korlátozza a további ügyfelek csatlakozási lehetőségeit.</span><span class="sxs-lookup"><span data-stu-id="c0156-358">Keeping a connection open can help to improve responsiveness by reducing latency and network congestion, but it can be detrimental to scalability by keeping unnecessary connections open for longer than required, limiting the ability of other concurrent clients to connect.</span></span> <span data-ttu-id="c0156-359">Emellett ha az ügyfélalkalmazás mobileszközön fut, csökkentheti az eszköz akkumulátor-élettartamát is: ha az alkalmazás csak alkalmanként kérelmeket küld a kiszolgáló felé, a kapcsolat nyitva tartása gyorsabban lemerítheti az akkumulátort.</span><span class="sxs-lookup"><span data-stu-id="c0156-359">It can also affect battery life if the client application is running on a mobile device; if the application only makes occasional requests to the server, maintaining an open connection can cause the battery to drain more quickly.</span></span> <span data-ttu-id="c0156-360">Annak biztosításához, hogy a HTTP 1.1 ne tegyen állandóvá egy kapcsolatot, az ügyfél egy Connection:Close fejléc használatával felülírhatja az alapértelmezett viselkedést.</span><span class="sxs-lookup"><span data-stu-id="c0156-360">To ensure that a connection is not made persistent with HTTP 1.1, the client can include a Connection:Close header with messages to override the default behavior.</span></span> <span data-ttu-id="c0156-361">Ha egy kiszolgáló rendkívül nagy mennyiségű ügyfelet kezel, akkor a válaszaiban a Connection:Close fejléc használatával hasonló módon lezárhatja a kapcsolatokat, így kiszolgáló-erőforrásokat takaríthat meg.</span><span class="sxs-lookup"><span data-stu-id="c0156-361">Similarly, if a server is handling a very large number of clients it can include a Connection:Close header in response messages which should close the connection and save server resources.</span></span>

> [!NOTE]
> <span data-ttu-id="c0156-362">Az állandó HTTP-kapcsolatok funkciója teljes mértékben választható, és arra szolgál, hogy csökkentse a kommunikációs csatornák ismétlődő létrehozásával járó hálózati terhelést.</span><span class="sxs-lookup"><span data-stu-id="c0156-362">Persistent HTTP connections are a purely optional feature to reduce the network overhead associated with repeatedly establishing a communications channel.</span></span> <span data-ttu-id="c0156-363">Sem a webes API, sem az ügyfélalkalmazás nem függhet egy állandó HTTP-kapcsolat elérhetőségétől.</span><span class="sxs-lookup"><span data-stu-id="c0156-363">Neither the web API nor the client application should depend on a persistent HTTP connection being available.</span></span> <span data-ttu-id="c0156-364">Ne használjon állandó HTTP-kapcsolatokat a Comet stílusú értesítési rendszerek megvalósításához. Ehelyett használjon szoftvercsatornákat (vagy webes szoftvercsatornákat, ha elérhetők) a TCP-rétegben.</span><span class="sxs-lookup"><span data-stu-id="c0156-364">Do not use persistent HTTP connections to implement Comet-style notification systems; instead you should utilize sockets (or websockets if available) at the TCP layer.</span></span> <span data-ttu-id="c0156-365">Végül vegye figyelembe, hogy a Keep-Alive fejlécek csak korlátozottan használhatók, ha az ügyfélalkalmazás egy proxyn keresztül kommunikál a kiszolgálóval: ez esetben csak az ügyfél és a proxy kapcsolata lesz állandó.</span><span class="sxs-lookup"><span data-stu-id="c0156-365">Finally, note Keep-Alive headers are of limited use if a client application communicates with a server via a proxy; only the connection with the client and the proxy will be persistent.</span></span>

## <a name="publishing-and-managing-a-web-api"></a><span data-ttu-id="c0156-366">Webes API-k közzététele és kezelése</span><span class="sxs-lookup"><span data-stu-id="c0156-366">Publishing and managing a web API</span></span>

<span data-ttu-id="c0156-367">Ahhoz, hogy egy webes API elérhető legyen az ügyfélalkalmazások számára, a webes API-t telepíteni kell egy gazdakörnyezetben.</span><span class="sxs-lookup"><span data-stu-id="c0156-367">To make a web API available for client applications, the web API must be deployed to a host environment.</span></span> <span data-ttu-id="c0156-368">Ez a környezet általában egy webkiszolgáló, bár valamilyen más típusú gazdafolyamat is lehet.</span><span class="sxs-lookup"><span data-stu-id="c0156-368">This environment is typically a web server, although it may be some other type of host process.</span></span> <span data-ttu-id="c0156-369">A webes API-k közzétételekor vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="c0156-369">You should consider the following points when publishing a web API:</span></span>

- <span data-ttu-id="c0156-370">Minden kérelmet hitelesíteni és engedélyezni kell, és be kell tartatni a megfelelő szintű hozzáférés-vezérlést.</span><span class="sxs-lookup"><span data-stu-id="c0156-370">All requests must be authenticated and authorized, and the appropriate level of access control must be enforced.</span></span>
- <span data-ttu-id="c0156-371">A kereskedelmi webes API-k válaszidejére különböző minőségi garanciák vonatkozhatnak.</span><span class="sxs-lookup"><span data-stu-id="c0156-371">A commercial web API might be subject to various quality guarantees concerning response times.</span></span> <span data-ttu-id="c0156-372">Fontos, hogy a gazdakörnyezet skálázható legyen, ha a terhelés idővel nagymértékben változhat.</span><span class="sxs-lookup"><span data-stu-id="c0156-372">It is important to ensure that host environment is scalable if the load can vary significantly over time.</span></span>
- <span data-ttu-id="c0156-373">Szükség lehet a kérelmek mérésére pénzügyi okokból.</span><span class="sxs-lookup"><span data-stu-id="c0156-373">It may be necessary to meter requests for monetization purposes.</span></span>
- <span data-ttu-id="c0156-374">Lehetséges, hogy a webes API felé irányuló forgalmat korlátozni kell, valamint a kvótájukat felhasználó adott ügyfelekre vonatkozó szabályozást kell bevezetni.</span><span class="sxs-lookup"><span data-stu-id="c0156-374">It might be necessary to regulate the flow of traffic to the web API, and implement throttling for specific clients that have exhausted their quotas.</span></span>
- <span data-ttu-id="c0156-375">A szabályozási követelmények előírhatják az összes kérelem és válasz naplózását.</span><span class="sxs-lookup"><span data-stu-id="c0156-375">Regulatory requirements might mandate logging and auditing of all requests and responses.</span></span>
- <span data-ttu-id="c0156-376">A rendelkezésre állás biztosítása érdekében szükség lehet a webes API-t futtató kiszolgáló állapotának monitorozására, és adott esetben újraindítására.</span><span class="sxs-lookup"><span data-stu-id="c0156-376">To ensure availability, it may be necessary to monitor the health of the server hosting the web API and restart it if necessary.</span></span>

<span data-ttu-id="c0156-377">Ezeket a problémákat célszerű elkülöníteni a műszaki kérdésektől a webes API-k megvalósításakor.</span><span class="sxs-lookup"><span data-stu-id="c0156-377">It is useful to be able to decouple these issues from the technical issues concerning the implementation of the web API.</span></span> <span data-ttu-id="c0156-378">Emiatt érdemes lehet létrehozni egy [előtérrendszert](https://en.wikipedia.org/wiki/Facade_pattern), amely külön folyamatként fut, és a webes API-hoz irányítja a kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="c0156-378">For this reason, consider creating a [façade](https://en.wikipedia.org/wiki/Facade_pattern), running as a separate process and that routes requests to the web API.</span></span> <span data-ttu-id="c0156-379">Az előtérrendszer felügyeleti műveleteket biztosíthat, és továbbíthatja az érvényesített kéréseket a webes API felé.</span><span class="sxs-lookup"><span data-stu-id="c0156-379">The façade can provide the management operations and forward validated requests to the web API.</span></span> <span data-ttu-id="c0156-380">Az előtérrendszer használata számos funkcionális előnnyel is jár, többek között:</span><span class="sxs-lookup"><span data-stu-id="c0156-380">Using a façade can also bring many functional advantages, including:</span></span>

- <span data-ttu-id="c0156-381">Több webes API integrációs pontjaként szolgál.</span><span class="sxs-lookup"><span data-stu-id="c0156-381">Acting as an integration point for multiple web APIs.</span></span>
- <span data-ttu-id="c0156-382">különböző technológiák használatával átalakítja az üzeneteket és lefordítja a kommunikációs protokollokat az ügyfelek számára.</span><span class="sxs-lookup"><span data-stu-id="c0156-382">Transforming messages and translating communications protocols for clients built by using varying technologies.</span></span>
- <span data-ttu-id="c0156-383">Gyorsítótárazza a kérelmeket és válaszokat a webes API-t futtató kiszolgáló terhelésének csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="c0156-383">Caching requests and responses to reduce load on the server hosting the web API.</span></span>

## <a name="testing-a-web-api"></a><span data-ttu-id="c0156-384">Webes API tesztelése</span><span class="sxs-lookup"><span data-stu-id="c0156-384">Testing a web API</span></span>

<span data-ttu-id="c0156-385">A webes API-kat ugyanolyan alaposan kell tesztelni, mint minden más szoftvert.</span><span class="sxs-lookup"><span data-stu-id="c0156-385">A web API should be tested as thoroughly as any other piece of software.</span></span> <span data-ttu-id="c0156-386">Érdemes egységteszteket működésének létrehozása.</span><span class="sxs-lookup"><span data-stu-id="c0156-386">You should consider creating unit tests to validate the functionality.</span></span>

<span data-ttu-id="c0156-387">A webes API-k jellegét elérhetővé teszi a saját további követelmények alapján, hogy megfelelően működik-e.</span><span class="sxs-lookup"><span data-stu-id="c0156-387">The nature of a web API brings its own additional requirements to verify that it operates correctly.</span></span> <span data-ttu-id="c0156-388">Fordítson különös figyelmet a következőkre:</span><span class="sxs-lookup"><span data-stu-id="c0156-388">You should pay particular attention to the following aspects:</span></span>

- <span data-ttu-id="c0156-389">Ellenőrizze az összes útvonalat, hogy a megfelelő műveleteket hívják-e meg.</span><span class="sxs-lookup"><span data-stu-id="c0156-389">Test all routes to verify that they invoke the correct operations.</span></span> <span data-ttu-id="c0156-390">Különösen figyeljen a váratlanul visszaadott 405 (Nem engedélyezett metódus) HTTP-állapotkódra, mivel ez azt jelezheti, hogy egy útvonal és a rajta keresztül elküldhető HTTP-metódusok (GET, POST, PUT, DELETE) nem egyeznek.</span><span class="sxs-lookup"><span data-stu-id="c0156-390">Be especially aware of HTTP status code 405 (Method Not Allowed) being returned unexpectedly as this can indicate a mismatch between a route and the HTTP methods (GET, POST, PUT, DELETE) that can be dispatched to that route.</span></span>

    <span data-ttu-id="c0156-391">Küldjön HTTP-kérelmeket olyan útvonalakra, amelyeket nem támogatják őket, például egy POST kérelmet egy adott erőforrásra (a POST kérelmeket csak erőforrás-gyűjteményekre lehet küldeni).</span><span class="sxs-lookup"><span data-stu-id="c0156-391">Send HTTP requests to routes that do not support them, such as submitting a POST request to a specific resource (POST requests should only be sent to resource collections).</span></span> <span data-ttu-id="c0156-392">Ezekben az esetekben az *egyetlen* érvényes válasz a 405 (Nem engedélyezett) állapotkód lehet.</span><span class="sxs-lookup"><span data-stu-id="c0156-392">In these cases, the only valid response *should* be status code 405 (Not Allowed).</span></span>

- <span data-ttu-id="c0156-393">Ellenőrizze, hogy az összes útvonal megfelelően védett-e, és megtörténnek-e a megfelelő hitelesítési és engedélyezési ellenőrzések.</span><span class="sxs-lookup"><span data-stu-id="c0156-393">Verify that all routes are protected properly and are subject to the appropriate authentication and authorization checks.</span></span>

  > [!NOTE]
  > <span data-ttu-id="c0156-394">Bizonyos biztonsági intézkedésekért, például a felhasználók hitelesítésért valószínűleg nem a webes API, hanem a gazdakörnyezet felel, de ettől függetlenül még szükséges a biztonsági vizsgálatok elvégzése a telepítési folyamat részeként.</span><span class="sxs-lookup"><span data-stu-id="c0156-394">Some aspects of security such as user authentication are most likely to be the responsibility of the host environment rather than the web API, but it is still necessary to include security tests as part of the deployment process.</span></span>
  >
  >

- <span data-ttu-id="c0156-395">Tesztelje az egyes műveletek kivételkezelését, és ellenőrizze, hogy a műveletek megfelelő és jelentéssel bíró HTTP-válaszokat adnak-e vissza az ügyfélalkalmazásnak.</span><span class="sxs-lookup"><span data-stu-id="c0156-395">Test the exception handling performed by each operation and verify that an appropriate and meaningful HTTP response is passed back to the client application.</span></span>

- <span data-ttu-id="c0156-396">Ellenőrizze, hogy a kérelem- és válaszüzenetek szabályosak-e.</span><span class="sxs-lookup"><span data-stu-id="c0156-396">Verify that request and response messages are well-formed.</span></span> <span data-ttu-id="c0156-397">Ha például egy HTTP POST kérelem x-www-form-urlencoded formátumban tartalmazza egy új erőforrás adatait, győződjön meg arról, hogy a vonatkozó művelet megfelelően elemzi az adatokat, létrehozza az erőforrásokat, és visszaad egy választ, amely tartalmazza az új erőforrás részleteit, köztük a megfelelő Location fejlécet.</span><span class="sxs-lookup"><span data-stu-id="c0156-397">For example, if an HTTP POST request contains the data for a new resource in x-www-form-urlencoded format, confirm that the corresponding operation correctly parses the data, creates the resources, and returns a response containing the details of the new resource, including the correct Location header.</span></span>

- <span data-ttu-id="c0156-398">Ellenőrizze az összes hivatkozást és URI-t a válaszüzenetekben.</span><span class="sxs-lookup"><span data-stu-id="c0156-398">Verify all links and URIs in response messages.</span></span> <span data-ttu-id="c0156-399">Például egy HTTP POST üzenetnek az újonnan létrehozott erőforrás URI-jét kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="c0156-399">For example, an HTTP POST message should return the URI of the newly-created resource.</span></span> <span data-ttu-id="c0156-400">Minden HATEOAS-hivatkozásnak érvényesnek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="c0156-400">All HATEOAS links should be valid.</span></span>

- <span data-ttu-id="c0156-401">Győződjön meg arról, hogy a minden művelet a megfelelő állapotkódokat adja vissza a különböző bemeneti kombinációkra.</span><span class="sxs-lookup"><span data-stu-id="c0156-401">Ensure that each operation returns the correct status codes for different combinations of input.</span></span> <span data-ttu-id="c0156-402">Példa:</span><span class="sxs-lookup"><span data-stu-id="c0156-402">For example:</span></span>

  - <span data-ttu-id="c0156-403">Ha egy lekérdezés sikeres, a 200 (OK) állapotkódot kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="c0156-403">If a query is successful, it should return status code 200 (OK)</span></span>
  - <span data-ttu-id="c0156-404">Ha egy erőforrás nem található, a műveletnek a 404 (Nem található) HTTP-állapotkódot kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="c0156-404">If a resource is not found, the operation should return HTTP status code 404 (Not Found).</span></span>
  - <span data-ttu-id="c0156-405">Ha az ügyfél elküld egy kérelmet, amely sikeresen töröl egy erőforrást, a 204 (Nincs tartalom) állapotkódnak kell megjelennie.</span><span class="sxs-lookup"><span data-stu-id="c0156-405">If the client sends a request that successfully deletes a resource, the status code should be 204 (No Content).</span></span>
  - <span data-ttu-id="c0156-406">Az ügyfél elküld egy kérelmet, amely egy új erőforrást hoz létre, ha az állapotkód: 201 (létrehozva) kell lennie.</span><span class="sxs-lookup"><span data-stu-id="c0156-406">If the client sends a request that creates a new resource, the status code should be 201 (Created).</span></span>

<span data-ttu-id="c0156-407">Figyeljen a válaszokban a váratlan állapotkódokra az 5xx tartományban.</span><span class="sxs-lookup"><span data-stu-id="c0156-407">Watch out for unexpected response status codes in the 5xx range.</span></span> <span data-ttu-id="c0156-408">Ezekkel az üzenetekkel a gazdakiszolgáló általában azt jelzi, hogy nem tudott teljesíteni egy érvényes kérelmet.</span><span class="sxs-lookup"><span data-stu-id="c0156-408">These messages are usually reported by the host server to indicate that it was unable to fulfill a valid request.</span></span>

- <span data-ttu-id="c0156-409">Tesztelje az ügyfélalkalmazás által megadható különböző fejléc-kombinációkat, és győződjön meg arról, hogy a webes API a várt információt adja vissza a válaszüzenetekben.</span><span class="sxs-lookup"><span data-stu-id="c0156-409">Test the different request header combinations that a client application can specify and ensure that the web API returns the expected information in response messages.</span></span>

- <span data-ttu-id="c0156-410">Tesztelje a lekérdezési sztringekat.</span><span class="sxs-lookup"><span data-stu-id="c0156-410">Test query strings.</span></span> <span data-ttu-id="c0156-411">Ha egy műveletnek választható paraméterei is lehetnek (például tördelési kérések), tesztelje a paraméterek különböző kombinációit és sorrendjeit.</span><span class="sxs-lookup"><span data-stu-id="c0156-411">If an operation can take optional parameters (such as pagination requests), test the different combinations and order of parameters.</span></span>

- <span data-ttu-id="c0156-412">Ellenőrizze, hogy az aszinkron műveletek sikeresen befejeződnek-e.</span><span class="sxs-lookup"><span data-stu-id="c0156-412">Verify that asynchronous operations complete successfully.</span></span> <span data-ttu-id="c0156-413">Ha a webes API támogatja streamelést a nagyméretű bináris objektumokat (például videókat vagy hangfájlokat) visszaadó kérelmeknél, akkor ügyeljen arra, hogy az ügyfélkérelmek ne legyenek blokkolva az adatok streamelése közben.</span><span class="sxs-lookup"><span data-stu-id="c0156-413">If the web API supports streaming for requests that return large binary objects (such as video or audio), ensure that client requests are not blocked while the data is streamed.</span></span> <span data-ttu-id="c0156-414">Ha a webes API ciklikus lekérdezéseket használ a hosszan futó adatmódosítási műveletekhez, ellenőrizze, hogy a műveletek menet közben megfelelően jelentik-e az állapotukat.</span><span class="sxs-lookup"><span data-stu-id="c0156-414">If the web API implements polling for long-running data modification operations, verify that that the operations report their status correctly as they proceed.</span></span>

<span data-ttu-id="c0156-415">Emellett hozzon létre és futtasson teljesítményteszteket, amelyekkel ellenőrizheti, hogy a webes API kielégítően működik-e nagy terhelés alatt.</span><span class="sxs-lookup"><span data-stu-id="c0156-415">You should also create and run performance tests to check that the web API operates satisfactorily under duress.</span></span> <span data-ttu-id="c0156-416">Webes teljesítmény- és terheléses tesztelési projekteket a Visual Studio Ultimate használatával hozhat létre.</span><span class="sxs-lookup"><span data-stu-id="c0156-416">You can build a web performance and load test project by using Visual Studio Ultimate.</span></span> <span data-ttu-id="c0156-417">További információ: [Alkalmazások teljesítményének tesztelése közzététel előtt](https://msdn.microsoft.com/library/dn250793.aspx).</span><span class="sxs-lookup"><span data-stu-id="c0156-417">For more information, see [Run performance tests on an application before a release](https://msdn.microsoft.com/library/dn250793.aspx).</span></span>

## <a name="using-azure-api-management"></a><span data-ttu-id="c0156-418">Az Azure API Management használata</span><span class="sxs-lookup"><span data-stu-id="c0156-418">Using Azure API Management</span></span>

<span data-ttu-id="c0156-419">Az Azure-ban érdemes az [Azure API Management](/azure/api-management//services/api-management/) szolgáltatást használnia a webes API-k közzétételéhez és felügyeletéhez.</span><span class="sxs-lookup"><span data-stu-id="c0156-419">On Azure, consider using [Azue API Management](/azure/api-management//services/api-management/) to publish and manage a web API.</span></span> <span data-ttu-id="c0156-420">Ezzel az eszközzel létrehozhat egy olyan szolgáltatást, amely egy vagy több webes API előtér-szolgáltatásaként funkcionál.</span><span class="sxs-lookup"><span data-stu-id="c0156-420">Using this facility, you can generate a service that acts as a façade for one or more web APIs.</span></span> <span data-ttu-id="c0156-421">Maga a szolgáltatás egy méretezhető webszolgáltatás, amelyet az Azure felügyeleti portálján hozhat létre és konfigurálhat.</span><span class="sxs-lookup"><span data-stu-id="c0156-421">The service is itself a scalable web service that you can create and configure by using the Azure Management portal.</span></span> <span data-ttu-id="c0156-422">A szolgáltatással a következőképpen tehet közzé és felügyelhet egy webes API-t:</span><span class="sxs-lookup"><span data-stu-id="c0156-422">You can use this service to publish and manage a web API as follows:</span></span>

1. <span data-ttu-id="c0156-423">Telepítse az API-t egy webhelyre, Azure-felhőszolgáltatásba vagy Azure-beli virtuális gépre.</span><span class="sxs-lookup"><span data-stu-id="c0156-423">Deploy the web API to a website, Azure cloud service, or Azure virtual machine.</span></span>

2. <span data-ttu-id="c0156-424">Csatlakoztassa az API Management szolgáltatást a webes API-hoz.</span><span class="sxs-lookup"><span data-stu-id="c0156-424">Connect the API management service to the web API.</span></span> <span data-ttu-id="c0156-425">A felügyeleti API URL-címére küldött kérelmeket a webes API-ban lévő URI-kre képezi le a rendszer.</span><span class="sxs-lookup"><span data-stu-id="c0156-425">Requests sent to the URL of the management API are mapped to URIs in the web API.</span></span> <span data-ttu-id="c0156-426">Egy API Management szolgáltatás több webes API-hoz is irányíthatja a kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="c0156-426">The same API management service can route requests to more than one web API.</span></span> <span data-ttu-id="c0156-427">Ezáltal több webes API-t összesíthet egyetlen felügyeleti szolgáltatásban.</span><span class="sxs-lookup"><span data-stu-id="c0156-427">This enables you to aggregate multiple web APIs into a single management service.</span></span> <span data-ttu-id="c0156-428">Hasonlóképp egy webes API-ra több API Management szolgáltatás is hivatkozhat, ha a különböző alkalmazások számára elérhető funkciókat korlátozni vagy particionálni kell.</span><span class="sxs-lookup"><span data-stu-id="c0156-428">Similarly, the same web API can be referenced from more than one API management service if you need to restrict or partition the functionality available to different applications.</span></span>

     > [!NOTE]
     > <span data-ttu-id="c0156-429">A HTTP GET kérések válaszainak részeként létrehozott HATEOAS-hivatkozásokban található URI-knek az API Management szolgáltatás URL-címére kell hivatkozniuk, és nem a webes API-t üzemeltető webkiszolgálóra.</span><span class="sxs-lookup"><span data-stu-id="c0156-429">The URIs in HATEOAS links generated as part of the response for HTTP GET requests should reference the URL of the API management service and not the web server hosting the web API.</span></span>

3. <span data-ttu-id="c0156-430">Minden webes API-hoz adja meg a közzétett HTTP-műveleteket, valamint a műveletek által bemenetként felhasználható opcionális paramétereket.</span><span class="sxs-lookup"><span data-stu-id="c0156-430">For each web API, specify the HTTP operations that the web API exposes together with any optional parameters that an operation can take as input.</span></span> <span data-ttu-id="c0156-431">Azt is beállíthatja, hogy az API Management szolgáltatás gyorsítótárazza-e a webes API-tól kapott választ, így optimalizálhatja az ugyanazon adatokra irányuló ismétlődő kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="c0156-431">You can also configure whether the API management service should cache the response received from the web API to optimize repeated requests for the same data.</span></span> <span data-ttu-id="c0156-432">Rögzítse az egyes műveletek által adható HTTP-válaszok részleteit.</span><span class="sxs-lookup"><span data-stu-id="c0156-432">Record the details of the HTTP responses that each operation can generate.</span></span> <span data-ttu-id="c0156-433">Ezek az adatok a fejlesztői dokumentációk létrehozására szolgálnak, ezért fontos hogy pontosak és teljesek legyenek.</span><span class="sxs-lookup"><span data-stu-id="c0156-433">This information is used to generate documentation for developers, so it is important that it is accurate and complete.</span></span>

    <span data-ttu-id="c0156-434">A műveleteket meghatározhatja manuálisan az Azure felügyeleti portáljának varázslóival, vagy importálhatja őket egy fájlból, amely WADL vagy Swagger formátumban tartalmazza a definíciókat.</span><span class="sxs-lookup"><span data-stu-id="c0156-434">You can either define operations manually using the wizards provided by the Azure Management portal, or you can import them from a file containing the definitions in WADL or Swagger format.</span></span>

4. <span data-ttu-id="c0156-435">Konfigurálja az API Management szolgáltatás és a webes API-t üzemeltető webkiszolgáló közötti kommunikáció biztonsági beállításait.</span><span class="sxs-lookup"><span data-stu-id="c0156-435">Configure the security settings for communications between the API management service and the web server hosting the web API.</span></span> <span data-ttu-id="c0156-436">Az API Management szolgáltatás jelenleg támogatja a tanúsítványokkal végzett alapszintű hitelesítést és kölcsönös hitelesítést, valamint az OAuth 2.0 felhasználói hitelesítést.</span><span class="sxs-lookup"><span data-stu-id="c0156-436">The API management service currently supports Basic authentication and mutual authentication using certificates, and OAuth 2.0 user authorization.</span></span>

5. <span data-ttu-id="c0156-437">Hozzon létre egy terméket.</span><span class="sxs-lookup"><span data-stu-id="c0156-437">Create a product.</span></span> <span data-ttu-id="c0156-438">A termék a közzététel egysége: azokat a webes API-kat kell hozzáadnia, amelyeket korábban csatlakoztatott a kezelési szolgáltatáshoz.</span><span class="sxs-lookup"><span data-stu-id="c0156-438">A product is the unit of publication; you add the web APIs that you previously connected to the management service to the product.</span></span> <span data-ttu-id="c0156-439">A termék közzététele után a webes API-k elérhetővé válnak a fejlesztők számára.</span><span class="sxs-lookup"><span data-stu-id="c0156-439">When the product is published, the web APIs become available to developers.</span></span>

    > [!NOTE]
    > <span data-ttu-id="c0156-440">A termék közzététele előtt megadhat felhasználói csoportokat, amelyek hozzáférhetnek a termékhez, és felhasználókat adhat a csoportokhoz.</span><span class="sxs-lookup"><span data-stu-id="c0156-440">Prior to publishing a product, you can also define user-groups that can access the product and add users to these groups.</span></span> <span data-ttu-id="c0156-441">Ezzel szabályozható, hogy a webes API-t mely fejlesztők és alkalmazások használhatják.</span><span class="sxs-lookup"><span data-stu-id="c0156-441">This gives you control over the developers and applications that can use the web API.</span></span> <span data-ttu-id="c0156-442">Ha a webes API-t jóvá kell hagyni, a hozzáférés előtt a fejlesztőknek kérelmet kell küldeniük a termék adminisztrátorának.</span><span class="sxs-lookup"><span data-stu-id="c0156-442">If a web API is subject to approval, prior to being able to access it a developer must send a request to the product administrator.</span></span> <span data-ttu-id="c0156-443">A rendszergazda engedélyezheti vagy megtagadhatja a fejlesztő hozzáférését.</span><span class="sxs-lookup"><span data-stu-id="c0156-443">The administrator can grant or deny access to the developer.</span></span> <span data-ttu-id="c0156-444">A már engedélyezett fejlesztők is blokkolhatók, ha a körülmények megváltoznak.</span><span class="sxs-lookup"><span data-stu-id="c0156-444">Existing developers can also be blocked if circumstances change.</span></span>

6. <span data-ttu-id="c0156-445">Konfiguráljon szabályzatokat minden webes API-hoz.</span><span class="sxs-lookup"><span data-stu-id="c0156-445">Configure policies for each web API.</span></span> <span data-ttu-id="c0156-446">A szabályzatok meghatározzák például, hogy a tartományok közötti hívások engedélyezettek-e, hogy hogyan zajlik az ügyfelek hitelesítése, hogy az XML és JSON formátumok közötti átalakítás transzparens módon történik-e, hogy egy adott IP-címtartomány hívásai korlátozva legyenek-e, hogy a hívások sebessége korlátozott legyen-e, valamint a használati kvótákat.</span><span class="sxs-lookup"><span data-stu-id="c0156-446">Policies govern aspects such as whether cross-domain calls should be allowed, how to authenticate clients, whether to convert between XML and JSON data formats transparently, whether to restrict calls from a given IP range, usage quotas, and whether to limit the call rate.</span></span> <span data-ttu-id="c0156-447">A szabályzatok alkalmazhatók globálisan az egész termékre, a termékben lévő adott webes API-ra, vagy a webes API-k egyes műveleteire.</span><span class="sxs-lookup"><span data-stu-id="c0156-447">Policies can be applied globally across the entire product, for a single web API in a product, or for individual operations in a web API.</span></span>

<span data-ttu-id="c0156-448">További információ: [az API Management dokumentációja](/azure/api-management/).</span><span class="sxs-lookup"><span data-stu-id="c0156-448">For more information, see the [API Management Documentation](/azure/api-management/).</span></span>

> [!TIP]
> <span data-ttu-id="c0156-449">Az Azure az Azure Traffic Manager segítségével teszi lehetővé a feladatátvétel és a terheléselosztás megvalósítását, valamint egy webhely különböző földrajzi helyeken üzemeltetett példányai közötti késés csökkentését.</span><span class="sxs-lookup"><span data-stu-id="c0156-449">Azure provides the Azure Traffic Manager which enables you to implement failover and load-balancing, and reduce latency across multiple instances of a web site hosted in different geographic locations.</span></span> <span data-ttu-id="c0156-450">Az Azure Traffic Manager az API Management szolgáltatással együtt használható: az API Management az Azure Traffic Manager segítségével irányítja egy webhely példányaira küldött kérelmek útválasztását.</span><span class="sxs-lookup"><span data-stu-id="c0156-450">You can use Azure Traffic Manager in conjunction with the API Management Service; the API Management Service can route requests to instances of a web site through Azure Traffic Manager.</span></span> <span data-ttu-id="c0156-451">További információ: [A Traffic Manager forgalomirányítási módszerei](/azure/traffic-manager/traffic-manager-routing-methods/).</span><span class="sxs-lookup"><span data-stu-id="c0156-451">For more information, see [Traffic Manager routing Methods](/azure/traffic-manager/traffic-manager-routing-methods/).</span></span>
>
> <span data-ttu-id="c0156-452">Ha ebben a struktúrában egyéni DNS-neveket használ a webhelyekhez, konfigurálja mindegyik webhely megfelelő CNAME rekordját úgy, hogy az Azure Traffic Manager webhely DNS-nevére mutasson.</span><span class="sxs-lookup"><span data-stu-id="c0156-452">In this structure, if you are using custom DNS names for your web sites, you should configure the appropriate CNAME record for each web site to point to the DNS name of the Azure Traffic Manager web site.</span></span>

## <a name="supporting-client-side-developers"></a><span data-ttu-id="c0156-453">Ügyféloldali fejlesztők támogatása</span><span class="sxs-lookup"><span data-stu-id="c0156-453">Supporting client-side developers</span></span>

<span data-ttu-id="c0156-454">Az ügyfélalkalmazások fejlesztőinek általában információkra van szükségük a webes API elérésével kapcsolatban. Emellett dokumentációra is szükségük van a paraméterekről, adattípusokról, visszatérési típusokról és visszatérési kódokról, amelyek leírják a webszolgáltatás és az ügyfélalkalmazás között küldött különböző kérelmeket és válaszokat.</span><span class="sxs-lookup"><span data-stu-id="c0156-454">Developers constructing client applications typically require information on how to access the web API, and documentation concerning the parameters, data types, return types, and return codes that describe the different requests and responses between the web service and the client application.</span></span>

### <a name="document-the-rest-operations-for-a-web-api"></a><span data-ttu-id="c0156-455">A webes API-k REST-műveleteinek dokumentálása</span><span class="sxs-lookup"><span data-stu-id="c0156-455">Document the REST operations for a web API</span></span>

<span data-ttu-id="c0156-456">Az Azure API Management szolgáltatás tartalmaz egy fejlesztői portált, amely leírja a webes API-k által elérhetővé tett REST-műveleteket.</span><span class="sxs-lookup"><span data-stu-id="c0156-456">The Azure API Management Service includes a developer portal that describes the REST operations exposed by a web API.</span></span> <span data-ttu-id="c0156-457">A közzétett termékek megjelennek a portálon.</span><span class="sxs-lookup"><span data-stu-id="c0156-457">When a product has been published it appears on this portal.</span></span> <span data-ttu-id="c0156-458">A fejlesztők ezen a portálon regisztrálhatnak hozzáférésért, majd a rendszergazda jóváhagyhatja vagy visszautasítja a kérelmüket.</span><span class="sxs-lookup"><span data-stu-id="c0156-458">Developers can use this portal to sign up for access; the administrator can then approve or deny the request.</span></span> <span data-ttu-id="c0156-459">Ha a fejlesztőnek jóváhagyták a kérelmét, kap egy előfizetési kulcsot, amellyel hitelesítheti az általa fejlesztett ügyfélalkalmazások hívásait.</span><span class="sxs-lookup"><span data-stu-id="c0156-459">If the developer is approved, they are assigned a subscription key that is used to authenticate calls from the client applications that they develop.</span></span> <span data-ttu-id="c0156-460">Ezt a kulcsot meg kell adni minden webes API-hívással, máskülönben a rendszer elutasítja a hívást.</span><span class="sxs-lookup"><span data-stu-id="c0156-460">This key must be provided with each web API call otherwise it will be rejected.</span></span>

<span data-ttu-id="c0156-461">A portál a következőket is tartalmazza:</span><span class="sxs-lookup"><span data-stu-id="c0156-461">This portal also provides:</span></span>

- <span data-ttu-id="c0156-462">A termék dokumentációja, a termék által elérhetővé tett műveletek listája, a szükséges paraméterek és a különböző visszaadható válaszok.</span><span class="sxs-lookup"><span data-stu-id="c0156-462">Documentation for the product, listing the operations that it exposes, the parameters required, and the different responses that can be returned.</span></span> <span data-ttu-id="c0156-463">Vegye figyelembe, hogy ezek az információk a „Webes API közzététele a Microsoft Azure API Management szolgáltatással” című szakaszban található lista 3. lépésében megadott információ alapján jönnek létre.</span><span class="sxs-lookup"><span data-stu-id="c0156-463">Note that this information is generated from the details provided in step 3 in the list in the Publishing a web API by using the Microsoft Azure API Management Service section.</span></span>
- <span data-ttu-id="c0156-464">Kódrészletek, amelyek bemutatják a műveletek meghívását számos nyelvből, köztük a JavaScript, C#, Java, Ruby, Python, és PHP nyelvekből.</span><span class="sxs-lookup"><span data-stu-id="c0156-464">Code snippets that show how to invoke operations from several languages, including JavaScript, C#, Java, Ruby, Python, and PHP.</span></span>
- <span data-ttu-id="c0156-465">Egy fejlesztői konzol, amely lehetővé teszi a fejlesztőknek a termékműveletek HTTP-kérelmek küldésével való tesztelését, valamint az eredmények megtekintését.</span><span class="sxs-lookup"><span data-stu-id="c0156-465">A developers' console that enables a developer to send an HTTP request to test each operation in the product and view the results.</span></span>
- <span data-ttu-id="c0156-466">Egy oldal, ahol a fejlesztők jelenthetik a talált hibákat és problémákat.</span><span class="sxs-lookup"><span data-stu-id="c0156-466">A page where the developer can report any issues or problems found.</span></span>

<span data-ttu-id="c0156-467">Az Azure felügyeleti portálja lehetőséget nyújt a fejlesztői portál testreszabására: a portál stíluselemei és elrendezése a saját vállalat márkajegyeihez igazíthatók.</span><span class="sxs-lookup"><span data-stu-id="c0156-467">The Azure Management portal enables you to customize the developer portal to change the styling and layout to match the branding of your organization.</span></span>

### <a name="implement-a-client-sdk"></a><span data-ttu-id="c0156-468">Ügyféloldali SDK megvalósítása</span><span class="sxs-lookup"><span data-stu-id="c0156-468">Implement a client SDK</span></span>

<span data-ttu-id="c0156-469">Ha olyan ügyfélalkalmazást hoz létre, amely REST-kérelmek meghívásával ér el egy webes API-t, nagy mennyiségű kódot kell írni az egyes kérelmek létrehozásához, megfelelő formázásához és a webszolgáltatást futtató kiszolgálóra való elküldéséhez, valamint a válasz elemzéséhez, a kérelem sikerességének vagy sikertelenségének megállapításához és a visszaadott adatok kinyeréséhez.</span><span class="sxs-lookup"><span data-stu-id="c0156-469">Building a client application that invokes REST requests to access a web API requires writing a significant amount of code to construct each request and format it appropriately, send the request to the server hosting the web service, and parse the response to work out whether the request succeeded or failed and extract any data returned.</span></span> <span data-ttu-id="c0156-470">Ha el kívánja szigetelni az ügyfélalkalmazást ezektől a problémáktól, megadhat egy SDK-t, amely becsomagolja a REST-felületet, és egy jobban használható metódusgyűjteménybe foglalja ezeket a részleteket.</span><span class="sxs-lookup"><span data-stu-id="c0156-470">To insulate the client application from these concerns, you can provide an SDK that wraps the REST interface and abstracts these low-level details inside a more functional set of methods.</span></span> <span data-ttu-id="c0156-471">Az ügyfélalkalmazások felhasználhatják ezeket a metódusokat, amelyek transzparens módon átalakítják a hívásokat REST-kérelmekké, majd a válaszokat visszaalakítják a metódusok által visszaadott értékekké.</span><span class="sxs-lookup"><span data-stu-id="c0156-471">A client application uses these methods, which transparently convert calls into REST requests and then convert the responses back into method return values.</span></span> <span data-ttu-id="c0156-472">Ez egy elterjedt megoldás, amelyet számos szolgáltatás használ, köztük az Azure SDK is.</span><span class="sxs-lookup"><span data-stu-id="c0156-472">This is a common technique that is implemented by many services, including the Azure SDK.</span></span>

<span data-ttu-id="c0156-473">Egy ügyféloldali SDK létrehozása jelentős vállalkozás, mivel egységes megvalósítást és alapos tesztelést igényel.</span><span class="sxs-lookup"><span data-stu-id="c0156-473">Creating a client-side SDK is a considerable undertaking as it has to be implemented consistently and tested carefully.</span></span> <span data-ttu-id="c0156-474">Azonban a folyamat nagy része gépesíthető, és sok beszállító kínál olyan eszközöket, amelyekkel számos feladat automatizálható.</span><span class="sxs-lookup"><span data-stu-id="c0156-474">However, much of this process can be made mechanical, and many vendors supply tools that can automate many of these tasks.</span></span>

## <a name="monitoring-a-web-api"></a><span data-ttu-id="c0156-475">Webes API monitorozása</span><span class="sxs-lookup"><span data-stu-id="c0156-475">Monitoring a web API</span></span>

<span data-ttu-id="c0156-476">Attól függően, hogy a webes API hogyan lett közzétéve és üzembe helyezve, monitorozhatja az API-t közvetlenül, vagy felhasználási és állapotadatokat gyűjthet az API Management szolgáltatáson áthaladó forgalom elemzésével.</span><span class="sxs-lookup"><span data-stu-id="c0156-476">Depending on how you have published and deployed your web API you can monitor the web API directly, or you can gather usage and health information by analyzing the traffic that passes through the API Management service.</span></span>

### <a name="monitoring-a-web-api-directly"></a><span data-ttu-id="c0156-477">Webes API közvetlen monitorozása</span><span class="sxs-lookup"><span data-stu-id="c0156-477">Monitoring a web API directly</span></span>

<span data-ttu-id="c0156-478">Ha a webes API megvalósításához az ASP.NET Web API-sablont (akár webes API-projektként, akár egy Azure-felhőszolgáltatáson belüli webes szerepkörként) és a Visual Studio 2013-at használta, akkor az ASP.NET Application Insights segítségével adatokat gyűjthet a webes API rendelkezésre állásáról, teljesítményéről és használatáról.</span><span class="sxs-lookup"><span data-stu-id="c0156-478">If you have implemented your web API by using the ASP.NET Web API template (either as a Web API project or as a Web role in an Azure cloud service) and Visual Studio 2013, you can gather availability, performance, and usage data by using ASP.NET Application Insights.</span></span> <span data-ttu-id="c0156-479">Az Application Insights egy olyan csomag, amely transzparens módon nyomon követi és rögzíti a kérelmek és válaszok adatait, ha a webes API a felhőben lett üzembe helyezve. A csomag telepítése és konfigurálása után nem szükséges módosítani a webes API kódját a használatához.</span><span class="sxs-lookup"><span data-stu-id="c0156-479">Application Insights is a package that transparently tracks and records information about requests and responses when the web API is deployed to the cloud; once the package is installed and configured, you don't need to amend any code in your web API to use it.</span></span> <span data-ttu-id="c0156-480">Ha a webes API-t egy Azure-webhelyen telepíti, a rendszer minden forgalmat megvizsgál, és a következő statisztikákat gyűjti össze:</span><span class="sxs-lookup"><span data-stu-id="c0156-480">When you deploy the web API to an Azure web site, all traffic is examined and the following statistics are gathered:</span></span>

- <span data-ttu-id="c0156-481">kiszolgáló válaszideje,</span><span class="sxs-lookup"><span data-stu-id="c0156-481">Server response time.</span></span>
- <span data-ttu-id="c0156-482">kiszolgáló kérelmeinek száma és az egyes kérelmek részletei,</span><span class="sxs-lookup"><span data-stu-id="c0156-482">Number of server requests and the details of each request.</span></span>
- <span data-ttu-id="c0156-483">a leglassabb kérelmek átlagos válaszidő alapján,</span><span class="sxs-lookup"><span data-stu-id="c0156-483">The top slowest requests in terms of average response time.</span></span>
- <span data-ttu-id="c0156-484">a sikertelen kérelmek részletei,</span><span class="sxs-lookup"><span data-stu-id="c0156-484">The details of any failed requests.</span></span>
- <span data-ttu-id="c0156-485">a különböző böngészők és felhasználói ügynökök által kezdeményezett munkamenetek száma,</span><span class="sxs-lookup"><span data-stu-id="c0156-485">The number of sessions initiated by different browsers and user agents.</span></span>
- <span data-ttu-id="c0156-486">a leggyakrabban megtekintett lapok (ez nem elsősorban a webes API-khoz, hanem a webalkalmazásokhoz hasznos).</span><span class="sxs-lookup"><span data-stu-id="c0156-486">The most frequently viewed pages (primarily useful for web applications rather than web APIs).</span></span>
- <span data-ttu-id="c0156-487">a webes API-hoz hozzáférő különböző felhasználói szerepkörök.</span><span class="sxs-lookup"><span data-stu-id="c0156-487">The different user roles accessing the web API.</span></span>

<span data-ttu-id="c0156-488">Ezeket az adatokat valós időben követheti az Azure felügyeleti portálján.</span><span class="sxs-lookup"><span data-stu-id="c0156-488">You can view this data in real time from the Azure Management portal.</span></span> <span data-ttu-id="c0156-489">Létrehozhat webteszteket is, amelyek a webes API állapotát monitorozzák.</span><span class="sxs-lookup"><span data-stu-id="c0156-489">You can also create webtests that monitor the health of the web API.</span></span> <span data-ttu-id="c0156-490">A webtesztek rendszeres kérelmeket küldenek egy webes API megadott URI-jére, és rögzítik a válaszokat.</span><span class="sxs-lookup"><span data-stu-id="c0156-490">A webtest sends a periodic request to a specified URI in the web API and captures the response.</span></span> <span data-ttu-id="c0156-491">Meghatározhatja, mi számít sikeres válasznak (például a 200-as HTTP-állapotkód), és beállíthatja, hogy ha a kérelem nem ezt a választ adja vissza, a rendszer küldjön riasztást egy rendszergazdának.</span><span class="sxs-lookup"><span data-stu-id="c0156-491">You can specify the definition of a successful response (such as HTTP status code 200), and if the request does not return this response you can arrange for an alert to be sent to an administrator.</span></span> <span data-ttu-id="c0156-492">Szükség esetén a rendszergazda újraindíthatja a webes API-t futtató kiszolgálót, ha meghibásodott.</span><span class="sxs-lookup"><span data-stu-id="c0156-492">If necessary, the administrator can restart the server hosting the web API if it has failed.</span></span>

<span data-ttu-id="c0156-493">További információ: [Application Insights – Az ASP.NET használatának első lépései](/azure/application-insights/app-insights-asp-net/).</span><span class="sxs-lookup"><span data-stu-id="c0156-493">For more information, see [Application Insights - Get started with ASP.NET](/azure/application-insights/app-insights-asp-net/).</span></span>

### <a name="monitoring-a-web-api-through-the-api-management-service"></a><span data-ttu-id="c0156-494">Webes API monitorozása az API Management szolgáltatáson keresztül</span><span class="sxs-lookup"><span data-stu-id="c0156-494">Monitoring a web API through the API Management Service</span></span>

<span data-ttu-id="c0156-495">Ha az API Management szolgáltatással tette közzé a webes API-t, az Azure felügyeleti portál API Management oldala tartalmaz egy irányítópultot, amelyen áttekinthető a szolgáltatás általános teljesítménye.</span><span class="sxs-lookup"><span data-stu-id="c0156-495">If you have published your web API by using the API Management service, the API Management page on the Azure Management portal contains a dashboard that enables you to view the overall performance of the service.</span></span> <span data-ttu-id="c0156-496">Az Elemzés oldalon részletes elemzések találhatók a termék használatáról.</span><span class="sxs-lookup"><span data-stu-id="c0156-496">The Analytics page enables you to drill down into the details of how the product is being used.</span></span> <span data-ttu-id="c0156-497">Ez az oldal a következő lapokat tartalmazza:</span><span class="sxs-lookup"><span data-stu-id="c0156-497">This page contains the following tabs:</span></span>

- <span data-ttu-id="c0156-498">**Használat** –</span><span class="sxs-lookup"><span data-stu-id="c0156-498">**Usage**.</span></span> <span data-ttu-id="c0156-499">Ez a lap információkat közöl az API-hívások számáról és az ezek kezeléséhez igénybe vett sávszélességről.</span><span class="sxs-lookup"><span data-stu-id="c0156-499">This tab provides information about the number of API calls made and the bandwidth used to handle these calls over time.</span></span> <span data-ttu-id="c0156-500">A használati adatok szűrhetők termék, API és művelet szerint.</span><span class="sxs-lookup"><span data-stu-id="c0156-500">You can filter usage details by product, API, and operation.</span></span>
- <span data-ttu-id="c0156-501">**Állapot** –</span><span class="sxs-lookup"><span data-stu-id="c0156-501">**Health**.</span></span> <span data-ttu-id="c0156-502">Ezen a lapon megtekinthetők az API-kérelmek eredményei (a visszaadott HTTP-állapotkódok), a gyorsítótárazási szabályzat hatékonysága, az API válaszideje és a szolgáltatás válaszideje.</span><span class="sxs-lookup"><span data-stu-id="c0156-502">This tab enables you to view the outcome of API requests (the HTTP status codes returned), the effectiveness of the caching policy, the API response time, and the service response time.</span></span> <span data-ttu-id="c0156-503">Az állapotadatok szintén szűrhetők termék, API és művelet szerint.</span><span class="sxs-lookup"><span data-stu-id="c0156-503">Again, you can filter health data by product, API, and operation.</span></span>
- <span data-ttu-id="c0156-504">**Tevékenység** –</span><span class="sxs-lookup"><span data-stu-id="c0156-504">**Activity**.</span></span> <span data-ttu-id="c0156-505">Ez a lap szöveges összegzést tartalmaz a sikeres, sikertelen és blokkolt hívásokról, az átlagos válaszidőről, valamint az egyes termékek, webes API-k és műveletek válaszidejéről.</span><span class="sxs-lookup"><span data-stu-id="c0156-505">This tab provides a text summary of the numbers of successful calls, failed calls, blocked calls, average response time, and response times for each product, web API, and operation.</span></span> <span data-ttu-id="c0156-506">Emellett az oldal az egyes fejlesztők által indított hívások számát is felsorolja.</span><span class="sxs-lookup"><span data-stu-id="c0156-506">This page also lists the number of calls made by each developer.</span></span>
- <span data-ttu-id="c0156-507">**Áttekintés** –</span><span class="sxs-lookup"><span data-stu-id="c0156-507">**At a glance**.</span></span> <span data-ttu-id="c0156-508">Ez a lap a teljesítményadatok összegzését tartalmazza, beleértve a legtöbb API-hívást indító fejlesztőket, és az e hívásokat fogadó termékeket, webes API-kat és műveleteket.</span><span class="sxs-lookup"><span data-stu-id="c0156-508">This tab displays a summary of the performance data, including the developers responsible for making the most API calls, and the products, web APIs, and operations that received these calls.</span></span>

<span data-ttu-id="c0156-509">Ezen adatok alapján lehet megállapítani, hogy egy adott webes API vagy művelet szűk keresztmetszetet okoz-e, majd szükség esetén skálázhatja a gazdakörnyezetet további kiszolgálókkal.</span><span class="sxs-lookup"><span data-stu-id="c0156-509">You can use this information to determine whether a particular web API or operation is causing a bottleneck, and if necessary scale the host environment and add more servers.</span></span> <span data-ttu-id="c0156-510">Emellett az is megállapítható, ha egy vagy több alkalmazás aránytalanul nagy mennyiségű erőforrást használ, majd a megfelelő szabályzatokkal kvóták állíthatók be és korlátozható a hívások gyakorisága.</span><span class="sxs-lookup"><span data-stu-id="c0156-510">You can also ascertain whether one or more applications are using a disproportionate volume of resources and apply the appropriate policies to set quotas and limit call rates.</span></span>

> [!NOTE]
> <span data-ttu-id="c0156-511">A közzétett termékek részleteinek módosításai azonnal hatályba lépnek.</span><span class="sxs-lookup"><span data-stu-id="c0156-511">You can change the details for a published product, and the changes are applied immediately.</span></span> <span data-ttu-id="c0156-512">Például egy webes API-hoz hozzáadhat vagy eltávolíthat egy műveletet anélkül, hogy újra közzé kellene tennie a webes API-t tartalmazó terméket.</span><span class="sxs-lookup"><span data-stu-id="c0156-512">For example, you can add or remove an operation from a web API without requiring that you republish the product that contains the web API.</span></span>

## <a name="more-information"></a><span data-ttu-id="c0156-513">További információ</span><span class="sxs-lookup"><span data-stu-id="c0156-513">More information</span></span>

- <span data-ttu-id="c0156-514">Az [ASP.NET – webes API OData](https://www.asp.net/web-api/overview/odata-support-in-aspnet-web-api) példákat és további információkat tartalmaz az OData webes API-k ASP.NET használatával való megvalósításáról.</span><span class="sxs-lookup"><span data-stu-id="c0156-514">[ASP.NET Web API OData](https://www.asp.net/web-api/overview/odata-support-in-aspnet-web-api) contains examples and further information on implementing an OData web API by using ASP.NET.</span></span>
- <span data-ttu-id="c0156-515">[Kötegelés támogatásának a webes API-t és a webes API Odatában](https://blogs.msdn.microsoft.com/webdev/2013/11/01/introducing-batch-support-in-web-api-and-web-api-odata/) ismerteti, hogyan lehet kötegelt műveleteket megvalósítani egy webes API OData használatával.</span><span class="sxs-lookup"><span data-stu-id="c0156-515">[Introducing batch support in Web API and Web API OData](https://blogs.msdn.microsoft.com/webdev/2013/11/01/introducing-batch-support-in-web-api-and-web-api-odata/) describes how to implement batch operations in a web API by using OData.</span></span>
- <span data-ttu-id="c0156-516">[Idempotens minták](https://blog.jonathanoliver.com/idempotency-patterns/) blogján Jonathan Oliver idempotenciáról, és hogyan kapcsolódik az adatkezelési műveletekhez áttekintést nyújt.</span><span class="sxs-lookup"><span data-stu-id="c0156-516">[Idempotency patterns](https://blog.jonathanoliver.com/idempotency-patterns/) on Jonathan Oliver’s blog provides an overview of idempotency and how it relates to data management operations.</span></span>
- <span data-ttu-id="c0156-517">A W3C webhely [Állapotkód-definíciókat](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) ismertető lapján megtalálható a HTTP-állapotkódok teljes listája és a leírásaik.</span><span class="sxs-lookup"><span data-stu-id="c0156-517">[Status Code Definitions](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) on the W3C website contains a full list of HTTP status codes and their descriptions.</span></span>
- <span data-ttu-id="c0156-518">A [Háttérfeladatok WebJobs-feladatokkal való futtatásáról](/azure/app-service-web/web-sites-create-web-jobs/) szóló cikk útmutatást és példákat tartalmaz a háttérbeli műveletek WebJobs használatával való végrehajtásához.</span><span class="sxs-lookup"><span data-stu-id="c0156-518">[Run background tasks with WebJobs](/azure/app-service-web/web-sites-create-web-jobs/) provides information and examples on using WebJobs to perform background operations.</span></span>
- <span data-ttu-id="c0156-519">[Értesítse a felhasználókat az Azure Notification Hubs](/azure/notification-hubs/notification-hubs-aspnet-backend-windows-dotnet-wns-notification/) mutatja be az ügyfélalkalmazások aszinkron válaszok leküldése az Azure Notification Hub használatával.</span><span class="sxs-lookup"><span data-stu-id="c0156-519">[Azure Notification Hubs notify users](/azure/notification-hubs/notification-hubs-aspnet-backend-windows-dotnet-wns-notification/) shows how to use an Azure Notification Hub to push asynchronous responses to client applications.</span></span>
- <span data-ttu-id="c0156-520">Az [API Management](https://azure.microsoft.com/services/api-management/) leírja, hogyan lehet közzétenni egy terméket, amely felügyelt és biztonságos hozzáférést biztosít egy webes API-hoz.</span><span class="sxs-lookup"><span data-stu-id="c0156-520">[API Management](https://azure.microsoft.com/services/api-management/) describes how to publish a product that provides controlled and secure access to a web API.</span></span>
- <span data-ttu-id="c0156-521">[Az Azure API Management REST API-referencia](https://msdn.microsoft.com/library/azure/dn776326.aspx) azt ismerteti, hogyan használható az API Management REST API egyéni felügyeleti alkalmazások létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="c0156-521">[Azure API Management REST API reference](https://msdn.microsoft.com/library/azure/dn776326.aspx) describes how to use the API Management REST API to build custom management applications.</span></span>
- <span data-ttu-id="c0156-522">[A TRAFFIC Manager útválasztási módszerei](/azure/traffic-manager/traffic-manager-routing-methods/) összefoglalja, hogyan Azure Traffic Manager segítségével el a kérelmek terhelése egy webes API-t futtató webhely több példánya között.</span><span class="sxs-lookup"><span data-stu-id="c0156-522">[Traffic Manager routing methods](/azure/traffic-manager/traffic-manager-routing-methods/) summarizes how Azure Traffic Manager can be used to load-balance requests across multiple instances of a website hosting a web API.</span></span>
- <span data-ttu-id="c0156-523">Az [Application Insights – Az ASP.NET első lépéseit](/azure/application-insights/app-insights-asp-net/) ismertető cikk részletes információkat nyújt az Application Insights ASP.NET webes API-projektben történő telepítéséhez és konfigurálásához.</span><span class="sxs-lookup"><span data-stu-id="c0156-523">[Application Insights - Get started with ASP.NET](/azure/application-insights/app-insights-asp-net/) provides detailed information on installing and configuring Application Insights in an ASP.NET Web API project.</span></span>

<!-- links -->

[api-design]: ./api-design.md
