---
title: API-implementálási segédlet
description: Útmutatás az API-k megvalósítása után.
author: dragon119
ms.date: 07/13/2016
pnp.series.title: Best Practices
ms.openlocfilehash: cc28864de36afdeed2f8a7155a307e312c3a398e
ms.sourcegitcommit: c93f1b210b3deff17cc969fb66133bc6399cfd10
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 01/05/2018
ms.locfileid: "27596019"
---
# <a name="api-implementation"></a><span data-ttu-id="98de3-103">API-implementáció</span><span class="sxs-lookup"><span data-stu-id="98de3-103">API implementation</span></span>

<span data-ttu-id="98de3-104">Gondosan tervezett RESTful webes API-k meghatározása az erőforrásokat, a kapcsolatokat és a navigációs rendszerek ügyfélalkalmazások számára elérhető.</span><span class="sxs-lookup"><span data-stu-id="98de3-104">A carefully-designed RESTful web API defines the resources, relationships, and navigation schemes that are accessible to client applications.</span></span> <span data-ttu-id="98de3-105">Megvalósítása és központi telepítése a webes API-k, gondolja át a fizikai követelményeinek a a webes API-t és az üzemeltetési környezetben található, amely a webes API-k összeállított ahelyett, hogy az adatok logikai szerkezetének.</span><span class="sxs-lookup"><span data-stu-id="98de3-105">When you implement and deploy a web API, you should consider the physical requirements of the environment hosting the web API and the way in which the web API is constructed rather than the logical structure of the data.</span></span> <span data-ttu-id="98de3-106">Ez az útmutató mutatja be gyakorlati tanácsok a webes API-k megvalósítása és közzétételi azt, hogy az ügyfélalkalmazások számára elérhető legyen.</span><span class="sxs-lookup"><span data-stu-id="98de3-106">This guidance focusses on best practices for implementing a web API and publishing it to make it available to client applications.</span></span> <span data-ttu-id="98de3-107">Részletes információ a webes API modell: [API tervezési útmutató](/azure/architecture/best-practices/api-design).</span><span class="sxs-lookup"><span data-stu-id="98de3-107">For detailed information about web API design, see [API Design Guidance](/azure/architecture/best-practices/api-design).</span></span>

## <a name="processing-requests"></a><span data-ttu-id="98de3-108">Kérelmek feldolgozása</span><span class="sxs-lookup"><span data-stu-id="98de3-108">Processing requests</span></span>

<span data-ttu-id="98de3-109">A kód a tanúsítványigénylések bevezetésekor, vegye figyelembe a következő szempontokat.</span><span class="sxs-lookup"><span data-stu-id="98de3-109">Consider the following points when you implement the code to handle requests.</span></span>

### <a name="get-put-delete-head-and-patch-actions-should-be-idempotent"></a><span data-ttu-id="98de3-110">GET, PUT, DELETE, HEAD és JAVÍTÁSI műveletek idempotent kell lennie</span><span class="sxs-lookup"><span data-stu-id="98de3-110">GET, PUT, DELETE, HEAD, and PATCH actions should be idempotent</span></span>

<span data-ttu-id="98de3-111">Ezek a kérelmek megvalósító kódot kell ugyanazok a mellékhatással működő.</span><span class="sxs-lookup"><span data-stu-id="98de3-111">The code that implements these requests should not impose any side-effects.</span></span> <span data-ttu-id="98de3-112">A kérésben felett erőforrást ismétlődő olyan állapotban kell kiváltani.</span><span class="sxs-lookup"><span data-stu-id="98de3-112">The same request repeated over the same resource should result in the same state.</span></span> <span data-ttu-id="98de3-113">Például több DELETE kérelmet küld a ugyanilyen URI kell rendelkeznie a hatást, bár lehet, hogy a HTTP-állapotkód a válaszüzenetek különböző.</span><span class="sxs-lookup"><span data-stu-id="98de3-113">For example, sending multiple DELETE requests to the same URI should have the same effect, although the HTTP status code in the response messages may be different.</span></span> <span data-ttu-id="98de3-114">Az első törlési kérés előfordulhat, hogy vissza állapotkód: 204 (nincs tartalom), miközben egy későbbi törlési kérés előfordulhat, hogy térjen vissza az állapotkód: 404-es (nem található).</span><span class="sxs-lookup"><span data-stu-id="98de3-114">The first DELETE request might return status code 204 (No Content), while a subsequent DELETE request might return status code 404 (Not Found).</span></span>

> [!NOTE]
> <span data-ttu-id="98de3-115">A cikk [idempotencia minták](http://blog.jonathanoliver.com/idempotency-patterns/) Jonathan Oliver blogjában áttekintést idempotencia, és hogyan vonatkozik az felügyeleti műveleteket.</span><span class="sxs-lookup"><span data-stu-id="98de3-115">The article [Idempotency Patterns](http://blog.jonathanoliver.com/idempotency-patterns/) on Jonathan Oliver’s blog provides an overview of idempotency and how it relates to data management operations.</span></span>
>

### <a name="post-actions-that-create-new-resources-should-not-have-unrelated-side-effects"></a><span data-ttu-id="98de3-116">Hozzon létre új erőforrások utáni műveletek kell nem rendelkezik egymástól független hatásai</span><span class="sxs-lookup"><span data-stu-id="98de3-116">POST actions that create new resources should not have unrelated side-effects</span></span>

<span data-ttu-id="98de3-117">Hozzon létre egy új erőforrást egy POST kérést olyan, ha a kérelem eredő korlátozódik az új erőforrás (és valószínűleg bármely közvetlenül kapcsolódó erőforrások esetén valamilyen kapcsolat érintett) például egy kereskedelmi rendszerben POST kérelmet létrehoz egy új rendelést, az ügyfél is előfordulhat, hogy módosítani kell a készlet szintek és számlázási adatokat, de nem módosíthatja a sorrend nem közvetlenül kapcsolódó információkat vagy mellékhatásokkal bármely más – a rendszer általános állapotát.</span><span class="sxs-lookup"><span data-stu-id="98de3-117">If a POST request is intended to create a new resource, the effects of the request should be limited to the new resource (and possibly any directly related resources if there is some sort of linkage involved) For example, in an ecommerce system, a POST request that creates a new order for a customer might also amend inventory levels and generate billing information, but it should not modify information not directly related to the order or have any other side-effects on the overall state of the system.</span></span>

### <a name="avoid-implementing-chatty-post-put-and-delete-operations"></a><span data-ttu-id="98de3-118">Kerülje a chatty POST, PUT és DELETE műveletek végrehajtása</span><span class="sxs-lookup"><span data-stu-id="98de3-118">Avoid implementing chatty POST, PUT, and DELETE operations</span></span>

<span data-ttu-id="98de3-119">Támogatja a POST, PUT és DELETE kérelmek felett erőforrást gyűjtemények.</span><span class="sxs-lookup"><span data-stu-id="98de3-119">Support POST, PUT and DELETE requests over resource collections.</span></span> <span data-ttu-id="98de3-120">Egy POST kérést is tartalmazza az új erőforrások több, és adja hozzá az összes ugyanaz a gyűjtemény, PUT-kérelmekben lecserélheti egy gyűjtemény-erőforrások teljes készletét, és a törlési kérelem távolíthatja el egy teljes gyűjteményt.</span><span class="sxs-lookup"><span data-stu-id="98de3-120">A POST request can contain the details for multiple new resources and add them all to the same collection, a PUT request can replace the entire set of resources in a collection, and a DELETE request can remove an entire collection.</span></span>

<span data-ttu-id="98de3-121">Kötegelt kérelmekben teszi lehetővé az OData-támogatást ASP.NET Web API 2 szerepel.</span><span class="sxs-lookup"><span data-stu-id="98de3-121">The OData support included in ASP.NET Web API 2 provides the ability to batch requests.</span></span> <span data-ttu-id="98de3-122">Egy ügyfélalkalmazás becsomagolhatja a több webes API-kérelmek és küldje el a kiszolgáló a egyetlen HTTP-kérelmek, és egyetlen HTTP-válasz tartalmazza a válaszok az egyes kérelmek fogadására.</span><span class="sxs-lookup"><span data-stu-id="98de3-122">A client application can package up several web API requests and send them to the server in a single HTTP request, and receive a single HTTP response that contains the replies to each request.</span></span> <span data-ttu-id="98de3-123">További információ [kötegelt támogatást bevezeti a webes API- és webes API OData](http://blogs.msdn.com/b/webdev/archive/2013/11/01/introducing-batch-support-in-web-api-and-web-api-odata.aspx).</span><span class="sxs-lookup"><span data-stu-id="98de3-123">For more information, [Introducing Batch Support in Web API and Web API OData](http://blogs.msdn.com/b/webdev/archive/2013/11/01/introducing-batch-support-in-web-api-and-web-api-odata.aspx).</span></span>

### <a name="follow-the-http-specification-when-sending-a-response"></a><span data-ttu-id="98de3-124">A válasz küldésekor, hajtsa végre a HTTP-specifikáció</span><span class="sxs-lookup"><span data-stu-id="98de3-124">Follow the HTTP specification when sending a response</span></span> 

<span data-ttu-id="98de3-125">Egy webes API-t, hogy a megfelelő HTTP-állapotkód: ahhoz, hogy az ügyfél határozza meg, hogyan legyen kezelve az eredmény, a megfelelő HTTP-fejlécek, hogy az ügyfél megértette az eredmény, és az ügyfél számára, hogy megfelelően formázott törzs tartalmazó üzenetek kell visszaadnia. az eredmény elemzése.</span><span class="sxs-lookup"><span data-stu-id="98de3-125">A web API must return messages that contain the correct HTTP status code to enable the client to determine how to handle the result, the appropriate HTTP headers so that the client understands the nature of the result, and a suitably formatted body to enable the client to parse the result.</span></span> 

<span data-ttu-id="98de3-126">Például a POST műveletet kell visszaadnia állapotkód (létrehozva) 201 és a válaszüzenetet a helyet megjelölő fejlécet a válaszüzenet bele kell foglalni az újonnan létrehozott erőforrás URI.</span><span class="sxs-lookup"><span data-stu-id="98de3-126">For example, a POST operation should return status code 201 (Created) and the response message should include the URI of the newly created resource in the Location header of the response message.</span></span>

### <a name="support-content-negotiation"></a><span data-ttu-id="98de3-127">Támogatja a tartalom egyeztetését</span><span class="sxs-lookup"><span data-stu-id="98de3-127">Support content negotiation</span></span>

<span data-ttu-id="98de3-128">A válasz üzenet törzsét tartalmazhat adatok többféle formátumúak.</span><span class="sxs-lookup"><span data-stu-id="98de3-128">The body of a response message may contain data in a variety of formats.</span></span> <span data-ttu-id="98de3-129">Például egy HTTP GET kérést sikerült elküldeni JSON, vagy XML-formátuma.</span><span class="sxs-lookup"><span data-stu-id="98de3-129">For example, an HTTP GET request could return data in JSON, or XML format.</span></span> <span data-ttu-id="98de3-130">Az ügyfél elküldte a kérelmet, azt is adja meg az Accept fejlécet, amely meghatározza az adatok formátumok, amelyet kezelni tud.</span><span class="sxs-lookup"><span data-stu-id="98de3-130">When the client submits a request, it can include an Accept header that specifies the data formats that it can handle.</span></span> <span data-ttu-id="98de3-131">Ezek a formátumok adathordozó-típusok vannak megadva.</span><span class="sxs-lookup"><span data-stu-id="98de3-131">These formats are specified as media types.</span></span> <span data-ttu-id="98de3-132">Ügyfél, amely kibocsát egy GET kérelmet, amely lekéri a lemezkép megadhatja például, egy Accept fejlécet, amely az ügyfél képes kezelni, például a "kép/jpeg, kép/gif, kép vagy png" média-típusok listája.</span><span class="sxs-lookup"><span data-stu-id="98de3-132">For example, a client that issues a GET request that retrieves an image can specify an Accept header that lists the media types that the client can handle, such as "image/jpeg, image/gif, image/png".</span></span>  <span data-ttu-id="98de3-133">A webes API-t az eredményt adja vissza, ha azt kell adatok formázásához médiatípust egyikének használatával, és adja meg a formátum a válasz a Content-Type fejléc.</span><span class="sxs-lookup"><span data-stu-id="98de3-133">When the web API returns the result, it should format the data by using one of these media types and specify the format in the Content-Type header of the response.</span></span>

<span data-ttu-id="98de3-134">Ha az ügyfél nem adott meg az Accept fejlécet, majd formátumának a használatára nem ésszerű alapértelmezett a választörzset.</span><span class="sxs-lookup"><span data-stu-id="98de3-134">If the client does not specify an Accept header, then use a sensible default format for the response body.</span></span> <span data-ttu-id="98de3-135">Tegyük fel az ASP.NET Web API-keretrendszer alapértelmezés szerint az JSON szöveges adatok.</span><span class="sxs-lookup"><span data-stu-id="98de3-135">As an example, the ASP.NET Web API framework defaults to JSON for text-based data.</span></span>

### <a name="provide-links-to-support-hateoas-style-navigation-and-discovery-of-resources"></a><span data-ttu-id="98de3-136">Tartalmaznak egy HATEOAS stílusú navigációs és az erőforrások felderítési támogatása</span><span class="sxs-lookup"><span data-stu-id="98de3-136">Provide links to support HATEOAS-style navigation and discovery of resources</span></span>

<span data-ttu-id="98de3-137">A HATEOAS megközelítés lehetővé teszi az ügyfél keresse meg és felderíthetik az erőforrásokat egy kezdeti kiindulási pontot.</span><span class="sxs-lookup"><span data-stu-id="98de3-137">The HATEOAS approach enables a client to navigate and discover resources from an initial starting point.</span></span> <span data-ttu-id="98de3-138">Ez az tartalmazó URI-azonosítók; hivatkozások használatával érhető el Amikor egy ügyfél megszerezni egy erőforrást HTTP GET kérelmet ad ki, a válasz URI-azonosítók, amelyek lehetővé teszik egy ügyfélalkalmazás bármely közvetlenül kapcsolódó erőforrások kereshetők meg gyorsan kell tartalmaznia.</span><span class="sxs-lookup"><span data-stu-id="98de3-138">This is achieved by using links containing URIs; when a client issues an HTTP GET request to obtain a resource, the response should contain URIs that enable a client application to quickly locate any directly related resources.</span></span> <span data-ttu-id="98de3-139">Például a webes API-k, amely az elektronikus kereskedelmi megoldás támogatja, az ügyfél esetleg elhelyezett megrendelést.</span><span class="sxs-lookup"><span data-stu-id="98de3-139">For example, in a web API that supports an e-commerce solution, a customer may have placed many orders.</span></span> <span data-ttu-id="98de3-140">Ha egy ügyfél-alkalmazás adatait ügyfél olvas be, a válasz hivatkozások, amelyek lehetővé teszik az ügyfélalkalmazás küldeni HTTP GET kérelmeket, amelyek ezeket a rendeléseket kell tartalmaznia.</span><span class="sxs-lookup"><span data-stu-id="98de3-140">When a client application retrieves the details for a customer, the response should include links that enable the client application to send HTTP GET requests that can retrieve these orders.</span></span> <span data-ttu-id="98de3-141">Emellett HATEOAS stílusú hivatkozások le kell írnia a többi művelet (POST, PUT, DELETE, és így tovább), hogy minden kapcsolódó erőforrás által támogatott minden egyes kérelem teljesítéséhez a hozzá tartozó URI együtt.</span><span class="sxs-lookup"><span data-stu-id="98de3-141">Additionally, HATEOAS-style links should describe the other operations (POST, PUT, DELETE, and so on) that each linked resource supports together with the corresponding URI to perform each request.</span></span> <span data-ttu-id="98de3-142">Ez a megközelítés a további részletes leírását lásd [API tervezési][api-design].</span><span class="sxs-lookup"><span data-stu-id="98de3-142">This approach is described in more detail in [API Design][api-design].</span></span>

<span data-ttu-id="98de3-143">Jelenleg nincsenek HATEOAS végrehajtásának meghatározó szabványok nem, de a következő példában látható módon egy lehetséges módszer.</span><span class="sxs-lookup"><span data-stu-id="98de3-143">Currently there are no standards that govern the implementation of HATEOAS, but the following example illustrates one possible approach.</span></span> <span data-ttu-id="98de3-144">Ebben a példában a részletek megtalált ügyfél HTTP GET kérelemre adja vissza egy választ, amely az adott ügyfélhez tartozó rendelések hivatkozó HATEOAS mutató hivatkozásokat tartalmaznak:</span><span class="sxs-lookup"><span data-stu-id="98de3-144">In this example, an HTTP GET request that finds the details for a customer returns a response that include HATEOAS links that reference the orders for that customer:</span></span>

```HTTP
GET http://adventure-works.com/customers/2 HTTP/1.1
Accept: text/json
...
```

```HTTP
HTTP/1.1 200 OK
...
Content-Type: application/json; charset=utf-8
...
Content-Length: ...
{"CustomerID":2,"CustomerName":"Bert","Links":[
    {"rel":"self",
    "href":"http://adventure-works.com/customers/2",
    "action":"GET",
    "types":["text/xml","application/json"]},
    {"rel":"self",
    "href":"http://adventure-works.com/customers/2",
    "action":"PUT",
    "types":["application/x-www-form-urlencoded"]},
    {"rel":"self",
    "href":"http://adventure-works.com/customers/2",
    "action":"DELETE",
    "types":[]},
    {"rel":"orders",
    "href":"http://adventure-works.com/customers/2/orders",
    "action":"GET",
    "types":["text/xml","application/json"]},
    {"rel":"orders",
    "href":"http://adventure-works.com/customers/2/orders",
    "action":"POST",
    "types":["application/x-www-form-urlencoded"]}
]}
```

<span data-ttu-id="98de3-145">Ebben a példában a felhasználói adatok által képviselt a `Customer` osztály a következő kódrészletben látható.</span><span class="sxs-lookup"><span data-stu-id="98de3-145">In this example, the customer data is represented by the `Customer` class shown in the following code snippet.</span></span> <span data-ttu-id="98de3-146">A HATEOAS hivatkozások tartják a `Links` gyűjteménytulajdonság:</span><span class="sxs-lookup"><span data-stu-id="98de3-146">The HATEOAS links are held in the `Links` collection property:</span></span>

```csharp
public class Customer
{
    public int CustomerID { get; set; }
    public string CustomerName { get; set; }
    public List<Link> Links { get; set; }
    ...
}

public class Link
{
    public string Rel { get; set; }
    public string Href { get; set; }
    public string Action { get; set; }
    public string [] Types { get; set; }
}
```

<span data-ttu-id="98de3-147">A HTTP GET művelet lekérdezi a felhasználói adatok tárolási és szerkezetek egy `Customer` objektumot, és majd feltölti a `Links` gyűjtemény.</span><span class="sxs-lookup"><span data-stu-id="98de3-147">The HTTP GET operation retrieves the customer data from storage and constructs a `Customer` object, and then populates the `Links` collection.</span></span> <span data-ttu-id="98de3-148">Az eredmény válaszüzenetet JSON formátumúak.</span><span class="sxs-lookup"><span data-stu-id="98de3-148">The result is formatted as a JSON response message.</span></span> <span data-ttu-id="98de3-149">Mindegyik hivatkozás a következő mezőket tartalmazza:</span><span class="sxs-lookup"><span data-stu-id="98de3-149">Each link comprises the following fields:</span></span>

* <span data-ttu-id="98de3-150">A visszaküldött objektum és a kapcsolat által ismertetett objektum közötti kapcsolat.</span><span class="sxs-lookup"><span data-stu-id="98de3-150">The relationship between the object being returned and the object described by the link.</span></span> <span data-ttu-id="98de3-151">Ebben az esetben "önkiszolgáló" azt jelzi, hogy a hivatkozás egy hivatkozást az objektum (hasonlóan egy `this` sok objektumorientált nyelvű mutató), "rendelések" Ez a név az ahhoz kapcsolódó információkat tartalmazó gyűjtemény.</span><span class="sxs-lookup"><span data-stu-id="98de3-151">In this case "self" indicates that the link is a reference back to the object itself (similar to a `this` pointer in many object-oriented languages), and "orders" is the name of a collection containing the related order information.</span></span>
* <span data-ttu-id="98de3-152">A hivatkozás (`Href`) által URI formájában hivatkozás alatt leírt objektumhoz.</span><span class="sxs-lookup"><span data-stu-id="98de3-152">The hyperlink (`Href`) for the object being described by the link in the form of a URI.</span></span>
* <span data-ttu-id="98de3-153">A HTTP-kérelem típusa (`Action`), amely ezt az URI lehet küldeni.</span><span class="sxs-lookup"><span data-stu-id="98de3-153">The type of HTTP request (`Action`) that can be sent to this URI.</span></span>
* <span data-ttu-id="98de3-154">Adatok formátuma (`Types`), amely kell adni a HTTP kérelem, vagy adhatók vissza a válaszban, a kérelem típusától függően.</span><span class="sxs-lookup"><span data-stu-id="98de3-154">The format of any data (`Types`) that should be provided in the HTTP request or that can be returned in the response, depending on the type of the request.</span></span>

<span data-ttu-id="98de3-155">A példa HTTP-válasz HATEOAS hivatkozások arra utal, hogy egy ügyfél-alkalmazás a következő műveleteket hajthat végre:</span><span class="sxs-lookup"><span data-stu-id="98de3-155">The HATEOAS links shown in the example HTTP response indicate that a client application can perform the following operations:</span></span>

* <span data-ttu-id="98de3-156">Az URI azonosító a HTTP GET kérelemre `http://adventure-works.com/customers/2` az ügyfél (újra) részleteinek beolvasása.</span><span class="sxs-lookup"><span data-stu-id="98de3-156">An HTTP GET request to the URI `http://adventure-works.com/customers/2` to fetch the details of the customer (again).</span></span> <span data-ttu-id="98de3-157">Az adatok adhatók vissza XML-vagy JSON-NÁ.</span><span class="sxs-lookup"><span data-stu-id="98de3-157">The data can be returned as XML or JSON.</span></span>
* <span data-ttu-id="98de3-158">Az URI egy HTTP PUT-kérelmet `http://adventure-works.com/customers/2` módosításához az ügyfél részletes adatait.</span><span class="sxs-lookup"><span data-stu-id="98de3-158">An HTTP PUT request to the URI `http://adventure-works.com/customers/2` to modify the details of the customer.</span></span> <span data-ttu-id="98de3-159">Az új adatokat a kérelemüzenet x-www-form-urlencoded formátumban kell megadni.</span><span class="sxs-lookup"><span data-stu-id="98de3-159">The new data must be provided in the request message in x-www-form-urlencoded format.</span></span>
* <span data-ttu-id="98de3-160">Az URI egy HTTP DELETE kérelmet `http://adventure-works.com/customers/2` az ügyfél törli.</span><span class="sxs-lookup"><span data-stu-id="98de3-160">An HTTP DELETE request to the URI `http://adventure-works.com/customers/2` to delete the customer.</span></span> <span data-ttu-id="98de3-161">A kérelem nem minden további információkra, vagy vissza adatokat a válasz üzenet törzsében.</span><span class="sxs-lookup"><span data-stu-id="98de3-161">The request does not expect any additional information or return data in the response message body.</span></span>
* <span data-ttu-id="98de3-162">Az URI azonosító a HTTP GET kérelemre `http://adventure-works.com/customers/2/orders` az ügyfél a rendeléseket kereséséhez.</span><span class="sxs-lookup"><span data-stu-id="98de3-162">An HTTP GET request to the URI `http://adventure-works.com/customers/2/orders` to find all the orders for the customer.</span></span> <span data-ttu-id="98de3-163">Az adatok adhatók vissza XML-vagy JSON-NÁ.</span><span class="sxs-lookup"><span data-stu-id="98de3-163">The data can be returned as XML or JSON.</span></span>
* <span data-ttu-id="98de3-164">Az URI egy HTTP PUT-kérelmet `http://adventure-works.com/customers/2/orders` hozzon létre egy új ahhoz, hogy az ügyfél számára.</span><span class="sxs-lookup"><span data-stu-id="98de3-164">An HTTP PUT request to the URI `http://adventure-works.com/customers/2/orders` to create a new order for this customer.</span></span> <span data-ttu-id="98de3-165">Az adatok a kérelemüzenet x-www-form-urlencoded formátumban kell megadni.</span><span class="sxs-lookup"><span data-stu-id="98de3-165">The data must be provided in the request message in x-www-form-urlencoded format.</span></span>

## <a name="handling-exceptions"></a><span data-ttu-id="98de3-166">Kivételek kezelése</span><span class="sxs-lookup"><span data-stu-id="98de3-166">Handling exceptions</span></span>

<span data-ttu-id="98de3-167">Ha egy művelet nem kezelt kivételt jelez, vegye figyelembe a következő szempontokat.</span><span class="sxs-lookup"><span data-stu-id="98de3-167">Consider the following points if an operation throws an uncaught exception.</span></span>

### <a name="capture-exceptions-and-return-a-meaningful-response-to-clients"></a><span data-ttu-id="98de3-168">Rögzítheti a kivételeket, és az ügyfelek számára értelmes választ</span><span class="sxs-lookup"><span data-stu-id="98de3-168">Capture exceptions and return a meaningful response to clients</span></span>

<span data-ttu-id="98de3-169">A HTTP-művelet megvalósító kódot kell biztosítania az átfogó kivétel kezelése és terjesztése a keretrendszer nem kezelt kivételek helyett.</span><span class="sxs-lookup"><span data-stu-id="98de3-169">The code that implements an HTTP operation should provide comprehensive exception handling rather than letting uncaught exceptions propagate to the framework.</span></span> <span data-ttu-id="98de3-170">Kivétel nem teszi lehetővé a művelet sikeres, ha vissza a válaszüzenetben található függvénynek adható át a kivételt, de egy beszédes leírást, a hiba a kivételt okozó tartalmaznia kell.</span><span class="sxs-lookup"><span data-stu-id="98de3-170">If an exception makes it impossible to complete the operation successfully, the exception can be passed back in the response message, but it should include a meaningful description of the error that caused the exception.</span></span> <span data-ttu-id="98de3-171">A kivétel is tartalmaznia kell minden esetben egyszerűen adatszolgáltató állapotkódja 500 a megfelelő HTTP-állapotkód helyett.</span><span class="sxs-lookup"><span data-stu-id="98de3-171">The exception should also include the appropriate HTTP status code rather than simply returning status code 500 for every situation.</span></span> <span data-ttu-id="98de3-172">Például, ha a felhasználó kérésére, amely megsérti a korlátozás (például egy ügyfél, amely rendelkezik a nyitott rendelések törlésére tett kísérlet) adatbázis frissítése miatt, térjen vissza állapot kód 409 (Ütközés) és az ütközés okát jelző üzenet törzse.</span><span class="sxs-lookup"><span data-stu-id="98de3-172">For example, if a user request causes a database update that violates a constraint (such as attempting to delete a customer that has outstanding orders), you should return status code 409 (Conflict) and a message body indicating the reason for the conflict.</span></span> <span data-ttu-id="98de3-173">Ha bizonyos más feltétel Ez a beállítás a kérelem elérhetetlen, állapotkód: 400 (hibás kérés) térhet vissza.</span><span class="sxs-lookup"><span data-stu-id="98de3-173">If some other condition renders the request unachievable, you can return status code 400 (Bad Request).</span></span> <span data-ttu-id="98de3-174">A HTTP-állapotkódok teljes listáját megtalálhatja a [állapotkódok definícióit](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) lap a W3C-webhelyen.</span><span class="sxs-lookup"><span data-stu-id="98de3-174">You can find a full list of HTTP status codes on the [Status Code Definitions](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) page on the W3C website.</span></span>

<span data-ttu-id="98de3-175">A Kódpélda trapek különböző feltételeket, és egy megfelelő választ ad vissza.</span><span class="sxs-lookup"><span data-stu-id="98de3-175">The code example traps different conditions and returns an appropriate response.</span></span>

```csharp
[HttpDelete]
[Route("customers/{id:int}")]
public IHttpActionResult DeleteCustomer(int id)
{
    try
    {
        // Find the customer to be deleted in the repository
        var customerToDelete = repository.GetCustomer(id);

        // If there is no such customer, return an error response
        // with status code 404 (Not Found)
        if (customerToDelete == null)
        {
                return NotFound();
        }

        // Remove the customer from the repository
        // The DeleteCustomer method returns true if the customer
        // was successfully deleted
        if (repository.DeleteCustomer(id))
        {
            // Return a response message with status code 204 (No Content)
            // To indicate that the operation was successful
            return StatusCode(HttpStatusCode.NoContent);
        }
        else
        {
            // Otherwise return a 400 (Bad Request) error response
            return BadRequest(Strings.CustomerNotDeleted);
        }
    }
    catch
    {
        // If an uncaught exception occurs, return an error response
        // with status code 500 (Internal Server Error)
        return InternalServerError();
    }
}
```

> [!TIP]
> <span data-ttu-id="98de3-176">Ne adjon meg információt, hogy egy támadó megpróbálta behatoljanak az API-érdemes lehet.</span><span class="sxs-lookup"><span data-stu-id="98de3-176">Do not include information that could be useful to an attacker attempting to penetrate your API.</span></span>
  
<span data-ttu-id="98de3-177">Sok webkiszolgáló trapfeltételek hiba magukat a webes API elérése előtti.</span><span class="sxs-lookup"><span data-stu-id="98de3-177">Many web servers trap error conditions themselves before they reach the web API.</span></span> <span data-ttu-id="98de3-178">Például ha a webhely hitelesítést, és a felhasználó nem adja meg a megfelelő hitelesítési adatokat, a webkiszolgáló kell válaszolnia állapotkód 401 (nem engedélyezett).</span><span class="sxs-lookup"><span data-stu-id="98de3-178">For example, if you configure authentication for a web site and the user fails to provide the correct authentication information, the web server should respond with status code 401 (Unauthorized).</span></span> <span data-ttu-id="98de3-179">Amennyiben az ügyfél hitelesítése megtörtént, a kód végezheti a saját ellenőrzi, hogy ellenőrizze, hogy az ügyfél férnek hozzá a kért erőforrás kell lennie.</span><span class="sxs-lookup"><span data-stu-id="98de3-179">Once a client has been authenticated, your code can perform its own checks to verify that the client should be able access the requested resource.</span></span> <span data-ttu-id="98de3-180">Ha a hitelesítés sikertelen, térjen vissza állapotkód 403 (tiltott).</span><span class="sxs-lookup"><span data-stu-id="98de3-180">If this authorization fails, you should return status code 403 (Forbidden).</span></span>
 
### <a name="handle-exceptions-consistently-and-log-information-about-errors"></a><span data-ttu-id="98de3-181">Kivételek következetesen kezelnek, és a hibákkal kapcsolatos adatok</span><span class="sxs-lookup"><span data-stu-id="98de3-181">Handle exceptions consistently and log information about errors</span></span>

<span data-ttu-id="98de3-182">Egységes módon kezelje a kivételeket, vegye fontolóra egy globális hibakezelési stratégia a teljes webes API-k között.</span><span class="sxs-lookup"><span data-stu-id="98de3-182">To handle exceptions in a consistent manner, consider implementing a global error handling strategy across the entire web API.</span></span> <span data-ttu-id="98de3-183">Is tartalmazniuk kell a naplózás, amely részletesen az egyes kivétel; rögzíti hiba Ez a hiba napló részletes információkat is tartalmazhat, mindaddig, amíg azt nem elérhetővé válik az interneten keresztül az ügyfelek számára.</span><span class="sxs-lookup"><span data-stu-id="98de3-183">You should also incorporate error logging which captures the full details of each exception; this error log can contain detailed information as long as it is not made accessible over the web to clients.</span></span> 

### <a name="distinguish-between-client-side-errors-and-server-side-errors"></a><span data-ttu-id="98de3-184">Hibák az ügyféloldali és kiszolgálóoldali hibák megkülönböztetésére</span><span class="sxs-lookup"><span data-stu-id="98de3-184">Distinguish between client-side errors and server-side errors</span></span>

<span data-ttu-id="98de3-185">A HTTP protokoll különböztet miatt az ügyfélalkalmazás (a HTTP 4xx állapotkódok) előforduló hibákat, és a kiszolgálón (a HTTP 5xx állapotkódok) szülőmappához által okozott hibákat.</span><span class="sxs-lookup"><span data-stu-id="98de3-185">The HTTP protocol distinguishes between errors that occur due to the client application (the HTTP 4xx status codes), and errors that are caused by a mishap on the server (the HTTP 5xx status codes).</span></span> <span data-ttu-id="98de3-186">Győződjön meg arról, hogy a válasz hibaüzeneteket az egyezmény tiszteletben.</span><span class="sxs-lookup"><span data-stu-id="98de3-186">Make sure that you respect this convention in any error response messages.</span></span>

## <a name="optimizing-client-side-data-access"></a><span data-ttu-id="98de3-187">Ügyféloldali adatelérési optimalizálása</span><span class="sxs-lookup"><span data-stu-id="98de3-187">Optimizing client-side data access</span></span>
<span data-ttu-id="98de3-188">Például a webkiszolgáló és az ügyfélalkalmazások elosztott környezetben a hálózati érintő elsődleges forrásokból.</span><span class="sxs-lookup"><span data-stu-id="98de3-188">In a distributed environment such as that involving a web server and client applications, one of the primary sources of concern is the network.</span></span> <span data-ttu-id="98de3-189">Ez működhet, és jelentős szűk keresztmetszet, különösen akkor, ha az ügyfélalkalmazás gyakran kérelmeket küld vagy fogad adatokat.</span><span class="sxs-lookup"><span data-stu-id="98de3-189">This can act as a considerable bottleneck, especially if a client application is frequently sending requests or receiving data.</span></span> <span data-ttu-id="98de3-190">Ezért akkor érhető el a hálózaton keresztül zajló kommunikációról forgalom csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="98de3-190">Therefore you should aim to minimize the amount of traffic that flows across the network.</span></span> <span data-ttu-id="98de3-191">A kód lekéri és adatok karbantartása bevezetésekor, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="98de3-191">Consider the following points when you implement the code to retrieve and maintain data:</span></span>

### <a name="support-client-side-caching"></a><span data-ttu-id="98de3-192">Támogatja az ügyféloldali gyorsítótárazás</span><span class="sxs-lookup"><span data-stu-id="98de3-192">Support client-side caching</span></span>

<span data-ttu-id="98de3-193">A HTTP 1.1 protokoll támogatja a gyorsítótárazást az ügyfeleken és a köztes kiszolgálókon keresztül, amely egy kérelem webproxykiszolgálókra irányítja a Cache-Control fejléc használatát.</span><span class="sxs-lookup"><span data-stu-id="98de3-193">The HTTP 1.1 protocol supports caching in clients and intermediate servers through which a request is routed by the use of the Cache-Control header.</span></span> <span data-ttu-id="98de3-194">Amikor egy ügyfél-alkalmazás egy HTTP GET kérést küld a webes API-t, a válasz tartalmazhat egy Cache-Control-fejlécet, amely jelzi, hogy az adatokat a választörzs biztonságosan gyorsítótárazhatók az ügyfél vagy egy közbenső kiszolgálón, amelyen keresztül a kérelem volt irányíthatja, és mennyi ideig, mielőtt azt lejárati és elavult veszi figyelembe.</span><span class="sxs-lookup"><span data-stu-id="98de3-194">When a client application sends an HTTP GET request to the web API, the response can include a Cache-Control header that indicates whether the data in the body of the response can be safely cached by the client or an intermediate server through which the request has been routed, and for how long before it should expire and be considered out-of-date.</span></span> <span data-ttu-id="98de3-195">A következő példa bemutatja a HTTP GET kérelemre, és a sérülésre adott válasz, amely tartalmazza a Cache-Control fejléc:</span><span class="sxs-lookup"><span data-stu-id="98de3-195">The following example shows an HTTP GET request and the corresponding response that includes a Cache-Control header:</span></span>

```HTTP
GET http://adventure-works.com/orders/2 HTTP/1.1
```

```HTTP
HTTP/1.1 200 OK
...
Cache-Control: max-age=600, private
Content-Type: text/json; charset=utf-8
Content-Length: ...
{"orderID":2,"productID":4,"quantity":2,"orderValue":10.00}
```

<span data-ttu-id="98de3-196">Ebben a példában a Cache-Control-fejlécet határozza meg, hogy az adatok vissza kell lejárt 600 másodperc után csak egyetlen ügyfél számára megfelelő és nem kell más ügyfelek által használt megosztott gyorsítótárával tárolni (Ez *titkos*).</span><span class="sxs-lookup"><span data-stu-id="98de3-196">In this example, the Cache-Control header specifies that the data returned should be expired after 600 seconds, and is only suitable for a single client and must not be stored in a shared cache used by other clients (it is *private*).</span></span> <span data-ttu-id="98de3-197">Megadhatja a Cache-Control fejléc *nyilvános* helyett *titkos* ebben az esetben az adatok megosztott gyorsítótárával tárolhatja, vagy megadhatja azt *no-tároló* ebben az esetben az adatok kell **nem** kell az ügyfél gyorsítótárába.</span><span class="sxs-lookup"><span data-stu-id="98de3-197">The Cache-Control header could specify *public* rather than *private* in which case the data can be stored in a shared cache, or it could specify *no-store* in which case the data must **not** be cached by the client.</span></span> <span data-ttu-id="98de3-198">Az alábbi példakód bemutatja, hogyan hozható létre a válaszüzenetet Cache-Control fejléc:</span><span class="sxs-lookup"><span data-stu-id="98de3-198">The following code example shows how to construct a Cache-Control header in a response message:</span></span>

```csharp
public class OrdersController : ApiController
{
    ...
    [Route("api/orders/{id:int:min(0)}")]
    [HttpGet]
    public IHttpActionResult FindOrderByID(int id)
    {
        // Find the matching order
        Order order = ...;
        ...
        // Create a Cache-Control header for the response
        var cacheControlHeader = new CacheControlHeaderValue();
        cacheControlHeader.Private = true;
        cacheControlHeader.MaxAge = new TimeSpan(0, 10, 0);
        ...

        // Return a response message containing the order and the cache control header
        OkResultWithCaching<Order> response = new OkResultWithCaching<Order>(order, this)
        {
            CacheControlHeader = cacheControlHeader
        };
        return response;
    }
    ...
}
```

<span data-ttu-id="98de3-199">Ez a kód egy egyéni használ `IHttpActionResult` osztályt `OkResultWithCaching`.</span><span class="sxs-lookup"><span data-stu-id="98de3-199">This code makes use of a custom `IHttpActionResult` class named `OkResultWithCaching`.</span></span> <span data-ttu-id="98de3-200">Ez az osztály lehetővé teszi, hogy a tartományvezérlő beállítása a gyorsítótár fejléc tartalma:</span><span class="sxs-lookup"><span data-stu-id="98de3-200">This class enables the controller to set the cache header contents:</span></span>

```csharp
public class OkResultWithCaching<T> : OkNegotiatedContentResult<T>
{
    public OkResultWithCaching(T content, ApiController controller)
        : base(content, controller) { }

    public OkResultWithCaching(T content, IContentNegotiator contentNegotiator, HttpRequestMessage request, IEnumerable<MediaTypeFormatter> formatters)
        : base(content, contentNegotiator, request, formatters) { }

    public CacheControlHeaderValue CacheControlHeader { get; set; }
    public EntityTagHeaderValue ETag { get; set; }

    public override async Task<HttpResponseMessage> ExecuteAsync(CancellationToken cancellationToken)
    {
        HttpResponseMessage response;
        try
        {
            response = await base.ExecuteAsync(cancellationToken);
            response.Headers.CacheControl = this.CacheControlHeader;
            response.Headers.ETag = ETag;
        }
        catch (OperationCanceledException)
        {
            response = new HttpResponseMessage(HttpStatusCode.Conflict) {ReasonPhrase = "Operation was cancelled"};
        }
        return response;
    }
}
```

> [!NOTE]
> <span data-ttu-id="98de3-201">A HTTP protokollt is meghatároz. a *no-cache* fejlécéhez Cache-Control direktíva.</span><span class="sxs-lookup"><span data-stu-id="98de3-201">The HTTP protocol also defines the *no-cache* directive for the Cache-Control header.</span></span> <span data-ttu-id="98de3-202">Ahelyett, hogy megtévesztően Ez a direktíva nem jelent "nem gyorsítótárazzák" helyett "kísérelje meg újra érvényesítését a gyorsítótárban lévő adatokkal a kiszolgálóval való visszaküldés előtt."; de az adatok továbbra is gyorsítótárazható, de a rendszer minden alkalommal, amikor ellenőrzi segítségével győződjön meg arról, hogy az aktuális továbbra is.</span><span class="sxs-lookup"><span data-stu-id="98de3-202">Rather confusingly, this directive does not mean "do not cache" but rather "revalidate the cached information with the server before returning it"; the data can still be cached, but it is checked each time it is used to ensure that it is still current.</span></span>
>
>

<span data-ttu-id="98de3-203">Gyorsítótár kezelése feladata az ügyfélalkalmazás vagy köztes server, de ha a megfelelően megvalósított is sávszélességet, és a jobb teljesítmény érdekében szükség már nemrég beolvasása fetch adatokhoz.</span><span class="sxs-lookup"><span data-stu-id="98de3-203">Cache management is the responsibility of the client application or intermediate server, but if properly implemented it can save bandwidth and improve performance by removing the need to fetch data that has already been recently retrieved.</span></span>

<span data-ttu-id="98de3-204">A *maximális-életkora* a Cache-Control fejléc értéke csak egy útmutató, és nem biztosítja, hogy a megfelelő adatokat nem módosítja a megadott időszakban.</span><span class="sxs-lookup"><span data-stu-id="98de3-204">The *max-age* value in the Cache-Control header is only a guide and not a guarantee that the corresponding data won't change during the specified time.</span></span> <span data-ttu-id="98de3-205">A webes API-t kell beállítania a maximális életkora attól függően, hogy a várt illékonyság az adatok a megfelelő értéket.</span><span class="sxs-lookup"><span data-stu-id="98de3-205">The web API should set the max-age to a suitable value depending on the expected volatility of the data.</span></span> <span data-ttu-id="98de3-206">Ha ez az időszak lejár, az ügyfél törölnie kell az objektumot a gyorsítótárból.</span><span class="sxs-lookup"><span data-stu-id="98de3-206">When this period expires, the client should discard the object from the cache.</span></span>

> [!NOTE]
> <span data-ttu-id="98de3-207">A legtöbb modern böngésző támogatja, ügyféloldali gyorsítótárazás a megfelelő a cache-control fejlécek hozzáadásával a kérelmekre, és az eredmények a fejlécek vizsgálata leírtak szerint.</span><span class="sxs-lookup"><span data-stu-id="98de3-207">Most modern web browsers support client-side caching by adding the appropriate cache-control headers to requests and examining the headers of the results, as described.</span></span> <span data-ttu-id="98de3-208">Egyes régebbi böngészők azonban nem gyorsítótárazhatják az egy URL-címet, amely tartalmazza a lekérdezési karakterlánc által visszaadott értékeket.</span><span class="sxs-lookup"><span data-stu-id="98de3-208">However, some older browsers will not cache the values returned from a URL that includes a query string.</span></span> <span data-ttu-id="98de3-209">Ez a nem általában probléma valósítja meg a saját gyorsítótár felügyeleti stratégiájának a Microsofttól protokollon alapuló egyéni ügyfélalkalmazások esetében.</span><span class="sxs-lookup"><span data-stu-id="98de3-209">This is not usually an issue for custom client applications which implement their own cache management strategy based on the protocol discussed here.</span></span>
>
> <span data-ttu-id="98de3-210">Néhány régebbi proxyk ugyanilyen viselkedést, és előfordulhat, hogy gyorsítótárazzák URL-címek alapján a lekérdezési karakterláncokat tartalmazó kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="98de3-210">Some older proxies exhibit the same behavior and might not cache requests based on URLs with query strings.</span></span> <span data-ttu-id="98de3-211">Ez az egyedi ügyfél-alkalmazások például olyan proxyn keresztül a webkiszolgálóhoz való csatlakozáshoz problémát okozhat.</span><span class="sxs-lookup"><span data-stu-id="98de3-211">This could be an issue for custom client applications that connect to a web server through such a proxy.</span></span>
>

### <a name="provide-etags-to-optimize-query-processing"></a><span data-ttu-id="98de3-212">Adja meg a lekérdezés feldolgozása optimalizálása ETag-EK</span><span class="sxs-lookup"><span data-stu-id="98de3-212">Provide ETags to optimize query processing</span></span>

<span data-ttu-id="98de3-213">Ha egy ügyfélalkalmazás olvas be olyan objektum, a válaszüzenetet is tartalmazhatnak egy *ETag* (Entitáscímke).</span><span class="sxs-lookup"><span data-stu-id="98de3-213">When a client application retrieves an object, the response message can also include an *ETag* (Entity Tag).</span></span> <span data-ttu-id="98de3-214">Az ETag, amely jelzi, az erőforrás; verziója nem átlátszó karakterláncra minden alkalommal, amikor egy erőforrást módosítja az Etag is módosul.</span><span class="sxs-lookup"><span data-stu-id="98de3-214">An ETag is an opaque string that indicates the version of a resource; each time a resource changes the Etag is also modified.</span></span> <span data-ttu-id="98de3-215">Az ügyfélalkalmazás az ETag gyorsítótárazza az adatokat részeként.</span><span class="sxs-lookup"><span data-stu-id="98de3-215">This ETag should be cached as part of the data by the client application.</span></span> <span data-ttu-id="98de3-216">Az alábbi példakód bemutatja, hogyan adja hozzá az egy ETag HTTP GET kérelemre adott válasz részeként.</span><span class="sxs-lookup"><span data-stu-id="98de3-216">The following code example shows how to add an ETag as part of the response to an HTTP GET request.</span></span> <span data-ttu-id="98de3-217">Ezt a kódot használja a `GetHashCode` metódus az objektum létrehozása egy numerikus érték, amely azonosítja az objektum (ha szükséges, bírálja felül ezt a módszert és saját olyan algoritmussal, például az MD5 kivonatoló készítése):</span><span class="sxs-lookup"><span data-stu-id="98de3-217">This code uses the `GetHashCode` method of an object to generate a numeric value that identifies the object (you can override this method if necessary and generate your own hash using an algorithm such as MD5) :</span></span>

```csharp
public class OrdersController : ApiController
{
    ...
    public IHttpActionResult FindOrderByID(int id)
    {
        // Find the matching order
        Order order = ...;
        ...

        var hashedOrder = order.GetHashCode();
        string hashedOrderEtag = $"\"{hashedOrder}\"";
        var eTag = new EntityTagHeaderValue(hashedOrderEtag);

        // Return a response message containing the order and the cache control header
        OkResultWithCaching<Order> response = new OkResultWithCaching<Order>(order, this)
        {
            ...,
            ETag = eTag
        };
        return response;
    }
    ...
}
```

<span data-ttu-id="98de3-218">A webes API-k által közzétett válaszüzenetet így néz ki:</span><span class="sxs-lookup"><span data-stu-id="98de3-218">The response message posted by the web API looks like this:</span></span>

```HTTP
HTTP/1.1 200 OK
...
Cache-Control: max-age=600, private
Content-Type: text/json; charset=utf-8
ETag: "2147483648"
Content-Length: ...
{"orderID":2,"productID":4,"quantity":2,"orderValue":10.00}
```

> [!TIP]
> <span data-ttu-id="98de3-219">Biztonsági okokból nem engedélyezett bizalmas adatok vagy gyorsítótárazható hitelesített (HTTPS) kapcsolaton keresztül által visszaadott adatokat.</span><span class="sxs-lookup"><span data-stu-id="98de3-219">For security reasons, do not allow sensitive data or data returned over an authenticated (HTTPS) connection to be cached.</span></span>
>
>

<span data-ttu-id="98de3-220">Egy ügyfélalkalmazás is későbbi GET kérést erőforrást beolvasásához bármikor, és ha az erőforrás változott (rendelkezik egy eltérő ETag) nem használhatók fel a gyorsítótárazott verzió és az új verzió kerüljön a gyorsítótárba.</span><span class="sxs-lookup"><span data-stu-id="98de3-220">A client application can issue a subsequent GET request to retrieve the same resource at any time, and if the resource has changed (it has a different ETag) the cached version should be discarded and the new version added to the cache.</span></span> <span data-ttu-id="98de3-221">Ha egy erőforrás nagy, és az ügyfélnek küldött sávszélesség jelentős időt igényel, ugyanazok az adatok lehívása ismétlődő kérelmek nem elég hatékony válhat.</span><span class="sxs-lookup"><span data-stu-id="98de3-221">If a resource is large and requires a significant amount of bandwidth to transmit back to the client, repeated requests to fetch the same data can become inefficient.</span></span> <span data-ttu-id="98de3-222">Ez elleni, a HTTP protokoll meghatározza, hogy a GET kérelmek egy webes API-t támogató kell optimalizálása a következő folyamat:</span><span class="sxs-lookup"><span data-stu-id="98de3-222">To combat this, the HTTP protocol defines the following process for optimizing GET requests that you should support in a web API:</span></span>

* <span data-ttu-id="98de3-223">Az ügyfél az If-None-Match HTTP-fejlécekben hivatkozott erőforrás-jelenleg gyorsítótárazott verziójának ETag tartalmazó GET kérést hoz létre:</span><span class="sxs-lookup"><span data-stu-id="98de3-223">The client constructs a GET request containing the ETag for the currently cached version of the resource referenced in an If-None-Match HTTP header:</span></span>

    ```HTTP
    GET http://adventure-works.com/orders/2 HTTP/1.1
    If-None-Match: "2147483648"
    ```
* <span data-ttu-id="98de3-224">A webes API-t a GET műveletet szerzi be a jelenlegi ETag a kért adatok (2. sorrendje a fenti példában), és összehasonlítja az értéket az If-None-Match fejléc.</span><span class="sxs-lookup"><span data-stu-id="98de3-224">The GET operation in the web API obtains the current ETag for the requested data (order 2 in the above example), and compares it to the value in the If-None-Match header.</span></span>
* <span data-ttu-id="98de3-225">Ha a jelenlegi ETag a kért adatok megegyezik a kérés megadott ETag, az erőforrás nem változott, és a webes API-t egy HTTP-válasz 304 (nem módosított) állapotkódot és egy üres üzenettörzs kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="98de3-225">If the current ETag for the requested data matches the ETag provided by the request, the resource has not changed and the web API should return an HTTP response with an empty message body and a status code of 304 (Not Modified).</span></span>
* <span data-ttu-id="98de3-226">A kért adatok jelenlegi ETag nem egyezik a kérelem által biztosított, ha az adatok változásairól, és a webes API-t kell visszaadnia egy HTTP-válasz az új adatokkal az üzenettörzs és 200-as (OK) állapotkódot.</span><span class="sxs-lookup"><span data-stu-id="98de3-226">If the current ETag for the requested data does not match the ETag provided by the request, then the data has changed and the web API should return an HTTP response with the new data in the message body and a status code of 200 (OK).</span></span>
* <span data-ttu-id="98de3-227">Ha a kért adatok már nem létezik a webes API-t az állapotkód: 404-es (nem található), egy HTTP-válasz kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="98de3-227">If the requested data no longer exists then the web API should return an HTTP response with the status code of 404 (Not Found).</span></span>
* <span data-ttu-id="98de3-228">Az ügyfél az állapotkód: használja a gyorsítótár karbantartása.</span><span class="sxs-lookup"><span data-stu-id="98de3-228">The client uses the status code to maintain the cache.</span></span> <span data-ttu-id="98de3-229">Ha az adatok nem változott (állapotkód 304), akkor az objektum gyorsítótárazott maradhat, és az ügyfélalkalmazás továbbra is az az objektum jelenlegi verzióját használja.</span><span class="sxs-lookup"><span data-stu-id="98de3-229">If the data has not changed (status code 304) then the object can remain cached and the client application should continue to use this version of the object.</span></span> <span data-ttu-id="98de3-230">Ha az adatok megváltozott (állapotkód 200), majd a gyorsítótárazott objektum kellene, és az újat kerülnek.</span><span class="sxs-lookup"><span data-stu-id="98de3-230">If the data has changed (status code 200) then the cached object should be discarded and the new one inserted.</span></span> <span data-ttu-id="98de3-231">Ha már nem érhető el az adatokat (állapotkód: 404), majd az objektum el kell távolítani a gyorsítótárból.</span><span class="sxs-lookup"><span data-stu-id="98de3-231">If the data is no longer available (status code 404) then the object should be removed from the cache.</span></span>

> [!NOTE]
> <span data-ttu-id="98de3-232">Ha a válasz fejléce a Cache-Control fejléc-tároló nem tartalmaz, akkor az objektum mindig el kell távolítani a gyorsítótárból, függetlenül a HTTP-állapotkód:.</span><span class="sxs-lookup"><span data-stu-id="98de3-232">If the response header contains the Cache-Control header no-store then the object should always be removed from the cache regardless of the HTTP status code.</span></span>
>

<span data-ttu-id="98de3-233">Az alábbi kódot a `FindOrderByID` metódus terjeszteni az If-None-Match fejléc támogatja.</span><span class="sxs-lookup"><span data-stu-id="98de3-233">The code below shows the `FindOrderByID` method extended to support the If-None-Match header.</span></span> <span data-ttu-id="98de3-234">Figyelje meg, hogy ha az If-None-Match fejléc hiányzik, a megadott sorrendben mindig olvassa:</span><span class="sxs-lookup"><span data-stu-id="98de3-234">Notice that if the If-None-Match header is omitted, the specified order is always retrieved:</span></span>

```csharp
public class OrdersController : ApiController
{
    [Route("api/orders/{id:int:min(0)}")]
    [HttpGet]
    public IHttpActionResult FindOrderByID(int id)
    {
        try
        {
            // Find the matching order
            Order order = ...;

            // If there is no such order then return NotFound
            if (order == null)
            {
                return NotFound();
            }

            // Generate the ETag for the order
            var hashedOrder = order.GetHashCode();
            string hashedOrderEtag = $"\"{hashedOrder}\"";

            // Create the Cache-Control and ETag headers for the response
            IHttpActionResult response;
            var cacheControlHeader = new CacheControlHeaderValue();
            cacheControlHeader.Public = true;
            cacheControlHeader.MaxAge = new TimeSpan(0, 10, 0);
            var eTag = new EntityTagHeaderValue(hashedOrderEtag);

            // Retrieve the If-None-Match header from the request (if it exists)
            var nonMatchEtags = Request.Headers.IfNoneMatch;

            // If there is an ETag in the If-None-Match header and
            // this ETag matches that of the order just retrieved,
            // then create a Not Modified response message
            if (nonMatchEtags.Count > 0 &&
                String.CompareOrdinal(nonMatchEtags.First().Tag, hashedOrderEtag) == 0)
            {
                response = new EmptyResultWithCaching()
                {
                    StatusCode = HttpStatusCode.NotModified,
                    CacheControlHeader = cacheControlHeader,
                    ETag = eTag
                };
            }
            // Otherwise create a response message that contains the order details
            else
            {
                response = new OkResultWithCaching<Order>(order, this)
                {
                    CacheControlHeader = cacheControlHeader,
                    ETag = eTag
                };
            }

            return response;
        }
        catch
        {
            return InternalServerError();
        }
    }
...
}
```

<span data-ttu-id="98de3-235">Ebben a példában a szerződés magában foglalja egy további egyéni `IHttpActionResult` osztályt `EmptyResultWithCaching`.</span><span class="sxs-lookup"><span data-stu-id="98de3-235">This example incorporates an additional custom `IHttpActionResult` class named `EmptyResultWithCaching`.</span></span> <span data-ttu-id="98de3-236">Ez az osztály egyszerűen funkcionál csomagolásának egy `HttpResponseMessage` objektum, amely nem tartalmaz egy adott válasz törzse:</span><span class="sxs-lookup"><span data-stu-id="98de3-236">This class simply acts as a wrapper around an `HttpResponseMessage` object that does not contain a response body:</span></span>

```csharp
public class EmptyResultWithCaching : IHttpActionResult
{
    public CacheControlHeaderValue CacheControlHeader { get; set; }
    public EntityTagHeaderValue ETag { get; set; }
    public HttpStatusCode StatusCode { get; set; }
    public Uri Location { get; set; }

    public async Task<HttpResponseMessage> ExecuteAsync(CancellationToken cancellationToken)
    {
        HttpResponseMessage response = new HttpResponseMessage(StatusCode);
        response.Headers.CacheControl = this.CacheControlHeader;
        response.Headers.ETag = this.ETag;
        response.Headers.Location = this.Location;
        return response;
    }
}
```

> [!TIP]
> <span data-ttu-id="98de3-237">Ebben a példában az adatok ETag az adatok, az alapul szolgáló adatforrásban kivonatolásával jön létre.</span><span class="sxs-lookup"><span data-stu-id="98de3-237">In this example, the ETag for the data is generated by hashing the data retrieved from the underlying data source.</span></span> <span data-ttu-id="98de3-238">Az ETag más módon számítható ki, ha a folyamat további is lehet optimalizálni, és az adatok csak szükség lehet lekérni az adatforrásból, amennyiben a változás.</span><span class="sxs-lookup"><span data-stu-id="98de3-238">If the ETag can be computed in some other way, then the process can be optimized further and the data only needs to be fetched from the data source if it has changed.</span></span>  <span data-ttu-id="98de3-239">Ezt a módszert akkor különösen akkor hasznos, ha az adatok mérete nagy, vagy az adatforrás eléréséhez szükséges eredményezhet jelentős késés (például, ha az adatforrás egy távoli adatbázishoz).</span><span class="sxs-lookup"><span data-stu-id="98de3-239">This approach is especially useful if the data is large or accessing the data source can result in significant latency (for example, if the data source is a remote database).</span></span>
>

### <a name="use-etags-to-support-optimistic-concurrency"></a><span data-ttu-id="98de3-240">ETag-EK használatával támogatja az egyidejű hozzáférések optimista</span><span class="sxs-lookup"><span data-stu-id="98de3-240">Use ETags to Support Optimistic Concurrency</span></span>

<span data-ttu-id="98de3-241">Korábban a gyorsítótárazott adatok frissítések engedélyezéséhez a HTTP protokollt támogatja az egyidejű hozzáférések optimista stratégia.</span><span class="sxs-lookup"><span data-stu-id="98de3-241">To enable updates over previously cached data, the HTTP protocol supports an optimistic concurrency strategy.</span></span> <span data-ttu-id="98de3-242">Ha után beolvasása, és a gyorsítótár egy erőforrást, az ügyfélalkalmazás ezt követően módosítsa vagy távolítsa el az erőforrás PUT vagy DELETE kérelmet küld, azt az ETag hivatkozó If-Match fejléc bele kell foglalni.</span><span class="sxs-lookup"><span data-stu-id="98de3-242">If, after fetching and caching a resource, the client application subsequently sends a PUT or DELETE request to change or remove the resource, it should include in If-Match header that references the ETag.</span></span> <span data-ttu-id="98de3-243">A webes API-t használhatja ezeket az információkat határozza meg, hogy az erőforrás már megtörtént egy másik felhasználó lekérdezés óta, és egy megfelelő választ az ügyfélalkalmazás küldése az alábbiak szerint:</span><span class="sxs-lookup"><span data-stu-id="98de3-243">The web API can then use this information to determine whether the resource has already been changed by another user since it was retrieved and send an appropriate response back to the client application as follows:</span></span>

* <span data-ttu-id="98de3-244">Az ügyfél hoz létre egy új részletes adatainak megadása az erőforrás és az ETag az If-Match HTTP-fejlécekben hivatkozott erőforrás-jelenleg gyorsítótárazott verziójának tartalmazó PUT-kérelmekben.</span><span class="sxs-lookup"><span data-stu-id="98de3-244">The client constructs a PUT request containing the new details for the resource and the ETag for the currently cached version of the resource referenced in an If-Match HTTP header.</span></span> <span data-ttu-id="98de3-245">A következő példa bemutatja, amely sorrendben frissíti a PUT-kérelmekben:</span><span class="sxs-lookup"><span data-stu-id="98de3-245">The following example shows a PUT request that updates an order:</span></span>

    ```HTTP
    PUT http://adventure-works.com/orders/1 HTTP/1.1
    If-Match: "2282343857"
    Content-Type: application/x-www-form-urlencoded
    Content-Length: ...
    productID=3&quantity=5&orderValue=250
    ```
* <span data-ttu-id="98de3-246">A webes API-t a PUT-műveletével szerzi be a jelenlegi ETag a kért adatok (1. sorrendje a fenti példában), és összehasonlítja az értéket az If-Match fejlécben.</span><span class="sxs-lookup"><span data-stu-id="98de3-246">The PUT operation in the web API obtains the current ETag for the requested data (order 1 in the above example), and compares it to the value in the If-Match header.</span></span>
* <span data-ttu-id="98de3-247">Ha a jelenlegi ETag a kért adatok megegyezik a kérés megadott ETag, az erőforrás nem változott, és a webes API-k végre kell hajtania a frissítést, egy üzenetet, amelyben a HTTP-állapotkód: 204 (nincs tartalom) ad vissza, ha sikeres.</span><span class="sxs-lookup"><span data-stu-id="98de3-247">If the current ETag for the requested data matches the ETag provided by the request, the resource has not changed and the web API should perform the update, returning a message with HTTP status code 204 (No Content) if it is successful.</span></span> <span data-ttu-id="98de3-248">A válasz a Cache-Control és a frissített verziót az erőforrás ETag fejlécek tartalmazhatnak.</span><span class="sxs-lookup"><span data-stu-id="98de3-248">The response can include Cache-Control and ETag headers for the updated version of the resource.</span></span> <span data-ttu-id="98de3-249">A válasz mindig tartalmaznia kell a helyre fejlécet tartalmazta, amely az újonnan frissített erőforrás URI hivatkozik.</span><span class="sxs-lookup"><span data-stu-id="98de3-249">The response should always include the Location header that references the URI of the newly updated resource.</span></span>
* <span data-ttu-id="98de3-250">Ha a kért adatok jelenlegi ETag nem egyezik meg a kérés megadott ETag, majd az adatok egy másik felhasználó óta megváltozott lehívása és a webes API-t kell visszaadnia egy HTTP-válasz egy üres üzenet szövege és annak 412 (előfeltétel be egy állapotkód: sikertelen).</span><span class="sxs-lookup"><span data-stu-id="98de3-250">If the current ETag for the requested data does not match the ETag provided by the request, then the data has been changed by another user since it was fetched and the web API should return an HTTP response with an empty message body and a status code of 412 (Precondition Failed).</span></span>
* <span data-ttu-id="98de3-251">Ha frissítenie kell az erőforrás már nem létezik a webes API-t az állapotkód: 404-es (nem található), egy HTTP-válasz kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="98de3-251">If the resource to be updated no longer exists then the web API should return an HTTP response with the status code of 404 (Not Found).</span></span>
* <span data-ttu-id="98de3-252">Az ügyfél a gyorsítótár karbantartása az állapot kód- és válaszfejlécekről használ.</span><span class="sxs-lookup"><span data-stu-id="98de3-252">The client uses the status code and response headers to maintain the cache.</span></span> <span data-ttu-id="98de3-253">Ha az adatok frissítése (állapotkód: 204), akkor az objektum is maradniuk gyorsítótárazott (a Cache-Control fejléc nem adja meg a nem-tároló), de az ETag frissíteni kell.</span><span class="sxs-lookup"><span data-stu-id="98de3-253">If the data has been updated (status code 204) then the object can remain cached (as long as the Cache-Control header does not specify no-store) but the ETag should be updated.</span></span> <span data-ttu-id="98de3-254">Ha az adatokat egy másik felhasználó módosította (állapotkód 412) módosult, vagy nem található (állapotkód: 404), majd a gyorsítótárazott objektum kellene.</span><span class="sxs-lookup"><span data-stu-id="98de3-254">If the data was changed by another user changed (status code 412) or not found (status code 404) then the cached object should be discarded.</span></span>

<span data-ttu-id="98de3-255">A következő példakód a PUT művelet az rendelések tartományvezérlő megvalósítását mutatja:</span><span class="sxs-lookup"><span data-stu-id="98de3-255">The next code example shows an implementation of the PUT operation for the Orders controller:</span></span>

```csharp
public class OrdersController : ApiController
{
    [HttpPut]
    [Route("api/orders/{id:int}")]
    public IHttpActionResult UpdateExistingOrder(int id, DTOOrder order)
    {
        try
        {
            var baseUri = Constants.GetUriFromConfig();
            var orderToUpdate = this.ordersRepository.GetOrder(id);
            if (orderToUpdate == null)
            {
                return NotFound();
            }

            var hashedOrder = orderToUpdate.GetHashCode();
            string hashedOrderEtag = $"\"{hashedOrder}\"";

            // Retrieve the If-Match header from the request (if it exists)
            var matchEtags = Request.Headers.IfMatch;

            // If there is an Etag in the If-Match header and
            // this etag matches that of the order just retrieved,
            // or if there is no etag, then update the Order
            if (((matchEtags.Count > 0 &&
                String.CompareOrdinal(matchEtags.First().Tag, hashedOrderEtag) == 0)) ||
                matchEtags.Count == 0)
            {
                // Modify the order
                orderToUpdate.OrderValue = order.OrderValue;
                orderToUpdate.ProductID = order.ProductID;
                orderToUpdate.Quantity = order.Quantity;

                // Save the order back to the data store
                // ...

                // Create the No Content response with Cache-Control, ETag, and Location headers
                var cacheControlHeader = new CacheControlHeaderValue();
                cacheControlHeader.Private = true;
                cacheControlHeader.MaxAge = new TimeSpan(0, 10, 0);

                hashedOrder = order.GetHashCode();
                hashedOrderEtag = $"\"{hashedOrder}\"";
                var eTag = new EntityTagHeaderValue(hashedOrderEtag);

                var location = new Uri($"{baseUri}/{Constants.ORDERS}/{id}");
                var response = new EmptyResultWithCaching()
                {
                    StatusCode = HttpStatusCode.NoContent,
                    CacheControlHeader = cacheControlHeader,
                    ETag = eTag,
                    Location = location
                };

                return response;
            }

            // Otherwise return a Precondition Failed response
            return StatusCode(HttpStatusCode.PreconditionFailed);
        }
        catch
        {
            return InternalServerError();
        }
    }
    ...
}
```

> [!TIP]
> <span data-ttu-id="98de3-256">Az If-Match fejléc nem teljesen kötelező, és ha nincs megadva a webes API mindig megpróbálja frissíteni a megadott sorrendben, esetleg egy másik felhasználó által végrehajtott frissítés mappába felülírja.</span><span class="sxs-lookup"><span data-stu-id="98de3-256">Use of the If-Match header is entirely optional, and if it is omitted the web API will always attempt to update the specified order, possibly blindly overwriting an update made by another user.</span></span> <span data-ttu-id="98de3-257">Elveszett frissítése problémák elkerülése érdekében mindig adja meg az If-Match fejléc.</span><span class="sxs-lookup"><span data-stu-id="98de3-257">To avoid problems due to lost updates, always provide an If-Match header.</span></span>
>
>

## <a name="handling-large-requests-and-responses"></a><span data-ttu-id="98de3-258">Nagy kérelmeit és válaszait kezelése</span><span class="sxs-lookup"><span data-stu-id="98de3-258">Handling large requests and responses</span></span>
<span data-ttu-id="98de3-259">Lehetnek olyan alkalmak, amikor egy ügyfél alkalmazást kell elküldeni vagy fogadni a több mérete (MB) lehet adatokat kérelmek ki (vagy nagyobb) mérete.</span><span class="sxs-lookup"><span data-stu-id="98de3-259">There may be occasions when a client application needs to issue requests that send or receive data that may be several megabytes (or bigger) in size.</span></span> <span data-ttu-id="98de3-260">Várakozás a adatmennyiség továbbított okozhat az ügyfélalkalmazás válaszol.</span><span class="sxs-lookup"><span data-stu-id="98de3-260">Waiting while this amount of data is transmitted could cause the client application to become unresponsive.</span></span> <span data-ttu-id="98de3-261">Ha jelentős mennyiségű adatot tartalmazó kérelmek kezeléséhez van szüksége, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="98de3-261">Consider the following points when you need to handle requests that include significant amounts of data:</span></span>

### <a name="optimize-requests-and-responses-that-involve-large-objects"></a><span data-ttu-id="98de3-262">Kérelmeit és válaszait, például a nagyméretű objektumok optimalizálása</span><span class="sxs-lookup"><span data-stu-id="98de3-262">Optimize requests and responses that involve large objects</span></span>

<span data-ttu-id="98de3-263">Bizonyos erőforrások nagy objektumok vagy nagy mezők, például képeket vagy más típusú bináris adatok szerepelhetnek.</span><span class="sxs-lookup"><span data-stu-id="98de3-263">Some resources may be large objects or include large fields, such as graphics images or other types of binary data.</span></span> <span data-ttu-id="98de3-264">A webes API támogatnia kell a folyamatos átviteli optimalizált feltöltése és ezekkel az erőforrásokkal való letöltésének engedélyezése.</span><span class="sxs-lookup"><span data-stu-id="98de3-264">A web API should support streaming to enable optimized uploading and downloading of these resources.</span></span>

<span data-ttu-id="98de3-265">A HTTP protokoll biztosítja a darabolásos átviteli kódolás mechanizmus nagyméretű objektumok egy ügyfél adatfolyamként történő küldéséhez.</span><span class="sxs-lookup"><span data-stu-id="98de3-265">The HTTP protocol provides the chunked transfer encoding mechanism to stream large data objects back to a client.</span></span> <span data-ttu-id="98de3-266">Az ügyfél egy nagy objektumot egy HTTP GET kérést küld, a webes API-t is küldhet a válasz vissza darabonkénti *adattömbök* HTTP-kapcsolaton keresztül.</span><span class="sxs-lookup"><span data-stu-id="98de3-266">When the client sends an HTTP GET request for a large object, the web API can send the reply back in piecemeal *chunks* over an HTTP connection.</span></span> <span data-ttu-id="98de3-267">A válaszban adatok hossza nem lehet, hogy kezdetben ismert (Ez lehet, hogy hozható létre), ezért a webes API-t futtató kiszolgálót az egyes adattömbök, amely meghatározza a Transfer-Encoding válaszüzenetet küldött e: darabolásos Content-Length fejlécet helyett fejléc.</span><span class="sxs-lookup"><span data-stu-id="98de3-267">The length of the data in the reply may not be known initially (it might be generated), so the server hosting the web API should send a response message with each chunk that specifies the Transfer-Encoding: Chunked header rather than a Content-Length header.</span></span> <span data-ttu-id="98de3-268">Az ügyfélalkalmazás kaphat az egyes adattömbök viszont, hogy a teljes válasz kialakításához.</span><span class="sxs-lookup"><span data-stu-id="98de3-268">The client application can receive each chunk in turn to build up the complete response.</span></span> <span data-ttu-id="98de3-269">Az adatok átvitele befejeződött, ha a kiszolgáló küld vissza a végső rendszer mérete nulla.</span><span class="sxs-lookup"><span data-stu-id="98de3-269">The data transfer completes when the server sends back a final chunk with zero size.</span></span> 

<span data-ttu-id="98de3-270">Egyetlen kérelem kapcsolódását eredményezheti egy nagy objektumot, amely jelentős erőforrásokat használ fel.</span><span class="sxs-lookup"><span data-stu-id="98de3-270">A single request could conceivably result in a massive object that consumes considerable resources.</span></span> <span data-ttu-id="98de3-271">Ha a folyamatos átviteli folyamat során a webes API-k határozza meg, hogy a kérelemben adatok mennyisége túllépte néhány elfogadható határai, akkor megszakítja a műveletet, és vissza válaszüzenetet állapotkóddal 413 (kérelem entitás túl nagy).</span><span class="sxs-lookup"><span data-stu-id="98de3-271">If, during the streaming process, the web API determines that the amount of data in a request has exceeded some acceptable bounds, it can abort the operation and return a response message with status code 413 (Request Entity Too Large).</span></span>

<span data-ttu-id="98de3-272">Minimalizálhatja a HTTP-tömörítés a hálózaton keresztül továbbított nagy objektumok méretét.</span><span class="sxs-lookup"><span data-stu-id="98de3-272">You can minimize the size of large objects transmitted over the network by using HTTP compression.</span></span> <span data-ttu-id="98de3-273">Ez a megközelítés segít csökkentheti a hálózati forgalom és a kapcsolódó hálózati késés, de az ügyfél és a webes API-t futtató kiszolgáló további feldolgozását igénylő.</span><span class="sxs-lookup"><span data-stu-id="98de3-273">This approach helps to reduce the amount of network traffic and the associated network latency, but at the cost of requiring additional processing at the client and the server hosting the web API.</span></span> <span data-ttu-id="98de3-274">Például egy ügyfélalkalmazást, amely a tömörített adatok fogadására vár tartalmazhatnak elfogadás-kódolással: gzip kérelem fejléce (más algoritmusok is megadható adattömörítés).</span><span class="sxs-lookup"><span data-stu-id="98de3-274">For example, a client application that expects to receive compressed data can include an Accept-Encoding: gzip request header (other data compression algorithms can also be specified).</span></span> <span data-ttu-id="98de3-275">Ha a kiszolgáló támogatja a tömörítést azt kell válaszolnia a gzip-formátumban a üzenet szövege és a tartalom-kódolás tárolt tartalmat: gzip válaszfejlécet.</span><span class="sxs-lookup"><span data-stu-id="98de3-275">If the server supports compression it should respond with the content held in gzip format in the message body and the Content-Encoding: gzip response header.</span></span>

<span data-ttu-id="98de3-276">Kombinálhatja a kódolt tömörítés, amelynél adatfolyamos; először előtt streaming az adatok tömörítésére, és adja meg a gzip tartalmának kódolását és darabolásos átviteli kódolás a üzenetfejlécben.</span><span class="sxs-lookup"><span data-stu-id="98de3-276">You can combine encoded compression with streaming; compress the data first before streaming it, and specify the gzip content encoding and chunked transfer encoding in the message headers.</span></span> <span data-ttu-id="98de3-277">Ne feledje, hogy olyan webkiszolgálók (például az Internet Information Server) beállítható úgy, hogy automatikusan tömöríti a HTTP-válaszokat, függetlenül attól, hogy a webes API-k tömöríti-e az adatokat, vagy nem.</span><span class="sxs-lookup"><span data-stu-id="98de3-277">Also note that some web servers (such as Internet Information Server) can be configured to automatically compress HTTP responses regardless of whether the web API compresses the data or not.</span></span>

### <a name="implement-partial-responses-for-clients-that-do-not-support-asynchronous-operations"></a><span data-ttu-id="98de3-278">Részleges válasz az ügyfelek, amelyek nem támogatják az aszinkron műveletek végrehajtása</span><span class="sxs-lookup"><span data-stu-id="98de3-278">Implement partial responses for clients that do not support asynchronous operations</span></span>

<span data-ttu-id="98de3-279">Aszinkron streaming alternatívájaként ügyfélalkalmazás is igényelhetnek adattömböket, részleges válasz néven nagy objektumok adatait.</span><span class="sxs-lookup"><span data-stu-id="98de3-279">As an alternative to asynchronous streaming, a client application can explicitly request data for large objects in chunks, known as partial responses.</span></span> <span data-ttu-id="98de3-280">Az ügyfélalkalmazás megszerezni az objektum adatait egy HTTP HEAD-kérést küld.</span><span class="sxs-lookup"><span data-stu-id="98de3-280">The client application sends an HTTP HEAD request to obtain information about the object.</span></span> <span data-ttu-id="98de3-281">Ha a webes API támogatja a részleges válasz, ha a HEAD kérelem, amely tartalmaz egy elfogadás-tartományok és a Content-Length fejlécet, amely az objektum teljes méretét válaszüzenetet válaszolnia kell, de az üzenet törzsét üresnek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="98de3-281">If the web API supports partial responses if should respond to the HEAD request with a response message that contains an Accept-Ranges header and a Content-Length header that indicates the total size of the object, but the body of the message should be empty.</span></span> <span data-ttu-id="98de3-282">Az ügyfélalkalmazás ezen információk használatával hozható létre több GET kérelem által megadott bájttartomány fogadására.</span><span class="sxs-lookup"><span data-stu-id="98de3-282">The client application can use this information to construct a series of GET requests that specify a range of bytes to receive.</span></span> <span data-ttu-id="98de3-283">A webes API HTTP-állapot 206 (részleges tartalom), a Content-Length fejlécet, amely meghatározza a válaszüzenetet, és a Content-Range fejléc, amely jelzi, mely része (például bájt 4000 üzenettörzsbeli adatok tényleges mennyiségét válaszüzenetet kell visszaadnia. 8000) az az objektum az adatok jelöli.</span><span class="sxs-lookup"><span data-stu-id="98de3-283">The web API should return a response message with HTTP status 206 (Partial Content), a Content-Length header that specifies the actual amount of data included in the body of the response message, and a Content-Range header that indicates which part (such as bytes 4000 to 8000) of the object this data represents.</span></span>

<span data-ttu-id="98de3-284">Részletesen ismerteti a HTTP HEAD-kérelmek és a részleges válasz [API tervezési][api-design].</span><span class="sxs-lookup"><span data-stu-id="98de3-284">HTTP HEAD requests and partial responses are described in more detail in [API Design][api-design].</span></span>

### <a name="avoid-sending-unnecessary-100-continue-status-messages-in-client-applications"></a><span data-ttu-id="98de3-285">Ne küldjön szükségtelen 100-ügyfélalkalmazások található állapotüzenetek folytatása</span><span class="sxs-lookup"><span data-stu-id="98de3-285">Avoid sending unnecessary 100-Continue status messages in client applications</span></span>

<span data-ttu-id="98de3-286">Egy ügyfél-alkalmazás, amely arra készül, hogy a nagy mennyiségű adatot küldeni előfordulhat, hogy meghatározásához először a kiszolgáló tényleges hajlandó a kérést.</span><span class="sxs-lookup"><span data-stu-id="98de3-286">A client application that is about to send a large amount of data to a server may determine first whether the server is actually willing to accept the request.</span></span> <span data-ttu-id="98de3-287">Az adatküldés előtt az ügyfélalkalmazás is elküldhetik a egy várt HTTP-kérelem: 100-továbbra is a fejlécet, a Content-Length fejlécet, amely az adatokat, de egy üres üzenettörzs méretét jelzi.</span><span class="sxs-lookup"><span data-stu-id="98de3-287">Prior to sending the data, the client application can submit an HTTP request with an Expect: 100-Continue header, a Content-Length header that indicates the size of the data, but an empty message body.</span></span> <span data-ttu-id="98de3-288">Ha a kiszolgáló hajlandó kezelni a kérést, azt egy üzenet, amely meghatározza a HTTP-állapot – 100 (Folytatás) kell válaszolnia.</span><span class="sxs-lookup"><span data-stu-id="98de3-288">If the server is willing to handle the request, it should respond with a message that specifies the HTTP status 100 (Continue).</span></span> <span data-ttu-id="98de3-289">Az ügyfélalkalmazás majd a folytatáshoz, és a teljes, beleértve az adatokat az üzenet törzsében kérelem küldése.</span><span class="sxs-lookup"><span data-stu-id="98de3-289">The client application can then proceed and send the complete request including the data in the message body.</span></span>

<span data-ttu-id="98de3-290">Ha az IIS használatával az üzemeltetett szolgáltatás, a HTTP.sys illesztő automatikusan észleli és kezeli a várt: 100-fejlécek folytatni a kérelmek a webes alkalmazásba való továbbítása előtt.</span><span class="sxs-lookup"><span data-stu-id="98de3-290">If you are hosting a service by using IIS, the HTTP.sys driver automatically detects and handles Expect: 100-Continue headers before passing requests to your web application.</span></span> <span data-ttu-id="98de3-291">Ez azt jelenti, hogy nem valószínű, hogy ezek a fejlécek, az alkalmazás kódjában, és akkor feltételezheti, hogy az IIS már szűri, akkor megfelelően konfiguráltnak ítéli alkalmatlan vagy túl nagy üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="98de3-291">This means that you are unlikely to see these headers in your application code, and you can assume that IIS has already filtered any messages that it deems to be unfit or too large.</span></span>

<span data-ttu-id="98de3-292">Ha a .NET-keretrendszer használatával hoz létre az ügyfélalkalmazások, akkor minden POST és a PUT üzenetek először a várt üzenetet szeretne küldeni: 100-alapértelmezés szerint továbbra is a fejléceket.</span><span class="sxs-lookup"><span data-stu-id="98de3-292">If you are building client applications by using the .NET Framework, then all POST and PUT messages will first send messages with Expect: 100-Continue headers by default.</span></span> <span data-ttu-id="98de3-293">Csakúgy, mint a kiszolgálóoldali, a folyamat kezeli transzparens módon a .NET-keretrendszer.</span><span class="sxs-lookup"><span data-stu-id="98de3-293">As with the server-side, the process is handled transparently by the .NET Framework.</span></span> <span data-ttu-id="98de3-294">Ez a folyamat azonban a kiszolgálóra, még akkor is a kis-kéréseket két üzenetváltások utak számát, amely minden POST és a PUT kérés eredményez.</span><span class="sxs-lookup"><span data-stu-id="98de3-294">However, this process results in each POST and PUT request causing two round-trips to the server, even for small requests.</span></span> <span data-ttu-id="98de3-295">Ha az alkalmazás kérelmek nagy mennyiségű adatot nem küld, ez a szolgáltatás segítségével letilthatja a `ServicePointManager` osztály létrehozása `ServicePoint` az ügyfélalkalmazás az objektumok.</span><span class="sxs-lookup"><span data-stu-id="98de3-295">If your application is not sending requests with large amounts of data, you can disable this feature by using the `ServicePointManager` class to create `ServicePoint` objects in the client application.</span></span> <span data-ttu-id="98de3-296">A `ServicePoint` objektum kezeli a kapcsolatokat, az ügyfél által az alapján a rendszer és a gazdagép darabjai URI, amely azonosítja a kiszolgálón.</span><span class="sxs-lookup"><span data-stu-id="98de3-296">A `ServicePoint` object handles the connections that the client makes to a server based on the scheme and host fragments of URIs that identify resources on the server.</span></span> <span data-ttu-id="98de3-297">Ezután beállíthatja a `Expect100Continue` tulajdonsága a `ServicePoint` objektum false értékre.</span><span class="sxs-lookup"><span data-stu-id="98de3-297">You can then set the `Expect100Continue` property of the `ServicePoint` object to false.</span></span> <span data-ttu-id="98de3-298">URI, amely megfelel a rendszer és a gazdagép darabjai keresztül az ügyfél által küldött összes további POST és a PUT kérelmek a `ServicePoint` objektum rendszer anélkül küldi el várt: 100-fejlécek folytatni.</span><span class="sxs-lookup"><span data-stu-id="98de3-298">All subsequent POST and PUT requests made by the client through a URI that matches the scheme and host fragments of the `ServicePoint` object will be sent without Expect: 100-Continue headers.</span></span> <span data-ttu-id="98de3-299">A következő kód bemutatja, hogyan konfigurálhatja a `ServicePoint` objektum összes tervet az URI-azonosítók küldött kérelmeket a konfigurált `http` és `www.contoso.com`.</span><span class="sxs-lookup"><span data-stu-id="98de3-299">The following code shows how to configure a `ServicePoint` object that configures all requests sent to URIs with a scheme of `http` and a host of `www.contoso.com`.</span></span>

```csharp
Uri uri = new Uri("http://www.contoso.com/");
ServicePoint sp = ServicePointManager.FindServicePoint(uri);
sp.Expect100Continue = false;
```

<span data-ttu-id="98de3-300">Azt is beállíthatja a statikus `Expect100Continue` tulajdonsága a `ServicePointManager` adhatja meg ennek a tulajdonságnak az alapértelmezett érték az összes azt követő osztály `ServicePoint` objektumok.</span><span class="sxs-lookup"><span data-stu-id="98de3-300">You can also set the static `Expect100Continue` property of the `ServicePointManager` class to specify the default value of this property for all subsequently created `ServicePoint` objects.</span></span> <span data-ttu-id="98de3-301">További információkért lásd: [ServicePoint osztály](https://msdn.microsoft.com/library/system.net.servicepoint.aspx).</span><span class="sxs-lookup"><span data-stu-id="98de3-301">For more information, see [ServicePoint Class](https://msdn.microsoft.com/library/system.net.servicepoint.aspx).</span></span>

### <a name="support-pagination-for-requests-that-may-return-large-numbers-of-objects"></a><span data-ttu-id="98de3-302">Tördelési támogatja, amelyek nagy számú objektum térhetnek vissza kérelmeknél</span><span class="sxs-lookup"><span data-stu-id="98de3-302">Support pagination for requests that may return large numbers of objects</span></span>

<span data-ttu-id="98de3-303">Ha egy gyűjtemény sok erőforrást tartalmaz, GET kérés kiadása a hozzá tartozó URI képes jelentős feldolgozási teljesítményét webes API-t üzemeltető kiszolgálón eredményez, és hálózati forgalom, ami jelentős mennyiségű készítése nagyobb késéseket.</span><span class="sxs-lookup"><span data-stu-id="98de3-303">If a collection contains a large number of resources, issuing a GET request to the corresponding URI could result in significant processing on the server hosting the web API affecting performance, and generate a significant amount of network traffic resulting in increased latency.</span></span>

<span data-ttu-id="98de3-304">Ezekben az esetekben kezelni, a webes API-k támogatnia kell a lekérdezési karakterláncok, amelyek lehetővé teszik az ügyfélalkalmazás kérelmek finomíthatja vagy adatlehívás könnyebben kezelhető, különálló tömb (vagy lapok).</span><span class="sxs-lookup"><span data-stu-id="98de3-304">To handle these cases, the web API should support query strings that enable the client application to refine requests or fetch data in more manageable, discrete blocks (or pages).</span></span> <span data-ttu-id="98de3-305">Az alábbi kódot a `GetAllOrders` metódust a `Orders` vezérlő.</span><span class="sxs-lookup"><span data-stu-id="98de3-305">The code below shows the `GetAllOrders` method in the `Orders` controller.</span></span> <span data-ttu-id="98de3-306">Ez a módszer lekéri a rendelés részleteit.</span><span class="sxs-lookup"><span data-stu-id="98de3-306">This method retrieves the details of orders.</span></span> <span data-ttu-id="98de3-307">Ez a metódus lett megkötés nélkül, kapcsolódását visszaadhatja nagy mennyiségű adatot.</span><span class="sxs-lookup"><span data-stu-id="98de3-307">If this method was unconstrained, it could conceivably return a large amount of data.</span></span> <span data-ttu-id="98de3-308">A `limit` és `offset` paraméterek célja, hogy csökkentse az adatok mennyisége kisebb részhalmazát, ez esetben csak az első 10 rendeléseket alapértelmezés szerint:</span><span class="sxs-lookup"><span data-stu-id="98de3-308">The `limit` and `offset` parameters are intended to reduce the volume of data to a smaller subset, in this case only the first 10 orders by default:</span></span>

```csharp
public class OrdersController : ApiController
{
    ...
    [Route("api/orders")]
    [HttpGet]
    public IEnumerable<Order> GetAllOrders(int limit=10, int offset=0)
    {
        // Find the number of orders specified by the limit parameter
        // starting with the order specified by the offset parameter
        var orders = ...
        return orders;
    }
    ...
}
```

<span data-ttu-id="98de3-309">Egy ügyfélalkalmazás kiadhatnak egy URI segítségével 50 eltolástól kezdve 30 kérelmek lekérésére irányuló kérelem `http://www.adventure-works.com/api/orders?limit=30&offset=50`.</span><span class="sxs-lookup"><span data-stu-id="98de3-309">A client application can issue a request to retrieve 30 orders starting at offset 50 by using the URI `http://www.adventure-works.com/api/orders?limit=30&offset=50`.</span></span>

> [!TIP]
> <span data-ttu-id="98de3-310">Kerülje a megadásához, amelyek URI, amely az érték 2000-nél több karakter hosszú lekérdezési karakterláncok ügyfélalkalmazások engedélyezését.</span><span class="sxs-lookup"><span data-stu-id="98de3-310">Avoid enabling client applications to specify query strings that result in a URI that is more than 2000 characters long.</span></span> <span data-ttu-id="98de3-311">Számos webalkalmazás-ügyfelek és kiszolgálók ilyen hosszú URI-azonosítók nem tudja kezelni.</span><span class="sxs-lookup"><span data-stu-id="98de3-311">Many web clients and servers cannot handle URIs that are this long.</span></span>
>
>

## <a name="maintaining-responsiveness-scalability-and-availability"></a><span data-ttu-id="98de3-312">Reakcióidőt, a méretezhetőség és a rendelkezésre állás fenntartása</span><span class="sxs-lookup"><span data-stu-id="98de3-312">Maintaining responsiveness, scalability, and availability</span></span>
<span data-ttu-id="98de3-313">Az azonos web API futtató bárhol a világon sok ügyfélalkalmazások előfordulhat, hogy lesz szükség.</span><span class="sxs-lookup"><span data-stu-id="98de3-313">The same web API might be utilized by many client applications running anywhere in the world.</span></span> <span data-ttu-id="98de3-314">Fontos biztosítania, hogy a webes API-t kell lennie a magas különböző munkaterhelések támogatásához, és rendelkezésre állás biztosításához az üzleti szempontból kulcsfontosságú műveleteket az ügyfelek méretezhető, nagy terhelés alatt válaszkészsége fenntartásához.</span><span class="sxs-lookup"><span data-stu-id="98de3-314">It is important to ensure that the web API is implemented to maintain responsiveness under a heavy load, to be scalable to support a highly varying workload, and to guarantee availability for clients that perform business-critical operations.</span></span> <span data-ttu-id="98de3-315">Ha ezek a követelmények teljesítéséhez módjának meghatározása, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="98de3-315">Consider the following points when determining how to meet these requirements:</span></span>

### <a name="provide-asynchronous-support-for-long-running-requests"></a><span data-ttu-id="98de3-316">Aszinkron támogatást nyújt a hosszan futó kérelmek</span><span class="sxs-lookup"><span data-stu-id="98de3-316">Provide asynchronous support for long-running requests</span></span>

<span data-ttu-id="98de3-317">A kérelmeket, amelyek feldolgozása hosszú időbe telhet, hogy a kérés elküldése megtörtént az ügyfél blokkolása nélkül kell elvégezni.</span><span class="sxs-lookup"><span data-stu-id="98de3-317">A request that might take a long time to process should be performed without blocking the client that submitted the request.</span></span> <span data-ttu-id="98de3-318">A webes API-k hajthatják végre a kérelem ellenőrzéséhez kezdeményezni egy külön feladat a munkájuk elvégzéséhez, és térjen vissza a HTTP-kód 202 (elfogadható) válaszüzenetet néhány kezdeti ellenőrzése.</span><span class="sxs-lookup"><span data-stu-id="98de3-318">The web API can perform some initial checking to validate the request, initiate a separate task to perform the work, and then return a response message with HTTP code 202 (Accepted).</span></span> <span data-ttu-id="98de3-319">A feladat futtathat a webes API részeként aszinkron feldolgozás, vagy a háttérfeladat sikerült kiszervezett.</span><span class="sxs-lookup"><span data-stu-id="98de3-319">The task could run asynchronously as part of the web API processing, or it could be offloaded to a background task.</span></span>

<span data-ttu-id="98de3-320">A webes API-t kell is egy olyan mechanizmus biztosítása az ügyfélalkalmazás találatot feldolgozását.</span><span class="sxs-lookup"><span data-stu-id="98de3-320">The web API should also provide a mechanism to return the results of the processing to the client application.</span></span> <span data-ttu-id="98de3-321">Ennek érdekében azáltal, hogy a rendszeres időközönként lekérdezés alkalmazásokat egy olyan ügyfél lekérdezési mechanizmus e feldolgozása befejeződik, és az eredményt vagy engedélyezése a webes API-k elküldeni egy értesítést, ha a művelet befejeződött.</span><span class="sxs-lookup"><span data-stu-id="98de3-321">You can achieve this by providing a polling mechanism for client applications to periodically query whether the processing has finished and obtain the result, or enabling the web API to send a notification when the operation has completed.</span></span>

<span data-ttu-id="98de3-322">Egy egyszerű lekérdezési módszer biztosításával valósíthat meg egy *lekérdezési* URI, amely úgy működik, mint egy virtuális erőforrást a következő módon:</span><span class="sxs-lookup"><span data-stu-id="98de3-322">You can implement a simple polling mechanism by providing a *polling* URI that acts as a virtual resource using the following approach:</span></span>

1. <span data-ttu-id="98de3-323">Az ügyfélalkalmazás a kezdeti kérést küld a webes API-t.</span><span class="sxs-lookup"><span data-stu-id="98de3-323">The client application sends the initial request to the web API.</span></span>
2. <span data-ttu-id="98de3-324">A webes API-t a kérelem kapcsolatos információkat tárolja a table storage vagy a Microsoft Azure Cache tárolt tábla, és állít elő ez a bejegyzés egyedi kulcs, valószínűleg egy GUID formájában.</span><span class="sxs-lookup"><span data-stu-id="98de3-324">The web API stores information about the request in a table held in table storage or Microsoft Azure Cache, and generates a unique key for this entry, possibly in the form of a GUID.</span></span>
3. <span data-ttu-id="98de3-325">A webes API-k indít el egy külön feladat feldolgozásával.</span><span class="sxs-lookup"><span data-stu-id="98de3-325">The web API initiates the processing as a separate task.</span></span> <span data-ttu-id="98de3-326">A webes API-t a feladat állapotát rögzíti a táblázat *futtató*.</span><span class="sxs-lookup"><span data-stu-id="98de3-326">The web API records the state of the task in the table as *Running*.</span></span>
4. <span data-ttu-id="98de3-327">A webes API-t adja vissza válaszüzenetet HTTP-állapotkód: 202 (elfogadható), és a táblabeli GUID-azonosítója az üzenet törzsét.</span><span class="sxs-lookup"><span data-stu-id="98de3-327">The web API returns a response message with HTTP status code 202 (Accepted), and the GUID of the table entry in the body of the message.</span></span>
5. <span data-ttu-id="98de3-328">A feladat befejezése után a webes API-t tárolja az eredményeket a táblában, és a feladat állapotának beállítása *Complete*.</span><span class="sxs-lookup"><span data-stu-id="98de3-328">When the task has completed, the web API stores the results in the table, and sets the state of the task to *Complete*.</span></span> <span data-ttu-id="98de3-329">Ne feledje, hogy a feladat sikertelen lesz, ha a webes API-k sikerült is a hibával kapcsolatos információkat tárolja az állapot beállítása *sikertelen*.</span><span class="sxs-lookup"><span data-stu-id="98de3-329">Note that if the task fails, the web API could also store information about the failure and set the status to *Failed*.</span></span>
6. <span data-ttu-id="98de3-330">A feladat futása közben, az ügyfél továbbra is a saját feldolgozási végrehajtása.</span><span class="sxs-lookup"><span data-stu-id="98de3-330">While the task is running, the client can continue performing its own processing.</span></span> <span data-ttu-id="98de3-331">Azt is rendszeresen kérelmet küld az URI */polling/ {guid}* ahol *{guid}* a globálisan egyedi Azonosítót ad vissza a 202 válaszüzenetben a webes API-t.</span><span class="sxs-lookup"><span data-stu-id="98de3-331">It can periodically send a request to the URI */polling/{guid}* where *{guid}* is the GUID returned in the 202 response message by the web API.</span></span>
7. <span data-ttu-id="98de3-332">A webes API-t, a */polling/ {guid}* URI a táblázatban a megfelelő feladat állapotának lekérdezése, és adja vissza egy válaszüzenetben HTTP-állapotkód: 200 (OK) ebben az állapotban (*futtató*, *Teljes*, vagy *sikertelen*).</span><span class="sxs-lookup"><span data-stu-id="98de3-332">The web API at the */polling/{guid}* URI queries the state of the corresponding task in the table and returns a response message with HTTP status code 200 (OK) containing this state (*Running*, *Complete*, or *Failed*).</span></span> <span data-ttu-id="98de3-333">Ha a feladat befejeződött, vagy sikertelen volt, a válaszüzenetet is hozzáadhat az eredmények a feldolgozás vagy bármely információ elérhető a hiba okát.</span><span class="sxs-lookup"><span data-stu-id="98de3-333">If the task has completed or failed, the response message can also include the results of the processing or any information available about the reason for the failure.</span></span>

<span data-ttu-id="98de3-334">Az értesítések végrehajtási lehetőségek a következők:</span><span class="sxs-lookup"><span data-stu-id="98de3-334">Options for implementing notifications include:</span></span>

- <span data-ttu-id="98de3-335">Az Azure Notification Hub használatával, majd az aszinkron válaszok ügyfélalkalmazások számára.</span><span class="sxs-lookup"><span data-stu-id="98de3-335">Using an Azure Notification Hub to push asynchronous responses to client applications.</span></span> <span data-ttu-id="98de3-336">További információkért lásd: [Azure Notification Hubs – felhasználók értesítése](/azure/notification-hubs/notification-hubs-aspnet-backend-windows-dotnet-wns-notification/).</span><span class="sxs-lookup"><span data-stu-id="98de3-336">For more information, see [Azure Notification Hubs Notify Users](/azure/notification-hubs/notification-hubs-aspnet-backend-windows-dotnet-wns-notification/).</span></span>
- <span data-ttu-id="98de3-337">Az ügyfél biztonsági a üstökös modell használatával szeretné megőrizni az ügyfél és a webes API-t futtató kiszolgáló közötti hálózati kapcsolatot, és a kapcsolattal a leküldéses üzenetek a kiszolgálóról.</span><span class="sxs-lookup"><span data-stu-id="98de3-337">Using the Comet model to retain a persistent network connection between the client and the server hosting the web API, and using this connection to push messages from the server back to the client.</span></span> <span data-ttu-id="98de3-338">Az MSDN újság cikk [egy egyszerű üstökös alkalmazást a Microsoft .NET-keretrendszer összeállítása](https://msdn.microsoft.com/magazine/jj891053.aspx) egy példa megoldást ismertet.</span><span class="sxs-lookup"><span data-stu-id="98de3-338">The MSDN magazine article [Building a Simple Comet Application in the Microsoft .NET Framework](https://msdn.microsoft.com/magazine/jj891053.aspx) describes an example solution.</span></span>
- <span data-ttu-id="98de3-339">SignalR segítségével adatokat küldeni valós idejű a webkiszolgáló az ügyfél hálózati kapcsolaton keresztül.</span><span class="sxs-lookup"><span data-stu-id="98de3-339">Using SignalR to push data in real-time from the web server to the client over a persistent network connection.</span></span> <span data-ttu-id="98de3-340">SignalR érhető el az ASP.NET-webalkalmazások számára történő NuGet-csomagként.</span><span class="sxs-lookup"><span data-stu-id="98de3-340">SignalR is available for ASP.NET web applications as a NuGet package.</span></span> <span data-ttu-id="98de3-341">További információ található a [ASP.NET SignalR](http://signalr.net/) webhelyet.</span><span class="sxs-lookup"><span data-stu-id="98de3-341">You can find more information on the [ASP.NET SignalR](http://signalr.net/) website.</span></span>

### <a name="ensure-that-each-request-is-stateless"></a><span data-ttu-id="98de3-342">Gondoskodjon arról, hogy az egyes kérelmek állapot nélküli</span><span class="sxs-lookup"><span data-stu-id="98de3-342">Ensure that each request is stateless</span></span>

<span data-ttu-id="98de3-343">Minden egyes kérelem atomi figyelembe venni.</span><span class="sxs-lookup"><span data-stu-id="98de3-343">Each request should be considered atomic.</span></span> <span data-ttu-id="98de3-344">Egy ügyfélalkalmazás egy kérelmet, és bármely későbbi ugyanaz az ügyfél által küldött kérelmeket közötti függőségek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="98de3-344">There should be no dependencies between one request made by a client application and any subsequent requests submitted by the same client.</span></span> <span data-ttu-id="98de3-345">Ez a megközelítés segít a méretezhetőségi; a webszolgáltatás példánya több kiszolgálót is telepíthető.</span><span class="sxs-lookup"><span data-stu-id="98de3-345">This approach assists in scalability; instances of the web service can be deployed on a number of servers.</span></span> <span data-ttu-id="98de3-346">Ügyfélkérések irányítható, ezek a példányok, és az eredmények mindig azonosnak kell lennie.</span><span class="sxs-lookup"><span data-stu-id="98de3-346">Client requests can be directed at any of these instances and the results should always be the same.</span></span> <span data-ttu-id="98de3-347">Ez is növeli a rendelkezésre állási hasonló okból; Ha egy web server sikertelen kérelmeket egy másik példányhoz átirányítható (Azure Traffic Manager használatával) során a kiszolgáló újraindítása nincs sérültnek hatása az ügyfélalkalmazások számára.</span><span class="sxs-lookup"><span data-stu-id="98de3-347">It also improves availability for a similar reason; if a web server fails requests can be routed to another instance (by using Azure Traffic Manager) while the server is restarted with no ill effects on client applications.</span></span>

### <a name="track-clients-and-implement-throttling-to-reduce-the-chances-of-dos-attacks"></a><span data-ttu-id="98de3-348">Nyomon követheti az ügyfelek és a sávszélesség-szabályozás megvalósítása esélyét csökkentheti a Szolgáltatásmegtagadási támadások</span><span class="sxs-lookup"><span data-stu-id="98de3-348">Track clients and implement throttling to reduce the chances of DOS attacks</span></span>

<span data-ttu-id="98de3-349">Ha egy adott ügyfél nagy számú kérést küld egy adott időn belül, előfordulhat, hogy se sajátíthassa ki a szolgáltatás és a teljesítményét a más ügyfelekkel.</span><span class="sxs-lookup"><span data-stu-id="98de3-349">If a specific client makes a large number of requests within a given period of time it might monopolize the service and affect the performance of other clients.</span></span> <span data-ttu-id="98de3-350">A probléma orvoslása érdekében webes API-k nyomon követését az IP-cím, az összes beérkező kérelem vagy -naplózás minden hitelesített hozzáférést figyelheti ügyfélalkalmazások hívásait.</span><span class="sxs-lookup"><span data-stu-id="98de3-350">To mitigate this issue, a web API can monitor calls from client applications either by tracking the IP address of all incoming requests or by logging each authenticated access.</span></span> <span data-ttu-id="98de3-351">Ezek az információk használatával korlátozható az erőforrásokhoz való hozzáférést.</span><span class="sxs-lookup"><span data-stu-id="98de3-351">You can use this information to limit resource access.</span></span> <span data-ttu-id="98de3-352">Ha egy ügyfél meghaladja a meghatározott korláttal, a webes API-k vissza válaszüzenetet 503-as (a szolgáltatás nem érhető el) állapotú, és tartalmaznak egy újrapróbálkozási után fejlécet, amely meghatározza, amikor az ügyfél feladateseményeket küldhet a következő kérés nélkül alatt elutasította.</span><span class="sxs-lookup"><span data-stu-id="98de3-352">If a client exceeds a defined limit, the web API can return a response message with status 503 (Service Unavailable) and include a Retry-After header that specifies when the client can send the next request without it being declined.</span></span> <span data-ttu-id="98de3-353">Ezt a stratégiát segíthet a veszélyét annak, hogy a szolgáltatás megtagadása (DOS) támadás lévő ügyfelek, a rendszer leállása csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="98de3-353">This strategy can help to reduce the chances of a Denial Of Service (DOS) attack from a set of clients stalling the system.</span></span>

### <a name="manage-persistent-http-connections-carefully"></a><span data-ttu-id="98de3-354">Állandó HTTP-kapcsolatok gondosan kezelése</span><span class="sxs-lookup"><span data-stu-id="98de3-354">Manage persistent HTTP connections carefully</span></span>

<span data-ttu-id="98de3-355">A HTTP protokoll azok állandó HTTP-kapcsolatokat támogatja.</span><span class="sxs-lookup"><span data-stu-id="98de3-355">The HTTP protocol supports persistent HTTP connections where they are available.</span></span> <span data-ttu-id="98de3-356">A HTTP 1.0 leírásnak fel a kapcsolatot: Keep-Alive fejléc, amely lehetővé teszi egy ügyfélalkalmazást, annak jelzésére, hogy az újakat nyitása helyett későbbi kérelmek küldéséhez használhatja ugyanazt a kapcsolatot a kiszolgálóval.</span><span class="sxs-lookup"><span data-stu-id="98de3-356">The HTTP 1.0 specificiation added the Connection:Keep-Alive header that enables a client application to indicate to the server that it can use the same connection to send subsequent requests rather than opening new ones.</span></span> <span data-ttu-id="98de3-357">Ha az ügyfél nem használja fel a kapcsolatot a gazdagép által megadott időn belül automatikusan bezáródik a kapcsolatot.</span><span class="sxs-lookup"><span data-stu-id="98de3-357">The connection closes automatically if the client does not reuse the connection within a period defined by the host.</span></span> <span data-ttu-id="98de3-358">Ez a viselkedés a HTTP 1.1 Azure-szolgáltatások által használt, így nem szükséges belefoglalni a fejlécek életben tartási üzenetek az alapértelmezett beállítás.</span><span class="sxs-lookup"><span data-stu-id="98de3-358">This behavior is the default in HTTP 1.1 as used by Azure services, so there is no need to include Keep-Alive headers in messages.</span></span>

<span data-ttu-id="98de3-359">Csökkenti a késést és a hálózati torlódás válaszkészsége javítása érdekében kapcsolatot nyitva tartása segítséget, de azok méretezhetőség sértő szükségtelen kapcsolatok hosszabb, mint más egyidejű ügyfelek képességét korlátozása szükséges nyitva tartja Csatlakoztassa.</span><span class="sxs-lookup"><span data-stu-id="98de3-359">Keeping a connection open can help to improve responsiveness by reducing latency and network congestion, but it can be detrimental to scalability by keeping unnecessary connections open for longer than required, limiting the ability of other concurrent clients to connect.</span></span> <span data-ttu-id="98de3-360">Azt is befolyásolhatja az eszközakkumulátor élettartamának, ha az ügyfél-alkalmazás fut egy mobileszközön; Ha az alkalmazás csak alkalmi kérelmeket küld a kiszolgáló, nyitott kapcsolat fenntartása okozhat az akkumulátor gyorsabban kiürítése.</span><span class="sxs-lookup"><span data-stu-id="98de3-360">It can also affect battery life if the client application is running on a mobile device; if the application only makes occasional requests to the server, maintaining an open connection can cause the battery to drain more quickly.</span></span> <span data-ttu-id="98de3-361">Győződjön meg arról, hogy a kapcsolat nem jön létre a HTTP 1.1 állandó, az ügyfél az alapértelmezett viselkedés felülbírálásához kapcsolat: Close fejlécet is tartalmaznia.</span><span class="sxs-lookup"><span data-stu-id="98de3-361">To ensure that a connection is not made persistent with HTTP 1.1, the client can include a Connection:Close header with messages to override the default behavior.</span></span> <span data-ttu-id="98de3-362">Hasonlóképpen ha a kiszolgáló által kezelt nagyon nagy mennyiségű ügyfelet része lehet kapcsolat: Close fejléc a válaszüzenetek, amely kell zárja le a kapcsolatot, és kiszolgáló-erőforrás mentése.</span><span class="sxs-lookup"><span data-stu-id="98de3-362">Similarly, if a server is handling a very large number of clients it can include a Connection:Close header in response messages which should close the connection and save server resources.</span></span>

> [!NOTE]
> <span data-ttu-id="98de3-363">Állandó HTTP-kapcsolatok csak választható újdonsága a ismételten a kommunikációs csatornát létrehozó társított hálózati terhelésének csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="98de3-363">Persistent HTTP connections are a purely optional feature to reduce the network overhead associated with repeatedly establishing a communications channel.</span></span> <span data-ttu-id="98de3-364">A webes API-t és az ügyfélalkalmazás nem függ egy állandó HTTP-kapcsolat rendelkezésre állása.</span><span class="sxs-lookup"><span data-stu-id="98de3-364">Neither the web API nor the client application should depend on a persistent HTTP connection being available.</span></span> <span data-ttu-id="98de3-365">Ne használjon állandó HTTP-kapcsolatok megvalósításához üstökös stílusú értesítési rendszere; Ehelyett sockets (vagy websocket elemek, ha elérhető) használatára kell a TCP-rétegben.</span><span class="sxs-lookup"><span data-stu-id="98de3-365">Do not use persistent HTTP connections to implement Comet-style notification systems; instead you should utilize sockets (or websockets if available) at the TCP layer.</span></span> <span data-ttu-id="98de3-366">Végül vegye figyelembe a Keep-Alive fejléc korlátozott használat van, ha egy ügyfél-alkalmazás; proxyn keresztülmenő kiszolgálóval kommunikálva csak az ügyfél és a proxy kapcsolódási állandó lesz.</span><span class="sxs-lookup"><span data-stu-id="98de3-366">Finally, note Keep-Alive headers are of limited use if a client application communicates with a server via a proxy; only the connection with the client and the proxy will be persistent.</span></span>
>
>

## <a name="publishing-and-managing-a-web-api"></a><span data-ttu-id="98de3-367">Közzététele és webes API-k kezelése</span><span class="sxs-lookup"><span data-stu-id="98de3-367">Publishing and managing a web API</span></span>
<span data-ttu-id="98de3-368">Webes API-k akkor válik elérhetővé az ügyfélalkalmazások, a webes API-t telepíteni kell egy gazdagép-környezetben.</span><span class="sxs-lookup"><span data-stu-id="98de3-368">To make a web API available for client applications, the web API must be deployed to a host environment.</span></span> <span data-ttu-id="98de3-369">Ebben a környezetben az általában a webkiszolgáló, bár lehet, hogy más típusú gazdafolyamat.</span><span class="sxs-lookup"><span data-stu-id="98de3-369">This environment is typically a web server, although it may be some other type of host process.</span></span> <span data-ttu-id="98de3-370">A webes API közzétételekor, a következő szempontokat kell figyelembe vennie:</span><span class="sxs-lookup"><span data-stu-id="98de3-370">You should consider the following points when publishing a web API:</span></span>

* <span data-ttu-id="98de3-371">Összes kérelem kell hitelesítenie és engedélyeznie, és a megfelelő szintű hozzáférés-vezérlés kényszerítettnek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="98de3-371">All requests must be authenticated and authorized, and the appropriate level of access control must be enforced.</span></span>
* <span data-ttu-id="98de3-372">Kereskedelmi webes API-k válaszidők vonatkozó különböző szolgáltatásminőségi garanciák célpontjává válhat.</span><span class="sxs-lookup"><span data-stu-id="98de3-372">A commercial web API might be subject to various quality guarantees concerning response times.</span></span> <span data-ttu-id="98de3-373">Fontos méretezhető, hogy a gazdagép-környezetben, így ha a terhelést időbeli nagymértékben változhat.</span><span class="sxs-lookup"><span data-stu-id="98de3-373">It is important to ensure that host environment is scalable if the load can vary significantly over time.</span></span>
* <span data-ttu-id="98de3-374">Elképzelhető, hogy szükséges mérési kérelmekre jeleníthetnek célokra.</span><span class="sxs-lookup"><span data-stu-id="98de3-374">It may be necessary to meter requests for monetization purposes.</span></span>
* <span data-ttu-id="98de3-375">Szabályozza a forgalmat a webes API-hoz, és a kvóták kimerített adott ügyfelek sávszélesség-szabályozás megvalósításához szükség lehet.</span><span class="sxs-lookup"><span data-stu-id="98de3-375">It might be necessary to regulate the flow of traffic to the web API, and implement throttling for specific clients that have exhausted their quotas.</span></span>
* <span data-ttu-id="98de3-376">Szabályozási követelmények előfordulhat, hogy engedélyezhetik naplózása és az összes kérelmeit és válaszait naplózását.</span><span class="sxs-lookup"><span data-stu-id="98de3-376">Regulatory requirements might mandate logging and auditing of all requests and responses.</span></span>
* <span data-ttu-id="98de3-377">Rendelkezésre állás biztosítása érdekében, akkor lehet szükség a webes API-t futtató kiszolgáló állapotának figyelésére, és szükség esetén indítsa újra.</span><span class="sxs-lookup"><span data-stu-id="98de3-377">To ensure availability, it may be necessary to monitor the health of the server hosting the web API and restart it if necessary.</span></span>

<span data-ttu-id="98de3-378">Akkor célszerű lehet használata leválasztja ezeket a problémákat a műszaki problémák, a webes API-k végrehajtására vonatkozó.</span><span class="sxs-lookup"><span data-stu-id="98de3-378">It is useful to be able to decouple these issues from the technical issues concerning the implementation of the web API.</span></span> <span data-ttu-id="98de3-379">Emiatt érdemes lehet létrehozni egy [homlokzati](http://en.wikipedia.org/wiki/Facade_pattern), és külön folyamatban futó kérelmek irányítja a webes API-hoz.</span><span class="sxs-lookup"><span data-stu-id="98de3-379">For this reason, consider creating a [façade](http://en.wikipedia.org/wiki/Facade_pattern), running as a separate process and that routes requests to the web API.</span></span> <span data-ttu-id="98de3-380">A homlokzati biztosíthat a felügyeleti műveleteket, és előre érvényesíteni a kéréseket a webes API-hoz.</span><span class="sxs-lookup"><span data-stu-id="98de3-380">The façade can provide the management operations and forward validated requests to the web API.</span></span> <span data-ttu-id="98de3-381">Egy homlokzati használatával művelettel is sok működési előnyöket, többek között:</span><span class="sxs-lookup"><span data-stu-id="98de3-381">Using a façade can also bring many functional advantages, including:</span></span>

* <span data-ttu-id="98de3-382">Több Web API-k integrációs pontjaként működött.</span><span class="sxs-lookup"><span data-stu-id="98de3-382">Acting as an integration point for multiple web APIs.</span></span>
* <span data-ttu-id="98de3-383">Üzenetek átalakítása, és a kommunikációs protokollokat fordítása ügyfelek különböző technológiák használatával készültek.</span><span class="sxs-lookup"><span data-stu-id="98de3-383">Transforming messages and translating communications protocols for clients built by using varying technologies.</span></span>
* <span data-ttu-id="98de3-384">Gyorsítótárazás kérelmeit és válaszait csökkentése érdekében betölteni a webes API-t futtató kiszolgálón.</span><span class="sxs-lookup"><span data-stu-id="98de3-384">Caching requests and responses to reduce load on the server hosting the web API.</span></span>

## <a name="testing-a-web-api"></a><span data-ttu-id="98de3-385">A webes API tesztelése</span><span class="sxs-lookup"><span data-stu-id="98de3-385">Testing a web API</span></span>
<span data-ttu-id="98de3-386">Egy webes API-t, mint minden más olyan szoftver alaposan kell vizsgálni.</span><span class="sxs-lookup"><span data-stu-id="98de3-386">A web API should be tested as thoroughly as any other piece of software.</span></span> <span data-ttu-id="98de3-387">Érdemes lehet egység tesztet végrehajtva ellenőrizze a webes API-k jellege működésére létrehozása számos lehetőséget kínál a saját további követelmények ellenőrzése, hogy megfelelően működik-e.</span><span class="sxs-lookup"><span data-stu-id="98de3-387">You should consider creating unit tests to validate the functionality of The nature of a web API brings its own additional requirements to verify that it operates correctly.</span></span> <span data-ttu-id="98de3-388">Meg kell különös figyelmet fordítani az alábbi szempontokat:</span><span class="sxs-lookup"><span data-stu-id="98de3-388">You should pay particular attention to the following aspects:</span></span>

* <span data-ttu-id="98de3-389">Az összes útvonal ellenőrzése, hogy azok a megfelelő műveleteket hívhatnak meg a teszteléséhez.</span><span class="sxs-lookup"><span data-stu-id="98de3-389">Test all routes to verify that they invoke the correct operations.</span></span> <span data-ttu-id="98de3-390">Különösen ügyeljen a visszaadott HTTP-állapotkód: (a metódus nem engedélyezett) 405 váratlanul Ez azt jelzi, hogy az útvonal és a HTTP-metódus (GET, POST, PUT, DELETE), amely képes továbbítani, hogy az útvonal eltérést.</span><span class="sxs-lookup"><span data-stu-id="98de3-390">Be especially aware of HTTP status code 405 (Method Not Allowed) being returned unexpectedly as this can indicate a mismatch between a route and the HTTP methods (GET, POST, PUT, DELETE) that can be dispatched to that route.</span></span>

    <span data-ttu-id="98de3-391">HTTP-kérelmeket küldjön útvonalakat, amelyek nem támogatják őket, például egy adott erőforrás POST kérelem elküldése (a POST kérelmek csak küldjön el erőforrás-gyűjtemények).</span><span class="sxs-lookup"><span data-stu-id="98de3-391">Send HTTP requests to routes that do not support them, such as submitting a POST request to a specific resource (POST requests should only be sent to resource collections).</span></span> <span data-ttu-id="98de3-392">Ezekben az esetekben az egyetlen érvényes válasz *kell* állapotkód 405 (nem engedélyezett) lehet.</span><span class="sxs-lookup"><span data-stu-id="98de3-392">In these cases, the only valid response *should* be status code 405 (Not Allowed).</span></span>
* <span data-ttu-id="98de3-393">Győződjön meg arról, hogy az összes útvonal megfelelően védettek, és a megfelelő hitelesítési és engedélyezési ellenőrzés alatt áll.</span><span class="sxs-lookup"><span data-stu-id="98de3-393">Verify that all routes are protected properly and are subject to the appropriate authentication and authorization checks.</span></span>

  > [!NOTE]
  > <span data-ttu-id="98de3-394">Például a felhasználó hitelesítési olyan vonatkozásai feltehetően az ezzel a webes API-k, hanem a gazdagép-környezetben, de továbbra is szükséges, hogy biztonsági vizsgálatok tartalmazzák a telepítési folyamat részeként.</span><span class="sxs-lookup"><span data-stu-id="98de3-394">Some aspects of security such as user authentication are most likely to be the responsibility of the host environment rather than the web API, but it is still necessary to include security tests as part of the deployment process.</span></span>
  >
  >
* <span data-ttu-id="98de3-395">Minden egyes művelet által végrehajtott kivételkezelést tesztelése, és győződjön meg arról, hogy egy megfelelő és a jelentéssel bíró HTTP-válasz küld vissza az ügyfélalkalmazást.</span><span class="sxs-lookup"><span data-stu-id="98de3-395">Test the exception handling performed by each operation and verify that an appropriate and meaningful HTTP response is passed back to the client application.</span></span>
* <span data-ttu-id="98de3-396">Ellenőrizze, hogy szabályos és válasz üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="98de3-396">Verify that request and response messages are well-formed.</span></span> <span data-ttu-id="98de3-397">Például ha egy HTTP POST-kérelmet tartalmazza az adatokat egy új erőforrás x-www-form-urlencoded formátumban, győződjön meg arról, hogy a megfelelő műveletet megfelelően elemzi az adatokat, az erőforrásokat, és az új erőforrás részleteit tartalmazó választ többek között a megfelelő helyet megjelölő fejlécet.</span><span class="sxs-lookup"><span data-stu-id="98de3-397">For example, if an HTTP POST request contains the data for a new resource in x-www-form-urlencoded format, confirm that the corresponding operation correctly parses the data, creates the resources, and returns a response containing the details of the new resource, including the correct Location header.</span></span>
* <span data-ttu-id="98de3-398">Ellenőrizze az összes hivatkozásokat és URI-azonosítók a válaszüzenetek.</span><span class="sxs-lookup"><span data-stu-id="98de3-398">Verify all links and URIs in response messages.</span></span> <span data-ttu-id="98de3-399">Például egy HTTP POST üzenet az újonnan létrehozott erőforrás URI kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="98de3-399">For example, an HTTP POST message should return the URI of the newly-created resource.</span></span> <span data-ttu-id="98de3-400">Minden HATEOAS kapcsolat érvényesnek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="98de3-400">All HATEOAS links should be valid.</span></span>

* <span data-ttu-id="98de3-401">Győződjön meg arról, hogy a minden művelet bemeneti különböző kombinációkban megfelelő állapotkódjai adja vissza.</span><span class="sxs-lookup"><span data-stu-id="98de3-401">Ensure that each operation returns the correct status codes for different combinations of input.</span></span> <span data-ttu-id="98de3-402">Példa:</span><span class="sxs-lookup"><span data-stu-id="98de3-402">For example:</span></span>

  * <span data-ttu-id="98de3-403">Sikeres lekérdezés esetén visszaadja-e állapotkód 200 (OK)</span><span class="sxs-lookup"><span data-stu-id="98de3-403">If a query is successful, it should return status code 200 (OK)</span></span>
  * <span data-ttu-id="98de3-404">Ha egy erőforrás nem található, a művelet HTTP-állapotkód: 404-es (nem található) kell visszaadnia.</span><span class="sxs-lookup"><span data-stu-id="98de3-404">If a resource is not found, the operation should return HTTP status code 404 (Not Found).</span></span>
  * <span data-ttu-id="98de3-405">Ha az ügyfél elküldi a kérelmeket, amelyek sikeresen töröl egy erőforrást, az állapotkód: 204 (nincs tartalom) kell lennie.</span><span class="sxs-lookup"><span data-stu-id="98de3-405">If the client sends a request that successfully deletes a resource, the status code should be 204 (No Content).</span></span>
  * <span data-ttu-id="98de3-406">Az ügyfél által létrehozott egy új erőforrást kérelmet küld, ha az állapotkódnak kell-e a 201-es (létrehozva)</span><span class="sxs-lookup"><span data-stu-id="98de3-406">If the client sends a request that creates a new resource, the status code should be 201 (Created)</span></span>

<span data-ttu-id="98de3-407">Figyelje, hogy váratlan állapotkódok 5xx tartományban vannak.</span><span class="sxs-lookup"><span data-stu-id="98de3-407">Watch out for unexpected response status codes in the 5xx range.</span></span> <span data-ttu-id="98de3-408">Ezek az üzenetek általában jelenti a kiszolgáló által annak jelzésére, hogy az eszköz nem egy érvényes kérelem teljesítéséhez.</span><span class="sxs-lookup"><span data-stu-id="98de3-408">These messages are usually reported by the host server to indicate that it was unable to fulfill a valid request.</span></span>

* <span data-ttu-id="98de3-409">A különböző kérelem fejléc kombinációit, amelyek egy ügyfélalkalmazást, adja meg, és győződjön meg arról, hogy a webes API-t adja vissza a várt információkat válaszüzenetek tesztelése.</span><span class="sxs-lookup"><span data-stu-id="98de3-409">Test the different request header combinations that a client application can specify and ensure that the web API returns the expected information in response messages.</span></span>
* <span data-ttu-id="98de3-410">Lekérdezési karakterláncok tesztelése.</span><span class="sxs-lookup"><span data-stu-id="98de3-410">Test query strings.</span></span> <span data-ttu-id="98de3-411">Egy műveletet a választható paraméterek: (például tördelési kérések) is igénybe vehet, ha tesztelni a különböző kombinációkban és a paraméterek sorrendjét.</span><span class="sxs-lookup"><span data-stu-id="98de3-411">If an operation can take optional parameters (such as pagination requests), test the different combinations and order of parameters.</span></span>
* <span data-ttu-id="98de3-412">Győződjön meg arról, hogy az aszinkron műveletek sikeresen befejeződnek.</span><span class="sxs-lookup"><span data-stu-id="98de3-412">Verify that asynchronous operations complete successfully.</span></span> <span data-ttu-id="98de3-413">Ha a webes API támogatja az adatfolyam-kérelmek nagyméretű bináris objektumok (például a video- vagy hang) visszaadó, győződjön meg arról, hogy ügyfélkérelmek nem tiltanak közben az adatok továbbítja adatfolyamként.</span><span class="sxs-lookup"><span data-stu-id="98de3-413">If the web API supports streaming for requests that return large binary objects (such as video or audio), ensure that client requests are not blocked while the data is streamed.</span></span> <span data-ttu-id="98de3-414">Ha a webes API-k megvalósítja a hosszan futó adatmódosítási műveletek lekérdezése, győződjön meg arról, hogy a műveletek jelentett állapotuk megfelelően azok a folytatáshoz.</span><span class="sxs-lookup"><span data-stu-id="98de3-414">If the web API implements polling for long-running data modification operations, verify that that the operations report their status correctly as they proceed.</span></span>

<span data-ttu-id="98de3-415">Inkább hozzon létre, és teljesítmény tesztek futtatása annak ellenőrzése, hogy a webes API-k cselekedjenek kielégítően működik.</span><span class="sxs-lookup"><span data-stu-id="98de3-415">You should also create and run performance tests to check that the web API operates satisfactorily under duress.</span></span> <span data-ttu-id="98de3-416">Webalkalmazás teljesítmény- és tesztelése a projekt betöltésekor Visual Studio Ultimate használatával hozhat létre.</span><span class="sxs-lookup"><span data-stu-id="98de3-416">You can build a web performance and load test project by using Visual Studio Ultimate.</span></span> <span data-ttu-id="98de3-417">További információkért lásd: [teljesítmény vizsgálat futtatása előtt egy alkalmazás](https://msdn.microsoft.com/library/dn250793.aspx).</span><span class="sxs-lookup"><span data-stu-id="98de3-417">For more information, see [Run performance tests on an application before a release](https://msdn.microsoft.com/library/dn250793.aspx).</span></span>

## <a name="using-azure-api-management"></a><span data-ttu-id="98de3-418">Az Azure API Management használata</span><span class="sxs-lookup"><span data-stu-id="98de3-418">Using Azure API Management</span></span> 

<span data-ttu-id="98de3-419">A Azure-érdemes [Azue API Management](https://azure.microsoft.com/documentation/services/api-management/) közzétételét és kezelését egy webes API-t.</span><span class="sxs-lookup"><span data-stu-id="98de3-419">On Azure, consider using [Azue API Management](https://azure.microsoft.com/documentation/services/api-management/) to publish and manage a web API.</span></span> <span data-ttu-id="98de3-420">Ez a funkció segítségével is létrehozhat olyan szolgáltatás, amely egy vagy több Web API-k egy homlokzati funkcionál.</span><span class="sxs-lookup"><span data-stu-id="98de3-420">Using this facility, you can generate a service that acts as a façade for one or more web APIs.</span></span> <span data-ttu-id="98de3-421">A szolgáltatás pedig egy méretezhető webszolgáltatás, amelyet hozhat létre és konfigurálja az Azure felügyeleti portál használatával.</span><span class="sxs-lookup"><span data-stu-id="98de3-421">The service is itself a scalable web service that you can create and configure by using the Azure Management portal.</span></span> <span data-ttu-id="98de3-422">Ez a szolgáltatás segítségével közzétehet és kezelhet a webes API-k az alábbiak szerint:</span><span class="sxs-lookup"><span data-stu-id="98de3-422">You can use this service to publish and manage a web API as follows:</span></span>

1. <span data-ttu-id="98de3-423">Egy webhely, az Azure cloud service vagy Azure virtuális gép központi telepítése a webes API-t.</span><span class="sxs-lookup"><span data-stu-id="98de3-423">Deploy the web API to a website, Azure cloud service, or Azure virtual machine.</span></span>
2. <span data-ttu-id="98de3-424">Az API management szolgáltatás kapcsolódni a webes API-t.</span><span class="sxs-lookup"><span data-stu-id="98de3-424">Connect the API management service to the web API.</span></span> <span data-ttu-id="98de3-425">A felügyeleti API URL-címre küldött kérelmeket a webes API URI-azonosítók van leképezve.</span><span class="sxs-lookup"><span data-stu-id="98de3-425">Requests sent to the URL of the management API are mapped to URIs in the web API.</span></span> <span data-ttu-id="98de3-426">Az azonos API management szolgáltatás irányíthatja a kérelmek egynél több webes API-hoz.</span><span class="sxs-lookup"><span data-stu-id="98de3-426">The same API management service can route requests to more than one web API.</span></span> <span data-ttu-id="98de3-427">Ez lehetővé teszi, hogy több webes API-k az egyetlen felügyeleti szolgáltatást összesíteni.</span><span class="sxs-lookup"><span data-stu-id="98de3-427">This enables you to aggregate multiple web APIs into a single management service.</span></span> <span data-ttu-id="98de3-428">Ehhez hasonlóan az azonos web API lehet hivatkozni több API management szolgáltatás Ha korlátozhatja, vagy a különböző alkalmazások funkcióinak partícióazonosító kell.</span><span class="sxs-lookup"><span data-stu-id="98de3-428">Similarly, the same web API can be referenced from more than one API management service if you need to restrict or partition the functionality available to different applications.</span></span>

   > [!NOTE]
   > <span data-ttu-id="98de3-429">Az URI-azonosítók a HTTP GET kérelmek válasz részeként létrehozott HATEOAS hivatkozások hivatkoznia kell az API management szolgáltatás és nem a webes API-t üzemeltető webkiszolgáló URL-CÍMÉT.</span><span class="sxs-lookup"><span data-stu-id="98de3-429">The URIs in HATEOAS links generated as part of the response for HTTP GET requests should reference the URL of the API management service and not the web server hosting the web API.</span></span>
   >
   >
3. <span data-ttu-id="98de3-430">Minden webes API-t, adja meg, amely a webes API-t és a választható paraméterek: egy művelet által végrehajtható elérhetővé teszi a HTTP-műveletek bemeneti adatként.</span><span class="sxs-lookup"><span data-stu-id="98de3-430">For each web API, specify the HTTP operations that the web API exposes together with any optional parameters that an operation can take as input.</span></span> <span data-ttu-id="98de3-431">Is beállítható, hogy az API management szolgáltatás kell gyorsítótárazza a választ, a webes API ismétlődő kérelmek az adatok optimalizálása kapott.</span><span class="sxs-lookup"><span data-stu-id="98de3-431">You can also configure whether the API management service should cache the response received from the web API to optimize repeated requests for the same data.</span></span> <span data-ttu-id="98de3-432">A minden művelet hozhat létre a HTTP-válasz részletes adatait rögzíti.</span><span class="sxs-lookup"><span data-stu-id="98de3-432">Record the details of the HTTP responses that each operation can generate.</span></span> <span data-ttu-id="98de3-433">Az adatok létrehozásához a dokumentáció a fejlesztők számára, ezért fontos, hogy a rendszer pontos és teljes.</span><span class="sxs-lookup"><span data-stu-id="98de3-433">This information is used to generate documentation for developers, so it is important that it is accurate and complete.</span></span>

   <span data-ttu-id="98de3-434">Megadhat műveletek az Azure felügyeleti portál által szolgáltatott varázslók segítségével manuálisan, vagy importálhatja azokat a definíciók WADL vagy Swagger formátumú tartalmazó fájlt.</span><span class="sxs-lookup"><span data-stu-id="98de3-434">You can either define operations manually using the wizards provided by the Azure Management portal, or you can import them from a file containing the definitions in WADL or Swagger format.</span></span>
4. <span data-ttu-id="98de3-435">A biztonsági beállítások az API management szolgáltatás és a webkiszolgáló a webes API-k közötti kommunikáció céljára.</span><span class="sxs-lookup"><span data-stu-id="98de3-435">Configure the security settings for communications between the API management service and the web server hosting the web API.</span></span> <span data-ttu-id="98de3-436">Az API management szolgáltatás jelenleg az egyszerű hitelesítés és a kölcsönös hitelesítést tanúsítványokkal, és az OAuth 2.0 felhasználói engedélyezési támogatja.</span><span class="sxs-lookup"><span data-stu-id="98de3-436">The API management service currently supports Basic authentication and mutual authentication using certificates, and OAuth 2.0 user authorization.</span></span>
5. <span data-ttu-id="98de3-437">Hozzon létre egy termék.</span><span class="sxs-lookup"><span data-stu-id="98de3-437">Create a product.</span></span> <span data-ttu-id="98de3-438">A termék a egység kiadvány; a webes API-t a kezelési szolgáltatást, hogy a termék korábban csatolva hozzá.</span><span class="sxs-lookup"><span data-stu-id="98de3-438">A product is the unit of publication; you add the web APIs that you previously connected to the management service to the product.</span></span> <span data-ttu-id="98de3-439">A termék meg van nyitva, a webes API-k elérhetővé válnak a fejlesztők számára.</span><span class="sxs-lookup"><span data-stu-id="98de3-439">When the product is published, the web APIs become available to developers.</span></span>

   > [!NOTE]
   > <span data-ttu-id="98de3-440">Közzététel a termék, mielőtt-felhasználócsoportokat, amelyek a termék elérheti és felhasználók hozzáadása az ezeket a csoportokat is meghatározhatja.</span><span class="sxs-lookup"><span data-stu-id="98de3-440">Prior to publishing a product, you can also define user-groups that can access the product and add users to these groups.</span></span> <span data-ttu-id="98de3-441">A felügyelhető a fejlesztők és a webes API-t használó alkalmazásokban.</span><span class="sxs-lookup"><span data-stu-id="98de3-441">This gives you control over the developers and applications that can use the web API.</span></span> <span data-ttu-id="98de3-442">Ha a webes API jóvá, nem tudnak hozzáférni az előtt egy fejlesztő kérést kell küldenie a termék rendszergazdájának.</span><span class="sxs-lookup"><span data-stu-id="98de3-442">If a web API is subject to approval, prior to being able to access it a developer must send a request to the product administrator.</span></span> <span data-ttu-id="98de3-443">A rendszergazda is hozzáférés engedélyezése vagy megtagadása a fejlesztőnek.</span><span class="sxs-lookup"><span data-stu-id="98de3-443">The administrator can grant or deny access to the developer.</span></span> <span data-ttu-id="98de3-444">Meglévő fejlesztők is blokkolható, ha olyan körülmények között módosíthatja.</span><span class="sxs-lookup"><span data-stu-id="98de3-444">Existing developers can also be blocked if circumstances change.</span></span>
   >
   >
6. <span data-ttu-id="98de3-445">Minden webes API-szabályzatok konfigurálása</span><span class="sxs-lookup"><span data-stu-id="98de3-445">Configure policies for each web API.</span></span> <span data-ttu-id="98de3-446">Házirendek szabályozására, például hogy a tartományok közötti hívások engedélyezni kell, hogyan hitelesíti az ügyfeleket, hogy XML és JSON adatok formázza transzparens módon, hogy egy adott IP-címtartomány hívásait korlátozza-e szempontok használati kvóták, és korlátozhatja a hívás sebessége.</span><span class="sxs-lookup"><span data-stu-id="98de3-446">Policies govern aspects such as whether cross-domain calls should be allowed, how to authenticate clients, whether to convert between XML and JSON data formats transparently, whether to restrict calls from a given IP range, usage quotas, and whether to limit the call rate.</span></span> <span data-ttu-id="98de3-447">Házirendek globálisan alkalmazhatók a teljes termék, a termék egy webes API-t vagy webes API-k az egyes műveletek között.</span><span class="sxs-lookup"><span data-stu-id="98de3-447">Policies can be applied globally across the entire product, for a single web API in a product, or for individual operations in a web API.</span></span>

<span data-ttu-id="98de3-448">További információkért lásd: a [API Management dokumentációja](/azure/api-management/).</span><span class="sxs-lookup"><span data-stu-id="98de3-448">For more information, see the [API Management Documentation](/azure/api-management/).</span></span> 

> [!TIP]
> <span data-ttu-id="98de3-449">Azure biztosít az Azure Traffic Manager, ami lehetővé teszi a feladatátvételi és terheléselosztási megvalósítása, és a késés csökkentésére különböző földrajzi helyeken található üzemeltetett webhely több példánya között.</span><span class="sxs-lookup"><span data-stu-id="98de3-449">Azure provides the Azure Traffic Manager which enables you to implement failover and load-balancing, and reduce latency across multiple instances of a web site hosted in different geographic locations.</span></span> <span data-ttu-id="98de3-450">Az API Management szolgáltatással; együtt használhatja az Azure Traffic Manager az API Management Service egy webhely keresztül Azure Traffic Manager-példányokban kívánja irányíthatja a kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="98de3-450">You can use Azure Traffic Manager in conjunction with the API Management Service; the API Management Service can route requests to instances of a web site through Azure Traffic Manager.</span></span>  <span data-ttu-id="98de3-451">További információkért lásd: [Traffic Manager útválasztási metódusok](/azure/traffic-manager/traffic-manager-routing-methods/).</span><span class="sxs-lookup"><span data-stu-id="98de3-451">For more information, see [Traffic Manager routing Methods](/azure/traffic-manager/traffic-manager-routing-methods/).</span></span>
>
> <span data-ttu-id="98de3-452">Ez a struktúra a webhelyek, az egyéni DNS-nevek használatakor konfigurálnia kell a megfelelő CNAME rekordot a DNS-nevével, az Azure Traffic Manager webhely ponthoz minden webhelyhez.</span><span class="sxs-lookup"><span data-stu-id="98de3-452">In this structure, if you are using custom DNS names for your web sites, you should configure the appropriate CNAME record for each web site to point to the DNS name of the Azure Traffic Manager web site.</span></span>
>

## <a name="supporting-client-side-developers"></a><span data-ttu-id="98de3-453">Ügyféloldali fejlesztők támogatása</span><span class="sxs-lookup"><span data-stu-id="98de3-453">Supporting client-side developers</span></span>
<span data-ttu-id="98de3-454">A fejlesztők ügyfélalkalmazások általában hozhat létre a web API, és a paraméterek, a adattípusok, a visszatérési típusok és a visszatérési kódokat, amelyek bemutatják a különböző kérelmek és között a webes válaszok vonatkozó dokumentációt elérésével ismereteket igényel szolgáltatás és az ügyfélalkalmazást.</span><span class="sxs-lookup"><span data-stu-id="98de3-454">Developers constructing client applications typically require information on how to access the web API, and documentation concerning the parameters, data types, return types, and return codes that describe the different requests and responses between the web service and the client application.</span></span>

### <a name="document-the-rest-operations-for-a-web-api"></a><span data-ttu-id="98de3-455">A webes API-k REST műveleteinek dokumentálása</span><span class="sxs-lookup"><span data-stu-id="98de3-455">Document the REST operations for a web API</span></span>
<span data-ttu-id="98de3-456">Az Azure API Management Service tartalmaz, amely leírja a REST-műveletek webes API-k által elérhetővé tett egy fejlesztői portálján.</span><span class="sxs-lookup"><span data-stu-id="98de3-456">The Azure API Management Service includes a developer portal that describes the REST operations exposed by a web API.</span></span> <span data-ttu-id="98de3-457">A termék is közzé lett téve jelenik meg ezen a portálon.</span><span class="sxs-lookup"><span data-stu-id="98de3-457">When a product has been published it appears on this portal.</span></span> <span data-ttu-id="98de3-458">A fejlesztők is használhatja e portált Feliratkozás a hozzáférést. a rendszergazda ezután jóváhagyhatja vagy visszautasítja a kérelmet.</span><span class="sxs-lookup"><span data-stu-id="98de3-458">Developers can use this portal to sign up for access; the administrator can then approve or deny the request.</span></span> <span data-ttu-id="98de3-459">Ha a fejlesztői jóvá van hagyva, rendelt való hitelesítéshez szükséges hívások az ügyfélalkalmazások számára, ők fejlesztik ki az előfizetés kulcsa.</span><span class="sxs-lookup"><span data-stu-id="98de3-459">If the developer is approved, they are assigned a subscription key that is used to authenticate calls from the client applications that they develop.</span></span> <span data-ttu-id="98de3-460">Ezt a kulcsot meg kell adni minden webes API-hívással egyébként elutasításra kerül.</span><span class="sxs-lookup"><span data-stu-id="98de3-460">This key must be provided with each web API call otherwise it will be rejected.</span></span>

<span data-ttu-id="98de3-461">Ezen a portálon is biztosítja:</span><span class="sxs-lookup"><span data-stu-id="98de3-461">This portal also provides:</span></span>

* <span data-ttu-id="98de3-462">Műveletek a érheti el, a szükséges paraméterek és a különböző válaszokat visszaadható listázása a termék dokumentációját.</span><span class="sxs-lookup"><span data-stu-id="98de3-462">Documentation for the product, listing the operations that it exposes, the parameters required, and the different responses that can be returned.</span></span> <span data-ttu-id="98de3-463">Vegye figyelembe, hogy ezek az információk jönnek létre a 3. lépésben a közzétételi listájában megadott adatok egy webes API-t a Microsoft Azure API Management Service szakasz segítségével.</span><span class="sxs-lookup"><span data-stu-id="98de3-463">Note that this information is generated from the details provided in step 3 in the list in the Publishing a web API by using the Microsoft Azure API Management Service section.</span></span>
* <span data-ttu-id="98de3-464">Az kódrészletek, amelyek bemutatják, hogyan több nyelven, beleértve a JavaScript, C#, Java, Ruby, Python, és a PHP műveleteket hívhatnak meg.</span><span class="sxs-lookup"><span data-stu-id="98de3-464">Code snippets that show how to invoke operations from several languages, including JavaScript, C#, Java, Ruby, Python, and PHP.</span></span>
* <span data-ttu-id="98de3-465">A fejlesztők konzol, amely lehetővé teszi a fejlesztők a termékben lévő egyes műveletek tesztelése, és az eredmények megtekintése a HTTP-kérelem küldése.</span><span class="sxs-lookup"><span data-stu-id="98de3-465">A developers' console that enables a developer to send an HTTP request to test each operation in the product and view the results.</span></span>
* <span data-ttu-id="98de3-466">Egy oldal, ahol a fejlesztői jelenthetik-e bármilyen problémák vagy a talált problémákat.</span><span class="sxs-lookup"><span data-stu-id="98de3-466">A page where the developer can report any issues or problems found.</span></span>

<span data-ttu-id="98de3-467">Az Azure felügyeleti portálra lehetővé teszi a fejlesztői portálján stíluselemekkel és az elrendezés felel meg a szervezet branding módosítása testreszabását.</span><span class="sxs-lookup"><span data-stu-id="98de3-467">The Azure Management portal enables you to customize the developer portal to change the styling and layout to match the branding of your organization.</span></span>

### <a name="implement-a-client-sdk"></a><span data-ttu-id="98de3-468">Egy ügyfél SDK megvalósítása</span><span class="sxs-lookup"><span data-stu-id="98de3-468">Implement a client SDK</span></span>
<span data-ttu-id="98de3-469">Egy ügyfélalkalmazás létrehozása, amely meghívja a többi hozzáférés kérése a webes API megköveteli, hogy minden kérelmet létrehozni és formázza megfelelően, a webszolgáltatást futtató kiszolgálón a kérelem elküldése és kidolgozására válasz elemzése kód jelentős mennyiségű írása a kérelem e sikeres vagy sikertelen volt, és minden visszaadott adatok kinyerése érdekében.</span><span class="sxs-lookup"><span data-stu-id="98de3-469">Building a client application that invokes REST requests to access a web API requires writing a significant amount of code to construct each request and format it appropriately, send the request to the server hosting the web service, and parse the response to work out whether the request succeeded or failed and extract any data returned.</span></span> <span data-ttu-id="98de3-470">Az ügyfélalkalmazás az a problémák elleni védekezésben, hogy a REST-felületet burkolja és kivonatolja a kevésbé fontos részletek belül több működési készlete módszerek SDK biztosíthat.</span><span class="sxs-lookup"><span data-stu-id="98de3-470">To insulate the client application from these concerns, you can provide an SDK that wraps the REST interface and abstracts these low-level details inside a more functional set of methods.</span></span> <span data-ttu-id="98de3-471">Egy ügyfélalkalmazás ezek a módszerek, amely transzparens módon hívások konvertálása a REST-kérelmek és alakítsa át a válaszok metódus visszatérési értékek programba.</span><span class="sxs-lookup"><span data-stu-id="98de3-471">A client application uses these methods, which transparently convert calls into REST requests and then convert the responses back into method return values.</span></span> <span data-ttu-id="98de3-472">Ez a sok szolgáltatásokat, például az Azure SDK által megvalósított közös technika.</span><span class="sxs-lookup"><span data-stu-id="98de3-472">This is a common technique that is implemented by many services, including the Azure SDK.</span></span>

<span data-ttu-id="98de3-473">Jelentős vállalkozás egy ügyféloldali SDK létrehozása esetén, mert van egységesen kell végrehajtani, alaposan tesztelni.</span><span class="sxs-lookup"><span data-stu-id="98de3-473">Creating a client-side SDK is a considerable undertaking as it has to be implemented consistently and tested carefully.</span></span> <span data-ttu-id="98de3-474">Azonban a folyamat nagy része gépi tehető, és sok szállítók eszközöket, amelyek a automatizálhat ezek a feladatok fogja tartalmazni.</span><span class="sxs-lookup"><span data-stu-id="98de3-474">However, much of this process can be made mechanical, and many vendors supply tools that can automate many of these tasks.</span></span>

## <a name="monitoring-a-web-api"></a><span data-ttu-id="98de3-475">Webes API-k figyelése</span><span class="sxs-lookup"><span data-stu-id="98de3-475">Monitoring a web API</span></span>
<span data-ttu-id="98de3-476">Attól függően, hogy hogyan közzététele és telepítése a webes API-t is figyelheti a webes API-k közvetlenül, vagy használati és adatokat gyűjthet a forgalomhoz, amely az API Management szolgáltatáson keresztül elemzésével.</span><span class="sxs-lookup"><span data-stu-id="98de3-476">Depending on how you have published and deployed your web API you can monitor the web API directly, or you can gather usage and health information by analyzing the traffic that passes through the API Management service.</span></span>

### <a name="monitoring-a-web-api-directly"></a><span data-ttu-id="98de3-477">Webes API-k közvetlenül figyelése</span><span class="sxs-lookup"><span data-stu-id="98de3-477">Monitoring a web API directly</span></span>
<span data-ttu-id="98de3-478">Ha a webes API-t az ASP.NET Web API-sablont (vagy a Web API-projektet, vagy egy Azure-felhőszolgáltatásban a webes szerepkör) és a Visual Studio 2013 megvalósítását, gyűjthet rendelkezésre állását, teljesítményét és használati adatok ASP.NET Application Insights segítségével.</span><span class="sxs-lookup"><span data-stu-id="98de3-478">If you have implemented your web API by using the ASP.NET Web API template (either as a Web API project or as a Web role in an Azure cloud service) and Visual Studio 2013, you can gather availability, performance, and usage data by using ASP.NET Application Insights.</span></span> <span data-ttu-id="98de3-479">Az Application Insights egy csomagot, amely transzparens módon nyomon követi, és információt kérelmeit és válaszait rögzíti, amikor a webes API-t a rendszer a felhő; Ha a csomag telepítve és konfigurálva van, nem kell módosítani kell a kódot a webes API-t használja.</span><span class="sxs-lookup"><span data-stu-id="98de3-479">Application Insights is a package that transparently tracks and records information about requests and responses when the web API is deployed to the cloud; once the package is installed and configured, you don't need to amend any code in your web API to use it.</span></span> <span data-ttu-id="98de3-480">A webes API-t az Azure-webhelyre történő telepítésekor az összes forgalom vizsgálják, és a következő adatokat gyűjti az adatokat:</span><span class="sxs-lookup"><span data-stu-id="98de3-480">When you deploy the web API to an Azure web site, all traffic is examined and the following statistics are gathered:</span></span>

* <span data-ttu-id="98de3-481">Kiszolgáló válaszideje.</span><span class="sxs-lookup"><span data-stu-id="98de3-481">Server response time.</span></span>
* <span data-ttu-id="98de3-482">Kiszolgáló kérések számát és az egyes kérelmek részletei.</span><span class="sxs-lookup"><span data-stu-id="98de3-482">Number of server requests and the details of each request.</span></span>
* <span data-ttu-id="98de3-483">A felső leglassabb kérelmek átlagos válaszidő tekintetében.</span><span class="sxs-lookup"><span data-stu-id="98de3-483">The top slowest requests in terms of average response time.</span></span>
* <span data-ttu-id="98de3-484">A sikertelen kérelmek részleteit.</span><span class="sxs-lookup"><span data-stu-id="98de3-484">The details of any failed requests.</span></span>
* <span data-ttu-id="98de3-485">A munkamenetek számának a különböző böngészők és a felhasználó által kezdeményezett ügynökök.</span><span class="sxs-lookup"><span data-stu-id="98de3-485">The number of sessions initiated by different browsers and user agents.</span></span>
* <span data-ttu-id="98de3-486">A legtöbb gyakran megtekintett lapok (elsősorban akkor hasznos, webes alkalmazásokhoz, hanem a webes API-khoz).</span><span class="sxs-lookup"><span data-stu-id="98de3-486">The most frequently viewed pages (primarily useful for web applications rather than web APIs).</span></span>
* <span data-ttu-id="98de3-487">A különböző felhasználói szerepköröket a webes API-k eléréséhez.</span><span class="sxs-lookup"><span data-stu-id="98de3-487">The different user roles accessing the web API.</span></span>

<span data-ttu-id="98de3-488">Valós idejű az Azure felügyeleti portálon megtekintheti ezeket az adatokat.</span><span class="sxs-lookup"><span data-stu-id="98de3-488">You can view this data in real time from the Azure Management portal.</span></span> <span data-ttu-id="98de3-489">Webtests, amely a webes API-k állapotának figyelésére is létrehozhat.</span><span class="sxs-lookup"><span data-stu-id="98de3-489">You can also create webtests that monitor the health of the web API.</span></span> <span data-ttu-id="98de3-490">A webtesztben rendszeres kérést küld a megadott URI-azonosító található a webes API-t, és a válasz rögzíti.</span><span class="sxs-lookup"><span data-stu-id="98de3-490">A webtest sends a periodic request to a specified URI in the web API and captures the response.</span></span> <span data-ttu-id="98de3-491">A sikeres válasz (például a HTTP-állapotkód 200) definícióját is megadhat, és ha a kérelem nem ad vissza ezt a választ egy rendszergazda küldendő riasztás elrendezheti.</span><span class="sxs-lookup"><span data-stu-id="98de3-491">You can specify the definition of a successful response (such as HTTP status code 200), and if the request does not return this response you can arrange for an alert to be sent to an administrator.</span></span> <span data-ttu-id="98de3-492">Ha szükséges, a rendszergazda újraindíthatja a kiszolgáló, a webes API-t futtató, ha sikertelen volt.</span><span class="sxs-lookup"><span data-stu-id="98de3-492">If necessary, the administrator can restart the server hosting the web API if it has failed.</span></span>

<span data-ttu-id="98de3-493">További információkért lásd: [ASP.NET Application Insights – első lépések](/azure/application-insights/app-insights-asp-net/).</span><span class="sxs-lookup"><span data-stu-id="98de3-493">For more information, see [Application Insights - Get started with ASP.NET](/azure/application-insights/app-insights-asp-net/).</span></span>

### <a name="monitoring-a-web-api-through-the-api-management-service"></a><span data-ttu-id="98de3-494">Az API Management szolgáltatáson keresztül webes API-k figyelése</span><span class="sxs-lookup"><span data-stu-id="98de3-494">Monitoring a web API through the API Management Service</span></span>
<span data-ttu-id="98de3-495">Ha a webes API-t az API Management szolgáltatással közzétett, az API Management oldalon, az Azure felügyeleti portálra tartalmaz egy irányítópultot, amely lehetővé teszi az általános teljesítményt, a szolgáltatás megtekintését.</span><span class="sxs-lookup"><span data-stu-id="98de3-495">If you have published your web API by using the API Management service, the API Management page on the Azure Management portal contains a dashboard that enables you to view the overall performance of the service.</span></span> <span data-ttu-id="98de3-496">Az Analytics lap lehetővé teszi a részletekbe menően tárhatják fel a termék felhasználási módjának részleteit.</span><span class="sxs-lookup"><span data-stu-id="98de3-496">The Analytics page enables you to drill down into the details of how the product is being used.</span></span> <span data-ttu-id="98de3-497">Ezen a lapon az alábbi lapokat tartalmazza:</span><span class="sxs-lookup"><span data-stu-id="98de3-497">This page contains the following tabs:</span></span>

* <span data-ttu-id="98de3-498">**Használati**.</span><span class="sxs-lookup"><span data-stu-id="98de3-498">**Usage**.</span></span> <span data-ttu-id="98de3-499">Ezen a lapon API-hívások és a sávszélesség adott idő alatt az adott hívások kezelésére használt információkat tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="98de3-499">This tab provides information about the number of API calls made and the bandwidth used to handle these calls over time.</span></span> <span data-ttu-id="98de3-500">Szűrheti a használat részleteiről termék, az API és a művelet.</span><span class="sxs-lookup"><span data-stu-id="98de3-500">You can filter usage details by product, API, and operation.</span></span>
* <span data-ttu-id="98de3-501">**Állapotfigyelő**.</span><span class="sxs-lookup"><span data-stu-id="98de3-501">**Health**.</span></span> <span data-ttu-id="98de3-502">Ezen a lapon megtekintheti az API-kérelmek (a HTTP-állapotkódok visszaadott) eredményeit, a gyorsítótárazási házirendet, az API válaszidő és a szolgáltatás válaszidejének hatékonyságát teszi lehetővé.</span><span class="sxs-lookup"><span data-stu-id="98de3-502">This tab enables you to view the outcome of API requests (the HTTP status codes returned), the effectiveness of the caching policy, the API response time, and the service response time.</span></span> <span data-ttu-id="98de3-503">Ebben az esetben szűrheti állapotadatok termék, az API és a művelet.</span><span class="sxs-lookup"><span data-stu-id="98de3-503">Again, you can filter health data by product, API, and operation.</span></span>
* <span data-ttu-id="98de3-504">**Tevékenység**.</span><span class="sxs-lookup"><span data-stu-id="98de3-504">**Activity**.</span></span> <span data-ttu-id="98de3-505">Ezen a lapon a sikeres hívás, sikertelen hívás, letiltott hívások, átlagos válaszidő és minden egyes termék, a webes API és a működéséhez válaszidők számú szöveg összegzését tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="98de3-505">This tab provides a text summary of the numbers of successful calls, failed calls, blocked calls, average response time, and response times for each product, web API, and operation.</span></span> <span data-ttu-id="98de3-506">Ezen a lapon is találhatók minden egyes fejlesztő felé indított hívások száma.</span><span class="sxs-lookup"><span data-stu-id="98de3-506">This page also lists the number of calls made by each developer.</span></span>
* <span data-ttu-id="98de3-507">**Egy pillanat alatt**.</span><span class="sxs-lookup"><span data-stu-id="98de3-507">**At a glance**.</span></span> <span data-ttu-id="98de3-508">Ezen a lapon a teljesítményadatokat, beleértve a fejlesztők feladata, hogy a legtöbb API-hívások, és a termékek, a webes API-k és a fogadott hívásokat a műveletek összegzését jeleníti meg.</span><span class="sxs-lookup"><span data-stu-id="98de3-508">This tab displays a summary of the performance data, including the developers responsible for making the most API calls, and the products, web APIs, and operations that received these calls.</span></span>

<span data-ttu-id="98de3-509">Ezek az információk segítségével határozza meg, hogy egy adott webes API-t vagy a művelet hatására a szűk keresztmetszetek, és ha szükséges méretezni a gazdagép-környezetben, és adjon hozzá további kiszolgálókat.</span><span class="sxs-lookup"><span data-stu-id="98de3-509">You can use this information to determine whether a particular web API or operation is causing a bottleneck, and if necessary scale the host environment and add more servers.</span></span> <span data-ttu-id="98de3-510">Akkor is megállapítása, hogy egy vagy több alkalmazást le aránytalanul nagy mennyiségű erőforrást használ, és a megfelelő házirendekkel kvótáit és hívás díjszabás korlátozza.</span><span class="sxs-lookup"><span data-stu-id="98de3-510">You can also ascertain whether one or more applications are using a disproportionate volume of resources and apply the appropriate policies to set quotas and limit call rates.</span></span>

> [!NOTE]
> <span data-ttu-id="98de3-511">Módosíthatja a közzétett termék adatait, és a módosítások azonnal.</span><span class="sxs-lookup"><span data-stu-id="98de3-511">You can change the details for a published product, and the changes are applied immediately.</span></span> <span data-ttu-id="98de3-512">Például vegye fel vagy távolítsa el a művelet a webes API-k anélkül, hogy újra közzé a terméket, amely tartalmazza a webes API-t.</span><span class="sxs-lookup"><span data-stu-id="98de3-512">For example, you can add or remove an operation from a web API without requiring that you republish the product that contains the web API.</span></span>
>
>

## <a name="more-information"></a><span data-ttu-id="98de3-513">További információ</span><span class="sxs-lookup"><span data-stu-id="98de3-513">More information</span></span>
* <span data-ttu-id="98de3-514">[Az ASP.NET Web API OData](http://www.asp.net/web-api/overview/odata-support-in-aspnet-web-api) példák és további információkat tartalmaz az OData webes API-k végrehajtási ASP.NET használatával.</span><span class="sxs-lookup"><span data-stu-id="98de3-514">[ASP.NET Web API OData](http://www.asp.net/web-api/overview/odata-support-in-aspnet-web-api) contains examples and further information on implementing an OData web API by using ASP.NET.</span></span>
* <span data-ttu-id="98de3-515">[Introducing kötegelt támogatása a webes API- és webes API OData](http://blogs.msdn.com/b/webdev/archive/2013/11/01/introducing-batch-support-in-web-api-and-web-api-odata.aspx) kötegműveletek megvalósítását a webes API-k használatával OData ismerteti.</span><span class="sxs-lookup"><span data-stu-id="98de3-515">[Introducing Batch Support in Web API and Web API OData](http://blogs.msdn.com/b/webdev/archive/2013/11/01/introducing-batch-support-in-web-api-and-web-api-odata.aspx) describes how to implement batch operations in a web API by using OData.</span></span>
* <span data-ttu-id="98de3-516">[Idempotencia minták](http://blog.jonathanoliver.com/idempotency-patterns/) Jonathan Oliver blogjában áttekintést idempotencia, és hogyan vonatkozik az felügyeleti műveleteket.</span><span class="sxs-lookup"><span data-stu-id="98de3-516">[Idempotency Patterns](http://blog.jonathanoliver.com/idempotency-patterns/) on Jonathan Oliver’s blog provides an overview of idempotency and how it relates to data management operations.</span></span>
* <span data-ttu-id="98de3-517">[Állapotkódok definícióit](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) a W3C a webhely HTTP-állapotkódok és azok leírásait tartalmazza a teljes listáját tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="98de3-517">[Status Code Definitions](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) on the W3C website contains a full list of HTTP status codes and their descriptions.</span></span>
* <span data-ttu-id="98de3-518">[Háttérfeladatok futtatása a webjobs-feladatok](/azure/app-service-web/web-sites-create-web-jobs/) útmutatást és példákat nyújt WebJobs használata a háttérbeli műveletek végrehajtásához.</span><span class="sxs-lookup"><span data-stu-id="98de3-518">[Run background tasks with WebJobs](/azure/app-service-web/web-sites-create-web-jobs/) provides information and examples on using WebJobs to perform background operations.</span></span>
* <span data-ttu-id="98de3-519">[Az Azure Notification Hubs – felhasználók értesítése](/azure/notification-hubs/notification-hubs-aspnet-backend-windows-dotnet-wns-notification/) bemutatja, hogyan használja az Azure Notification Hub leküldéses aszinkron válaszok ügyfélalkalmazások számára.</span><span class="sxs-lookup"><span data-stu-id="98de3-519">[Azure Notification Hubs Notify Users](/azure/notification-hubs/notification-hubs-aspnet-backend-windows-dotnet-wns-notification/) shows how to use an Azure Notification Hub to push asynchronous responses to client applications.</span></span>
* <span data-ttu-id="98de3-520">[Az API Management](https://azure.microsoft.com/services/api-management/) egy webes API-k felügyelt és biztonságos hozzáférést biztosító termék közzétételét ismerteti.</span><span class="sxs-lookup"><span data-stu-id="98de3-520">[API Management](https://azure.microsoft.com/services/api-management/) describes how to publish a product that provides controlled and secure access to a web API.</span></span>
* <span data-ttu-id="98de3-521">[Az Azure API Management REST API-referencia](https://msdn.microsoft.com/library/azure/dn776326.aspx) az API Management REST API használata egyéni felügyeleti alkalmazásokat hozhatnak létre.</span><span class="sxs-lookup"><span data-stu-id="98de3-521">[Azure API Management REST API Reference](https://msdn.microsoft.com/library/azure/dn776326.aspx) describes how to use the API Management REST API to build custom management applications.</span></span>
* <span data-ttu-id="98de3-522">[A TRAFFIC Manager útválasztási metódusok](/azure/traffic-manager/traffic-manager-routing-methods/) összefoglalja, hogyan Azure Traffic Manager segítségével terheléselosztásához kérelmek egy webes API-t futtató webhely több példánya között.</span><span class="sxs-lookup"><span data-stu-id="98de3-522">[Traffic Manager Routing Methods](/azure/traffic-manager/traffic-manager-routing-methods/) summarizes how Azure Traffic Manager can be used to load-balance requests across multiple instances of a website hosting a web API.</span></span>
* <span data-ttu-id="98de3-523">[Az Application Insights – első lépések ASP.NET](/azure/application-insights/app-insights-asp-net/) telepítését és konfigurálását egy ASP.NET Web API-projektet az Application Insights részletes információkat tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="98de3-523">[Application Insights - Get started with ASP.NET](/azure/application-insights/app-insights-asp-net/) provides detailed information on installing and configuring Application Insights in an ASP.NET Web API project.</span></span>


<!-- links -->

[api-design]: ./api-design.md
