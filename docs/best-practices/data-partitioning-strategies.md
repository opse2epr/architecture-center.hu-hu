---
title: Adatok particionálási stratégiái
titleSuffix: Best practices for cloud applications
description: Megadhat, és külön elérhető adatok partíciók útmutatást.
author: dragon119
ms.date: 11/04/2018
ms.topic: best-practice
ms.service: architecture-center
ms.subservice: cloud-fundamentals
ms.custom: seodec18
ms.openlocfilehash: bb810f549c78d16eabd4a96cd811cdc120cc8b6f
ms.sourcegitcommit: 579c39ff4b776704ead17a006bf24cd4cdc65edd
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 04/17/2019
ms.locfileid: "59640940"
---
# <a name="data-partitioning-strategies"></a><span data-ttu-id="2d356-103">Adatok particionálási stratégiái</span><span class="sxs-lookup"><span data-stu-id="2d356-103">Data partitioning strategies</span></span>

<span data-ttu-id="2d356-104">Ez a cikk ismerteti a különböző Azure adattárakban lévő adatokat a particionálás néhány stratégiát.</span><span class="sxs-lookup"><span data-stu-id="2d356-104">This article describes some strategies for partitioning data in various Azure data stores.</span></span> <span data-ttu-id="2d356-105">Adatok particionálása és ajánlott eljárások mikor kapcsolatos általános útmutatásért lásd [adatparticionálás](./data-partitioning.md)</span><span class="sxs-lookup"><span data-stu-id="2d356-105">For general guidance about when to partition data and best practices, see [Data partitioning](./data-partitioning.md)</span></span>

## <a name="partitioning-azure-sql-database"></a><span data-ttu-id="2d356-106">Az Azure SQL Database particionálási</span><span class="sxs-lookup"><span data-stu-id="2d356-106">Partitioning Azure SQL Database</span></span>

<span data-ttu-id="2d356-107">Az egyes SQL-adatbázisokban tárolható adatok mennyisége korlátozott.</span><span class="sxs-lookup"><span data-stu-id="2d356-107">A single SQL database has a limit to the volume of data that it can contain.</span></span> <span data-ttu-id="2d356-108">A feldolgozási sebességet architekturális tényezők és az adatbázis által támogatott egyidejű kapcsolatok száma korlátozzák.</span><span class="sxs-lookup"><span data-stu-id="2d356-108">Throughput is constrained by architectural factors and the number of concurrent connections that it supports.</span></span>

<span data-ttu-id="2d356-109">[Rugalmas készletek](/azure/sql-database/sql-database-elastic-pool) támogatja a horizontális skálázást SQL-adatbázishoz.</span><span class="sxs-lookup"><span data-stu-id="2d356-109">[Elastic pools](/azure/sql-database/sql-database-elastic-pool) support horizontal scaling for a SQL database.</span></span> <span data-ttu-id="2d356-110">Rugalmas készletek használata esetén is particionálja az adatait, amely több SQL-adatbázis között szegmensekre.</span><span class="sxs-lookup"><span data-stu-id="2d356-110">Using elastic pools, you can partition your data into shards that are spread across multiple SQL databases.</span></span> <span data-ttu-id="2d356-111">A kezelendő adatok mennyiségének növekedésével vagy csökkenésével hozzá is adhat és el is távolíthat szegmenseket.</span><span class="sxs-lookup"><span data-stu-id="2d356-111">You can also add or remove shards as the volume of data that you need to handle grows and shrinks.</span></span> <span data-ttu-id="2d356-112">Rugalmas készletek is segít csökkenteni a versengést elosztja a terhelést az adatbázisok között.</span><span class="sxs-lookup"><span data-stu-id="2d356-112">Elastic pools can also help reduce contention by distributing the load across databases.</span></span>

<span data-ttu-id="2d356-113">Minden egyes szegmens egy SQL-adatbázisként van megvalósítva.</span><span class="sxs-lookup"><span data-stu-id="2d356-113">Each shard is implemented as a SQL database.</span></span> <span data-ttu-id="2d356-114">Szegmensek több adatkészletet képes tárolni (nevű egy *shardlet*).</span><span class="sxs-lookup"><span data-stu-id="2d356-114">A shard can hold more than one dataset (called a *shardlet*).</span></span> <span data-ttu-id="2d356-115">Minden egyes adatbázis maga biztosítja a benne található shardleteket leíró metaadatokat.</span><span class="sxs-lookup"><span data-stu-id="2d356-115">Each database maintains metadata that describes the shardlets that it contains.</span></span> <span data-ttu-id="2d356-116">Egy shardlet lehet egyetlen adatelemet vagy shardlet ugyanazzal a kulccsal rendelkező elemek csoportja.</span><span class="sxs-lookup"><span data-stu-id="2d356-116">A shardlet can be a single data item, or a group of items that share the same shardlet key.</span></span> <span data-ttu-id="2d356-117">Ha például egy több-bérlős alkalmazásban, a shardletkulcs lehet a bérlő Azonosítóját, és egy bérlő összes adatát ugyanaz a shardlet tárolhatja tárolhatja.</span><span class="sxs-lookup"><span data-stu-id="2d356-117">For example, in a multitenant application, the shardlet key can be the tenant ID, and all data for a tenant can be held in the same shardlet.</span></span>

<span data-ttu-id="2d356-118">Ügyfélalkalmazások adatkészlet társít egy shardletkulcs felelős.</span><span class="sxs-lookup"><span data-stu-id="2d356-118">Client applications are responsible for associating a dataset with a shardlet key.</span></span> <span data-ttu-id="2d356-119">Egy külön SQL-adatbázis szolgál globális szegmenstérkép-kezelőként.</span><span class="sxs-lookup"><span data-stu-id="2d356-119">A separate SQL database acts as a global shard map manager.</span></span> <span data-ttu-id="2d356-120">Az adatbázis összes szegmens és shardlet listáját a rendszer tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="2d356-120">This database has a list of all the shards and shardlets in the system.</span></span> <span data-ttu-id="2d356-121">Az alkalmazás egy példányát a szegmenstérkép beszerzése a szegmenstérkép-kezelő adatbázis csatlakozik.</span><span class="sxs-lookup"><span data-stu-id="2d356-121">The application connects to the shard map manager database to obtain a copy of the shard map.</span></span> <span data-ttu-id="2d356-122">A horizontális skálázási térképet helyben gyorsítótárazza, és használja a térkép kérelmek átirányítása a megfelelő szegmensre.</span><span class="sxs-lookup"><span data-stu-id="2d356-122">It caches the shard map locally, and uses the map to route data requests to the appropriate shard.</span></span> <span data-ttu-id="2d356-123">Ez a funkció takarja el egy sor API, amely tartalmazza a [Elastic Database-ügyfélkódtár](/azure/sql-database/sql-database-elastic-database-client-library), amely Java és .NET érhető el.</span><span class="sxs-lookup"><span data-stu-id="2d356-123">This functionality is hidden behind a series of APIs that are contained in the [Elastic Database client library](/azure/sql-database/sql-database-elastic-database-client-library), which is available for Java and .NET.</span></span>

<span data-ttu-id="2d356-124">Rugalmas készletek kapcsolatos további információkért lásd: [horizontális felskálázás az Azure SQL Database](/azure/sql-database/sql-database-elastic-scale-introduction).</span><span class="sxs-lookup"><span data-stu-id="2d356-124">For more information about elastic pools, see [Scaling out with Azure SQL Database](/azure/sql-database/sql-database-elastic-scale-introduction).</span></span>

<span data-ttu-id="2d356-125">Csökkentheti a késéseket és javítható a rendelkezésre állás, a globális szegmenstérkép-kezelő adatbázis lehet replikálni.</span><span class="sxs-lookup"><span data-stu-id="2d356-125">To reduce latency and improve availability, you can replicate the global shard map manager database.</span></span> <span data-ttu-id="2d356-126">A prémium szintű díjcsomagok árából, az aktív georeplikáció folyamatosan replikálhatja az adatokat különböző régiókban lévő adatbázisokba konfigurálható.</span><span class="sxs-lookup"><span data-stu-id="2d356-126">With the Premium pricing tiers, you can configure active geo-replication to continuously copy data to databases in different regions.</span></span>

<span data-ttu-id="2d356-127">Másik megoldásként használhatja [Azure SQL Data Sync](/azure/sql-database/sql-database-sync-data) vagy [Azure Data Factory](/azure/data-factory/) a szegmenstérkép-kezelő adatbázis replikálása régiók között elosztva.</span><span class="sxs-lookup"><span data-stu-id="2d356-127">Alternatively, use [Azure SQL Data Sync](/azure/sql-database/sql-database-sync-data) or [Azure Data Factory](/azure/data-factory/) to replicate the shard map manager database across regions.</span></span> <span data-ttu-id="2d356-128">Ilyen típusú replikáció időközönként fut, és megfelelőbb, ha a szegmenstérkép ritkán módosul, és nem szükséges prémium szintű.</span><span class="sxs-lookup"><span data-stu-id="2d356-128">This form of replication runs periodically and is more suitable if the shard map changes infrequently, and does not require Premium tier.</span></span>

<span data-ttu-id="2d356-129">Az Elastic Database két sémát kínál az adatok shardletekre való leképezésére és a szegmenseken való eltárolására:</span><span class="sxs-lookup"><span data-stu-id="2d356-129">Elastic Database provides two schemes for mapping data to shardlets and storing them in shards:</span></span>

- <span data-ttu-id="2d356-130">A **listás szegmenstérkép** ugyanazt a kulcsot egy shardlet társítja.</span><span class="sxs-lookup"><span data-stu-id="2d356-130">A **list shard map** associates a single key to a shardlet.</span></span> <span data-ttu-id="2d356-131">Például egy több-bérlős rendszerben az egyes bérlők adatai egy egyedi kulccsal lehetnek társítva, majd egy külön shardletben tárolhatók.</span><span class="sxs-lookup"><span data-stu-id="2d356-131">For example, in a multitenant system, the data for each tenant can be associated with a unique key and stored in its own shardlet.</span></span> <span data-ttu-id="2d356-132">Elkülönítés biztosítása, minden egyes shardletek saját horizontális megtartható.</span><span class="sxs-lookup"><span data-stu-id="2d356-132">To guarantee isolation, each shardlet can be held within its own shard.</span></span>

    ![Bérlők adatainak tárolása külön szegmensekben listás szegmenstérkép használatával](./images/data-partitioning/PointShardlet.png)

- <span data-ttu-id="2d356-134">A **tartomány-szegmenstérkép** társítja a egy shardlet összefüggő key értékek egy halmazát.</span><span class="sxs-lookup"><span data-stu-id="2d356-134">A **range shard map** associates a set of contiguous key values to a shardlet.</span></span> <span data-ttu-id="2d356-135">Ha például csoportosíthatók azon bérlők számára (mindegyik saját kulccsal) belül ugyanaz a shardlet tárolhatja az adatokat.</span><span class="sxs-lookup"><span data-stu-id="2d356-135">For example, you can group the data for a set of tenants (each with their own key) within the same shardlet.</span></span> <span data-ttu-id="2d356-136">Ez a séma kevésbé költséges, mint az első, mivel a bérlők osztoznak az adattárolási, de kevesebb elszigetelést.</span><span class="sxs-lookup"><span data-stu-id="2d356-136">This scheme is less expensive than the first, because tenants share data storage, but has less isolation.</span></span>

    ![Bérlőtartomány adatainak tárolása tartomány-szegmenstérkép használatával](./images/data-partitioning/RangeShardlet.png)

<span data-ttu-id="2d356-138">Egyetlen szegmens több shardlet adatait is tartalmazhatja.</span><span class="sxs-lookup"><span data-stu-id="2d356-138">A single shard can contain the data for several shardlets.</span></span> <span data-ttu-id="2d356-139">Például listás shardletek használatával több nem egymást követő shardlet adatait is tárolhatja egyetlen szegmensben.</span><span class="sxs-lookup"><span data-stu-id="2d356-139">For example, you can use list shardlets to store data for different non-contiguous tenants in the same shard.</span></span> <span data-ttu-id="2d356-140">Bár ezek külön térképeken kibocsátásokban megtörténik a tartományshardleteket és a listás shardleteket ugyanabban a szegmensben is kombinálhatók.</span><span class="sxs-lookup"><span data-stu-id="2d356-140">You can also mix range shardlets and list shardlets in the same shard, although they will be addressed through different maps.</span></span> <span data-ttu-id="2d356-141">Az alábbi ábrán ez a módszer:</span><span class="sxs-lookup"><span data-stu-id="2d356-141">The following diagram shows this approach:</span></span>

![Több szegmenstérkép megvalósítása](./images/data-partitioning/MultipleShardMaps.png)

<span data-ttu-id="2d356-143">Rugalmas készletek adjon hozzá és távolíthat szegmenseket az adatmennyiség növekedésének vagy csökkenésének lehetővé teszi.</span><span class="sxs-lookup"><span data-stu-id="2d356-143">Elastic pools makes it possible to add and remove shards as the volume of data shrinks and grows.</span></span> <span data-ttu-id="2d356-144">Ügyfél-alkalmazások létrehozása és törölhetnek szegmenseket dinamikusan, és transzparens módon frissíthetik a szegmenstérkép-kezelőt.</span><span class="sxs-lookup"><span data-stu-id="2d356-144">Client applications can create and delete shards dynamically, and transparently update the shard map manager.</span></span> <span data-ttu-id="2d356-145">A szegmensek eltávolítása azonban egy destruktív művelet, amelyet követően a szegmensben lévő összes adatot törölni kell.</span><span class="sxs-lookup"><span data-stu-id="2d356-145">However, removing a shard is a destructive operation that also requires deleting all the data in that shard.</span></span>

<span data-ttu-id="2d356-146">Ha egy alkalmazásnak kell osztani két külön szegmensekben vagy összevonás szegmensekre, használja a [felosztási-egyesítési eszközének](/azure/sql-database/sql-database-elastic-scale-overview-split-and-merge).</span><span class="sxs-lookup"><span data-stu-id="2d356-146">If an application needs to split a shard into two separate shards or combine shards, use the [split-merge tool](/azure/sql-database/sql-database-elastic-scale-overview-split-and-merge).</span></span> <span data-ttu-id="2d356-147">Ez az eszköz egy Azure-webszolgáltatásként fut, és migrálja az adatokat a szegmensek közötti biztonságos.</span><span class="sxs-lookup"><span data-stu-id="2d356-147">This tool runs as an Azure web service, and migrates data safely between shards.</span></span>

<span data-ttu-id="2d356-148">A particionálási séma jelentős hatással lehet a rendszer teljesítményét.</span><span class="sxs-lookup"><span data-stu-id="2d356-148">The partitioning scheme can significantly affect the performance of your system.</span></span> <span data-ttu-id="2d356-149">Azt is befolyásolhatja a sebesség, amellyel szegmensek kell hozzáadni vagy eltávolítani, illetve adatokat kell kell particionálni a szegmensek között.</span><span class="sxs-lookup"><span data-stu-id="2d356-149">It can also affect the rate at which shards have to be added or removed, or that data must be repartitioned across shards.</span></span> <span data-ttu-id="2d356-150">Vegye figyelembe a következőket:</span><span class="sxs-lookup"><span data-stu-id="2d356-150">Consider the following points:</span></span>

- <span data-ttu-id="2d356-151">Ugyanabban a szegmensben az együtt használt adatokat csoportosítsa, és kerülje az olyan műveleteket, amelyek több szegmens származó adatok eléréséhez.</span><span class="sxs-lookup"><span data-stu-id="2d356-151">Group data that is used together in the same shard, and avoid operations that access data from multiple shards.</span></span> <span data-ttu-id="2d356-152">Egy szegmens egy önálló SQL-adatbázis, és adatbázisok közti összekapcsolásokat az ügyféloldalon kell végrehajtani.</span><span class="sxs-lookup"><span data-stu-id="2d356-152">A shard is a SQL database in its own right, and cross-database joins must be performed on the client side.</span></span>

    <span data-ttu-id="2d356-153">Bár az SQL Database nem támogatja az adatbázisok közti összekapcsolásokat, a rugalmas Adatbáziseszközök végrehajtásához használhatja [több horizontális partíciós lekérdezések](/azure/sql-database/sql-database-elastic-scale-multishard-querying).</span><span class="sxs-lookup"><span data-stu-id="2d356-153">Although SQL Database does not support cross-database joins, you can use the Elastic Database tools to perform [multi-shard queries](/azure/sql-database/sql-database-elastic-scale-multishard-querying).</span></span> <span data-ttu-id="2d356-154">Többszegmenses lekérdezés egyéni lekérdezéseket küld minden egyes adatbázishoz, és egyesíti az eredményeket.</span><span class="sxs-lookup"><span data-stu-id="2d356-154">A multi-shard query sends individual queries to each database and merges the results.</span></span>

- <span data-ttu-id="2d356-155">Olyan rendszerek, szegmensek közötti függőségek rendelkező kialakítását.</span><span class="sxs-lookup"><span data-stu-id="2d356-155">Don't design a system that has dependencies between shards.</span></span> <span data-ttu-id="2d356-156">Hivatkozási integritási megkötéseket, eseményindítók és a egy adatbázisban tárolt eljárások nem hivatkozhat egy másik objektumaira.</span><span class="sxs-lookup"><span data-stu-id="2d356-156">Referential integrity constraints, triggers, and stored procedures in one database cannot reference objects in another.</span></span>

- <span data-ttu-id="2d356-157">Ha rendelkezik a lekérdezések által gyakran használt referenciaadatok, fontolja meg az adatok replikálása a szegmensek között.</span><span class="sxs-lookup"><span data-stu-id="2d356-157">If you have reference data that is frequently used by queries, consider replicating this data across shards.</span></span> <span data-ttu-id="2d356-158">Ez a megközelítés is szükségtelenné teszi a data join több adatbázisban.</span><span class="sxs-lookup"><span data-stu-id="2d356-158">This approach can remove the need to join data across databases.</span></span> <span data-ttu-id="2d356-159">Ideális esetben az ilyen adatok lehetnek statikus vagy lassan mozgó, csökkentheti a replikálás beavatkozást, és csökkentheti a replikációigény elavult.</span><span class="sxs-lookup"><span data-stu-id="2d356-159">Ideally, such data should be static or slow-moving, to minimize the replication effort and reduce the chances of it becoming stale.</span></span>

- <span data-ttu-id="2d356-160">Ugyanahhoz a szegmenstérképhez tartozó Shardlet ugyanazzal a sémával kell rendelkeznie.</span><span class="sxs-lookup"><span data-stu-id="2d356-160">Shardlets that belong to the same shard map should have the same schema.</span></span> <span data-ttu-id="2d356-161">Ez a szabály nem kényszeríti az SQL Database, azonban az adatok kezelése és lekérdezése rendkívül bonyolulttá, ha az egyes shardletek különböző sémákkal rendelkeznek válik.</span><span class="sxs-lookup"><span data-stu-id="2d356-161">This rule is not enforced by SQL Database, but data management and querying becomes very complex if each shardlet has a different schema.</span></span> <span data-ttu-id="2d356-162">Ehelyett hozzon létre külön szegmenstérképet minden séma.</span><span class="sxs-lookup"><span data-stu-id="2d356-162">Instead, create separate shard maps for each schema.</span></span> <span data-ttu-id="2d356-163">Ne feledje, hogy különböző shardleteken adatokat tárolhatja ugyanabban a szegmensben.</span><span class="sxs-lookup"><span data-stu-id="2d356-163">Remember that data belonging to different shardlets can be stored in the same shard.</span></span>

- <span data-ttu-id="2d356-164">Tranzakciós műveletek csak az adatok horizontális skálázáson belül, és a szegmensek között nem támogatottak.</span><span class="sxs-lookup"><span data-stu-id="2d356-164">Transactional operations are only supported for data within a shard, and not across shards.</span></span> <span data-ttu-id="2d356-165">A tranzakciók több shardletet is érinthetnek, amennyiben azok egyazon szegmens részét képezik.</span><span class="sxs-lookup"><span data-stu-id="2d356-165">Transactions can span shardlets as long as they are part of the same shard.</span></span> <span data-ttu-id="2d356-166">Ezért ha az üzleti logikának kell tranzakciókat végrehajtania, vagy ugyanabban a szegmensben lévő adatok tárolásához, vagy valósítson meg végső konzisztenciát.</span><span class="sxs-lookup"><span data-stu-id="2d356-166">Therefore, if your business logic needs to perform transactions, either store the data in the same shard or implement eventual consistency.</span></span>

- <span data-ttu-id="2d356-167">A szegmenseket tárolja az azokban lévő adatokat használó felhasználók közelében helyezze el.</span><span class="sxs-lookup"><span data-stu-id="2d356-167">Place shards close to the users that access the data in those shards.</span></span> <span data-ttu-id="2d356-168">Ezzel a stratégiával csökkenthetők a késések.</span><span class="sxs-lookup"><span data-stu-id="2d356-168">This strategy helps reduce latency.</span></span>

- <span data-ttu-id="2d356-169">Kerülje a nagyon aktív és inaktív viszonylag szegmensek vegyesen kellene.</span><span class="sxs-lookup"><span data-stu-id="2d356-169">Avoid having a mixture of highly active and relatively inactive shards.</span></span> <span data-ttu-id="2d356-170">Próbálja a terhelést egyenletesen elosztani a szegmensek között.</span><span class="sxs-lookup"><span data-stu-id="2d356-170">Try to spread the load evenly across shards.</span></span> <span data-ttu-id="2d356-171">Előfordulhat, hogy a horizontális skálázás kulcsok kivonatoláshoz.</span><span class="sxs-lookup"><span data-stu-id="2d356-171">This might require hashing the sharding keys.</span></span> <span data-ttu-id="2d356-172">Ha a szegmensek földrajzi elhelyezkedése lényeges, gondoskodjon róla, hogy a kivonatalapú kulcsok az adatokat használó felhasználókhoz közeli szegmensekben tárolt shardletekre mutatnak.</span><span class="sxs-lookup"><span data-stu-id="2d356-172">If you are geo-locating shards, make sure that the hashed keys map to shardlets held in shards stored close to the users that access that data.</span></span>

### <a name="partitioning-azure-table-storage"></a><span data-ttu-id="2d356-173">Az Azure Table Storage particionálása</span><span class="sxs-lookup"><span data-stu-id="2d356-173">Partitioning Azure table storage</span></span>

<span data-ttu-id="2d356-174">Az Azure Table Storage egy particionálási célokra kifejlesztett kulcs-érték tároló.</span><span class="sxs-lookup"><span data-stu-id="2d356-174">Azure table storage is a key-value store that's designed around partitioning.</span></span> <span data-ttu-id="2d356-175">Minden entitás tárolása egy partícióban történik, és a partíciókat belsőleg az Azure Table Storage kezeli.</span><span class="sxs-lookup"><span data-stu-id="2d356-175">All entities are stored in a partition, and partitions are managed internally by Azure table storage.</span></span> <span data-ttu-id="2d356-176">A táblákban tárolt minden entitás meg kell adnia egy kétrészes kulcsot, amely tartalmazza:</span><span class="sxs-lookup"><span data-stu-id="2d356-176">Each entity stored in a table must provide a two-part key that includes:</span></span>

- <span data-ttu-id="2d356-177">**A partíciókulcs**.</span><span class="sxs-lookup"><span data-stu-id="2d356-177">**The partition key**.</span></span> <span data-ttu-id="2d356-178">Ha az Azure table storage helyezi az entitást, amely meghatározza a partíció karakterlánc-érték ez.</span><span class="sxs-lookup"><span data-stu-id="2d356-178">This is a string value that determines the partition where Azure table storage will place the entity.</span></span> <span data-ttu-id="2d356-179">Ugyanazzal a partíciókulccsal rendelkező entitások mind ugyanazon a partíción tárolja.</span><span class="sxs-lookup"><span data-stu-id="2d356-179">All entities with the same partition key are stored in the same partition.</span></span>

- <span data-ttu-id="2d356-180">**A sorkulcs**.</span><span class="sxs-lookup"><span data-stu-id="2d356-180">**The row key**.</span></span> <span data-ttu-id="2d356-181">Ez az egy karakterláncérték, amely azonosítja az entitást a partíción belül.</span><span class="sxs-lookup"><span data-stu-id="2d356-181">This is a string value that identifies the entity within the partition.</span></span> <span data-ttu-id="2d356-182">A partícióban lévő entitások a sorkulcs alapján vannak növekvő betűrendbe rendezve.</span><span class="sxs-lookup"><span data-stu-id="2d356-182">All entities within a partition are sorted lexically, in ascending order, by this key.</span></span> <span data-ttu-id="2d356-183">Minden egyes entitásnak egyedi partíciókulcs-sorkulcs kombinációval kell rendelkeznie, amelynek a hossza legfeljebb 1 KB lehet.</span><span class="sxs-lookup"><span data-stu-id="2d356-183">The partition key/row key combination must be unique for each entity and cannot exceed 1 KB in length.</span></span>

<span data-ttu-id="2d356-184">Ha egy korábban nem használt partíciókulccsal rendelkező entitást vesz fel egy táblába, az Azure Table Storage egy új partíciót hoz létre az entitás számára.</span><span class="sxs-lookup"><span data-stu-id="2d356-184">If an entity is added to a table with a previously unused partition key, Azure table storage creates a new partition for this entity.</span></span> <span data-ttu-id="2d356-185">Az ezzel a partíciókulccsal rendelkező többi entitás is ugyanezen a partíción lesz tárolva.</span><span class="sxs-lookup"><span data-stu-id="2d356-185">Other entities with the same partition key will be stored in the same partition.</span></span>

<span data-ttu-id="2d356-186">Ez az eljárás lényegében egy automatikus horizontális felskálázási stratégiát valósít meg.</span><span class="sxs-lookup"><span data-stu-id="2d356-186">This mechanism effectively implements an automatic scale-out strategy.</span></span> <span data-ttu-id="2d356-187">Mindegyik partíció tárolja az Azure-adatközpontban annak biztosítására, hogy adatokat egyetlen partícióról lekérő lekérdezések gyorsan futhassanak ugyanazon a kiszolgálón.</span><span class="sxs-lookup"><span data-stu-id="2d356-187">Each partition is stored on the same server in an Azure datacenter to help ensure that queries that retrieve data from a single partition run quickly.</span></span>

<span data-ttu-id="2d356-188">A Microsoft tett közzé [teljesítménycélokat] Azure Storage-hoz.</span><span class="sxs-lookup"><span data-stu-id="2d356-188">Microsoft has published [scalability targets] for Azure Storage.</span></span> <span data-ttu-id="2d356-189">Ha a rendszer várhatóan meghaladja majd ezeket a korlátokat, érdemes lehet entitások felosztása több táblára felosztva.</span><span class="sxs-lookup"><span data-stu-id="2d356-189">If your system is likely to exceed these limits, consider splitting entities into multiple tables.</span></span> <span data-ttu-id="2d356-190">Vertikális particionálás használatával ossza fel a mezőket csoportokra aszerint, hogy várhatóan melyik mezőkhöz férnek hozzá együtt.</span><span class="sxs-lookup"><span data-stu-id="2d356-190">Use vertical partitioning to divide the fields into the groups that are most likely to be accessed together.</span></span>

<span data-ttu-id="2d356-191">Az alábbi ábrán látható egy példatárfiókban logikai struktúráját.</span><span class="sxs-lookup"><span data-stu-id="2d356-191">The following diagram shows the logical structure of an example storage account.</span></span> <span data-ttu-id="2d356-192">A tárfiók három táblát tartalmaz: Customer Info, Product Info és Order Info.</span><span class="sxs-lookup"><span data-stu-id="2d356-192">The storage account contains three tables: Customer Info, Product Info, and Order Info.</span></span>

![Táblák és partíciók egy példatárfiókban](./images/data-partitioning/TableStorage.png)

<span data-ttu-id="2d356-194">Mindegyik tábla több partíciót tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="2d356-194">Each table has multiple partitions.</span></span>

- <span data-ttu-id="2d356-195">A Customer Info táblában az adatok particionálása az alapján a város, ahol az ügyfél megtalálható.</span><span class="sxs-lookup"><span data-stu-id="2d356-195">In the Customer Info table, the data is partitioned according to the city where the customer is located.</span></span> <span data-ttu-id="2d356-196">A sorkulcs az ügyfél-azonosítót tartalmaz.</span><span class="sxs-lookup"><span data-stu-id="2d356-196">The row key contains the customer ID.</span></span>
- <span data-ttu-id="2d356-197">A Product Info táblában a termékek a termékkategória szerint vannak particionálva, és a sorkulcs a termékszám.</span><span class="sxs-lookup"><span data-stu-id="2d356-197">In the Product Info table, products are partitioned by product category, and the row key contains the product number.</span></span>
- <span data-ttu-id="2d356-198">Az Order Info táblában a megrendelések rendelési dátum szerint vannak particionálva, és a sorkulcs Megadja azt az időtartamot, a megrendelések fogadásának.</span><span class="sxs-lookup"><span data-stu-id="2d356-198">In the Order Info table, the orders are partitioned by order date, and the row key specifies the time the order was received.</span></span> <span data-ttu-id="2d356-199">Az adatok az egyes partíciókban a sorkulcs alapján vannak rendezve.</span><span class="sxs-lookup"><span data-stu-id="2d356-199">Note that all data is ordered by the row key in each partition.</span></span>

<span data-ttu-id="2d356-200">Az Azure Table Storage-ben használt entitások kialakításakor vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="2d356-200">Consider the following points when you design your entities for Azure table storage:</span></span>

- <span data-ttu-id="2d356-201">Válassza ki egy partíciókulcsot és a sorkulcs szerint hogyan az adatokhoz.</span><span class="sxs-lookup"><span data-stu-id="2d356-201">Select a partition key and row key by how the data is accessed.</span></span> <span data-ttu-id="2d356-202">Válasszon olyan partíciókulcs-sorkulcs kombinációt, amely a lekérdezések nagyobb részét támogatja.</span><span class="sxs-lookup"><span data-stu-id="2d356-202">Choose a partition key/row key combination that supports the majority of your queries.</span></span> <span data-ttu-id="2d356-203">A leghatékonyabb lekérdezések a partíciókulcs és a sorkulcs megadásával kérik le az adatokat.</span><span class="sxs-lookup"><span data-stu-id="2d356-203">The most efficient queries retrieve data by specifying the partition key and the row key.</span></span> <span data-ttu-id="2d356-204">Az egy partíciókulcsot és a sorkulcsok egy tartományát megadó lekérdezések egy partíció vizsgálatával hajthatók végre.</span><span class="sxs-lookup"><span data-stu-id="2d356-204">Queries that specify a partition key and a range of row keys can be completed by scanning a single partition.</span></span> <span data-ttu-id="2d356-205">Ez viszonylag gyorsan megy, mivel az adatok a sorkulcs szerint vannak rendezve.</span><span class="sxs-lookup"><span data-stu-id="2d356-205">This is relatively fast because the data is held in row key order.</span></span> <span data-ttu-id="2d356-206">Lekérdezések nem adja meg, melyik partíciót kell átvizsgálni, ha minden partíciót kell átvizsgálni.</span><span class="sxs-lookup"><span data-stu-id="2d356-206">If queries don't specify which partition to scan, every partition must be scanned.</span></span>

- <span data-ttu-id="2d356-207">Ha valamely entitás természetes kulccsal rendelkezik, használja azt partíciókulcsként, és adjon meg egy üres sztringet sorkulcsként.</span><span class="sxs-lookup"><span data-stu-id="2d356-207">If an entity has one natural key, then use it as the partition key and specify an empty string as the row key.</span></span> <span data-ttu-id="2d356-208">Ha egy entitás két tulajdonság álló összetett kulccsal rendelkezik, válassza ki a ritkábban változó tulajdonságot partíciókulcsként, míg a másik sorkulcsként.</span><span class="sxs-lookup"><span data-stu-id="2d356-208">If an entity has a composite key consisting of two properties, select the slowest changing property as the partition key and the other as the row key.</span></span> <span data-ttu-id="2d356-209">Ha egy entitás kettőnél több kulcstulajdonsággal rendelkezik, a tulajdonságok összefűzésével adja meg a partíció- és a sorkulcsot.</span><span class="sxs-lookup"><span data-stu-id="2d356-209">If an entity has more than two key properties, use a concatenation of properties to provide the partition and row keys.</span></span>

- <span data-ttu-id="2d356-210">Ha rendszeresen hajt végre lekérdezéseket, amelyek a partíció- és sorkulcsot kulcsok eltérő mezők alapján adatokat kereshet, vegye fontolóra a [Indextábla minta](../patterns/index-table.md), vagy fontolja meg egy másik adattárhoz, amely támogatja az indexelést, például a Cosmos DB használatával .</span><span class="sxs-lookup"><span data-stu-id="2d356-210">If you regularly perform queries that look up data by using fields other than the partition and row keys, consider implementing the [Index Table pattern](../patterns/index-table.md), or consider using a different data store that supports indexing, such as Cosmos DB.</span></span>

- <span data-ttu-id="2d356-211">Ha a partíciókulcsokat egy monoton sorozat alapján (például "0001", "0002", "0003") használatával hozzon létre, és mindegyik partíció csak korlátozott mennyiségű adatot tartalmaz, az Azure table storage képes fizikailag csoportosítani ezeket a partíciókat együtt ugyanazon a kiszolgálón.</span><span class="sxs-lookup"><span data-stu-id="2d356-211">If you generate partition keys by using a monotonic sequence (such as "0001", "0002", "0003") and each partition only contains a limited amount of data, Azure table storage can physically group these partitions together on the same server.</span></span> <span data-ttu-id="2d356-212">Az Azure Storage feltételezi, hogy az alkalmazás nagy valószínűséggel egy egybefüggő tartományát (lekérdezések) partíciók közötti lekérdezések végrehajtásához, és ebben az esetben van optimalizálva.</span><span class="sxs-lookup"><span data-stu-id="2d356-212">Azure Storage assumes that the application is most likely to perform queries across a contiguous range of partitions (range queries) and is optimized for this case.</span></span> <span data-ttu-id="2d356-213">Azonban ez a megközelítés vezethet pontokhoz, mert az új entitások koncentrálódik várhatóan egyik végén lehet koncentrált az egybefüggő tartományát.</span><span class="sxs-lookup"><span data-stu-id="2d356-213">However, this approach can lead to hotspots, because all insertions of new entities are likely to be concentrated at one end the contiguous range.</span></span> <span data-ttu-id="2d356-214">Emellett a skálázhatóságot is csökkentheti.</span><span class="sxs-lookup"><span data-stu-id="2d356-214">It can also reduce scalability.</span></span> <span data-ttu-id="2d356-215">A terhelés egyenletesebb elosztását, érdemes kivonatolnia a partíciókulcsot.</span><span class="sxs-lookup"><span data-stu-id="2d356-215">To spread the load more evenly, consider hashing the partition key.</span></span>

- <span data-ttu-id="2d356-216">Az Azure Table Storage támogatja a tranzakciós műveletek végrehajtását az egyazon partíción lévő entitásokon.</span><span class="sxs-lookup"><span data-stu-id="2d356-216">Azure table storage supports transactional operations for entities that belong to the same partition.</span></span> <span data-ttu-id="2d356-217">Egy alkalmazás elvégezhet több insert, update, delete, cseréje vagy egyesítési műveletek egyetlen elemi egységként, mindaddig, amíg a tranzakció nem tartalmaz 100-nál több entitást és a kérelem hasznos adattartalma nem haladja meg a 4 MB.</span><span class="sxs-lookup"><span data-stu-id="2d356-217">An application can perform multiple insert, update, delete, replace, or merge operations as an atomic unit, as long as the transaction doesn't include more than 100 entities and the payload of the request doesn't exceed 4 MB.</span></span> <span data-ttu-id="2d356-218">Nem tranzakciós művelet több partíciót, és előfordulhat, hogy a végleges konzisztencia megvalósításával.</span><span class="sxs-lookup"><span data-stu-id="2d356-218">Operations that span multiple partitions are not transactional, and might require you to implement eventual consistency.</span></span> <span data-ttu-id="2d356-219">A table storage és a tranzakció kapcsolatos további információkért lásd: [Entitáscsoport-tranzakciók végrehajtása].</span><span class="sxs-lookup"><span data-stu-id="2d356-219">For more information about table storage and transactions, see [Performing entity group transactions].</span></span>

- <span data-ttu-id="2d356-220">Vegye figyelembe a partíciókulcs részletességét:</span><span class="sxs-lookup"><span data-stu-id="2d356-220">Consider the granularity of the partition key:</span></span>

  - <span data-ttu-id="2d356-221">Minden entitás ugyanazzal a partíciókulccsal használatával ugyanazon a partíción egy kiszolgálón tárolt eredménye.</span><span class="sxs-lookup"><span data-stu-id="2d356-221">Using the same partition key for every entity results in a single partition that's held on one server.</span></span> <span data-ttu-id="2d356-222">Ez megakadályozza, hogy a partíció horizontális felskálázás, és a terhelés összpontosít egyetlen kiszolgálón.</span><span class="sxs-lookup"><span data-stu-id="2d356-222">This prevents the partition from scaling out and focuses the load on a single server.</span></span> <span data-ttu-id="2d356-223">Ennek eredményeképpen Ez a módszer csak akkor kis számú entitást tárolására alkalmas.</span><span class="sxs-lookup"><span data-stu-id="2d356-223">As a result, this approach is only suitable for storing a small number of entities.</span></span> <span data-ttu-id="2d356-224">Azonban, győződjön meg arról, hogy valamennyi entitás részt vehet tranzakciók.</span><span class="sxs-lookup"><span data-stu-id="2d356-224">However, it does ensure that all entities can participate in entity group transactions.</span></span>

  - <span data-ttu-id="2d356-225">Minden entitás egyedi partíciókulccsal rendelkezik a table storage szolgáltatás egy külön partíciót az egyes entitásokhoz lévő nagy számú kis partíció létrehozásához.</span><span class="sxs-lookup"><span data-stu-id="2d356-225">Using a unique partition key for every entity causes the table storage service to create a separate partition for each entity, possibly resulting in a large number of small partitions.</span></span> <span data-ttu-id="2d356-226">Ez a megközelítés jobban skálázható, mint az, amelyik egyetlen partíciókulcsot használ, de az entitáscsoportokon végzett tranzakciók nem lehetségesek.</span><span class="sxs-lookup"><span data-stu-id="2d356-226">This approach is more scalable than using a single partition key, but entity group transactions are not possible.</span></span> <span data-ttu-id="2d356-227">Emellett a több entitást érintő lekérdezések esetén esetleg több kiszolgálót is olvasni kell.</span><span class="sxs-lookup"><span data-stu-id="2d356-227">Also, queries that fetch more than one entity might involve reading from more than one server.</span></span> <span data-ttu-id="2d356-228">Azonban az alkalmazás által végrehajtott lekérdezések, ha a partíciókulcsokat monoton sorozat mentén hozza majd használatával segíthet optimalizálhatóak.</span><span class="sxs-lookup"><span data-stu-id="2d356-228">However, if the application performs range queries, then using a monotonic sequence for the partition keys might help to optimize these queries.</span></span>

  - <span data-ttu-id="2d356-229">Különböző entitások egy részét a partíciós kulcs megosztása lehetővé teszi, hogy a csoport kapcsolódó entitások ugyanazon a partíción.</span><span class="sxs-lookup"><span data-stu-id="2d356-229">Sharing the partition key across a subset of entities makes it possible to group related entities in the same partition.</span></span> <span data-ttu-id="2d356-230">A kapcsolódó entitásokat érintő műveletek végrehajthatók entitáscsoport-tranzakciók használatával, és a több kapcsolódó entitást olvasó lekérdezések egyetlen kiszolgáló elérésével teljesíthetőek.</span><span class="sxs-lookup"><span data-stu-id="2d356-230">Operations that involve related entities can be performed by using entity group transactions, and queries that fetch a set of related entities can be satisfied by accessing a single server.</span></span>

<span data-ttu-id="2d356-231">További információkért lásd: [Az Azure Storage Table tervezési útmutatója].</span><span class="sxs-lookup"><span data-stu-id="2d356-231">For more information, see [Azure storage table design guide].</span></span>

## <a name="partitioning-azure-blob-storage"></a><span data-ttu-id="2d356-232">Az Azure Blob Storage particionálása</span><span class="sxs-lookup"><span data-stu-id="2d356-232">Partitioning Azure blob storage</span></span>

<span data-ttu-id="2d356-233">Az Azure blob storage segítségével nagyméretű bináris objektumok tárolhatóak.</span><span class="sxs-lookup"><span data-stu-id="2d356-233">Azure blob storage makes it possible to hold large binary objects.</span></span> <span data-ttu-id="2d356-234">Használja a blokkblobok használatát támogatják forgatókönyvekben, ha szeretne feltölteni, vagy töltse le a nagy adatmennyiségek gyors.</span><span class="sxs-lookup"><span data-stu-id="2d356-234">Use block blobs in scenarios when you need to upload or download large volumes of data quickly.</span></span> <span data-ttu-id="2d356-235">A lapblobok olyan alkalmazásokban használhatóak, ahol nem sorban, hanem véletlenszerűen kell elérni az adathalmaz egyes részeit.</span><span class="sxs-lookup"><span data-stu-id="2d356-235">Use page blobs for applications that require random rather than serial access to parts of the data.</span></span>

<span data-ttu-id="2d356-236">Minden blob (blokk vagy lap) külön tárolóban található egy Azure-tárfiókban.</span><span class="sxs-lookup"><span data-stu-id="2d356-236">Each blob (either block or page) is held in a container in an Azure storage account.</span></span> <span data-ttu-id="2d356-237">A tárolók használatával csoportokba rendezhetőek a hasonló biztonsági követelményekkel rendelkező kapcsolódó blobok.</span><span class="sxs-lookup"><span data-stu-id="2d356-237">You can use containers to group related blobs that have the same security requirements.</span></span> <span data-ttu-id="2d356-238">A csoportosítás nem fizikai, hanem logikai alapon történik.</span><span class="sxs-lookup"><span data-stu-id="2d356-238">This grouping is logical rather than physical.</span></span> <span data-ttu-id="2d356-239">A tárolókon belül minden egyes blob egyedi névvel rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="2d356-239">Inside a container, each blob has a unique name.</span></span>

<span data-ttu-id="2d356-240">A blobok partíciókulcsa a fiók neve + a tároló neve + a blob neve.</span><span class="sxs-lookup"><span data-stu-id="2d356-240">The partition key for a blob is account name + container name + blob name.</span></span> <span data-ttu-id="2d356-241">A partíciókulcs partíció tartományok és a tartományok adatok betöltése-között oszlanak el a rendszer segítségével.</span><span class="sxs-lookup"><span data-stu-id="2d356-241">The partition key is used to partition data into ranges and these ranges are load-balanced across the system.</span></span> <span data-ttu-id="2d356-242">A blobok leoszthatóak több kiszolgálóra a hozzáférés horizontális felskálázása érdekében, egy blobot azonban csak egyetlen kiszolgáló szolgálhat ki.</span><span class="sxs-lookup"><span data-stu-id="2d356-242">Blobs can be distributed across many servers in order to scale out access to them, but a single blob can only be served by a single server.</span></span>

<span data-ttu-id="2d356-243">Ha az elnevezési sémája időbélyegeket vagy numerikus azonosítókat használ, vezethet túlzott forgalmat egy partíciót, hogy hatékonyan korlátozza a rendszer a terheléselosztás.</span><span class="sxs-lookup"><span data-stu-id="2d356-243">If your naming scheme uses timestamps or numerical identifiers, it can lead to excessive traffic going to one partition, limiting the system from effectively load balancing.</span></span> <span data-ttu-id="2d356-244">Például ha egy blob objektumot használó időbélyegzővel ellátott például napi üzemeltetési *éééé-hh-nn*, a művelet az összes forgalom egypartíciós kiszolgálóhoz lép majd.</span><span class="sxs-lookup"><span data-stu-id="2d356-244">For instance, if you have daily operations that use a blob object with a timestamp such as *yyyy-mm-dd*, all the traffic for that operation would go to a single partition server.</span></span> <span data-ttu-id="2d356-245">Ehelyett érdemes lehet a név 3 számjegyből kivonattal előtag.</span><span class="sxs-lookup"><span data-stu-id="2d356-245">Instead, consider prefixing the name with a 3-digit hash.</span></span> <span data-ttu-id="2d356-246">További információkért lásd: [Partícióelnevezési konvenciót](/azure/storage/common/storage-performance-checklist#subheading47)</span><span class="sxs-lookup"><span data-stu-id="2d356-246">For more information, see [Partition Naming Convention](/azure/storage/common/storage-performance-checklist#subheading47)</span></span>

<span data-ttu-id="2d356-247">Egy egyetlen blokk vagy lap írására vonatkozó műveletek elemiek, de több blokkok, lapra vagy nem.</span><span class="sxs-lookup"><span data-stu-id="2d356-247">The actions of writing a single block or page are atomic, but operations that span blocks, pages, or blobs are not.</span></span> <span data-ttu-id="2d356-248">Ha biztosítania kell a blokkokon, lapokon és blobokon végzett írási műveletek során a konzisztenciát, blobbérlet alkalmazásával zárolhatja az írásukat.</span><span class="sxs-lookup"><span data-stu-id="2d356-248">If you need to ensure consistency when performing write operations across blocks, pages, and blobs, take out a write lock by using a blob lease.</span></span>

## <a name="partitioning-azure-storage-queues"></a><span data-ttu-id="2d356-249">Az Azure tároló-üzenetsorok particionálása</span><span class="sxs-lookup"><span data-stu-id="2d356-249">Partitioning Azure storage queues</span></span>

<span data-ttu-id="2d356-250">Az Azure tároló-üzenetsorok használatával folyamatok közötti aszinkron üzenetkezelés valósítható meg.</span><span class="sxs-lookup"><span data-stu-id="2d356-250">Azure storage queues enable you to implement asynchronous messaging between processes.</span></span> <span data-ttu-id="2d356-251">Minden egyes Azure-tárfiók korlátlan számú üzenetsort, és mindegyik üzenetsor korlátlan számú üzenetet tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="2d356-251">An Azure storage account can contain any number of queues, and each queue can contain any number of messages.</span></span> <span data-ttu-id="2d356-252">Az egyetlen korlát a tárfiókban rendelkezésre álló hely mennyisége.</span><span class="sxs-lookup"><span data-stu-id="2d356-252">The only limitation is the space that's available in the storage account.</span></span> <span data-ttu-id="2d356-253">Egy egyes üzenetek maximális mérete 64 KB.</span><span class="sxs-lookup"><span data-stu-id="2d356-253">The maximum size of an individual message is 64 KB.</span></span> <span data-ttu-id="2d356-254">Ha ennél nagyobb méretű üzenetekre van szüksége, vegye fontolóra az Azure Service Bus-üzenetsorok használatát.</span><span class="sxs-lookup"><span data-stu-id="2d356-254">If you require messages bigger than this, then consider using Azure Service Bus queues instead.</span></span>

<span data-ttu-id="2d356-255">Minden egyes üzenetsor egyedi névvel rendelkezik a tárfiókon belül, amelyben található.</span><span class="sxs-lookup"><span data-stu-id="2d356-255">Each storage queue has a unique name within the storage account that contains it.</span></span> <span data-ttu-id="2d356-256">Az Azure név alapján particionálja az üzenetsorokat.</span><span class="sxs-lookup"><span data-stu-id="2d356-256">Azure partitions queues based on the name.</span></span> <span data-ttu-id="2d356-257">Az egy üzenetsorba tartozó üzeneteket egy partíció tárolja, amelyet egy kiszolgáló vezérel.</span><span class="sxs-lookup"><span data-stu-id="2d356-257">All messages for the same queue are stored in the same partition, which is controlled by a single server.</span></span> <span data-ttu-id="2d356-258">A különböző üzenetsorok a terhelés elosztása érdekében futtathatók külön kiszolgálókon.</span><span class="sxs-lookup"><span data-stu-id="2d356-258">Different queues can be managed by different servers to help balance the load.</span></span> <span data-ttu-id="2d356-259">Az üzenetsorok kiszolgálókra való leosztása az alkalmazások és a felhasználók számára transzparens módon történik.</span><span class="sxs-lookup"><span data-stu-id="2d356-259">The allocation of queues to servers is transparent to applications and users.</span></span>

<span data-ttu-id="2d356-260">A nagy alkalmazásokban ne ugyanazt az üzenetsort használja az alkalmazás összes példányához, mivel így az üzenetsort futtató kiszolgáló kritikus ponttá válhat.</span><span class="sxs-lookup"><span data-stu-id="2d356-260">In a large-scale application, don't use the same storage queue for all instances of the application because this approach might cause the server that's hosting the queue to become a hotspot.</span></span> <span data-ttu-id="2d356-261">Használjon inkább külön üzenetsorokat az alkalmazás különböző funkcionális területei szerint.</span><span class="sxs-lookup"><span data-stu-id="2d356-261">Instead, use different queues for different functional areas of the application.</span></span> <span data-ttu-id="2d356-262">Az Azure storage üzenetsorok nem támogatják a tranzakciókat, így az üzeneteket külön üzenetsorokra irányítja az üzenetkonzisztenciát kis hatás kell rendelkeznie.</span><span class="sxs-lookup"><span data-stu-id="2d356-262">Azure storage queues do not support transactions, so directing messages to different queues should have little effect on messaging consistency.</span></span>

<span data-ttu-id="2d356-263">Az egyes Azure tároló-üzenetsorok másodpercenként 2000 üzenetet képesek feldolgozni.</span><span class="sxs-lookup"><span data-stu-id="2d356-263">An Azure storage queue can handle up to 2,000 messages per second.</span></span> <span data-ttu-id="2d356-264">Ha ennél nagyobb sebességre van szüksége, érdemes több üzenetsort létrehoznia.</span><span class="sxs-lookup"><span data-stu-id="2d356-264">If you need to process messages at a greater rate than this, consider creating multiple queues.</span></span> <span data-ttu-id="2d356-265">Például egy globális alkalmazás esetében hozzon létre külön tároló-üzenetsorokat külön tárfiókokban az egyes régiókban futó alkalmazáspéldányok kezelésére.</span><span class="sxs-lookup"><span data-stu-id="2d356-265">For example, in a global application, create separate storage queues in separate storage accounts to handle application instances that are running in each region.</span></span>

## <a name="partitioning-azure-service-bus"></a><span data-ttu-id="2d356-266">Az Azure Service Bus particionálási</span><span class="sxs-lookup"><span data-stu-id="2d356-266">Partitioning Azure Service Bus</span></span>

<span data-ttu-id="2d356-267">Az Azure Service Bus egy üzenetközvetítő használatával dolgozza fel a Service Bus-üzenetsorokra vagy -témakörökbe küldött üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="2d356-267">Azure Service Bus uses a message broker to handle messages that are sent to a Service Bus queue or topic.</span></span> <span data-ttu-id="2d356-268">Alapértelmezés szerint az üzenetsorra vagy témakörbe küldött összes üzenetet ugyanaz az üzenetközvetítő folyamat kezeli.</span><span class="sxs-lookup"><span data-stu-id="2d356-268">By default, all messages that are sent to a queue or topic are handled by the same message broker process.</span></span> <span data-ttu-id="2d356-269">Az ilyen architektúra korlátozhatja az üzenetsor teljes feldolgozási sebességét.</span><span class="sxs-lookup"><span data-stu-id="2d356-269">This architecture can place a limitation on the overall throughput of the message queue.</span></span> <span data-ttu-id="2d356-270">Az üzenetsorok és témakörök azonban a létrehozásukkor particionálhatóak.</span><span class="sxs-lookup"><span data-stu-id="2d356-270">However, you can also partition a queue or topic when it is created.</span></span> <span data-ttu-id="2d356-271">Ezt az üzenetsor vagy témakör *EnablePartitioning* tulajdonságának *true* értékre állításával teheti meg.</span><span class="sxs-lookup"><span data-stu-id="2d356-271">You do this by setting the *EnablePartitioning* property of the queue or topic description to *true*.</span></span>

<span data-ttu-id="2d356-272">A particionált üzenetsor vagy témakör több töredékre osztható fel, amelyek mindegyikét egy külön üzenettár és üzenetközvetítő szolgálja ki.</span><span class="sxs-lookup"><span data-stu-id="2d356-272">A partitioned queue or topic is divided into multiple fragments, each of which is backed by a separate message store and message broker.</span></span> <span data-ttu-id="2d356-273">A töredékek létrehozása és felügyelete a Service Bus feladata.</span><span class="sxs-lookup"><span data-stu-id="2d356-273">Service Bus takes responsibility for creating and managing these fragments.</span></span> <span data-ttu-id="2d356-274">Amikor egy alkalmazás üzenetet küld egy particionált üzenetsorra vagy témakörbe, a Service Bus hozzárendeli az üzenetet az üzenetsor vagy témakör valamelyik töredékéhez.</span><span class="sxs-lookup"><span data-stu-id="2d356-274">When an application posts a message to a partitioned queue or topic, Service Bus assigns the message to a fragment for that queue or topic.</span></span> <span data-ttu-id="2d356-275">Amikor egy alkalmazás üzenetet fogad egy üzenetsorról vagy előfizetésről, a Service Bus az összes töredékben ellenőrzi, hogy melyik a következő elérhető üzenet, és azt továbbítja az alkalmazásba feldolgozásra.</span><span class="sxs-lookup"><span data-stu-id="2d356-275">When an application receives a message from a queue or subscription, Service Bus checks each fragment for the next available message and then passes it to the application for processing.</span></span>

<span data-ttu-id="2d356-276">Ez a struktúra segít elosztani a terhelést az üzenetközvetítők és üzenettárak közt, így növeli a skálázhatóságot és javítja a rendelkezésre állást.</span><span class="sxs-lookup"><span data-stu-id="2d356-276">This structure helps distribute the load across message brokers and message stores, increasing scalability and improving availability.</span></span> <span data-ttu-id="2d356-277">Ha valamelyik töredék üzenetközvetítője vagy üzenettára átmenetileg nem érhető el, a Service Bus a többi elérhető töredék valamelyikéből ki tudja olvasni az üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="2d356-277">If the message broker or message store for one fragment is temporarily unavailable, Service Bus can retrieve messages from one of the remaining available fragments.</span></span>

<span data-ttu-id="2d356-278">A Service Bus az üzeneteket az alábbiak szerint osztja le a töredékekre:</span><span class="sxs-lookup"><span data-stu-id="2d356-278">Service Bus assigns a message to a fragment as follows:</span></span>

- <span data-ttu-id="2d356-279">Ha az üzenet egy munkamenethez, ugyanazt az értéket rendelkező üzenetek a *SessionId* tulajdonság ugyanarra a töredékre érkeznek.</span><span class="sxs-lookup"><span data-stu-id="2d356-279">If the message belongs to a session, all messages with the same value for the *SessionId*  property are sent to the same fragment.</span></span>

- <span data-ttu-id="2d356-280">Ha az üzenet nem képezi munkamenet részét, de a feladó megadta a *PartitionKey* tulajdonság értéket, az összes azonos *PartitionKey* értékű üzenet ugyanarra a töredékre lesz küldve.</span><span class="sxs-lookup"><span data-stu-id="2d356-280">If the message does not belong to a session, but the sender has specified a value for the *PartitionKey* property, then all messages with the same *PartitionKey* value are sent to the same fragment.</span></span>

  > [!NOTE]
  > <span data-ttu-id="2d356-281">Ha a *SessionId* és a *PartitionKey* tulajdonságok értéke egyaránt meg van adva, ezeket ugyanarra az értékre kell állítani, vagy az üzenet el lesz utasítva.</span><span class="sxs-lookup"><span data-stu-id="2d356-281">If the *SessionId* and *PartitionKey* properties are both specified, then they must be set to the same value or the message will be rejected.</span></span>

- <span data-ttu-id="2d356-282">Ha egy üzenet *SessionId* és *PartitionKey* tulajdonságai nincsenek megadva, de a duplikálásészlelés engedélyezve van, a rendszer a *MessageId* tulajdonságot használja.</span><span class="sxs-lookup"><span data-stu-id="2d356-282">If the *SessionId* and *PartitionKey* properties for a message are not specified, but duplicate detection is enabled, the *MessageId* property will be used.</span></span> <span data-ttu-id="2d356-283">Az azonos *MessageId* értékű üzenetek ugyanarra a töredékre lesznek küldve.</span><span class="sxs-lookup"><span data-stu-id="2d356-283">All messages with the same *MessageId* will be directed to the same fragment.</span></span>

- <span data-ttu-id="2d356-284">Ha az üzeneteknek nincs *SessionId, PartitionKey* vagy *MessageId* tulajdonsága, a Service Bus szekvenciálisan osztja le az üzeneteket a töredékekre.</span><span class="sxs-lookup"><span data-stu-id="2d356-284">If messages do not include a *SessionId, PartitionKey,* or *MessageId* property, then Service Bus assigns messages to fragments sequentially.</span></span> <span data-ttu-id="2d356-285">Ha egy töredék nem érhető el, a Service Bus továbblép a következőre.</span><span class="sxs-lookup"><span data-stu-id="2d356-285">If a fragment is unavailable, Service Bus will move on to the next.</span></span> <span data-ttu-id="2d356-286">Ez azt jelenti, hogy az üzenetkezelési infrastruktúra ideiglenes hibája nem okozza az üzenetküldési művelet meghiúsulását.</span><span class="sxs-lookup"><span data-stu-id="2d356-286">This means that a temporary fault in the messaging infrastructure does not cause the message-send operation to fail.</span></span>

<span data-ttu-id="2d356-287">A Service Bus-üzenetsorok vagy -témakörök particionálásának tervezése során mérlegelje a következőket:</span><span class="sxs-lookup"><span data-stu-id="2d356-287">Consider the following points when deciding if or how to partition a Service Bus message queue or topic:</span></span>

- <span data-ttu-id="2d356-288">A Service Bus-üzenetsorok és -témakörök egy Service Bus-névtér hatókörén belül jönnek létre.</span><span class="sxs-lookup"><span data-stu-id="2d356-288">Service Bus queues and topics are created within the scope of a Service Bus namespace.</span></span> <span data-ttu-id="2d356-289">A Service Bus névterenként jelenleg 100 particionált üzenetsort vagy témakört képes kezelni.</span><span class="sxs-lookup"><span data-stu-id="2d356-289">Service Bus currently allows up to 100 partitioned queues or topics per namespace.</span></span>

- <span data-ttu-id="2d356-290">Az egyes Service Bus-névterek kvótákat írnak elő a rendelkezésre álló erőforrásokra, például az egyes témakörök előfizetőinek számára, az egyidejű küldési és fogadási kérelmek számára, valamint a létrehozható egyidejű kapcsolatok maximális számára vonatkozóan.</span><span class="sxs-lookup"><span data-stu-id="2d356-290">Each Service Bus namespace imposes quotas on the available resources, such as the number of subscriptions per topic, the number of concurrent send and receive requests per second, and the maximum number of concurrent connections that can be established.</span></span> <span data-ttu-id="2d356-291">Kvóta vannak dokumentálva [Service Bus-kvóták].</span><span class="sxs-lookup"><span data-stu-id="2d356-291">These quotas are documented in [Service Bus quotas].</span></span> <span data-ttu-id="2d356-292">Ha várhatóan túllépi majd ezeket az értékeket, hozzon létre további névtereket a maguk üzenetsoraival és témaköreivel, és ossza le a terhelést ezekre a névterekre.</span><span class="sxs-lookup"><span data-stu-id="2d356-292">If you expect to exceed these values, then create additional namespaces with their own queues and topics, and spread the work across these namespaces.</span></span> <span data-ttu-id="2d356-293">Például egy globális alkalmazás esetében hozzon létre külön névtereket mindegyik régióban, és konfigurálja az alkalmazáspéldányokat, hogy a legközelebbi névtér üzenetsorait és témaköreit használják.</span><span class="sxs-lookup"><span data-stu-id="2d356-293">For example, in a global application, create separate namespaces in each region and configure application instances to use the queues and topics in the nearest namespace.</span></span>

- <span data-ttu-id="2d356-294">A tranzakciók keretében küldött üzenetekben meg kell adni egy partíciókulcsot.</span><span class="sxs-lookup"><span data-stu-id="2d356-294">Messages that are sent as part of a transaction must specify a partition key.</span></span> <span data-ttu-id="2d356-295">Ez lehet egy *SessionId*, egy *PartitionKey* vagy egy *MessageId* tulajdonság.</span><span class="sxs-lookup"><span data-stu-id="2d356-295">This can be a *SessionId*, *PartitionKey*, or *MessageId* property.</span></span> <span data-ttu-id="2d356-296">Az egy tranzakció keretében küldött üzenetekben ugyanazt a partíciókulcsot kell megadni, mivel ugyanannak az üzenetközvetítő folyamatnak kell feldolgoznia azokat.</span><span class="sxs-lookup"><span data-stu-id="2d356-296">All messages that are sent as part of the same transaction must specify the same partition key because they must be handled by the same message broker process.</span></span> <span data-ttu-id="2d356-297">Az egy tranzakcióba tartozó üzeneteket nem küldheti külön üzenetsorokra vagy témakörökbe.</span><span class="sxs-lookup"><span data-stu-id="2d356-297">You cannot send messages to different queues or topics within the same transaction.</span></span>

- <span data-ttu-id="2d356-298">A particionált üzenetsorok és témakörök nem konfigurálhatóak automatikus törlésre tétlenség esetére.</span><span class="sxs-lookup"><span data-stu-id="2d356-298">Partitioned queues and topics can't be configured to be automatically deleted when they become idle.</span></span>

- <span data-ttu-id="2d356-299">A particionált üzenetsorok és témakörök jelenleg nem használhatóak az Advanced Message Queueing Protocol (AMQP) protokollal, ha platformfüggetlen vagy hibrid megoldásokat épít fel.</span><span class="sxs-lookup"><span data-stu-id="2d356-299">Partitioned queues and topics can't currently be used with the Advanced Message Queuing Protocol (AMQP) if you are building cross-platform or hybrid solutions.</span></span>

## <a name="partitioning-cosmos-db"></a><span data-ttu-id="2d356-300">A Cosmos DB particionálási</span><span class="sxs-lookup"><span data-stu-id="2d356-300">Partitioning Cosmos DB</span></span>

<span data-ttu-id="2d356-301">Az Azure Cosmos DB egy NoSQL-adatbázis, amely az [Azure Cosmos DB SQL API][cosmosdb-sql-api] használatával képes JSON-dokumentumokat tárolni.</span><span class="sxs-lookup"><span data-stu-id="2d356-301">Azure Cosmos DB is a NoSQL database that can store JSON documents using the [Azure Cosmos DB SQL API][cosmosdb-sql-api].</span></span> <span data-ttu-id="2d356-302">A Cosmos DB-adatbázisban lévő objektumok vagy egyéb adatok JSON-szerializált ábrázolásai.</span><span class="sxs-lookup"><span data-stu-id="2d356-302">A document in a Cosmos DB database is a JSON-serialized representation of an object or other piece of data.</span></span> <span data-ttu-id="2d356-303">A rendszer nem tartat be rögzített sémákat, ez alól az egyetlen kivétel az, hogy minden dokumentumnak tartalmaznia kell egy egyedi azonosítót.</span><span class="sxs-lookup"><span data-stu-id="2d356-303">No fixed schemas are enforced except that every document must contain a unique ID.</span></span>

<span data-ttu-id="2d356-304">A dokumentumok gyűjteményekbe vannak rendezve.</span><span class="sxs-lookup"><span data-stu-id="2d356-304">Documents are organized into collections.</span></span> <span data-ttu-id="2d356-305">A kapcsolódó dokumentumokat gyűjteménybe foglalhatja.</span><span class="sxs-lookup"><span data-stu-id="2d356-305">You can group related documents together in a collection.</span></span> <span data-ttu-id="2d356-306">Például egy blogbejegyzéseket karbantartó rendszerben mindegyik blogbejegyzés tartalmát külön dokumentumban tárolhatja egy gyűjteményben.</span><span class="sxs-lookup"><span data-stu-id="2d356-306">For example, in a system that maintains blog postings, you can store the contents of each blog post as a document in a collection.</span></span> <span data-ttu-id="2d356-307">Az egyes tématípusok szerint is létrehozhat gyűjteményeket.</span><span class="sxs-lookup"><span data-stu-id="2d356-307">You can also create collections for each subject type.</span></span> <span data-ttu-id="2d356-308">Egy több-bérlős alkalmazásban, például egy olyan rendszerben, ahol több szerző is kezelheti és irányíthatja a saját blogbejegyzéseit, a blogokat particionálhatja szerző szerint, és mindegyik szerző számára külön gyűjteményeket hozhat létre.</span><span class="sxs-lookup"><span data-stu-id="2d356-308">Alternatively, in a multitenant application, such as a system where different authors control and manage their own blog posts, you can partition blogs by author and create separate collections for each author.</span></span> <span data-ttu-id="2d356-309">A gyűjtemények számára lefoglalt tárhely rugalmas, szükség szerint csökkenthető vagy növelhető.</span><span class="sxs-lookup"><span data-stu-id="2d356-309">The storage space that's allocated to collections is elastic and can shrink or grow as needed.</span></span>

<span data-ttu-id="2d356-310">A Cosmos DB támogatja az adatok automatikus particionálását az alkalmazásban definiált partíciókulcs alapján.</span><span class="sxs-lookup"><span data-stu-id="2d356-310">Cosmos DB supports automatic partitioning of data based on an application-defined partition key.</span></span> <span data-ttu-id="2d356-311">A *logikai partíció* egy olyan partíció, amely egy adott partíciókulcs-értékhez tartozó adatokat tárolja.</span><span class="sxs-lookup"><span data-stu-id="2d356-311">A *logical partition* is a partition that stores all the data for a single partition key value.</span></span> <span data-ttu-id="2d356-312">Az adott partíciókulcs-értékkel rendelkező összes dokumentum ugyanabba a logikai partícióba kerül.</span><span class="sxs-lookup"><span data-stu-id="2d356-312">All documents that share the same value for the partition key are placed within the same logical partition.</span></span> <span data-ttu-id="2d356-313">A Cosmos DB az értékeket a partíciókulcs kivonata alapján osztja el.</span><span class="sxs-lookup"><span data-stu-id="2d356-313">Cosmos DB distributes values according to hash of the partition key.</span></span> <span data-ttu-id="2d356-314">Az egyes logikai partíciók maximális mérete 10 GB.</span><span class="sxs-lookup"><span data-stu-id="2d356-314">A logical partition has a maximum size of 10 GB.</span></span> <span data-ttu-id="2d356-315">Így a partíciókulcs megfelelő megválasztása fontos szempont a tervezés során.</span><span class="sxs-lookup"><span data-stu-id="2d356-315">Therefore, the choice of the partition key is an important decision at design time.</span></span> <span data-ttu-id="2d356-316">Válasszon egy olyan tulajdonságot, amelynek az értékei és a hozzáférési mintái széles skálán mozognak.</span><span class="sxs-lookup"><span data-stu-id="2d356-316">Choose a property with a wide range of values and even access patterns.</span></span> <span data-ttu-id="2d356-317">További információkat az [Azure Cosmos DB particionálási és horizontális leskálázási eljárásait](/azure/cosmos-db/partition-data) ismertető cikkben talál.</span><span class="sxs-lookup"><span data-stu-id="2d356-317">For more information, see [Partition and scale in Azure Cosmos DB](/azure/cosmos-db/partition-data).</span></span>

> [!NOTE]
> <span data-ttu-id="2d356-318">Mindegyik Cosmos DB-adatbázis rendelkezik *teljesítményszinttel*, amely az adatbázis számára elérhető erőforrások mennyiségét határozza meg.</span><span class="sxs-lookup"><span data-stu-id="2d356-318">Each Cosmos DB database has a *performance level* that determines the amount of resources it gets.</span></span> <span data-ttu-id="2d356-319">A teljesítményszinthez egy *kérelemegység* (RU) sebességkorlát tartozik.</span><span class="sxs-lookup"><span data-stu-id="2d356-319">A performance level is associated with a *request unit* (RU) rate limit.</span></span> <span data-ttu-id="2d356-320">Az RU-sebességkorlát az adott gyűjtemény számára fenntartott, kizárólag általa használható erőforrások mennyiségét határozza meg.</span><span class="sxs-lookup"><span data-stu-id="2d356-320">The RU rate limit specifies the volume of resources that's reserved and available for exclusive use by that collection.</span></span> <span data-ttu-id="2d356-321">A gyűjtemény költségei az adott gyűjtemény számára kiválasztott teljesítményszinttől függenek.</span><span class="sxs-lookup"><span data-stu-id="2d356-321">The cost of a collection depends on the performance level that's selected for that collection.</span></span> <span data-ttu-id="2d356-322">A nagyobb teljesítményszint (és RU-sebességkorlát) nagyobb költségekkel jár.</span><span class="sxs-lookup"><span data-stu-id="2d356-322">The higher the performance level (and RU rate limit) the higher the charge.</span></span> <span data-ttu-id="2d356-323">A gyűjtemények teljesítményszintjét az Azure Portalon módosíthatja.</span><span class="sxs-lookup"><span data-stu-id="2d356-323">You can adjust the performance level of a collection by using the Azure portal.</span></span> <span data-ttu-id="2d356-324">További információkat [az Azure Cosmos DB kérelemegységeit ismertető][cosmos-db-ru] cikkben talál.</span><span class="sxs-lookup"><span data-stu-id="2d356-324">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span>

<span data-ttu-id="2d356-325">Ha a particionálási mechanizmust, Cosmos DB által biztosított nem elegendő, szükség lehet a szegmensben az adatokat az alkalmazás szintjén.</span><span class="sxs-lookup"><span data-stu-id="2d356-325">If the partitioning mechanism that Cosmos DB provides is not sufficient, you may need to shard the data at the application level.</span></span> <span data-ttu-id="2d356-326">A dokumentumgyűjtemények egy természetes mechanizmust kínálnak az adatok particionálására egy adott adatbázisban.</span><span class="sxs-lookup"><span data-stu-id="2d356-326">Document collections provide a natural mechanism for partitioning data within a single database.</span></span> <span data-ttu-id="2d356-327">A szegmensekre particionálás legegyszerűbben úgy valósítható meg, ha mindegyik szegmenshez létrehoz egy gyűjteményt.</span><span class="sxs-lookup"><span data-stu-id="2d356-327">The simplest way to implement sharding is to create a collection for each shard.</span></span> <span data-ttu-id="2d356-328">A tárolók logikai erőforrások, és több kiszolgálóra is kiterjedhetnek.</span><span class="sxs-lookup"><span data-stu-id="2d356-328">Containers are logical resources and can span one or more servers.</span></span> <span data-ttu-id="2d356-329">A rögzített méretű tárolók mérete legfeljebb 10 GB, feldolgozási sebessége legfeljebb 10000 RU/s lehet.</span><span class="sxs-lookup"><span data-stu-id="2d356-329">Fixed-size containers have a maximum limit of 10 GB and 10,000 RU/s throughput.</span></span> <span data-ttu-id="2d356-330">Korlátlan tárolók nem rendelkeznek maximális tárméret, de meg kell adnia egy partíciókulcsot.</span><span class="sxs-lookup"><span data-stu-id="2d356-330">Unlimited containers do not have a maximum storage size, but must specify a partition key.</span></span> <span data-ttu-id="2d356-331">Az alkalmazások horizontális particionálása esetén az ügyfélalkalmazásnak a kérelmeket a megfelelő szegmensre kell irányítania, ez általában az adatok a szegmenskulcsot meghatározó egyes attribútumain alapuló leképezési mechanizmussal valósítható meg.</span><span class="sxs-lookup"><span data-stu-id="2d356-331">With application sharding, the client application must direct requests to the appropriate shard, usually by implementing its own mapping mechanism based on some attributes of the data that define the shard key.</span></span>

<span data-ttu-id="2d356-332">Az összes adatbázis egy Cosmos DB-adatbázis adatbázisfiók környezetében jön létre.</span><span class="sxs-lookup"><span data-stu-id="2d356-332">All databases are created in the context of a Cosmos DB database account.</span></span> <span data-ttu-id="2d356-333">Egy fiók több adatbázist is tartalmazhat, és meghatározza, hogy az adatbázisok mely régiókban lesznek létrehozva.</span><span class="sxs-lookup"><span data-stu-id="2d356-333">A single account can contain several databases, and it specifies in which regions the databases are created.</span></span> <span data-ttu-id="2d356-334">Mindegyik fiók betartatja a saját hozzáférés-vezérlését.</span><span class="sxs-lookup"><span data-stu-id="2d356-334">Each account also enforces its own access control.</span></span> <span data-ttu-id="2d356-335">A Cosmos DB fiókok használatával a szegmenseket (az adatbázisokon belüli gyűjteményeket) az azokat használó felhasználókhoz földrajzilag közel helyezheti el, és kikényszerítheti, hogy csak az adott felhasználók érhessék el azokat.</span><span class="sxs-lookup"><span data-stu-id="2d356-335">You can use Cosmos DB accounts to geo-locate shards (collections within databases) close to the users who need to access them, and enforce restrictions so that only those users can connect to them.</span></span>

<span data-ttu-id="2d356-336">Ha az adatokat a Cosmos DB SQL API-val tervezi particionálni, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="2d356-336">Consider the following points when deciding how to partition data with the Cosmos DB SQL API:</span></span>

- <span data-ttu-id="2d356-337">**A Cosmos DB-adatbázis számára elérhető erőforrások mennyisége a fiók kvótakorlátainak függvénye**.</span><span class="sxs-lookup"><span data-stu-id="2d356-337">**The resources available to a Cosmos DB database are subject to the quota limitations of the account**.</span></span> <span data-ttu-id="2d356-338">Mindegyik adatbázis több gyűjteményt is tárolhat, és mindegyik gyűjteményhez tartozik egy teljesítményszint, amely az adott gyűjtemény RU-sebességkorlátját (a fenntartott feldolgozási sebességet) határozza meg.</span><span class="sxs-lookup"><span data-stu-id="2d356-338">Each database can hold a number of collections, and each collection is associated with a performance level that governs the RU rate limit (reserved throughput) for that collection.</span></span> <span data-ttu-id="2d356-339">További információk: [Az Azure-előfizetések és -szolgáltatások korlátozásai, kvótái és megkötései][azure-limits].</span><span class="sxs-lookup"><span data-stu-id="2d356-339">For more information, see [Azure subscription and service limits, quotas, and constraints][azure-limits].</span></span>

- <span data-ttu-id="2d356-340">**Mindegyik dokumentumnak rendelkeznie kell egy attribútummal, amely alapján egyedileg azonosítható a gyűjteményen belül**.</span><span class="sxs-lookup"><span data-stu-id="2d356-340">**Each document must have an attribute that can be used to uniquely identify that document within the collection in which it is held**.</span></span> <span data-ttu-id="2d356-341">Ez az attribútum nem azonos a partíciókulccsal, amely azt határozza meg, hogy melyik gyűjteményben található a dokumentum.</span><span class="sxs-lookup"><span data-stu-id="2d356-341">This attribute is different from the shard key, which defines which collection holds the document.</span></span> <span data-ttu-id="2d356-342">Egy gyűjtemény nagy számú dokumentumot tartalmazhat.</span><span class="sxs-lookup"><span data-stu-id="2d356-342">A collection can contain a large number of documents.</span></span> <span data-ttu-id="2d356-343">Ezt elméletileg csak a dokumentumazonosító hossza korlátozza.</span><span class="sxs-lookup"><span data-stu-id="2d356-343">In theory, it's limited only by the maximum length of the document ID.</span></span> <span data-ttu-id="2d356-344">A dokumentumazonosító legfeljebb 255 karakter hosszúságú lehet.</span><span class="sxs-lookup"><span data-stu-id="2d356-344">The document ID can be up to 255 characters.</span></span>

- <span data-ttu-id="2d356-345">**A dokumentumokra irányuló műveletek egy tranzakció környezetében lesznek végrehajtva. A tranzakciók hatóköre a dokumentumot tároló gyűjtemény.**</span><span class="sxs-lookup"><span data-stu-id="2d356-345">**All operations against a document are performed within the context of a transaction. Transactions are scoped to the collection in which the document is contained.**</span></span> <span data-ttu-id="2d356-346">Ha egy művelet meghiúsul, az általa végrehajtott feldolgozás vissza lesz vonva.</span><span class="sxs-lookup"><span data-stu-id="2d356-346">If an operation fails, the work that it has performed is rolled back.</span></span> <span data-ttu-id="2d356-347">Az épp feldolgozás alatt álló dokumentumokon végrehajtott módosítások pillanatképszinten el vannak különítve.</span><span class="sxs-lookup"><span data-stu-id="2d356-347">While a document is subject to an operation, any changes that are made are subject to snapshot-level isolation.</span></span> <span data-ttu-id="2d356-348">Ez a mechanizmus biztosítja, hogy ha például egy új dokumentum létrehozására irányuló kérelem meghiúsul, az adatbázist egyidejűleg lekérdező többi felhasználó nem látja a félkész, majd eltávolított dokumentumot.</span><span class="sxs-lookup"><span data-stu-id="2d356-348">This mechanism guarantees that if, for example, a request to create a new document fails, another user who's querying the database simultaneously will not see a partial document that is then removed.</span></span>

- <span data-ttu-id="2d356-349">**Az adatbázis-lekérdezések hatóköre szintén a gyűjtemény**.</span><span class="sxs-lookup"><span data-stu-id="2d356-349">**Database queries are also scoped to the collection level**.</span></span> <span data-ttu-id="2d356-350">Egy lekérdezés csak egyetlen gyűjtemény adatait kérdezheti le.</span><span class="sxs-lookup"><span data-stu-id="2d356-350">A single query can retrieve data from only one collection.</span></span> <span data-ttu-id="2d356-351">Ha több gyűjteményből kell lekérdeznie adatokat, mindegyik gyűjteményt külön-külön kell lekérdeznie, majd az eredményeket az alkalmazás kódjában egyesítenie.</span><span class="sxs-lookup"><span data-stu-id="2d356-351">If you need to retrieve data from multiple collections, you must query each collection individually and merge the results in your application code.</span></span>

- <span data-ttu-id="2d356-352">**A Cosmos DB támogatja a programozható elemek használatát, amelyek a gyűjteményben a dokumentumok mellett tárolhatóak**.</span><span class="sxs-lookup"><span data-stu-id="2d356-352">**Cosmos DB supports programmable items that can all be stored in a collection alongside documents**.</span></span> <span data-ttu-id="2d356-353">Ezek lehetnek tárolt eljárások, felhasználó által definiált függvények és eseményindítók (JavaScript nyelven).</span><span class="sxs-lookup"><span data-stu-id="2d356-353">These include stored procedures, user-defined functions, and triggers (written in JavaScript).</span></span> <span data-ttu-id="2d356-354">Ezek az elemek a gyűjteményen belül az összes dokumentumot elérhetik.</span><span class="sxs-lookup"><span data-stu-id="2d356-354">These items can access any document within the same collection.</span></span> <span data-ttu-id="2d356-355">Ezen felül ezek az elemek a környezeti tranzakció hatókörében (egy, valamely dokumentumon végrehajtott létrehozás, törlés vagy csere művelet eredményeként aktiválódó trigger esetén) vagy egy új tranzakció indításával (egy, valamely kifejezett ügyfélkérelem eredményeképp futtatott tárolt eljárás esetén) futtatható.</span><span class="sxs-lookup"><span data-stu-id="2d356-355">Furthermore, these items run either inside the scope of the ambient transaction (in the case of a trigger that fires as the result of a create, delete, or replace operation performed against a document), or by starting a new transaction (in the case of a stored procedure that is run as the result of an explicit client request).</span></span> <span data-ttu-id="2d356-356">Ha egy programozható elem kódja kivételt dob, a tranzakció vissza lesz vonva.</span><span class="sxs-lookup"><span data-stu-id="2d356-356">If the code in a programmable item throws an exception, the transaction is rolled back.</span></span> <span data-ttu-id="2d356-357">A tárolt eljárások és eseményindítók használatával tartható fent az integritás és a konzisztencia a dokumentumok közt, de a dokumentumoknak ugyanabba a gyűjteménybe kell tartoznia.</span><span class="sxs-lookup"><span data-stu-id="2d356-357">You can use stored procedures and triggers to maintain integrity and consistency between documents, but these documents must all be part of the same collection.</span></span>

- <span data-ttu-id="2d356-358">**Törekedni kell rá, hogy az adatbázisban tárolni kívánt gyűjtemények ne haladják meg a teljesítményszintjeik által meghatározott feldolgozási sebességeket**.</span><span class="sxs-lookup"><span data-stu-id="2d356-358">**The collections that you intend to hold in the databases should be unlikely to exceed the throughput limits defined by the performance levels of the collections**.</span></span> <span data-ttu-id="2d356-359">További információkat [az Azure Cosmos DB kérelemegységeit ismertető][cosmos-db-ru] cikkben talál.</span><span class="sxs-lookup"><span data-stu-id="2d356-359">For more information, see [Request Units in Azure Cosmos DB][cosmos-db-ru].</span></span> <span data-ttu-id="2d356-360">Ha várhatóan meghaladja majd ezeket a korlátokat, érdemes a gyűjteményeket különböző fiókokban lévő adatbázisokra szétosztani a terhelés csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="2d356-360">If you anticipate reaching these limits, consider splitting collections across databases in different accounts to reduce the load per collection.</span></span>

## <a name="partitioning-azure-search"></a><span data-ttu-id="2d356-361">Az Azure Search particionálási</span><span class="sxs-lookup"><span data-stu-id="2d356-361">Partitioning Azure Search</span></span>

<span data-ttu-id="2d356-362">Az adatkeresési funkcionalitás a webalkalmazások biztosított leggyakoribb navigációs és felfedezési módszer.</span><span class="sxs-lookup"><span data-stu-id="2d356-362">The ability to search for data is often the primary method of navigation and exploration that's provided by many web applications.</span></span> <span data-ttu-id="2d356-363">Segítségével a felhasználók gyorsan találhatják meg az erőforrásokat (például a termékeket egy e-kereskedelmi alkalmazásban) a keresési feltételek kombinációja alapján.</span><span class="sxs-lookup"><span data-stu-id="2d356-363">It helps users find resources quickly (for example, products in an e-commerce application) based on combinations of search criteria.</span></span> <span data-ttu-id="2d356-364">Az Azure Search szolgáltatás teljes szöveges keresési funkcionalitást biztosít a webes tartalmakban, és olyan szolgáltatásokat kínál, mint a szövegkiegészítés, a közeli találatokon alapuló lekérdezési javaslatok és a jellemzőalapú navigáció.</span><span class="sxs-lookup"><span data-stu-id="2d356-364">The Azure Search service provides full-text search capabilities over web content, and includes features such as type-ahead, suggested queries based on near matches, and faceted navigation.</span></span> <span data-ttu-id="2d356-365">További információkért lásd: [Mi az az Azure Search?].</span><span class="sxs-lookup"><span data-stu-id="2d356-365">For more information, see [What is Azure Search?].</span></span>

<span data-ttu-id="2d356-366">Az Azure Search a kereshető tartalmakat JSON-dokumentumokként tárolja egy adatbázisban.</span><span class="sxs-lookup"><span data-stu-id="2d356-366">Azure Search stores searchable content as JSON documents in a database.</span></span> <span data-ttu-id="2d356-367">Definiálhat indexeket a dokumentumok kereshető mezőinek a meghatározásához, majd ezeket a definíciókat megadhatja az Azure Searchnek.</span><span class="sxs-lookup"><span data-stu-id="2d356-367">You define indexes that specify the searchable fields in these documents and provide these definitions to Azure Search.</span></span> <span data-ttu-id="2d356-368">Amikor egy felhasználó beküld egy keresési kérelmet, az Azure Search a megfelelő indexek használatával találja meg az egyező elemeket.</span><span class="sxs-lookup"><span data-stu-id="2d356-368">When a user submits a search request, Azure Search uses the appropriate indexes to find matching items.</span></span>

<span data-ttu-id="2d356-369">A versengés csökkentése érdekében az Azure Search által használt tárterület 1, 2, 3, 4, 6 vagy 12 partícióra osztható, és mindegyik partíció 6 példányban replikálható.</span><span class="sxs-lookup"><span data-stu-id="2d356-369">To reduce contention, the storage that's used by Azure Search can be divided into 1, 2, 3, 4, 6, or 12 partitions, and each partition can be replicated up to 6 times.</span></span> <span data-ttu-id="2d356-370">A partíciók és a replikák számának szorzatát *keresési egységnek* (SU) nevezzük.</span><span class="sxs-lookup"><span data-stu-id="2d356-370">The product of the number of partitions multiplied by the number of replicas is called the *search unit* (SU).</span></span> <span data-ttu-id="2d356-371">Az Azure Search egyetlen példánya legfeljebb 36 SU-t tartalmazhat (tehát egy 12 partícióval rendelkező adatbázis legfeljebb 3 replikát támogat).</span><span class="sxs-lookup"><span data-stu-id="2d356-371">A single instance of Azure Search can contain a maximum of 36 SUs (a database with 12 partitions only supports a maximum of 3 replicas).</span></span>

<span data-ttu-id="2d356-372">A számlázás a szolgáltatásban lefoglalt SU-k száma alapján történik.</span><span class="sxs-lookup"><span data-stu-id="2d356-372">You are billed for each SU that is allocated to your service.</span></span> <span data-ttu-id="2d356-373">A kereshető tartalom mennyiségének vagy a keresési kérelmek számának növekedtével a meglévő Azure Search-példányok SU-inak száma is növelhető a többletterhelés kezelése érdekében.</span><span class="sxs-lookup"><span data-stu-id="2d356-373">As the volume of searchable content increases or the rate of search requests grows, you can add SUs to an existing instance of Azure Search to handle the extra load.</span></span> <span data-ttu-id="2d356-374">Maga az Azure Search a dokumentumokat egyenletesen osztja el a partíciók közt.</span><span class="sxs-lookup"><span data-stu-id="2d356-374">Azure Search itself distributes the documents evenly across the partitions.</span></span> <span data-ttu-id="2d356-375">A manuális particionálási stratégiák jelenleg nem támogatottak.</span><span class="sxs-lookup"><span data-stu-id="2d356-375">No manual partitioning strategies are currently supported.</span></span>

<span data-ttu-id="2d356-376">Mindegyik partíció legfeljebb 15 millió dokumentumot tartalmazhat vagy 300 GB tárterületet foglalhat el (amelyik érték kisebb).</span><span class="sxs-lookup"><span data-stu-id="2d356-376">Each partition can contain a maximum of 15 million documents or occupy 300 GB of storage space (whichever is smaller).</span></span> <span data-ttu-id="2d356-377">Legfeljebb 50 indexet hozhat létre.</span><span class="sxs-lookup"><span data-stu-id="2d356-377">You can create up to 50 indexes.</span></span> <span data-ttu-id="2d356-378">A szolgáltatás teljesítménye a dokumentumok összetettségétől, a rendelkezésre álló indexektől és a hálózati késés hatásaitól függően változik.</span><span class="sxs-lookup"><span data-stu-id="2d356-378">The performance of the service varies and depends on the complexity of the documents, the available indexes, and the effects of network latency.</span></span> <span data-ttu-id="2d356-379">Átlagosan egyetlen replika (1 SU) másodpercenként 15 lekérdezést (QPS) képes feldolgozni, bár javasolt saját adatok használatával teljesítménymérést végezni a feldolgozási sebesség pontosabb mérése érdekében.</span><span class="sxs-lookup"><span data-stu-id="2d356-379">On average, a single replica (1 SU) should be able to handle 15 queries per second (QPS), although we recommend performing benchmarking with your own data to obtain a more precise measure of throughput.</span></span> <span data-ttu-id="2d356-380">További információkért lásd: [Az Azure Search szolgáltatási korlátozásai].</span><span class="sxs-lookup"><span data-stu-id="2d356-380">For more information, see [Service limits in Azure Search].</span></span>

> [!NOTE]
> <span data-ttu-id="2d356-381">A kereshető dokumentumokban tárolható adatok típusa egy korlátozott halmazba tartozhat: sztringek, logikai értékek, numerikus adatok, dátum és idő adatok és egyes földrajzi adatok.</span><span class="sxs-lookup"><span data-stu-id="2d356-381">You can store a limited set of data types in searchable documents, including strings, Booleans, numeric data, datetime data, and some geographical data.</span></span> <span data-ttu-id="2d356-382">További információkért lásd [Támogatott adattípusok (Azure Search)] foglalkozó oldalt a Microsoft webhelyén.</span><span class="sxs-lookup"><span data-stu-id="2d356-382">For more details, see the page [Supported data types (Azure Search)] on the Microsoft website.</span></span>

<span data-ttu-id="2d356-383">Csak korlátozottan szabályozható, hogy az Azure Search hogyan particionálja az adatokat a szolgáltatás egyes példányaiban.</span><span class="sxs-lookup"><span data-stu-id="2d356-383">You have limited control over how Azure Search partitions data for each instance of the service.</span></span> <span data-ttu-id="2d356-384">Azonban egy globális környezetben esetleg növelhető a teljesítmény, valamint csökkenthető a késés és a versengés magának a szolgáltatásnak a particionálásával a következő stratégiák valamelyike mentén:</span><span class="sxs-lookup"><span data-stu-id="2d356-384">However, in a global environment you might be able to improve performance and reduce latency and contention further by partitioning the service itself using either of the following strategies:</span></span>

- <span data-ttu-id="2d356-385">Hozzon létre egy Azure Search-példányt minden egyes földrajzi régióban, és gondoskodjon róla, hogy az ügyfélalkalmazások a legközelebbi elérhető példányra legyenek irányítva.</span><span class="sxs-lookup"><span data-stu-id="2d356-385">Create an instance of Azure Search in each geographic region, and ensure that client applications are directed towards the nearest available instance.</span></span> <span data-ttu-id="2d356-386">Ehhez a stratégiához a kereshető tartalmak frissítéseit időben kell replikálni a szolgáltatás minden példányán.</span><span class="sxs-lookup"><span data-stu-id="2d356-386">This strategy requires that any updates to searchable content are replicated in a timely manner across all instances of the service.</span></span>

- <span data-ttu-id="2d356-387">Hozzon létre két szintet az Azure Searchben:</span><span class="sxs-lookup"><span data-stu-id="2d356-387">Create two tiers of Azure Search:</span></span>

  - <span data-ttu-id="2d356-388">Egy helyi szolgáltatást minden egyes régióban, amely az adott régióban lévő felhasználók által leggyakrabban lekérdezett adatokat tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="2d356-388">A local service in each region that contains the data that's most frequently accessed by users in that region.</span></span> <span data-ttu-id="2d356-389">A felhasználók a kérelmeket ide irányítva gyors, de korlátozott eredményeket kaphatnak.</span><span class="sxs-lookup"><span data-stu-id="2d356-389">Users can direct requests here for fast but limited results.</span></span>
  - <span data-ttu-id="2d356-390">Egy globális szolgáltatást, amely az összes adatot tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="2d356-390">A global service that encompasses all the data.</span></span> <span data-ttu-id="2d356-391">A felhasználók a kérelmeket ide irányítva lassabb, de teljesebb eredményeket kaphatnak.</span><span class="sxs-lookup"><span data-stu-id="2d356-391">Users can direct requests here for slower but more complete results.</span></span>

<span data-ttu-id="2d356-392">Ez a megközelítés akkor a legmegfelelőbb, ha a keresett adatok az egyes régiókban jelentősen eltérnek.</span><span class="sxs-lookup"><span data-stu-id="2d356-392">This approach is most suitable when there is a significant regional variation in the data that's being searched.</span></span>

## <a name="partitioning-azure-redis-cache"></a><span data-ttu-id="2d356-393">Az Azure Redis Cache particionálási</span><span class="sxs-lookup"><span data-stu-id="2d356-393">Partitioning Azure Redis Cache</span></span>

<span data-ttu-id="2d356-394">Az Azure Redis Cache egy, a Redis kulcs-érték adattáron alapuló megosztott gyorsítótárazási szolgáltatást biztosít a felhőben.</span><span class="sxs-lookup"><span data-stu-id="2d356-394">Azure Redis Cache provides a shared caching service in the cloud that's based on the Redis key-value data store.</span></span> <span data-ttu-id="2d356-395">Ahogy a neve is mutatja (cache = gyorsítótár), az Azure Redis Cache egy gyorsítótárazási megoldásnak készült.</span><span class="sxs-lookup"><span data-stu-id="2d356-395">As its name implies, Azure Redis Cache is intended as a caching solution.</span></span> <span data-ttu-id="2d356-396">Csak átmeneti adatok tárolására készült, és nem állandó adattárként szolgál.</span><span class="sxs-lookup"><span data-stu-id="2d356-396">Use it only for holding transient data and not as a permanent data store.</span></span> <span data-ttu-id="2d356-397">Lehet, hogy az alkalmazásokat, amelyek az Azure Redis Cache használata tud tovább működni, ha a gyorsítótár nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="2d356-397">Applications that use Azure Redis Cache should be able to continue functioning if the cache is unavailable.</span></span> <span data-ttu-id="2d356-398">Az Azure Redis Cache támogatja az elsődleges/másodlagos replikációt a magas rendelkezésre állás biztosítása érdekében, de jelenleg a gyorsítótár maximális mérete 53 GB-ra van korlátozva.</span><span class="sxs-lookup"><span data-stu-id="2d356-398">Azure Redis Cache supports primary/secondary replication to provide high availability, but currently limits the maximum cache size to 53 GB.</span></span> <span data-ttu-id="2d356-399">Ha ennél több tárhely szükséges, további gyorsítótárakat kell létrehoznia.</span><span class="sxs-lookup"><span data-stu-id="2d356-399">If you need more space than this, you must create additional caches.</span></span> <span data-ttu-id="2d356-400">További információkért lásd: [Azure Redis Cache].</span><span class="sxs-lookup"><span data-stu-id="2d356-400">For more information, see [Azure Redis Cache].</span></span>

<span data-ttu-id="2d356-401">A Redis-adattárak particionálása szétosztja az adatokat a Redis szolgáltatás példányai között.</span><span class="sxs-lookup"><span data-stu-id="2d356-401">Partitioning a Redis data store involves splitting the data across instances of the Redis service.</span></span> <span data-ttu-id="2d356-402">Minden példány egy külön partíciót alkot.</span><span class="sxs-lookup"><span data-stu-id="2d356-402">Each instance constitutes a single partition.</span></span> <span data-ttu-id="2d356-403">Az Azure Redis Cache a Redis-szolgáltatásokat egy előtár mögött kivonatolja, és nem teszi azokat közvetlenül közzé.</span><span class="sxs-lookup"><span data-stu-id="2d356-403">Azure Redis Cache abstracts the Redis services behind a façade and does not expose them directly.</span></span> <span data-ttu-id="2d356-404">A particionálás legegyszerűbben úgy valósítható meg, ha létrehoz több Azure Redis Cache-példányt, és az adatokat azok között osztja el.</span><span class="sxs-lookup"><span data-stu-id="2d356-404">The simplest way to implement partitioning is to create multiple Azure Redis Cache instances and spread the data across them.</span></span>

<span data-ttu-id="2d356-405">Ez egyes adatelemekhez hozzárendelhet egy azonosítót (a partíciókulcsot), amely meghatározza, hogy melyik gyorsítótár tárolja az adatelemet.</span><span class="sxs-lookup"><span data-stu-id="2d356-405">You can associate each data item with an identifier (a partition key) that specifies which cache stores the data item.</span></span> <span data-ttu-id="2d356-406">Az ügyfélalkalmazás logikája azután ennek az azonosítónak a használatával irányíthatja a kérelmeket a megfelelő partícióra.</span><span class="sxs-lookup"><span data-stu-id="2d356-406">The client application logic can then use this identifier to route requests to the appropriate partition.</span></span> <span data-ttu-id="2d356-407">Ez a séma nagyon egyszerű, de ha a particionálási séma módosul (például további Azure Redis Cache-példányok létrehozása esetén), az ügyfélalkalmazások újrakonfigurálására lehet szükség.</span><span class="sxs-lookup"><span data-stu-id="2d356-407">This scheme is very simple, but if the partitioning scheme changes (for example, if additional Azure Redis Cache instances are created), client applications might need to be reconfigured.</span></span>

<span data-ttu-id="2d356-408">A natív Redis (nem az Azure Redis Cache) támogatja a Redis-fürtözésen alapuló kiszolgálóoldali particionálást.</span><span class="sxs-lookup"><span data-stu-id="2d356-408">Native Redis (not Azure Redis Cache) supports server-side partitioning based on Redis clustering.</span></span> <span data-ttu-id="2d356-409">Ebben a megközelítésben az adatok egyenletesen oszthatók meg a kiszolgálók között egy kivonatoló mechanizmus segítségével.</span><span class="sxs-lookup"><span data-stu-id="2d356-409">In this approach, you can divide the data evenly across servers by using a hashing mechanism.</span></span> <span data-ttu-id="2d356-410">Mindegyik Redis-kiszolgáló tárolja a partíción tárolt kivonatkulcsokat leíró metaadatokat, és arra vonatkozóan is tartalmaz információkat, hogy mely kivonatkulcsok találhatók a más kiszolgálókon lévő partíciókon.</span><span class="sxs-lookup"><span data-stu-id="2d356-410">Each Redis server stores metadata that describes the range of hash keys that the partition holds, and also contains information about which hash keys are located in the partitions on other servers.</span></span>

<span data-ttu-id="2d356-411">Az ügyfélalkalmazások egyszerűen beküldik a kérelmeket valamelyik résztvevő Redis-kiszolgálóra (valószínűleg a legközelebbire).</span><span class="sxs-lookup"><span data-stu-id="2d356-411">Client applications simply send requests to any of the participating Redis servers (probably the closest one).</span></span> <span data-ttu-id="2d356-412">A Redis-kiszolgáló megvizsgálja az ügyfélkérelmet.</span><span class="sxs-lookup"><span data-stu-id="2d356-412">The Redis server examines the client request.</span></span> <span data-ttu-id="2d356-413">Ha az helyileg megoldható, akkor elvégzi a kért műveletet.</span><span class="sxs-lookup"><span data-stu-id="2d356-413">If it can be resolved locally, it performs the requested operation.</span></span> <span data-ttu-id="2d356-414">Ha nem oldható meg, továbbítja a kérést a megfelelő kiszolgálóra.</span><span class="sxs-lookup"><span data-stu-id="2d356-414">Otherwise it forwards the request on to the appropriate server.</span></span>

<span data-ttu-id="2d356-415">Erről a Redis-fürtözés használatával megvalósított modellről további részleteket a Redis webhelyén, a [Oktatóanyag Redis-fürtökhöz] tartalmazó oldalon talál.</span><span class="sxs-lookup"><span data-stu-id="2d356-415">This model is implemented by using Redis clustering, and is described in more detail on the [Redis cluster tutorial] page on the Redis website.</span></span> <span data-ttu-id="2d356-416">A Redis-fürtözés az ügyfélalkalmazások számára transzparens módon történik.</span><span class="sxs-lookup"><span data-stu-id="2d356-416">Redis clustering is transparent to client applications.</span></span> <span data-ttu-id="2d356-417">A fürthöz további Redis-kiszolgálók is hozzáadhatók (és az adatok újraparticionálhatók) anélkül, hogy az ügyfeleket újra kellene konfigurálni.</span><span class="sxs-lookup"><span data-stu-id="2d356-417">Additional Redis servers can be added to the cluster (and the data can be re-partitioned) without requiring that you reconfigure the clients.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="2d356-418">Az Azure Redis Cache jelenleg támogatja a Redis a Fürtszolgáltatás [prémium](/azure/azure-cache-for-redis/cache-how-to-premium-clustering) réteg csak.</span><span class="sxs-lookup"><span data-stu-id="2d356-418">Azure Redis Cache currently supports Redis clustering in [premium](/azure/azure-cache-for-redis/cache-how-to-premium-clustering) tier only.</span></span>

<span data-ttu-id="2d356-419">A Redis használatával történő particionálásról további információkat a Redis webhelyén elérhető, [Particionálás: adatok felosztása több Redis-példány között] leíró oldalon talál.</span><span class="sxs-lookup"><span data-stu-id="2d356-419">The page [Partitioning: how to split data among multiple Redis instances] on the Redis website provides more information about implementing partitioning with Redis.</span></span> <span data-ttu-id="2d356-420">A szakasz további része feltételezi, hogy ügyféloldali vagy proxyval támogatott particionálást végez.</span><span class="sxs-lookup"><span data-stu-id="2d356-420">The remainder of this section assumes that you are implementing client-side or proxy-assisted partitioning.</span></span>

<span data-ttu-id="2d356-421">Ha az adatokat az Azure Redis Cache-sel tervezi particionálni, vegye figyelembe a következő szempontokat:</span><span class="sxs-lookup"><span data-stu-id="2d356-421">Consider the following points when deciding how to partition data with Azure Redis Cache:</span></span>

- <span data-ttu-id="2d356-422">Az Azure Redis Cache nem végleges adattárolásra lett kialakítva, ezért bármilyen particionálási sémát választ is, az alkalmazás kódjának az adatokat egy, a gyorsítótártól különböző helyről kell tudnia lekérdezni.</span><span class="sxs-lookup"><span data-stu-id="2d356-422">Azure Redis Cache is not intended to act as a permanent data store, so whatever partitioning scheme you implement, your application code must be able to retrieve data from a location that's not the cache.</span></span>

- <span data-ttu-id="2d356-423">A gyakran együtt használt adatokat érdemes egy partíción tartani.</span><span class="sxs-lookup"><span data-stu-id="2d356-423">Data that is frequently accessed together should be kept in the same partition.</span></span> <span data-ttu-id="2d356-424">A Redis egy hatékony kulcs-érték tároló, amely több magas szinten optimalizált mechanizmust biztosít az adatok rendszerezéséhez.</span><span class="sxs-lookup"><span data-stu-id="2d356-424">Redis is a powerful key-value store that provides several highly optimized mechanisms for structuring data.</span></span> <span data-ttu-id="2d356-425">Ezek a mechanizmusok a következők lehetnek:</span><span class="sxs-lookup"><span data-stu-id="2d356-425">These mechanisms can be one of the following:</span></span>
  - <span data-ttu-id="2d356-426">Egyszerű sztringek (legfeljebb 512 MB hosszúságú bináris adatok)</span><span class="sxs-lookup"><span data-stu-id="2d356-426">Simple strings (binary data up to 512 MB in length)</span></span>
  - <span data-ttu-id="2d356-427">Összesített típusok, például listák (amelyek szolgálhatnak üzenetsorként vagy veremként)</span><span class="sxs-lookup"><span data-stu-id="2d356-427">Aggregate types such as lists (which can act as queues and stacks)</span></span>
  - <span data-ttu-id="2d356-428">Halmazok (rendezett és rendezetlen)</span><span class="sxs-lookup"><span data-stu-id="2d356-428">Sets (ordered and unordered)</span></span>
  - <span data-ttu-id="2d356-429">Kivonatok (amelyekkel csoportosíthatóak a kapcsolódó mezők, például az egy objektum mezőit jelölő elemek)</span><span class="sxs-lookup"><span data-stu-id="2d356-429">Hashes (which can group related fields together, such as the items that represent the fields in an object)</span></span>

- <span data-ttu-id="2d356-430">Az összesített típusok összerendelhető segítségével több kapcsolódó mező ugyanazzal a kulccsal.</span><span class="sxs-lookup"><span data-stu-id="2d356-430">The aggregate types enable you to associate many related values with the same key.</span></span> <span data-ttu-id="2d356-431">A Redis-kulcsok listákat, halmazokat vagy kivonatokat azonosítanak, nem pedig az azokban tárolt adatelemeket.</span><span class="sxs-lookup"><span data-stu-id="2d356-431">A Redis key identifies a list, set, or hash rather than the data items that it contains.</span></span> <span data-ttu-id="2d356-432">Ezek a típusok az Azure Redis Cache-ben mind elérhetők, és a Redis webhelyén, az [Adattípusok] lapon ismerhetőek meg.</span><span class="sxs-lookup"><span data-stu-id="2d356-432">These types are all available with Azure Redis Cache and are described by the [Data types] page on the Redis website.</span></span> <span data-ttu-id="2d356-433">Például egy e-kereskedelmi rendszer az ügyfelek által feladott megrendeléseket követő részében az egyes ügyfelek adatai tárolhatóak egy Redis-kivonatban, amelynek a kulcsa lehet a felhasználó azonosítója.</span><span class="sxs-lookup"><span data-stu-id="2d356-433">For example, in part of an e-commerce system that tracks the orders that are placed by customers, the details of each customer can be stored in a Redis hash that is keyed by using the customer ID.</span></span> <span data-ttu-id="2d356-434">Mindegyik kivonat az ügyfél megrendelésazonosítóinak egy gyűjteményét tárolja.</span><span class="sxs-lookup"><span data-stu-id="2d356-434">Each hash can hold a collection of order IDs for the customer.</span></span> <span data-ttu-id="2d356-435">Egy külön Redis-halmaz tárolhatja a megrendeléseket, ezeket is kivonatként strukturálva, és kulcsként a megrendelésazonosítót használva.</span><span class="sxs-lookup"><span data-stu-id="2d356-435">A separate Redis set can hold the orders, again structured as hashes, and keyed by using the order ID.</span></span> <span data-ttu-id="2d356-436">A 8. ábrán ez a struktúra látható.</span><span class="sxs-lookup"><span data-stu-id="2d356-436">Figure 8 shows this structure.</span></span> <span data-ttu-id="2d356-437">Vegye figyelembe, hogy a Redis nem valósít meg semmilyen hivatkozásintegritást, így a fejlesztő feladata, hogy fenntartsa az ügyfelek és a megrendelések kapcsolatát.</span><span class="sxs-lookup"><span data-stu-id="2d356-437">Note that Redis does not implement any form of referential integrity, so it is the developer's responsibility to maintain the relationships between customers and orders.</span></span>

![Javasolt struktúra a Redis-tárolóban a megrendelések és adataik rögzítéséhez](./images/data-partitioning/RedisCustomersandOrders.png)

<span data-ttu-id="2d356-439">*8. ábra Javasolt struktúra a Redis-tárolóban a megrendelések és adataik rögzítéséhez.*</span><span class="sxs-lookup"><span data-stu-id="2d356-439">*Figure 8. Suggested structure in Redis storage for recording customer orders and their details.*</span></span>

> [!NOTE]
> <span data-ttu-id="2d356-440">A Redisben a kulcsok bináris adatértékek (mint a Redis-sztringek), és legfeljebb 512 MB adatot tartalmazhatnak.</span><span class="sxs-lookup"><span data-stu-id="2d356-440">In Redis, all keys are binary data values (like Redis strings) and can contain up to 512 MB of data.</span></span> <span data-ttu-id="2d356-441">Elméletileg a kulcsok szinte bármilyen információt tartalmazhatnak.</span><span class="sxs-lookup"><span data-stu-id="2d356-441">In theory, a key can contain almost any information.</span></span> <span data-ttu-id="2d356-442">Javasoljuk azonban egy egységes kulcselnevezési konvenció bevezetését, amely leírja az adatok típusát és azonosítja az entitásokat, de nem túl hosszú.</span><span class="sxs-lookup"><span data-stu-id="2d356-442">However, we recommend adopting a consistent naming convention for keys that is descriptive of the type of data and that identifies the entity, but is not excessively long.</span></span> <span data-ttu-id="2d356-443">Általános megközelítésként javasolt „entitástípus:azonosító” formátumú kulcsokat használni.</span><span class="sxs-lookup"><span data-stu-id="2d356-443">A common approach is to use keys of the form "entity_type:ID".</span></span> <span data-ttu-id="2d356-444">Például a „user:99” névvel jelölheti egy 99-es azonosítójú ügyfél kulcsát.</span><span class="sxs-lookup"><span data-stu-id="2d356-444">For example, you can use "customer:99" to indicate the key for a customer with the ID 99.</span></span>

- <span data-ttu-id="2d356-445">A vertikális particionálás megvalósítható, ha a különböző összesítésekben lévő kapcsolódó információkat ugyanabban az adatbázisban tárolja.</span><span class="sxs-lookup"><span data-stu-id="2d356-445">You can implement vertical partitioning by storing related information in different aggregations in the same database.</span></span> <span data-ttu-id="2d356-446">Például egy e-kereskedelmi alkalmazásban tárolhatja a termékekkel kapcsolatos gyakran használt adatokat az egyik Redis-kivonatban, a kevésbé gyakran használt felhasználóadatokat pedig egy másikban.</span><span class="sxs-lookup"><span data-stu-id="2d356-446">For example, in an e-commerce application, you can store commonly accessed information about products in one Redis hash and less frequently used detailed information in another.</span></span> <span data-ttu-id="2d356-447">Mindkét kivonat használhatja ugyanazt a termékazonosítót a kulcs részeként.</span><span class="sxs-lookup"><span data-stu-id="2d356-447">Both hashes can use the same product ID as part of the key.</span></span> <span data-ttu-id="2d356-448">Használhatja például "termék: *Neurális hálózat*" (ahol *Neurális hálózat* a termékazonosító) a termékinformációkhoz és a "product_details: *Neurális hálózat*" a részletes adatokhoz.</span><span class="sxs-lookup"><span data-stu-id="2d356-448">For example, you can use "product: *nn*" (where *nn* is the product ID) for the product information and "product_details: *nn*" for the detailed data.</span></span> <span data-ttu-id="2d356-449">Ezzel a stratégiával csökkenthető a legtöbb lekérdezés által várhatóan beolvasott adatok mennyisége.</span><span class="sxs-lookup"><span data-stu-id="2d356-449">This strategy can help reduce the volume of data that most queries are likely to retrieve.</span></span>

- <span data-ttu-id="2d356-450">A Redis-adattárak újraparticionálhatóak, de érdemes figyelembe venni, hogy ez összetett és időigényes feladat.</span><span class="sxs-lookup"><span data-stu-id="2d356-450">You can repartition a Redis data store, but keep in mind that it's a complex and time-consuming task.</span></span> <span data-ttu-id="2d356-451">A Redis-fürtszolgáltatás képes automatikusan újraparticionálni az adatokat, ez a funkció azonban az Azure Redis Cache-ben nem elérhető.</span><span class="sxs-lookup"><span data-stu-id="2d356-451">Redis clustering can repartition data automatically, but this capability is not available with Azure Redis Cache.</span></span> <span data-ttu-id="2d356-452">Ezért a particionálási séma tervezésekor igyekezzen elegendő szabad helyet hagyni az egyes partíciókon az adatmennyiség idővel várható növekedésének megfelelően.</span><span class="sxs-lookup"><span data-stu-id="2d356-452">Therefore, when you design your partitioning scheme, try to leave sufficient free space in each partition to allow for expected data growth over time.</span></span> <span data-ttu-id="2d356-453">Ne feledje azonban, hogy az Azure Redis Cache az adatok ideiglenes gyorsítótárazására szolgál, valamint hogy a gyorsítótárban tárolt adatok élettartama korlátozható az élettartam (TTL) érték megadásával.</span><span class="sxs-lookup"><span data-stu-id="2d356-453">However, remember that Azure Redis Cache is intended to cache data temporarily, and that data held in the cache can have a limited lifetime specified as a time-to-live (TTL) value.</span></span> <span data-ttu-id="2d356-454">A viszonylag rövid életű adatok esetében az élettartam rövidre vehető, a statikus adatok esetében azonban sokkal hosszabbra.</span><span class="sxs-lookup"><span data-stu-id="2d356-454">For relatively volatile data, the TTL can be short, but for static data the TTL can be a lot longer.</span></span> <span data-ttu-id="2d356-455">Lehetőleg ne tároljon nagy mennyiségű hosszabb élettartamú adatot a gyorsítótárban, amennyiben azok mennyisége feltehetően megtöltené a gyorsítótárat.</span><span class="sxs-lookup"><span data-stu-id="2d356-455">Avoid storing large amounts of long-lived data in the cache if the volume of this data is likely to fill the cache.</span></span> <span data-ttu-id="2d356-456">Meghatározhat egy kiürítési szabályzatot, amely törli az adatokat az Azure Redis Cache-ből, ha a hely kiemelt fontosságú.</span><span class="sxs-lookup"><span data-stu-id="2d356-456">You can specify an eviction policy that causes Azure Redis Cache to remove data if space is at a premium.</span></span>

  > [!NOTE]
  > <span data-ttu-id="2d356-457">Az Azure Redis Cache használata esetén a gyorsítótár maximális mérete (250 MB és 53 GB között) a megfelelő tarifacsomag kiválasztásával határozható meg.</span><span class="sxs-lookup"><span data-stu-id="2d356-457">When you use Azure Redis cache, you specify the maximum size of the cache (from 250 MB to 53 GB) by selecting the appropriate pricing tier.</span></span> <span data-ttu-id="2d356-458">Azonban a méret az Azure Redis Cache-gyorsítótár létrehozása után nem növelhető (és nem is csökkenthető).</span><span class="sxs-lookup"><span data-stu-id="2d356-458">However, after an Azure Redis Cache has been created, you cannot increase (or decrease) its size.</span></span>

- <span data-ttu-id="2d356-459">A Redis-kötegek és -tranzakciók nem terjedhetnek ki több kapcsolatra, így az egyes kötegek vagy tranzakciók által érintett összes adatot ugyanabban az adatbázisban (szegmensben) kell tárolni.</span><span class="sxs-lookup"><span data-stu-id="2d356-459">Redis batches and transactions cannot span multiple connections, so all data that is affected by a batch or transaction should be held in the same database (shard).</span></span>

  > [!NOTE]
  > <span data-ttu-id="2d356-460">A Redis-tranzakcióban foglalt műveletszekvencia nem feltétlenül elemi jellegű.</span><span class="sxs-lookup"><span data-stu-id="2d356-460">A sequence of operations in a Redis transaction is not necessarily atomic.</span></span> <span data-ttu-id="2d356-461">A tranzakciókat alkotó parancsokat a rendszer a futtatás előtt ellenőrzi, majd az üzenetsorba küldi azokat.</span><span class="sxs-lookup"><span data-stu-id="2d356-461">The commands that compose a transaction are verified and queued before they run.</span></span> <span data-ttu-id="2d356-462">Ha ebben a fázisban hiba történik, a rendszer a teljes üzenetsort elveti.</span><span class="sxs-lookup"><span data-stu-id="2d356-462">If an error occurs during this phase, the entire queue is discarded.</span></span> <span data-ttu-id="2d356-463">Azonban miután a tranzakció sikeresen el lett küldve, az üzenetsorban lévő parancsok sorrendben lefutnak.</span><span class="sxs-lookup"><span data-stu-id="2d356-463">However, after the transaction has been successfully submitted, the queued commands run in sequence.</span></span> <span data-ttu-id="2d356-464">Ha bármely parancs meghiúsul, csak az adott parancs futása áll le.</span><span class="sxs-lookup"><span data-stu-id="2d356-464">If any command fails, only that command stops running.</span></span> <span data-ttu-id="2d356-465">A rendszer az üzenetsorban lévő összes megelőző és követő parancsot végrehajtja.</span><span class="sxs-lookup"><span data-stu-id="2d356-465">All previous and subsequent commands in the queue are performed.</span></span> <span data-ttu-id="2d356-466">További információkat a Redis webhelyén, a [tranzakciók] lapján talál.</span><span class="sxs-lookup"><span data-stu-id="2d356-466">For more information, go to the [Transactions] page on the Redis website.</span></span>

- <span data-ttu-id="2d356-467">A Redis korlátozott számú elemi műveletet támogat.</span><span class="sxs-lookup"><span data-stu-id="2d356-467">Redis supports a limited number of atomic operations.</span></span> <span data-ttu-id="2d356-468">Az ilyen típusú műveletek közül több kulcs és érték használatát kizárólag az MGET és az MSET művelet támogatja.</span><span class="sxs-lookup"><span data-stu-id="2d356-468">The only operations of this type that support multiple keys and values are MGET and MSET operations.</span></span> <span data-ttu-id="2d356-469">Az MGET műveletek kulcsok egy megadott listájához tartozó értékek gyűjteményét adják vissza, az MSET műveletek pedig ugyanezeket tárolják.</span><span class="sxs-lookup"><span data-stu-id="2d356-469">MGET operations return a collection of values for a specified list of keys, and MSET operations store a collection of values for a specified list of keys.</span></span> <span data-ttu-id="2d356-470">Ha használni szeretné ezeket a műveleteket, az MSET és az MGET parancsok által hivatkozott kulcs-érték párokat ugyanabban az adatbázisban kell tárolnia.</span><span class="sxs-lookup"><span data-stu-id="2d356-470">If you need to use these operations, the key-value pairs that are referenced by the MSET and MGET commands must be stored within the same database.</span></span>

## <a name="partitioning-azure-service-fabric"></a><span data-ttu-id="2d356-471">Az Azure Service Fabric particionálási</span><span class="sxs-lookup"><span data-stu-id="2d356-471">Partitioning Azure Service Fabric</span></span>

<span data-ttu-id="2d356-472">Az Azure Service Fabric egy mikroszolgáltatás-platform, amely futtatókörnyezetet biztosít az elosztott alkalmazások felhőben végzett futtatására.</span><span class="sxs-lookup"><span data-stu-id="2d356-472">Azure Service Fabric is a microservices platform that provides a runtime for distributed applications in the cloud.</span></span> <span data-ttu-id="2d356-473">A Service Fabric támogatja a .Net vendégrendszer futtatható fájljait, az állapotalapú és az állapotmentes szolgáltatásokat és a tárolókat.</span><span class="sxs-lookup"><span data-stu-id="2d356-473">Service Fabric supports .Net guest executables, stateful and stateless services, and containers.</span></span> <span data-ttu-id="2d356-474">Az állapotalapú szolgáltatások egy [megbízható gyűjteményt][service-fabric-reliable-collections] biztosítanak az adatok kulcs-érték gyűjteményben való tartós tárolásához a Service Fabric-fürtben.</span><span class="sxs-lookup"><span data-stu-id="2d356-474">Stateful services provide a [reliable collection][service-fabric-reliable-collections] to persistently store data in a key-value collection within the Service Fabric cluster.</span></span> <span data-ttu-id="2d356-475">Particionálási kulcsok megbízható gyűjteményekben vonatkozó stratégiákkal kapcsolatos további információkért lásd: [Irányelvek és javaslatok az Azure Service Fabric megbízható gyűjteményeihez].</span><span class="sxs-lookup"><span data-stu-id="2d356-475">For more information about strategies for partitioning keys in a reliable collection, see [guidelines and recommendations for reliable collections in Azure Service Fabric].</span></span>

### <a name="more-information"></a><span data-ttu-id="2d356-476">További információ</span><span class="sxs-lookup"><span data-stu-id="2d356-476">More information</span></span>

- <span data-ttu-id="2d356-477">[Az Azure Service Fabric áttekintése] egy bevezető az Azure Service Fabric szolgáltatáshoz.</span><span class="sxs-lookup"><span data-stu-id="2d356-477">[Overview of Azure Service Fabric] is an introduction to Azure Service Fabric.</span></span>

- <span data-ttu-id="2d356-478">[A Service Fabric Reliable Services particionálása] további információkat szolgáltat az Azure Service Fabric Reliable Services szolgáltatásairól.</span><span class="sxs-lookup"><span data-stu-id="2d356-478">[Partition Service Fabric reliable services] provides more information about reliable services in Azure Service Fabric.</span></span>

## <a name="partitioning-azure-event-hubs"></a><span data-ttu-id="2d356-479">Az Azure Event Hubs particionálási</span><span class="sxs-lookup"><span data-stu-id="2d356-479">Partitioning Azure Event Hubs</span></span>

<span data-ttu-id="2d356-480">Az [Azure Event Hubs][event-hubs] nagy léptékű adatstreamelésre lett kifejlesztve, és a particionálás integrált részét képezi a horizontális skálázás lehetővé tétele érdekében.</span><span class="sxs-lookup"><span data-stu-id="2d356-480">[Azure Event Hubs][event-hubs] is designed for data streaming at massive scale, and partitioning is built into the service to enable horizontal scaling.</span></span> <span data-ttu-id="2d356-481">Mindegyik felhasználó az üzenetstreamnek csak egy adott partícióját olvassa.</span><span class="sxs-lookup"><span data-stu-id="2d356-481">Each consumer only reads a specific partition of the message stream.</span></span>

<span data-ttu-id="2d356-482">Az esemény-közzétevő csak a partíciókulcsot ismeri, azt a partíciót nem, amelyre az esemény közzé lesz téve.</span><span class="sxs-lookup"><span data-stu-id="2d356-482">The event publisher is only aware of its partition key, not the partition to which the events are published.</span></span> <span data-ttu-id="2d356-483">A kulcs és a partíció szétválasztása révén a küldőnek nem szükséges behatóan ismernie az alárendelt feldolgozási folyamatokat.</span><span class="sxs-lookup"><span data-stu-id="2d356-483">This decoupling of key and partition insulates the sender from needing to know too much about the downstream processing.</span></span> <span data-ttu-id="2d356-484">(Eseményeket közvetlenül is küldhet adott partíciókra, az azonban általában nem ajánlott.)</span><span class="sxs-lookup"><span data-stu-id="2d356-484">(It's also possible send events directly to a given partition, but generally that's not recommended.)</span></span>  

<span data-ttu-id="2d356-485">A partíciószám megadásakor hosszú távú szempontokat érdemes mérlegelni.</span><span class="sxs-lookup"><span data-stu-id="2d356-485">Consider long-term scale when you select the partition count.</span></span> <span data-ttu-id="2d356-486">Az eseményközpontok létrehozását követően a partíciók száma nem módosítható.</span><span class="sxs-lookup"><span data-stu-id="2d356-486">After an event hub is created, you can't change the number of partitions.</span></span>

<span data-ttu-id="2d356-487">Az Event Hubs-partíciók használatával kapcsolatos további információkat a [Mi az Event Hubs?] című cikk tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="2d356-487">For more information about using partitions in Event Hubs, see [What is Event Hubs?].</span></span>

<span data-ttu-id="2d356-488">A rendelkezésre állás és a konzisztencia közti kompromisszummal kapcsolatos megfontolásokat a [Rendelkezésre állás és konzisztencia az Event Hubsban] című cikk tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="2d356-488">For considerations about trade-offs between availability and consistency, see [Availability and consistency in Event Hubs].</span></span>

[Rendelkezésre állás és konzisztencia az Event Hubsban]: /azure/event-hubs/event-hubs-availability-and-consistency
[Availability and consistency in Event Hubs]: /azure/event-hubs/event-hubs-availability-and-consistency
[azure-limits]: /azure/azure-subscription-service-limits
[Azure Content Delivery Network]: /azure/cdn/cdn-overview
[Azure Redis Cache]: https://azure.microsoft.com/services/cache/
[Azure Storage Scalability and Performance Targets]: /azure/storage/storage-scalability-targets
[Az Azure Storage Table tervezési útmutatója]: /azure/storage/storage-table-design-guide
[Azure Storage Table Design Guide]: /azure/storage/storage-table-design-guide
[Building a Polyglot Solution]: https://msdn.microsoft.com/library/dn313279.aspx
[cosmos-db-ru]: /azure/cosmos-db/request-units
[Data Access for Highly-Scalable Solutions: Using SQL, NoSQL, and Polyglot Persistence]: https://msdn.microsoft.com/library/dn271399.aspx
[Data consistency primer]: https://aka.ms/Data-Consistency-Primer
[Data Partitioning Guidance]: https://msdn.microsoft.com/library/dn589795.aspx
[Adattípusok]: https://redis.io/topics/data-types
[Data Types]: https://redis.io/topics/data-types
[cosmosdb-sql-api]: /azure/cosmos-db/sql-api-introduction
[Elastic Database features overview]: /azure/sql-database/sql-database-elastic-scale-introduction
[event-hubs]: /azure/event-hubs
[Federations Migration Utility]: https://code.msdn.microsoft.com/vstudio/Federations-Migration-ce61e9c1
[Irányelvek és javaslatok az Azure Service Fabric megbízható gyűjteményeihez]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[guidelines and recommendations for reliable collections in Azure Service Fabric]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections-guidelines
[Multi-shard querying]: /azure/sql-database/sql-database-elastic-scale-multishard-querying
[Az Azure Service Fabric áttekintése]: /azure/service-fabric/service-fabric-overview
[Overview of Azure Service Fabric]: /azure/service-fabric/service-fabric-overview
[A Service Fabric Reliable Services particionálása]: /azure/service-fabric/service-fabric-concepts-partitioning
[Partition Service Fabric reliable services]: /azure/service-fabric/service-fabric-concepts-partitioning
[Particionálás: adatok felosztása több Redis-példány között]: https://redis.io/topics/partitioning
[Partitioning: how to split data among multiple Redis instances]: https://redis.io/topics/partitioning
[Entitáscsoport-tranzakciók végrehajtása]: /rest/api/storageservices/Performing-Entity-Group-Transactions
[Performing Entity Group Transactions]: /rest/api/storageservices/Performing-Entity-Group-Transactions
[Oktatóanyag Redis-fürtökhöz]: https://redis.io/topics/cluster-tutorial
[Redis cluster tutorial]: https://redis.io/topics/cluster-tutorial
[Running Redis on a CentOS Linux VM in Azure]: https://blogs.msdn.microsoft.com/tconte/2012/06/08/running-redis-on-a-centos-linux-vm-in-windows-azure/
[Scaling using the Elastic Database split-merge tool]: /azure/sql-database/sql-database-elastic-scale-overview-split-and-merge
[Using Azure Content Delivery Network]: /azure/cdn/cdn-create-new-endpoint
[Service Bus-kvóták]: /azure/service-bus-messaging/service-bus-quotas
[Service Bus quotas]: /azure/service-bus-messaging/service-bus-quotas
[service-fabric-reliable-collections]: /azure/service-fabric/service-fabric-reliable-services-reliable-collections
[Az Azure Search szolgáltatási korlátozásai]:  /azure/search/search-limits-quotas-capacity
[Service limits in Azure Search]:  /azure/search/search-limits-quotas-capacity
[Sharding pattern]: ../patterns/sharding.md
[Támogatott adattípusok (Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Supported Data Types (Azure Search)]:  https://msdn.microsoft.com/library/azure/dn798938.aspx
[Tranzakciók]: https://redis.io/topics/transactions
[Transactions]: https://redis.io/topics/transactions
[Mi az Event Hubs?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[What is Event Hubs?]: /azure/event-hubs/event-hubs-what-is-event-hubs
[Mi az az Azure Search?]: /azure/search/search-what-is-azure-search
[What is Azure Search?]: /azure/search/search-what-is-azure-search
[What is Azure SQL Database?]: /azure/sql-database/sql-database-technical-overview
[teljesítménycélokat]: /azure/storage/common/storage-scalability-targets
[scalability targets]: /azure/storage/common/storage-scalability-targets
