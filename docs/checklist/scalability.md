---
title: "Méretezési ellenőrzőlista"
description: "Méretezhetőség ellenőrzőlista útmutató a tervezési szempontok az Azure automatikus skálázást."
author: dragon119
ms.date: 01/10/2018
ms.custom: checklist
ms.openlocfilehash: c3eaf41a038dbdd963f54d6c7cff8a8a772f8c48
ms.sourcegitcommit: 3d6dba524cc7661740bdbaf43870de7728d60a01
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 01/11/2018
---
# <a name="scalability-checklist"></a><span data-ttu-id="1e3b4-103">Méretezési ellenőrzőlista</span><span class="sxs-lookup"><span data-stu-id="1e3b4-103">Scalability checklist</span></span>

<span data-ttu-id="1e3b4-104">Méretezhetőség azon képessége, a rendszer a megnövekedett terhelés kezelése érdekében, és az egyik a [szoftver minőségű oszlopok](../guide/pillars.md).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-104">Scalability is the ability of a system to handle increased load, and is one of the [pillars of software quality](../guide/pillars.md).</span></span> <span data-ttu-id="1e3b4-105">Az alábbi ellenőrzőlista segítségével ellenőrizze az alkalmazás architektúrák méretezhetőség szempontból.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-105">Use this checklist to review your application architecture from a scalability standpoint.</span></span> 

## <a name="application-design"></a><span data-ttu-id="1e3b4-106">Alkalmazás tervezése</span><span class="sxs-lookup"><span data-stu-id="1e3b4-106">Application design</span></span>

<span data-ttu-id="1e3b4-107">**A munkaterhelés partícióazonosító**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-107">**Partition the workload**.</span></span> <span data-ttu-id="1e3b4-108">Tervezze meg a folyamat diszkrét és decomposable részeiről.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-108">Design parts of the process to be discrete and decomposable.</span></span> <span data-ttu-id="1e3b4-109">Egyes komponenseihez méretének minimalizálása a szokásos szabályok a problémákat és az egyetlen felelősségi elkülönítéséhez követése során.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-109">Minimize the size of each part, while following the usual rules for separation of concerns and the single responsibility principle.</span></span> <span data-ttu-id="1e3b4-110">Ez lehetővé teszi olyan oly módon, hogy minden számítási egység (például egy szerepkör vagy adatbázis-kiszolgáló) használata a lehető legnagyobbra növeli a összetevő kijelzők.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-110">This allows the component parts to be distributed in a way that maximizes use of each compute unit (such as a role or database server).</span></span> <span data-ttu-id="1e3b4-111">Azt is megkönnyíti az alkalmazás egy adott erőforráshoz példányai hozzáadásával méretezhető.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-111">It also makes it easier to scale the application by adding instances of specific resources.</span></span> <span data-ttu-id="1e3b4-112">Az összetett tartományok, fontolja meg a bevezetése egy [mikroszolgáltatások architektúra](..//guide/architecture-styles/microservices.md).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-112">For complex domains, consider adopting a [microservices architecture](..//guide/architecture-styles/microservices.md).</span></span>

<span data-ttu-id="1e3b4-113">**Tervezési méretezéshez**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-113">**Design for scaling**.</span></span> <span data-ttu-id="1e3b4-114">Lehetővé teszi olyan alkalmazások reagálni változó terhelés növelésével és szerepkörök, példányok számának csökkentésével várólisták, és más szolgáltatások használata.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-114">Scaling allows applications to react to variable load by increasing and decreasing the number of instances of roles, queues, and other services they use.</span></span> <span data-ttu-id="1e3b4-115">Azonban az alkalmazást úgy kell megtervezni a szem előtt.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-115">However, the application must be designed with this in mind.</span></span> <span data-ttu-id="1e3b4-116">Például az alkalmazás- és a használ állapotmentes, így a kérelmek tetszőleges példányra irányíthatja át kell lennie.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-116">For example, the application and the services it uses must be stateless, to allow requests to be routed to any instance.</span></span> <span data-ttu-id="1e3b4-117">Ez is megakadályozza, hogy a hozzáadását és eltávolítását olyan specifikus példányai kedvezőtlen hatással az aktuális felhasználók.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-117">This also prevents the addition or removal of specific instances from adversely impacting current users.</span></span> <span data-ttu-id="1e3b4-118">Is inkább konfigurációs vagy az automatikus észlelés példányok hozzáadni és eltávolítani, így az alkalmazás kódja hajthat végre a szükséges útválasztási.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-118">You should also implement configuration or auto-detection of instances as they are added and removed, so that code in the application can perform the necessary routing.</span></span> <span data-ttu-id="1e3b4-119">Például egy webes alkalmazás használhatja várólisták készlete ciklikus multiplexeléssel háttérszolgáltatások feldolgozói szerepkörök futó kérelmek útvonalat.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-119">For example, a web application might use a set of queues in a round-robin approach to route requests to background services running in worker roles.</span></span> <span data-ttu-id="1e3b4-120">A webalkalmazás azonosíthatók a módosításokat a sikeres kérelmek irányíthatja, és az alkalmazás terhelésének elosztása a várólisták számát képesnek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-120">The web application must be able to detect changes in the number of queues, to successfully route requests and balance the load on the application.</span></span>

<span data-ttu-id="1e3b4-121">**Skálázási egységként**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-121">**Scale as a unit**.</span></span> <span data-ttu-id="1e3b4-122">Tervezze meg a további forrásokat biztosít növekedéshez való alkalmazkodásra.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-122">Plan for additional resources to accommodate growth.</span></span> <span data-ttu-id="1e3b4-123">Az egyes erőforrások méretezési korlátok felső ismeri, és horizontális vagy felbontás ellen túlléphetik a működés felső korlátjának.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-123">For each resource, know the upper scaling limits, and use sharding or decomposition to go beyond these limits.</span></span> <span data-ttu-id="1e3b4-124">Határozza meg, a méretezési egységek, a rendszer erőforrások jól meghatározott készleteinek tekintetében.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-124">Determine the scale units for the system in terms of well-defined sets of resources.</span></span> <span data-ttu-id="1e3b4-125">Így alkalmazása kibővített műveletek egyszerűbbé, és vannak téve a negatív hatással az alkalmazásra az egyes részei a teljes rendszer erőforráshiány korlátozásokra keresztül.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-125">This makes applying scale-out operations easier, and less prone to negative impact on the application through limitations imposed by lack of resources in some part of the overall system.</span></span> <span data-ttu-id="1e3b4-126">Például hozzáadását x előfordulhat, hogy a webes és feldolgozói szerepkörök számának y további várólisták száma és a storage-fiókok kezelése a terhelést a szerepkörök által létrehozott z számát.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-126">For example, adding x number of web and worker roles might require y number of additional queues and z number of storage accounts to handle the additional workload generated by the roles.</span></span> <span data-ttu-id="1e3b4-127">A skálázási egység sikerült alkotják, webes és feldolgozói szerepkörök x *y* várólisták, és *z* storage-fiókok.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-127">So a scale unit could consist of x web and worker roles, *y* queues, and *z* storage accounts.</span></span> <span data-ttu-id="1e3b4-128">Az alkalmazás tervezze meg, hogy könnyen méretezve, egy vagy több skálázási egység.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-128">Design the application so that it's easily scaled by adding one or more scale units.</span></span>

<span data-ttu-id="1e3b4-129">**Ügyfél affinitása elkerülése**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-129">**Avoid client affinity**.</span></span> <span data-ttu-id="1e3b4-130">Ahol lehetséges, győződjön meg arról, hogy az alkalmazás nem szükséges kapcsolat.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-130">Where possible, ensure that the application does not require affinity.</span></span> <span data-ttu-id="1e3b4-131">Kérelmek így átirányítható tetszőleges példányra, és a példányok száma nem számít.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-131">Requests can thus be routed to any instance, and the number of instances is irrelevant.</span></span> <span data-ttu-id="1e3b4-132">Ezzel elkerülhető a többletterhelést, tárolása, lekérése és fenntartásának minden felhasználó állapot adatait is.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-132">This also avoids the overhead of storing, retrieving, and maintaining state information for each user.</span></span>

<span data-ttu-id="1e3b4-133">**Az automatikus skálázás platform előnyeit**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-133">**Take advantage of platform autoscaling features**.</span></span> <span data-ttu-id="1e3b4-134">Ha az üzemeltetési platformtól támogatja az automatikus skálázás funkció, például az Azure automatikus skálázás, inkább egyéni vagy külső mechanizmusokig, kivéve, ha a beépített mechanizmus a követelmények nem teljesíthető.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-134">Where the hosting platform supports an autoscaling capability, such as Azure Autoscale, prefer it to custom or third-party mechanisms unless the built-in mechanism can't fulfill your requirements.</span></span> <span data-ttu-id="1e3b4-135">Ütemezett méretezési Naptárszabályok használata, ahol lehetséges erőforrások biztosításához elérhetők a kezdeti késedelem nélkül, de reaktív automatikus skálázás hozzáadása a szabályok, ahol igény szerint váratlan változásai kezelése.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-135">Use scheduled scaling rules where possible to ensure resources are available without a start-up delay, but add reactive autoscaling to the rules where appropriate to cope with unexpected changes in demand.</span></span> <span data-ttu-id="1e3b4-136">Az automatikus skálázás műveletek használhatja a Service Management API automatikus skálázás beállításához, és adja hozzá az egyéni számlálók szabályok.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-136">You can use the autoscaling operations in the Service Management API to adjust autoscaling, and to add custom counters to rules.</span></span> <span data-ttu-id="1e3b4-137">További információkért lásd: [automatikus skálázás útmutatást](../best-practices/auto-scaling.md).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-137">For more information, see [Auto-scaling guidance](../best-practices/auto-scaling.md).</span></span>

<span data-ttu-id="1e3b4-138">**Háttérfeladatok intenzív CPU/IO feladatok kiszervezése**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-138">**Offload intensive CPU/IO tasks as background tasks**.</span></span> <span data-ttu-id="1e3b4-139">Ha a szolgáltatásnak küldött kérelemben várhatóan szükséges idő futtatásához, illetve jelentős erőforrásokat felvegye, kiszervezése egy külön feladat a kérelmek feldolgozását.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-139">If a request to a service is expected to take a long time to run or absorb considerable resources, offload the processing for this request to a separate task.</span></span> <span data-ttu-id="1e3b4-140">Ezek a feladatok végrehajtásához használja a feldolgozói szerepkörök és a feladatok a háttérben (attól függően, hogy az üzemeltetési platformtól).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-140">Use worker roles or background jobs (depending on the hosting platform) to execute these tasks.</span></span> <span data-ttu-id="1e3b4-141">Ezt a stratégiát lehetővé teszi, hogy a szolgáltatás továbbra is megkapja az további kérelmeket, és továbbra is válaszol.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-141">This strategy enables the service to continue receiving further requests and remain responsive.</span></span>  <span data-ttu-id="1e3b4-142">További információkért lásd: [feladatok útmutatást háttérben](../best-practices/background-jobs.md).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-142">For more information, see [Background jobs guidance](../best-practices/background-jobs.md).</span></span>

<span data-ttu-id="1e3b4-143">**A háttérben futó feladatot okozott terhelés elosztásához**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-143">**Distribute the workload for background tasks**.</span></span> <span data-ttu-id="1e3b4-144">Ha sok háttér feladatot, vagy a feladatok elvégzéséhez jelentős időt és erőforrásokat, a munkahelyi elosztva több számítási egységre is kiterjed (például feldolgozói szerepkörök és a feladatok a háttérben).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-144">Where there are many background tasks, or the tasks require considerable time or resources, spread the work across multiple compute units (such as worker roles or background jobs).</span></span> <span data-ttu-id="1e3b4-145">Egy lehetséges megoldás, tekintse meg a [versengő fogyasztók mintát](https://msdn.microsoft.com/library/dn568101.aspx).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-145">For one possible solution, see the [Competing Consumers Pattern](https://msdn.microsoft.com/library/dn568101.aspx).</span></span>

<span data-ttu-id="1e3b4-146">**Vegye figyelembe a mozgóátlag felé egy *osztott* architektúra**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-146">**Consider moving towards a *shared-nothing* architecture**.</span></span> <span data-ttu-id="1e3b4-147">Egy osztott architektúra független, ellenállni csomópontokat, amelyek nem egyetlen pont, versengés (például a megosztott szolgáltatások vagy a tároló) használja.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-147">A shared-nothing architecture uses independent, self-sufficient nodes that have no single point of contention (such as shared services or storage).</span></span> <span data-ttu-id="1e3b4-148">Elméletileg ilyen rendszer szinte határozatlan ideig méretezheti.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-148">In theory, such a system can scale almost indefinitely.</span></span> <span data-ttu-id="1e3b4-149">Amíg a teljes osztott megközelítés nincs általában a legtöbb alkalmazás gyakorlati, tartalmaznak, a lehetőségek megtervezheti a jobb méretezhetőség érdekében.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-149">While a fully shared-nothing approach is generally not practical for most applications, it may provide opportunities to design for better scalability.</span></span> <span data-ttu-id="1e3b4-150">Például elkerülve a kiszolgálóoldali munkamenet-állapot használatát, ügyfélaffinitás, és az adatok particionálása Példák jó áthelyezése egy osztott architektúra felé.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-150">For example, avoiding the use of server-side session state, client affinity, and data partitioning are good examples of moving towards a shared-nothing architecture.</span></span>

## <a name="data-management"></a><span data-ttu-id="1e3b4-151">Adatkezelés</span><span class="sxs-lookup"><span data-stu-id="1e3b4-151">Data management</span></span>

<span data-ttu-id="1e3b4-152">**Használja a adatparticionálás**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-152">**Use data partitioning**.</span></span> <span data-ttu-id="1e3b4-153">Az adatok osztja szét több adatbázis és adatbázis-kiszolgálók, vagy az alkalmazást, hogy az adatok tárolási szolgáltatásokért tervezési a particionálás transzparens módon biztosít (például az Azure SQL Database Elastic Database és Azure Table storage).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-153">Divide the data across multiple databases and database servers, or design the application to use data storage services that can provide this partitioning transparently (examples include Azure SQL Database Elastic Database, and Azure Table storage).</span></span> <span data-ttu-id="1e3b4-154">Ez a megközelítés segít teljesítmény maximalizálása és egyszerűbb skálázás engedélyezése.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-154">This approach can help to maximize performance and allow easier scaling.</span></span> <span data-ttu-id="1e3b4-155">Nincsenek, különböző módszereket, például a vízszintes, függőleges, particionálás és megfelelően működik.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-155">There are different partitioning techniques, such as horizontal, vertical, and functional.</span></span> <span data-ttu-id="1e3b4-156">Ezek kombinációja használható maximális hasznos nagyobb lekérdezési teljesítményt, egyszerűbb méretezhetőséget, rugalmasabb felügyeleti, jobb rendelkezésre állásának eléréséhez, és megfelelnek a tároló, azt fogja tárolni az adatokat.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-156">You can use a combination of these to achieve maximum benefit from increased query performance, simpler scalability, more flexible management, better availability, and to match the type of store to the data it will hold.</span></span> <span data-ttu-id="1e3b4-157">Emellett érdemes adattár különböző típusú különböző típusú adatok, milyen mértékben ezek vannak optimalizálva, az adott típusú adatok alapján kiválasztása.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-157">Also, consider using different types of data store for different types of data, choosing the types based on how well they are optimized for the specific type of data.</span></span> <span data-ttu-id="1e3b4-158">Ebbe beletartozik egy relációs adatbázisban, a table storage, a dokumentum-adatbázis vagy egy oszlop-család adattár, ahelyett, hogy vagy és használata.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-158">This may include using table storage, a document database, or a column-family data store, instead of, or as well as, a relational database.</span></span> <span data-ttu-id="1e3b4-159">További információkért lásd: [útmutatást particionálás adatok](../best-practices/data-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-159">For more information, see [Data partitioning guidance](../best-practices/data-partitioning.md).</span></span>

<span data-ttu-id="1e3b4-160">**Terv a végleges konzisztencia**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-160">**Design for eventual consistency**.</span></span> <span data-ttu-id="1e3b4-161">Végleges konzisztencia javul a méretezhetőség, csökkentését, vagy a kapcsolódó adatokra vonatkozó több üzletben között particionált szinkronizálásához szükséges idő eltávolításával.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-161">Eventual consistency improves scalability by reducing or removing the time needed to synchronize related data partitioned across multiple stores.</span></span> <span data-ttu-id="1e3b4-162">A költség, hogy az adat nem mindig konzisztens írásvédett, és néhány írási műveletek ütközéseket okozhat.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-162">The cost is that data is not always consistent when it is read, and some write operations may cause conflicts.</span></span> <span data-ttu-id="1e3b4-163">Olyan helyzetekben, ha ugyanazokat az adatokat gyakran beolvasott, de írása ritkán ideális a végleges konzisztencia.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-163">Eventual consistency is ideal for situations where the same data is read frequently but written infrequently.</span></span> <span data-ttu-id="1e3b4-164">További információkért lásd: a [adatok konzisztencia ismertetése](https://msdn.microsoft.com/library/dn589800.aspx).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-164">For more information, see the [Data Consistency Primer](https://msdn.microsoft.com/library/dn589800.aspx).</span></span>

<span data-ttu-id="1e3b4-165">**Összetevőkkel és szolgáltatásokkal közötti chatty párbeszéd csökkentése**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-165">**Reduce chatty interactions between components and services**.</span></span> <span data-ttu-id="1e3b4-166">Elkerülése, amelyben egy alkalmazás több hívások szolgáltatáshoz szükséges interakciók tervezése (amelyek adja vissza egy kisebb mennyiségű adatot), lépjen vissza az összes adat egyetlen hívás helyett.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-166">Avoid designing interactions in which an application is required to make multiple calls to a service (each of which returns a small amount of data), rather than a single call that can return all of the data.</span></span> <span data-ttu-id="1e3b4-167">Ahol lehetséges, és egy szolgáltatás vagy összetevő, amely észrevehető várakozási ideje a hívás esetén egyesítése egyetlen kérelem több kapcsolódó műveletek.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-167">Where possible, combine several related operations into a single request when the call is to a service or component that has noticeable latency.</span></span> <span data-ttu-id="1e3b4-168">Ez megkönnyíti a teljesítmény figyeléséhez és összetett műveletek optimalizálása.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-168">This makes it easier to monitor performance and optimize complex operations.</span></span> <span data-ttu-id="1e3b4-169">Például adatbázisok tárolt eljárások segítségével foglalják magukban a komplex logikai, és adjon meg kevesebb kiszolgálókkal való adatváltások számát és az erőforrás zárolását.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-169">For example, use stored procedures in databases to encapsulate complex logic, and reduce the number of round trips and resource locking.</span></span>

<span data-ttu-id="1e3b4-170">**A terhelés szintet nagy sebességű adatírás várólisták segítségével**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-170">**Use queues to level the load for high velocity data writes**.</span></span> <span data-ttu-id="1e3b4-171">A szolgáltatás igény szerinti emelkedéseit ne terhelje tovább a szolgáltatáshoz, és növekvő hibákhoz vezethet.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-171">Surges in demand for a service can overwhelm that service and cause escalating failures.</span></span> <span data-ttu-id="1e3b4-172">Ennek megelőzése érdekében vegye fontolóra a [terhelés simítás mintát várólista alapú](https://msdn.microsoft.com/library/dn589783.aspx).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-172">To prevent this, consider implementing the [Queue-Based Load Leveling Pattern](https://msdn.microsoft.com/library/dn589783.aspx).</span></span> <span data-ttu-id="1e3b4-173">Egy feladat és egy szolgáltatás, amely meghívja a közötti pufferként a várólista használja.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-173">Use a queue that acts as a buffer between a task and a service that it invokes.</span></span> <span data-ttu-id="1e3b4-174">Ez is sima időszakos nagy terhelések, amelyek egyébként okozhatnak a szolgáltatás leáll vagy a feladat túllépi az időkorlátot.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-174">This can smooth intermittent heavy loads that may otherwise cause the service to fail or the task to time out.</span></span>

<span data-ttu-id="1e3b4-175">**Az adattár terhelése minimalizálása**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-175">**Minimize the load on the data store**.</span></span> <span data-ttu-id="1e3b4-176">Az adattár általában feldolgozás szűk keresztmetszet, költséges erőforrás, és gyakran nem egyszerű horizontális skálázásra. Ahol lehetséges, távolítsa el (például az XML-dokumentumok vagy JSON-objektumok feldolgozása) programot a tárolót, és hajtsa végre az alkalmazáson belül feldolgozása.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-176">The data store is commonly a processing bottleneck, a costly resource, and often not easy to scale out. Where possible, remove logic (such as processing XML documents or JSON objects) from the data store, and perform processing within the application.</span></span> <span data-ttu-id="1e3b4-177">Például ahelyett, hogy át XML az adatbázishoz (eltérő tárolási nem átlátszó karakterláncként), szerializálható vagy belül az alkalmazási rétegre XML deszerializálása, és adja át az adattár natív űrlapon.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-177">For example, instead of passing XML to the database (other than as an opaque string for storage), serialize or deserialize the XML within the application layer and pass it in a form that is native to the data store.</span></span> <span data-ttu-id="1e3b4-178">Általában sokkal egyszerűbb, ezért meg kell kísérelni a lehető legtöbb számítási igényű feldolgozása az alkalmazáson belül lehető teendő a tárolót, mint az alkalmazás horizontális.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-178">It's typically much easier to scale out the application than the data store, so you should attempt to do as much of the compute-intensive processing as possible within the application.</span></span>

<span data-ttu-id="1e3b4-179">**Minimalizálása érdekében a beolvasott adatok mennyiségét**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-179">**Minimize the volume of data retrieved**.</span></span> <span data-ttu-id="1e3b4-180">Csak oszlopok és sorok kiválogatására feltételek alapján szükséges adatok lekérése.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-180">Retrieve only the data you require by specifying columns and using criteria to select rows.</span></span> <span data-ttu-id="1e3b4-181">Győződjön meg a tábla értékkel rendelkező paraméterek használatát és a megfelelő elkülönítési szintet.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-181">Make use of table value parameters and the appropriate isolation level.</span></span> <span data-ttu-id="1e3b4-182">Használjon mechanizmusok, például entitáscímkék adatgyűjtés feleslegesen elkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-182">Use mechanisms like entity tags to avoid retrieving data unnecessarily.</span></span>

<span data-ttu-id="1e3b4-183">**Agresszív használjon a gyorsítótárazást**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-183">**Aggressively use caching**.</span></span> <span data-ttu-id="1e3b4-184">Használjon, amikor csak lehetséges, erőforrások és szolgáltatások létrehozása, illetve az adatok ügyfelek terhelésének csökkentése érdekében gyorsítótárazást.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-184">Use caching wherever possible to reduce the load on resources and services that generate or deliver data.</span></span> <span data-ttu-id="1e3b4-185">Gyorsítótárazás adatokat ez viszonylag statikus, illetve az beszerzése jelentős feldolgozást igényel, amely általában alkalmazható.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-185">Caching is typically suited to data that is relatively static, or that requires considerable processing to obtain.</span></span> <span data-ttu-id="1e3b4-186">Gyorsítótárazás kell végrehajtani minden szinten adott esetben az alkalmazás, beleértve a adatok hozzáférés és a felhasználói felület minden egyes rétegben.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-186">Caching should occur at all levels where appropriate in each layer of the application, including data access and user interface generation.</span></span> <span data-ttu-id="1e3b4-187">További információkért lásd: a [gyorsítótárazás útmutatást](../best-practices/caching.md).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-187">For more information, see the [Caching Guidance](../best-practices/caching.md).</span></span>

<span data-ttu-id="1e3b4-188">**Az adatmennyiség-növekedés és megőrzési**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-188">**Handle data growth and retention**.</span></span> <span data-ttu-id="1e3b4-189">Az alkalmazások által tárolt adatok mennyisége idővel növekszik.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-189">The amount of data stored by an application grows over time.</span></span> <span data-ttu-id="1e3b4-190">A növekedési növeli a tárolási költségeket, és növeli a késleltetés az adatok elérése közben – amely alkalmazás átviteli sebesség és a teljesítményt befolyásolja.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-190">This growth increases storage costs, and increases latency when accessing the data — which affects application throughput and performance.</span></span> <span data-ttu-id="1e3b4-191">Rendszeres időközönként archiválja, amely már nem érhető el a régi adatok egy részét, vagy helyezze át a ritkán használt adatok a hosszú távú tároló, amely további költség hatékony, akkor is, ha a hozzáférési késés nagyobb is lehet.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-191">It may be possible to periodically archive some of the old data that is no longer accessed, or move data that is rarely accessed into long-term storage that is more cost efficient, even if the access latency is higher.</span></span>

<span data-ttu-id="1e3b4-192">**Adatok átvitele az objektumok (DTOs) egy hatékony bináris formátum optimalizálása**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-192">**Optimize Data Transfer Objects (DTOs) using an efficient binary format**.</span></span> <span data-ttu-id="1e3b4-193">DTOs sokszor átadott az alkalmazások a rétegek között.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-193">DTOs are passed between the layers of an application many times.</span></span> <span data-ttu-id="1e3b4-194">Minimalizálja a méretét csökkenti az erőforrások és a hálózat terhelése.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-194">Minimizing the size reduces the load on resources and the network.</span></span> <span data-ttu-id="1e3b4-195">Azonban egyenleg a megtakarítások a terhelést növelni az adatok konvertálása az egyes helyeken, ahol használják a szükséges formátumnak.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-195">However, balance the savings with the overhead of converting the data to the required format in each location where it is used.</span></span> <span data-ttu-id="1e3b4-196">Ahhoz, hogy az összetevő újrafelhasználás maximális együttműködési rendelkezik formátuma nem fogad el.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-196">Adopt a format that has the maximum interoperability to enable easy reuse of a component.</span></span>

<span data-ttu-id="1e3b4-197">**Gyorsítótár-vezérlésének**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-197">**Set cache control**.</span></span> <span data-ttu-id="1e3b4-198">Tervezése és konfigurálása a kimeneti gyorsítótár, vagy darabolható, lehetőség szerint minimálisra csökkenthető a feldolgozási terhelés gyorsítótárazása az alkalmazás.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-198">Design and configure the application to use output caching or fragment caching where possible, to minimize processing load.</span></span>

<span data-ttu-id="1e3b4-199">**Ügyféloldali gyorsítótárazás engedélyezése**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-199">**Enable client side caching**.</span></span> <span data-ttu-id="1e3b4-200">Webalkalmazások engedélyeznie kell a gyorsítótár beállításait a gyorsítótárazható tartalom.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-200">Web applications should enable cache settings on the content that can be cached.</span></span> <span data-ttu-id="1e3b4-201">Ez általában alapértelmezés szerint nincs engedélyezve.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-201">This is commonly disabled by default.</span></span> <span data-ttu-id="1e3b4-202">Konfigurálja a kiszolgálót, hogy a megfelelő gyorsítótár ahhoz, hogy a proxy kiszolgálókon vagy ügyfeleken tartalom gyorsítótárazását vezérlő fejlécek.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-202">Configure the server to deliver the appropriate cache control headers to enable caching of content on proxy servers and clients.</span></span>

<span data-ttu-id="1e3b4-203">**Az Azure blob storage és az Azure Content Delivery Network használja az alkalmazás terhelésének csökkentése érdekében**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-203">**Use Azure blob storage and the Azure Content Delivery Network to reduce the load on the application**.</span></span> <span data-ttu-id="1e3b4-204">Vegye figyelembe, hogy statikus vagy viszonylag statikus nyilvános tartalmak, képek, az erőforrások, a parancsfájlok és a stíluslapok, például blob Storage tárolóban végzett tárolása.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-204">Consider storing static or relatively static public content, such as images, resources, scripts, and style sheets, in blob storage.</span></span> <span data-ttu-id="1e3b4-205">Ez a megközelítés mentesíti az alkalmazás a dinamikusan létrehozásakor ezt a tartalmat, az egyes kérelmek okozta terhelés.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-205">This approach relieves the application of the load caused by dynamically generating this content for each request.</span></span> <span data-ttu-id="1e3b4-206">Emellett érdemes a tartalom kézbesítésével hálózati gyorsítótárazni a tartalmat, és kézbesíti az ügyfelek számára.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-206">Additionally, consider using the Content Delivery Network to cache this content and deliver it to clients.</span></span> <span data-ttu-id="1e3b4-207">A tartalom kézbesítésével hálózaton keresztül javíthatják a az ügyfél teljesítményét, mert a tartalomnak a földrajzilag legközelebbi adatközpont, amely tartalmazza a tartalom kézbesítésével hálózati gyorsítótár.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-207">Using the Content Delivery Network can improve performance at the client because the content is delivered from the geographically closest datacenter that contains a Content Delivery Network cache.</span></span> <span data-ttu-id="1e3b4-208">További információkért lásd: a [tartalom útmutató a kézbesítési hálózati](../best-practices/cdn.md).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-208">For more information, see the [Content Delivery Network Guidance](../best-practices/cdn.md).</span></span>

<span data-ttu-id="1e3b4-209">**Optimalizálása, és hangolja az SQL-lekérdezések és indexek**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-209">**Optimize and tune SQL queries and indexes**.</span></span> <span data-ttu-id="1e3b4-210">Néhány T-SQL-utasítások vagy szerkezeteket hatással lehet a teljesítményre, amely a kódot a tárolt eljárás optimalizálása csökkenthető.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-210">Some T-SQL statements or constructs may have an impact on performance that can be reduced by optimizing the code in a stored procedure.</span></span> <span data-ttu-id="1e3b4-211">Például a átalakításának elkerülése **datetime** típust egy **varchar** összehasonlítva az előtt egy **datetime** konstans érték.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-211">For example, avoid converting **datetime** types to a **varchar** before comparing with a **datetime** literal value.</span></span> <span data-ttu-id="1e3b4-212">Ehelyett használja a dátum/idő összehasonlító függvény.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-212">Use date/time comparison functions instead.</span></span> <span data-ttu-id="1e3b4-213">Megfelelő indexek hiánya is lelassíthatja a lekérdezés végrehajtása.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-213">Lack of appropriate indexes can also slow query execution.</span></span> <span data-ttu-id="1e3b4-214">Ha egy objektum relációs leképezési keretrendszert használja, ismerje meg, hogyan működik, és hogyan az hatással lehet az adatelérési réteg teljesítményét.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-214">If you use an object/relational mapping framework, understand how it works and how it may affect performance of the data access layer.</span></span> <span data-ttu-id="1e3b4-215">További információkért lásd: [lekérdezés hangolása](https://technet.microsoft.com/library/ms176005.aspx).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-215">For more information, see [Query Tuning](https://technet.microsoft.com/library/ms176005.aspx).</span></span>

<span data-ttu-id="1e3b4-216">**Fontolja meg deszerializálni normalizálása az adatok**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-216">**Consider de-normalizing data**.</span></span> <span data-ttu-id="1e3b4-217">Adatok normalizálási segít az ismétlődést és inkonzisztencia elkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-217">Data normalization helps to avoid duplication and inconsistency.</span></span> <span data-ttu-id="1e3b4-218">Több index karbantartása, a hivatkozási integritás-ellenőrzés, végrehajtása való kis adattömböket írnak több hozzáférések és az adatok ügyfél tábla szab egy terhelést, amely befolyásolhatja a teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-218">However, maintaining multiple indexes, checking for referential integrity, performing multiple accesses to small chunks of data, and joining tables to reassemble the data imposes an overhead that can affect performance.</span></span> <span data-ttu-id="1e3b4-219">Fontolja meg, hogy néhány további tárolókötetet és ismétlődést elfogadható az adattár terhelésének csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-219">Consider if some additional storage volume and duplication is acceptable in order to reduce the load on the data store.</span></span> <span data-ttu-id="1e3b4-220">Figyelembe venni, ha az alkalmazás maga (amely általában egyszerűbb, skálázása) is lehet hivatkozni átvenni a feladatokat, mint a hivatkozási integritás kezelése az adattár terhelésének csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-220">Also, consider if the application itself (which is typically easier to scale) can be relied upon to take over tasks such as managing referential integrity in order to reduce the load on the data store.</span></span> <span data-ttu-id="1e3b4-221">További információkért lásd: [útmutatást particionálás adatok](../best-practices/data-partitioning.md).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-221">For more information, see [Data partitioning guidance](../best-practices/data-partitioning.md).</span></span>

## <a name="implementation"></a><span data-ttu-id="1e3b4-222">Megvalósítás</span><span class="sxs-lookup"><span data-stu-id="1e3b4-222">Implementation</span></span>

<span data-ttu-id="1e3b4-223">**Tekintse át a teljesítmény antipatterns**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-223">**Review the performance antipatterns**.</span></span> <span data-ttu-id="1e3b4-224">Lásd: [teljesítmény antipatterns felhőalkalmazásokhoz](../antipatterns/index.md) a gyakori eljárásokat, amelyek valószínűleg méretezhetőség problémákat okozhat, ha egy alkalmazás terhelés alatt áll.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-224">See [Performance antipatterns for cloud applications](../antipatterns/index.md) for common practices that are likely to cause scalability problems when an application is under pressure.</span></span>

<span data-ttu-id="1e3b4-225">**Használja az aszinkron hívásai**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-225">**Use asynchronous calls**.</span></span> <span data-ttu-id="1e3b4-226">Aszinkron kód lehetőség, ha használ elérése során erőforrásokhoz vagy szolgáltatásokhoz, amelyek i/o vagy a hálózati sávszélesség, illetve hogy korlátozhatja észrevehető késést, a hívó szál zárolásának elkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-226">Use asynchronous code wherever possible when accessing resources or services that may be limited by I/O or network bandwidth, or that have a noticeable latency, in order to avoid locking the calling thread.</span></span> 

<span data-ttu-id="1e3b4-227">**Erőforrások zárolásának elkerülése, és helyette a optimista megközelítés**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-227">**Avoid locking resources, and use an optimistic approach instead**.</span></span> <span data-ttu-id="1e3b4-228">Soha nem erőforrások, például a tároló zárolása eléréséhez és egyéb szolgáltatások, amelyek észrevehető késést, mert ez teljesítményproblémákat elsődleges oka.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-228">Never lock access to resources such as storage or other services that have noticeable latency, because this is a primary cause of poor performance.</span></span> <span data-ttu-id="1e3b4-229">Mindig használjon optimista módszer párhuzamos műveletek, például a tárolási írása kezelése.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-229">Always use optimistic approaches to managing concurrent operations, such as writing to storage.</span></span> <span data-ttu-id="1e3b4-230">A tárolási réteg szolgáltatásai segítségével ütközések kezelésére.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-230">Use features of the storage layer to manage conflicts.</span></span> <span data-ttu-id="1e3b4-231">Elosztott alkalmazások adatok lehet csak idővel konzisztenssé.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-231">In distributed applications, data may be only eventually consistent.</span></span>

<span data-ttu-id="1e3b4-232">**Magas tömöríthető adatok tömörítése nagy késleltetésű, alacsony sávszélességű hálózatokon keresztül**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-232">**Compress highly compressible data over high latency, low bandwidth networks**.</span></span> <span data-ttu-id="1e3b4-233">A legtöbb esetben a webalkalmazást az alkalmazás által létrehozott és a hálózaton keresztül továbbított adatok legnagyobb mennyisége HTTP-válaszok ügyfélkérelmekre.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-233">In the majority of cases in a web application, the largest volume of data generated by the application and passed over the network is HTTP responses to client requests.</span></span> <span data-ttu-id="1e3b4-234">A HTTP-tömörítés csökkentheti Ez jelentősen, különösen a statikus tartalmat.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-234">HTTP compression can reduce this considerably, especially for static content.</span></span> <span data-ttu-id="1e3b4-235">Ez csökkenti költség, valamint a csökkentése a hálózat terhelése, ha a dinamikus tartalom tömörítése alkalmazása fractionally magasabb terhelés a kiszolgálón.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-235">This can reduce cost as well as reducing the load on the network, though compressing dynamic content does apply a fractionally higher load on the server.</span></span> <span data-ttu-id="1e3b4-236">Más, több általánosított környezetekben adattömörítés csökkentheti a továbbított adatok mennyiségét és átvitelének az idejét és a költségek minimalizálása érdekében, de a tömörítése és folyamatok fel Önnek a terhelést.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-236">In other, more generalized environments, data compression can reduce the volume of data transmitted and minimize transfer time and costs, but the compression and decompression processes incur overhead.</span></span> <span data-ttu-id="1e3b4-237">Ilyen tömörítés csak használandó bizonyítható jobb a teljesítménye esetén.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-237">As such, compression should only be used when there is a demonstrable gain in performance.</span></span> <span data-ttu-id="1e3b4-238">Más szerializálási módszerrel, JSON vagy bináris kódolás, például a terhelés méretének csökkentheti a teljesítményt, kisebb mértékű befolyásolása mellett, mivel XML várhatóan azt.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-238">Other serialization methods, such as JSON or binary encodings, may reduce the payload size while having less impact on performance, whereas XML is likely to increase it.</span></span>

<span data-ttu-id="1e3b4-239">**A kapcsolatok és erőforrások használatban lévő idő minimalizálása**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-239">**Minimize the time that connections and resources are in use**.</span></span> <span data-ttu-id="1e3b4-240">Kapcsolatok és erőforrások csak karbantartása mindaddig, amíg kell használni őket.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-240">Maintain connections and resources only for as long as you need to use them.</span></span> <span data-ttu-id="1e3b4-241">Például Minél később, nyitott kapcsolatot, és hogy vissza kell juttatni a kapcsolatkészletbe amint lehetséges.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-241">For example, open connections as late as possible, and allow them to be returned to the connection pool as soon as possible.</span></span> <span data-ttu-id="1e3b4-242">Erőforrások lehetséges késői beszereznie, és azokról a lehető leghamarabb.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-242">Acquire resources as late as possible, and dispose of them as soon as possible.</span></span>

<span data-ttu-id="1e3b4-243">**A szükséges kapcsolatok számának minimálisra csökkentése**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-243">**Minimize the number of connections required**.</span></span> <span data-ttu-id="1e3b4-244">Kapcsolatok felvegye erőforrásokat.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-244">Service connections absorb resources.</span></span> <span data-ttu-id="1e3b4-245">Korlátozza a számát, amelyet szükség, győződjön meg arról, hogy a meglévő kapcsolatok újrafelhasznált-e, amikor csak lehetséges.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-245">Limit the number that are required and ensure that existing connections are reused whenever possible.</span></span> <span data-ttu-id="1e3b4-246">Például hitelesítés elvégzése után a megszemélyesítést használhatja adott esetben egy adott identitás kód futtatásához.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-246">For example, after performing authentication, use impersonation where appropriate to run code as a specific identity.</span></span> <span data-ttu-id="1e3b4-247">Ez segít, hogy a kapcsolatot a kapcsolatkészletből lehető legjobb felhasználását újból felhasználja a kapcsolatokat.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-247">This can help to make best use of the connection pool by reusing connections.</span></span>
  
> [!NOTE]
> <span data-ttu-id="1e3b4-248">Egyes szolgáltatások API-k automatikusan kapcsolatok, ismét felhasználni, feltéve szolgáltatással kapcsolatos útmutatást követi.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-248">APIs for some services automatically reuse connections, provided service-specific guidelines are followed.</span></span> <span data-ttu-id="1e3b4-249">Fontos, hogy megértette a feltételeket, amelyek lehetővé teszik a kapcsolat felhasználhatja az egyes szolgáltatásokhoz, amelyek az alkalmazás használja.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-249">It's important that you understand the conditions that enable connection reuse for each service that your application uses.</span></span>
> 
> 

<span data-ttu-id="1e3b4-250">**Kérelmek küldése a hálózati optimalizálja kötegekben**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-250">**Send requests in batches to optimize network use**.</span></span> <span data-ttu-id="1e3b4-251">Például küldése és olvashatja kötegek várólista elérésekor, és hajtsa végre több olvasások és írások kötegként tároló- és a gyorsítótárba való hozzáféréskor.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-251">For example, send and read messages in batches when accessing a queue, and perform multiple reads or writes as a batch when accessing storage or a cache.</span></span> <span data-ttu-id="1e3b4-252">Ez segítheti a szolgáltatásaikat és adataikat tároló hatékonyságának maximalizálása a hálózaton keresztül hívások számának csökkentésével.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-252">This can help to maximize efficiency of the services and data stores by reducing the number of calls across the network.</span></span>

<span data-ttu-id="1e3b4-253">**Kerülje a követelmény a kiszolgálóoldali munkamenet-állapot tárolása** ahol csak lehetséges.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-253">**Avoid a requirement to store server-side session state** where possible.</span></span> <span data-ttu-id="1e3b4-254">A kiszolgálóoldali munkamenet-állapot kezelés általában ügyfélaffinitás (vagyis minden kérelmet van, útválasztási ugyanazon server-példányra), amely hatással van a szolgáltatás a rendszer szükséges.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-254">Server-side session state management typically requires client affinity (that is, routing each request to the same server instance), which affects the ability of the system to scale.</span></span> <span data-ttu-id="1e3b4-255">Ideális esetben akkor tervezzen ügyfelek állapotmentes az általuk használt kiszolgálók tekintetében.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-255">Ideally, you should design clients to be stateless with respect to the servers that they use.</span></span> <span data-ttu-id="1e3b4-256">Azonban ha az alkalmazás kell munkamenet-állapot karbantartásához, bizalmas adatokat tárolhatnak, vagy nagy mennyiségű ügyfél adatokat egy elosztott kiszolgálóoldali gyorsítótár, amely hozzáférhet az alkalmazás összes példányát.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-256">However, if the application must maintain session state, store sensitive data or large volumes of per-client data in a distributed server-side cache that all instances of the application can access.</span></span>

<span data-ttu-id="1e3b4-257">**Optimalizálja a tárhely táblasémákat**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-257">**Optimize table storage schemas**.</span></span> <span data-ttu-id="1e3b4-258">Tábla tárolja a tábla és oszlop nevét átadott és dolgozza fel, minden egyes lekérdezés, például az Azure table storage igénylő használata esetén érdemes lehet rövidebb nevek Ez a terhelés csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-258">When using table stores that require the table and column names to be passed and processed with every query, such as Azure table storage, consider using shorter names to reduce this overhead.</span></span> <span data-ttu-id="1e3b4-259">Azonban nem feláldozása olvashatóság vagy kezelhetőségi túlságosan kompakt nevek használatával.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-259">However, do not sacrifice readability or manageability by using overly compact names.</span></span>

<span data-ttu-id="1e3b4-260">**Erőforrás-függőségek létrehozása, üzembe helyezése során, vagy az alkalmazás indításakor**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-260">**Create resource dependencies during deployment or at application startup**.</span></span> <span data-ttu-id="1e3b4-261">Ne használjon ismétlődő hívások olyan metódusoknak, amelyek tesztelése erőforrás meglétét, majd hozza létre az erőforrás, ha nem létezik.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-261">Avoid repeated calls to methods that test the existence of a resource and then create the resource if it does not exist.</span></span> <span data-ttu-id="1e3b4-262">Például módszerek *CloudTable.CreateIfNotExists* és *CloudQueue.CreateIfNotExists* az Azure Storage ügyféloldali kódtár kövesse az ebben a mintában.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-262">Methods such as *CloudTable.CreateIfNotExists* and *CloudQueue.CreateIfNotExists* in the Azure Storage Client Library follow this pattern.</span></span> <span data-ttu-id="1e3b4-263">Ezek a módszerek adhat jelentős terhelés, ha azok minden hozzáférést egy adott tárolási tábla vagy a tároló várólista előtt kerül meghívásra.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-263">These methods can impose considerable overhead if they are invoked before each access to a storage table or storage queue.</span></span> <span data-ttu-id="1e3b4-264">Ehelyett:</span><span class="sxs-lookup"><span data-stu-id="1e3b4-264">Instead:</span></span>

* <span data-ttu-id="1e3b4-265">Hozzon létre a szükséges erőforrásokat, az alkalmazás központi telepítésekor, vagy először indításkor (egyetlen meghívása *CreateIfNotExists* minden erőforrás az indítási egy webes vagy feldolgozói szerepkör kódját nem elfogadható).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-265">Create the required resources when the application is deployed, or when it first starts (a single call to *CreateIfNotExists* for each resource in the startup code for a web or worker role is acceptable).</span></span> <span data-ttu-id="1e3b4-266">Azonban ügyeljen arra, hogy kezelni a kivételeket, amelyek esetleg felmerülő, ha a kódot próbál hozzáférni a nem létező erőforráshoz.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-266">However, be sure to handle exceptions that may arise if your code attempts to access a resource that doesn't exist.</span></span> <span data-ttu-id="1e3b4-267">Ezekben a helyzetekben, jelentkezzen a kivételt, és esetleg a riasztásra operátort, hogy az erőforrás hiányzik.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-267">In these situations, you should log the exception, and possibly alert an operator that a resource is missing.</span></span>
* <span data-ttu-id="1e3b4-268">Bizonyos esetekben célszerű lehet a hiányzó erőforrás létrehozása a kivételkezelő kód részeként.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-268">Under some circumstances, it may be appropriate to create the missing resource as part of the exception handling code.</span></span> <span data-ttu-id="1e3b4-269">Azonban ez a megközelítés körültekintően kell elfogadnia, mert lehet, hogy az erőforrás nem megléte, a programozási hiba (például hibásan erőforrás nevét), vagy valamilyen más infrastruktúra szintű problémákat.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-269">But you should adopt this approach with caution as the non-existence of the resource might be indicative of a programming error (a misspelled resource name for example), or some other infrastructure-level issue.</span></span>

<span data-ttu-id="1e3b4-270">**Egyszerűsített keretrendszerek használata**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-270">**Use lightweight frameworks**.</span></span> <span data-ttu-id="1e3b4-271">API-k és erőforrás-használat, végrehajtási ideje és az alkalmazás teljes terhelése minimalizálása érdekében használhat keretrendszerek gondosan kiválasztása.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-271">Carefully choose the APIs and frameworks you use to minimize resource usage, execution time, and overall load on the application.</span></span> <span data-ttu-id="1e3b4-272">Például a szolgáltatás-tanúsítványigénylések webes API segítségével csökkentheti az alkalmazás erőforrásigényét és végrehajtási sebesség növelése, de nem feltétlenül alkalmas speciális forgatókönyvek, ahol a további funkciókat a Windows Communication Foundation szükség.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-272">For example, using Web API to handle service requests can reduce the application footprint and increase execution speed, but it may not be suitable for advanced scenarios where the additional capabilities of Windows Communication Foundation are required.</span></span>

<span data-ttu-id="1e3b4-273">**Vegye figyelembe, minimalizálja a szolgáltatásfiókok számát**.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-273">**Consider minimizing the number of service accounts**.</span></span> <span data-ttu-id="1e3b4-274">Például egy adott fiók erőforrások eléréséhez vagy szolgáltatásokról, amelyek korlátozzák a kapcsolatokat, vagy indítson el jobb, ha kevesebb kapcsolat megmarad.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-274">For example, use a specific account to access resources or services that impose a limit on connections, or perform better where fewer connections are maintained.</span></span> <span data-ttu-id="1e3b4-275">Ez a megközelítés közös szolgáltatások, például adatbázisok, de ez befolyásolhatja pontosan naplózásának műveleteket, mert az eredeti felhasználó megszemélyesítésének a lehetősége.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-275">This approach is common for services such as databases, but it can affect the ability to accurately audit operations due to the impersonation of the original user.</span></span>

<span data-ttu-id="1e3b4-276">**Teljesítmény-profilkészítés végrehajtására és terheléses tesztelés** fejlesztési, tesztelési rutinok, és annak érdekében, hogy az alkalmazás hajt végre végleges és szükség szerint méretezik előtt részeként.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-276">**Carry out performance profiling and load testing** during development, as part of test routines, and before final release to ensure the application performs and scales as required.</span></span> <span data-ttu-id="1e3b4-277">A tesztelés kell végrehajtani a termelési platform, és az azonos típusú hardver azonos típusú és mennyiségű adatot és felhasználói terhelés az éles környezetben fog történni.</span><span class="sxs-lookup"><span data-stu-id="1e3b4-277">This testing should occur on the same type of hardware as the production platform, and with the same types and quantities of data and user load as it will encounter in production.</span></span> <span data-ttu-id="1e3b4-278">További információkért lásd: [egy felhőalapú szolgáltatás teljesítményének tesztelése](/azure/vs-azure-tools-performance-profiling-cloud-services/).</span><span class="sxs-lookup"><span data-stu-id="1e3b4-278">For more information, see [Testing the performance of a cloud service](/azure/vs-azure-tools-performance-profiling-cloud-services/).</span></span>

