---
title: "Méretezési ellenőrzőlista"
description: "Méretezhetőség ellenőrzőlista útmutató a tervezési szempontok az Azure automatikus skálázást."
author: dragon119
ms.date: 01/10/2018
ms.custom: checklist
ms.openlocfilehash: c3eaf41a038dbdd963f54d6c7cff8a8a772f8c48
ms.sourcegitcommit: 3d6dba524cc7661740bdbaf43870de7728d60a01
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 01/11/2018
---
# <a name="scalability-checklist"></a>Méretezési ellenőrzőlista

Méretezhetőség azon képessége, a rendszer a megnövekedett terhelés kezelése érdekében, és az egyik a [szoftver minőségű oszlopok](../guide/pillars.md). Az alábbi ellenőrzőlista segítségével ellenőrizze az alkalmazás architektúrák méretezhetőség szempontból. 

## <a name="application-design"></a>Alkalmazás tervezése

**A munkaterhelés partícióazonosító**. Tervezze meg a folyamat diszkrét és decomposable részeiről. Egyes komponenseihez méretének minimalizálása a szokásos szabályok a problémákat és az egyetlen felelősségi elkülönítéséhez követése során. Ez lehetővé teszi olyan oly módon, hogy minden számítási egység (például egy szerepkör vagy adatbázis-kiszolgáló) használata a lehető legnagyobbra növeli a összetevő kijelzők. Azt is megkönnyíti az alkalmazás egy adott erőforráshoz példányai hozzáadásával méretezhető. Az összetett tartományok, fontolja meg a bevezetése egy [mikroszolgáltatások architektúra](..//guide/architecture-styles/microservices.md).

**Tervezési méretezéshez**. Lehetővé teszi olyan alkalmazások reagálni változó terhelés növelésével és szerepkörök, példányok számának csökkentésével várólisták, és más szolgáltatások használata. Azonban az alkalmazást úgy kell megtervezni a szem előtt. Például az alkalmazás- és a használ állapotmentes, így a kérelmek tetszőleges példányra irányíthatja át kell lennie. Ez is megakadályozza, hogy a hozzáadását és eltávolítását olyan specifikus példányai kedvezőtlen hatással az aktuális felhasználók. Is inkább konfigurációs vagy az automatikus észlelés példányok hozzáadni és eltávolítani, így az alkalmazás kódja hajthat végre a szükséges útválasztási. Például egy webes alkalmazás használhatja várólisták készlete ciklikus multiplexeléssel háttérszolgáltatások feldolgozói szerepkörök futó kérelmek útvonalat. A webalkalmazás azonosíthatók a módosításokat a sikeres kérelmek irányíthatja, és az alkalmazás terhelésének elosztása a várólisták számát képesnek kell lennie.

**Skálázási egységként**. Tervezze meg a további forrásokat biztosít növekedéshez való alkalmazkodásra. Az egyes erőforrások méretezési korlátok felső ismeri, és horizontális vagy felbontás ellen túlléphetik a működés felső korlátjának. Határozza meg, a méretezési egységek, a rendszer erőforrások jól meghatározott készleteinek tekintetében. Így alkalmazása kibővített műveletek egyszerűbbé, és vannak téve a negatív hatással az alkalmazásra az egyes részei a teljes rendszer erőforráshiány korlátozásokra keresztül. Például hozzáadását x előfordulhat, hogy a webes és feldolgozói szerepkörök számának y további várólisták száma és a storage-fiókok kezelése a terhelést a szerepkörök által létrehozott z számát. A skálázási egység sikerült alkotják, webes és feldolgozói szerepkörök x *y* várólisták, és *z* storage-fiókok. Az alkalmazás tervezze meg, hogy könnyen méretezve, egy vagy több skálázási egység.

**Ügyfél affinitása elkerülése**. Ahol lehetséges, győződjön meg arról, hogy az alkalmazás nem szükséges kapcsolat. Kérelmek így átirányítható tetszőleges példányra, és a példányok száma nem számít. Ezzel elkerülhető a többletterhelést, tárolása, lekérése és fenntartásának minden felhasználó állapot adatait is.

**Az automatikus skálázás platform előnyeit**. Ha az üzemeltetési platformtól támogatja az automatikus skálázás funkció, például az Azure automatikus skálázás, inkább egyéni vagy külső mechanizmusokig, kivéve, ha a beépített mechanizmus a követelmények nem teljesíthető. Ütemezett méretezési Naptárszabályok használata, ahol lehetséges erőforrások biztosításához elérhetők a kezdeti késedelem nélkül, de reaktív automatikus skálázás hozzáadása a szabályok, ahol igény szerint váratlan változásai kezelése. Az automatikus skálázás műveletek használhatja a Service Management API automatikus skálázás beállításához, és adja hozzá az egyéni számlálók szabályok. További információkért lásd: [automatikus skálázás útmutatást](../best-practices/auto-scaling.md).

**Háttérfeladatok intenzív CPU/IO feladatok kiszervezése**. Ha a szolgáltatásnak küldött kérelemben várhatóan szükséges idő futtatásához, illetve jelentős erőforrásokat felvegye, kiszervezése egy külön feladat a kérelmek feldolgozását. Ezek a feladatok végrehajtásához használja a feldolgozói szerepkörök és a feladatok a háttérben (attól függően, hogy az üzemeltetési platformtól). Ezt a stratégiát lehetővé teszi, hogy a szolgáltatás továbbra is megkapja az további kérelmeket, és továbbra is válaszol.  További információkért lásd: [feladatok útmutatást háttérben](../best-practices/background-jobs.md).

**A háttérben futó feladatot okozott terhelés elosztásához**. Ha sok háttér feladatot, vagy a feladatok elvégzéséhez jelentős időt és erőforrásokat, a munkahelyi elosztva több számítási egységre is kiterjed (például feldolgozói szerepkörök és a feladatok a háttérben). Egy lehetséges megoldás, tekintse meg a [versengő fogyasztók mintát](https://msdn.microsoft.com/library/dn568101.aspx).

**Vegye figyelembe a mozgóátlag felé egy *osztott* architektúra**. Egy osztott architektúra független, ellenállni csomópontokat, amelyek nem egyetlen pont, versengés (például a megosztott szolgáltatások vagy a tároló) használja. Elméletileg ilyen rendszer szinte határozatlan ideig méretezheti. Amíg a teljes osztott megközelítés nincs általában a legtöbb alkalmazás gyakorlati, tartalmaznak, a lehetőségek megtervezheti a jobb méretezhetőség érdekében. Például elkerülve a kiszolgálóoldali munkamenet-állapot használatát, ügyfélaffinitás, és az adatok particionálása Példák jó áthelyezése egy osztott architektúra felé.

## <a name="data-management"></a>Adatkezelés

**Használja a adatparticionálás**. Az adatok osztja szét több adatbázis és adatbázis-kiszolgálók, vagy az alkalmazást, hogy az adatok tárolási szolgáltatásokért tervezési a particionálás transzparens módon biztosít (például az Azure SQL Database Elastic Database és Azure Table storage). Ez a megközelítés segít teljesítmény maximalizálása és egyszerűbb skálázás engedélyezése. Nincsenek, különböző módszereket, például a vízszintes, függőleges, particionálás és megfelelően működik. Ezek kombinációja használható maximális hasznos nagyobb lekérdezési teljesítményt, egyszerűbb méretezhetőséget, rugalmasabb felügyeleti, jobb rendelkezésre állásának eléréséhez, és megfelelnek a tároló, azt fogja tárolni az adatokat. Emellett érdemes adattár különböző típusú különböző típusú adatok, milyen mértékben ezek vannak optimalizálva, az adott típusú adatok alapján kiválasztása. Ebbe beletartozik egy relációs adatbázisban, a table storage, a dokumentum-adatbázis vagy egy oszlop-család adattár, ahelyett, hogy vagy és használata. További információkért lásd: [útmutatást particionálás adatok](../best-practices/data-partitioning.md).

**Terv a végleges konzisztencia**. Végleges konzisztencia javul a méretezhetőség, csökkentését, vagy a kapcsolódó adatokra vonatkozó több üzletben között particionált szinkronizálásához szükséges idő eltávolításával. A költség, hogy az adat nem mindig konzisztens írásvédett, és néhány írási műveletek ütközéseket okozhat. Olyan helyzetekben, ha ugyanazokat az adatokat gyakran beolvasott, de írása ritkán ideális a végleges konzisztencia. További információkért lásd: a [adatok konzisztencia ismertetése](https://msdn.microsoft.com/library/dn589800.aspx).

**Összetevőkkel és szolgáltatásokkal közötti chatty párbeszéd csökkentése**. Elkerülése, amelyben egy alkalmazás több hívások szolgáltatáshoz szükséges interakciók tervezése (amelyek adja vissza egy kisebb mennyiségű adatot), lépjen vissza az összes adat egyetlen hívás helyett. Ahol lehetséges, és egy szolgáltatás vagy összetevő, amely észrevehető várakozási ideje a hívás esetén egyesítése egyetlen kérelem több kapcsolódó műveletek. Ez megkönnyíti a teljesítmény figyeléséhez és összetett műveletek optimalizálása. Például adatbázisok tárolt eljárások segítségével foglalják magukban a komplex logikai, és adjon meg kevesebb kiszolgálókkal való adatváltások számát és az erőforrás zárolását.

**A terhelés szintet nagy sebességű adatírás várólisták segítségével**. A szolgáltatás igény szerinti emelkedéseit ne terhelje tovább a szolgáltatáshoz, és növekvő hibákhoz vezethet. Ennek megelőzése érdekében vegye fontolóra a [terhelés simítás mintát várólista alapú](https://msdn.microsoft.com/library/dn589783.aspx). Egy feladat és egy szolgáltatás, amely meghívja a közötti pufferként a várólista használja. Ez is sima időszakos nagy terhelések, amelyek egyébként okozhatnak a szolgáltatás leáll vagy a feladat túllépi az időkorlátot.

**Az adattár terhelése minimalizálása**. Az adattár általában feldolgozás szűk keresztmetszet, költséges erőforrás, és gyakran nem egyszerű horizontális skálázásra. Ahol lehetséges, távolítsa el (például az XML-dokumentumok vagy JSON-objektumok feldolgozása) programot a tárolót, és hajtsa végre az alkalmazáson belül feldolgozása. Például ahelyett, hogy át XML az adatbázishoz (eltérő tárolási nem átlátszó karakterláncként), szerializálható vagy belül az alkalmazási rétegre XML deszerializálása, és adja át az adattár natív űrlapon. Általában sokkal egyszerűbb, ezért meg kell kísérelni a lehető legtöbb számítási igényű feldolgozása az alkalmazáson belül lehető teendő a tárolót, mint az alkalmazás horizontális.

**Minimalizálása érdekében a beolvasott adatok mennyiségét**. Csak oszlopok és sorok kiválogatására feltételek alapján szükséges adatok lekérése. Győződjön meg a tábla értékkel rendelkező paraméterek használatát és a megfelelő elkülönítési szintet. Használjon mechanizmusok, például entitáscímkék adatgyűjtés feleslegesen elkerülése érdekében.

**Agresszív használjon a gyorsítótárazást**. Használjon, amikor csak lehetséges, erőforrások és szolgáltatások létrehozása, illetve az adatok ügyfelek terhelésének csökkentése érdekében gyorsítótárazást. Gyorsítótárazás adatokat ez viszonylag statikus, illetve az beszerzése jelentős feldolgozást igényel, amely általában alkalmazható. Gyorsítótárazás kell végrehajtani minden szinten adott esetben az alkalmazás, beleértve a adatok hozzáférés és a felhasználói felület minden egyes rétegben. További információkért lásd: a [gyorsítótárazás útmutatást](../best-practices/caching.md).

**Az adatmennyiség-növekedés és megőrzési**. Az alkalmazások által tárolt adatok mennyisége idővel növekszik. A növekedési növeli a tárolási költségeket, és növeli a késleltetés az adatok elérése közben – amely alkalmazás átviteli sebesség és a teljesítményt befolyásolja. Rendszeres időközönként archiválja, amely már nem érhető el a régi adatok egy részét, vagy helyezze át a ritkán használt adatok a hosszú távú tároló, amely további költség hatékony, akkor is, ha a hozzáférési késés nagyobb is lehet.

**Adatok átvitele az objektumok (DTOs) egy hatékony bináris formátum optimalizálása**. DTOs sokszor átadott az alkalmazások a rétegek között. Minimalizálja a méretét csökkenti az erőforrások és a hálózat terhelése. Azonban egyenleg a megtakarítások a terhelést növelni az adatok konvertálása az egyes helyeken, ahol használják a szükséges formátumnak. Ahhoz, hogy az összetevő újrafelhasználás maximális együttműködési rendelkezik formátuma nem fogad el.

**Gyorsítótár-vezérlésének**. Tervezése és konfigurálása a kimeneti gyorsítótár, vagy darabolható, lehetőség szerint minimálisra csökkenthető a feldolgozási terhelés gyorsítótárazása az alkalmazás.

**Ügyféloldali gyorsítótárazás engedélyezése**. Webalkalmazások engedélyeznie kell a gyorsítótár beállításait a gyorsítótárazható tartalom. Ez általában alapértelmezés szerint nincs engedélyezve. Konfigurálja a kiszolgálót, hogy a megfelelő gyorsítótár ahhoz, hogy a proxy kiszolgálókon vagy ügyfeleken tartalom gyorsítótárazását vezérlő fejlécek.

**Az Azure blob storage és az Azure Content Delivery Network használja az alkalmazás terhelésének csökkentése érdekében**. Vegye figyelembe, hogy statikus vagy viszonylag statikus nyilvános tartalmak, képek, az erőforrások, a parancsfájlok és a stíluslapok, például blob Storage tárolóban végzett tárolása. Ez a megközelítés mentesíti az alkalmazás a dinamikusan létrehozásakor ezt a tartalmat, az egyes kérelmek okozta terhelés. Emellett érdemes a tartalom kézbesítésével hálózati gyorsítótárazni a tartalmat, és kézbesíti az ügyfelek számára. A tartalom kézbesítésével hálózaton keresztül javíthatják a az ügyfél teljesítményét, mert a tartalomnak a földrajzilag legközelebbi adatközpont, amely tartalmazza a tartalom kézbesítésével hálózati gyorsítótár. További információkért lásd: a [tartalom útmutató a kézbesítési hálózati](../best-practices/cdn.md).

**Optimalizálása, és hangolja az SQL-lekérdezések és indexek**. Néhány T-SQL-utasítások vagy szerkezeteket hatással lehet a teljesítményre, amely a kódot a tárolt eljárás optimalizálása csökkenthető. Például a átalakításának elkerülése **datetime** típust egy **varchar** összehasonlítva az előtt egy **datetime** konstans érték. Ehelyett használja a dátum/idő összehasonlító függvény. Megfelelő indexek hiánya is lelassíthatja a lekérdezés végrehajtása. Ha egy objektum relációs leképezési keretrendszert használja, ismerje meg, hogyan működik, és hogyan az hatással lehet az adatelérési réteg teljesítményét. További információkért lásd: [lekérdezés hangolása](https://technet.microsoft.com/library/ms176005.aspx).

**Fontolja meg deszerializálni normalizálása az adatok**. Adatok normalizálási segít az ismétlődést és inkonzisztencia elkerülése érdekében. Több index karbantartása, a hivatkozási integritás-ellenőrzés, végrehajtása való kis adattömböket írnak több hozzáférések és az adatok ügyfél tábla szab egy terhelést, amely befolyásolhatja a teljesítményt. Fontolja meg, hogy néhány további tárolókötetet és ismétlődést elfogadható az adattár terhelésének csökkentése érdekében. Figyelembe venni, ha az alkalmazás maga (amely általában egyszerűbb, skálázása) is lehet hivatkozni átvenni a feladatokat, mint a hivatkozási integritás kezelése az adattár terhelésének csökkentése érdekében. További információkért lásd: [útmutatást particionálás adatok](../best-practices/data-partitioning.md).

## <a name="implementation"></a>Megvalósítás

**Tekintse át a teljesítmény antipatterns**. Lásd: [teljesítmény antipatterns felhőalkalmazásokhoz](../antipatterns/index.md) a gyakori eljárásokat, amelyek valószínűleg méretezhetőség problémákat okozhat, ha egy alkalmazás terhelés alatt áll.

**Használja az aszinkron hívásai**. Aszinkron kód lehetőség, ha használ elérése során erőforrásokhoz vagy szolgáltatásokhoz, amelyek i/o vagy a hálózati sávszélesség, illetve hogy korlátozhatja észrevehető késést, a hívó szál zárolásának elkerülése érdekében. 

**Erőforrások zárolásának elkerülése, és helyette a optimista megközelítés**. Soha nem erőforrások, például a tároló zárolása eléréséhez és egyéb szolgáltatások, amelyek észrevehető késést, mert ez teljesítményproblémákat elsődleges oka. Mindig használjon optimista módszer párhuzamos műveletek, például a tárolási írása kezelése. A tárolási réteg szolgáltatásai segítségével ütközések kezelésére. Elosztott alkalmazások adatok lehet csak idővel konzisztenssé.

**Magas tömöríthető adatok tömörítése nagy késleltetésű, alacsony sávszélességű hálózatokon keresztül**. A legtöbb esetben a webalkalmazást az alkalmazás által létrehozott és a hálózaton keresztül továbbított adatok legnagyobb mennyisége HTTP-válaszok ügyfélkérelmekre. A HTTP-tömörítés csökkentheti Ez jelentősen, különösen a statikus tartalmat. Ez csökkenti költség, valamint a csökkentése a hálózat terhelése, ha a dinamikus tartalom tömörítése alkalmazása fractionally magasabb terhelés a kiszolgálón. Más, több általánosított környezetekben adattömörítés csökkentheti a továbbított adatok mennyiségét és átvitelének az idejét és a költségek minimalizálása érdekében, de a tömörítése és folyamatok fel Önnek a terhelést. Ilyen tömörítés csak használandó bizonyítható jobb a teljesítménye esetén. Más szerializálási módszerrel, JSON vagy bináris kódolás, például a terhelés méretének csökkentheti a teljesítményt, kisebb mértékű befolyásolása mellett, mivel XML várhatóan azt.

**A kapcsolatok és erőforrások használatban lévő idő minimalizálása**. Kapcsolatok és erőforrások csak karbantartása mindaddig, amíg kell használni őket. Például Minél később, nyitott kapcsolatot, és hogy vissza kell juttatni a kapcsolatkészletbe amint lehetséges. Erőforrások lehetséges késői beszereznie, és azokról a lehető leghamarabb.

**A szükséges kapcsolatok számának minimálisra csökkentése**. Kapcsolatok felvegye erőforrásokat. Korlátozza a számát, amelyet szükség, győződjön meg arról, hogy a meglévő kapcsolatok újrafelhasznált-e, amikor csak lehetséges. Például hitelesítés elvégzése után a megszemélyesítést használhatja adott esetben egy adott identitás kód futtatásához. Ez segít, hogy a kapcsolatot a kapcsolatkészletből lehető legjobb felhasználását újból felhasználja a kapcsolatokat.
  
> [!NOTE]
> Egyes szolgáltatások API-k automatikusan kapcsolatok, ismét felhasználni, feltéve szolgáltatással kapcsolatos útmutatást követi. Fontos, hogy megértette a feltételeket, amelyek lehetővé teszik a kapcsolat felhasználhatja az egyes szolgáltatásokhoz, amelyek az alkalmazás használja.
> 
> 

**Kérelmek küldése a hálózati optimalizálja kötegekben**. Például küldése és olvashatja kötegek várólista elérésekor, és hajtsa végre több olvasások és írások kötegként tároló- és a gyorsítótárba való hozzáféréskor. Ez segítheti a szolgáltatásaikat és adataikat tároló hatékonyságának maximalizálása a hálózaton keresztül hívások számának csökkentésével.

**Kerülje a követelmény a kiszolgálóoldali munkamenet-állapot tárolása** ahol csak lehetséges. A kiszolgálóoldali munkamenet-állapot kezelés általában ügyfélaffinitás (vagyis minden kérelmet van, útválasztási ugyanazon server-példányra), amely hatással van a szolgáltatás a rendszer szükséges. Ideális esetben akkor tervezzen ügyfelek állapotmentes az általuk használt kiszolgálók tekintetében. Azonban ha az alkalmazás kell munkamenet-állapot karbantartásához, bizalmas adatokat tárolhatnak, vagy nagy mennyiségű ügyfél adatokat egy elosztott kiszolgálóoldali gyorsítótár, amely hozzáférhet az alkalmazás összes példányát.

**Optimalizálja a tárhely táblasémákat**. Tábla tárolja a tábla és oszlop nevét átadott és dolgozza fel, minden egyes lekérdezés, például az Azure table storage igénylő használata esetén érdemes lehet rövidebb nevek Ez a terhelés csökkentése érdekében. Azonban nem feláldozása olvashatóság vagy kezelhetőségi túlságosan kompakt nevek használatával.

**Erőforrás-függőségek létrehozása, üzembe helyezése során, vagy az alkalmazás indításakor**. Ne használjon ismétlődő hívások olyan metódusoknak, amelyek tesztelése erőforrás meglétét, majd hozza létre az erőforrás, ha nem létezik. Például módszerek *CloudTable.CreateIfNotExists* és *CloudQueue.CreateIfNotExists* az Azure Storage ügyféloldali kódtár kövesse az ebben a mintában. Ezek a módszerek adhat jelentős terhelés, ha azok minden hozzáférést egy adott tárolási tábla vagy a tároló várólista előtt kerül meghívásra. Ehelyett:

* Hozzon létre a szükséges erőforrásokat, az alkalmazás központi telepítésekor, vagy először indításkor (egyetlen meghívása *CreateIfNotExists* minden erőforrás az indítási egy webes vagy feldolgozói szerepkör kódját nem elfogadható). Azonban ügyeljen arra, hogy kezelni a kivételeket, amelyek esetleg felmerülő, ha a kódot próbál hozzáférni a nem létező erőforráshoz. Ezekben a helyzetekben, jelentkezzen a kivételt, és esetleg a riasztásra operátort, hogy az erőforrás hiányzik.
* Bizonyos esetekben célszerű lehet a hiányzó erőforrás létrehozása a kivételkezelő kód részeként. Azonban ez a megközelítés körültekintően kell elfogadnia, mert lehet, hogy az erőforrás nem megléte, a programozási hiba (például hibásan erőforrás nevét), vagy valamilyen más infrastruktúra szintű problémákat.

**Egyszerűsített keretrendszerek használata**. API-k és erőforrás-használat, végrehajtási ideje és az alkalmazás teljes terhelése minimalizálása érdekében használhat keretrendszerek gondosan kiválasztása. Például a szolgáltatás-tanúsítványigénylések webes API segítségével csökkentheti az alkalmazás erőforrásigényét és végrehajtási sebesség növelése, de nem feltétlenül alkalmas speciális forgatókönyvek, ahol a további funkciókat a Windows Communication Foundation szükség.

**Vegye figyelembe, minimalizálja a szolgáltatásfiókok számát**. Például egy adott fiók erőforrások eléréséhez vagy szolgáltatásokról, amelyek korlátozzák a kapcsolatokat, vagy indítson el jobb, ha kevesebb kapcsolat megmarad. Ez a megközelítés közös szolgáltatások, például adatbázisok, de ez befolyásolhatja pontosan naplózásának műveleteket, mert az eredeti felhasználó megszemélyesítésének a lehetősége.

**Teljesítmény-profilkészítés végrehajtására és terheléses tesztelés** fejlesztési, tesztelési rutinok, és annak érdekében, hogy az alkalmazás hajt végre végleges és szükség szerint méretezik előtt részeként. A tesztelés kell végrehajtani a termelési platform, és az azonos típusú hardver azonos típusú és mennyiségű adatot és felhasználói terhelés az éles környezetben fog történni. További információkért lásd: [egy felhőalapú szolgáltatás teljesítményének tesztelése](/azure/vs-azure-tools-performance-profiling-cloud-services/).

