# <a name="serverless-web-application"></a><span data-ttu-id="714d9-101">Kiszolgáló nélküli webalkalmazás</span><span class="sxs-lookup"><span data-stu-id="714d9-101">Serverless web application</span></span> 

<span data-ttu-id="714d9-102">Ez a referenciaarchitektúra bemutatja a kiszolgáló nélküli webalkalmazás.</span><span class="sxs-lookup"><span data-stu-id="714d9-102">This reference architecture shows a serverless web application.</span></span> <span data-ttu-id="714d9-103">Az alkalmazást a statikus tartalmat szolgáltat az Azure Blob Storage-ból, és a egy API-t az Azure Functions használatával valósítja meg.</span><span class="sxs-lookup"><span data-stu-id="714d9-103">The application serves static content from Azure Blob Storage, and implements an API using Azure Functions.</span></span> <span data-ttu-id="714d9-104">Az API beolvassa az adatokat a Cosmos DB és az eredményeket adja vissza a webalkalmazáshoz.</span><span class="sxs-lookup"><span data-stu-id="714d9-104">The API reads data from Cosmos DB and returns the results to the web app.</span></span> <span data-ttu-id="714d9-105">Az architektúra egy referenciaimplementációt érhető el az [GitHub][github].</span><span class="sxs-lookup"><span data-stu-id="714d9-105">A reference implementation for this architecture is available on [GitHub][github].</span></span>

![](./_images/serverless-web-app.png)
 
<span data-ttu-id="714d9-106">A kiszolgáló nélküli kifejezés két különálló, de kapcsolódó jelentéssel rendelkezik:</span><span class="sxs-lookup"><span data-stu-id="714d9-106">The term serverless has two distinct but related meanings:</span></span>

- <span data-ttu-id="714d9-107">**Háttérmodul-szolgáltatás** (BaaS).</span><span class="sxs-lookup"><span data-stu-id="714d9-107">**Backend as a service** (BaaS).</span></span> <span data-ttu-id="714d9-108">Háttérbeli felhőszolgáltatásokat, például adatbázisok és a storage, az API-k, amelyek lehetővé teszik ügyfélalkalmazások számára ezek a szolgáltatások való közvetlen csatlakozáshoz adja meg.</span><span class="sxs-lookup"><span data-stu-id="714d9-108">Backend cloud services, such as databases and storage, provide APIs that enable client applications to connect directly to these services.</span></span> 
- <span data-ttu-id="714d9-109">**A Functions szolgáltatás** (FaaS).</span><span class="sxs-lookup"><span data-stu-id="714d9-109">**Functions as a service** (FaaS).</span></span> <span data-ttu-id="714d9-110">Ebben a modellben egy "függvény" olyan kódot, amely a felhőben üzemel, és fut egy teljesen kivonatolja a kódot futtató kiszolgálók üzemeltetési környezet.</span><span class="sxs-lookup"><span data-stu-id="714d9-110">In this model, a "function" is a piece of code that is deployed to the cloud and runs inside a hosting environment that completely abstracts the servers that run the code.</span></span> 

<span data-ttu-id="714d9-111">Mindkét definíciók rendelkezik közös a ötlete, amellyel a fejlesztők és a fejlesztési és üzemeltetési munkatársai nem szükséges központi telepítése, konfigurálása és -kiszolgálók kezelése.</span><span class="sxs-lookup"><span data-stu-id="714d9-111">Both definitions have in common the idea that developers and DevOps personnel don't need to deploy, configure, or manage servers.</span></span> <span data-ttu-id="714d9-112">Ez a referenciaarchitektúra Azure Functions használatával FaaS összpontosít, bár a webes tartalmat szolgáltató az Azure Blob Storage-ból példaként szolgál a háttérkomponens-szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="714d9-112">This reference architecture focuses on FaaS using Azure Functions, although serving web content from Azure Blob Storage is an example of BaaS.</span></span> <span data-ttu-id="714d9-113">A FaaS néhány fontos jellemzői a következők:</span><span class="sxs-lookup"><span data-stu-id="714d9-113">Some important characteristics of FaaS are:</span></span>

1. <span data-ttu-id="714d9-114">A számítási erőforrások a platform által igényelt dinamikusan kiosztott.</span><span class="sxs-lookup"><span data-stu-id="714d9-114">Compute resources are allocated dynamically as needed by the platform.</span></span>
1. <span data-ttu-id="714d9-115">Díjszabás fogyasztásalapú: csak a kód végrehajtását használt számítási erőforrások díjkötelesek.</span><span class="sxs-lookup"><span data-stu-id="714d9-115">Consumption-based pricing: You are charged only for the compute resources used to execute your code.</span></span>
1. <span data-ttu-id="714d9-116">A számítási erőforrások igény szerint méretezhető alapján a forgalom, anélkül, hogy a fejlesztő bármely konfigurációs tennie kellene.</span><span class="sxs-lookup"><span data-stu-id="714d9-116">The compute resources scale on demand based on traffic, without the developer needing to do any configuration.</span></span>

<span data-ttu-id="714d9-117">Ha külső eseményindító történik, például egy HTTP-kérelem vagy egy üzenetsorba érkező üzeneteket a függvények végrehajtása történik.</span><span class="sxs-lookup"><span data-stu-id="714d9-117">Functions are executed when an external trigger occurs, such as an HTTP request or a message arriving on a queue.</span></span> <span data-ttu-id="714d9-118">Ez lehetővé teszi egy [eseményvezérelt architektúra stílusának] [ event-driven] természetes, kiszolgáló nélküli architektúrák.</span><span class="sxs-lookup"><span data-stu-id="714d9-118">This makes an [event-driven architecture style][event-driven] natural for serverless architectures.</span></span> <span data-ttu-id="714d9-119">Munka az architektúra összetevői közötti koordinációhoz, üzenetközvetítők vagy pub/sub minták használata javasolt.</span><span class="sxs-lookup"><span data-stu-id="714d9-119">To coordinate work between components in the architecture, consider using message brokers or pub/sub patterns.</span></span> <span data-ttu-id="714d9-120">Az Azure-ban üzenetkezelési technológiák közötti választással kapcsolatos útmutatásért lásd: [kézbesíti az üzeneteket az Azure-szolgáltatások közötti választás][azure-messaging].</span><span class="sxs-lookup"><span data-stu-id="714d9-120">For help choosing between messaging technologies in Azure, see [Choose between Azure services that deliver messages][azure-messaging].</span></span>

## <a name="architecture"></a><span data-ttu-id="714d9-121">Architektúra</span><span class="sxs-lookup"><span data-stu-id="714d9-121">Architecture</span></span>
<span data-ttu-id="714d9-122">Az architektúra a következőkben leírt összetevőkből áll.</span><span class="sxs-lookup"><span data-stu-id="714d9-122">The architecture consists of the following components.</span></span>

<span data-ttu-id="714d9-123">**A BLOB Storage-**.</span><span class="sxs-lookup"><span data-stu-id="714d9-123">**Blob Storage**.</span></span> <span data-ttu-id="714d9-124">Statikus tartalmak, például HTML, CSS és JavaScript-fájlok, az Azure Blob Storage tárolása és kiszolgálása ügyfeleknek használatával [statikus webhelyüzemeltetésre][static-hosting].</span><span class="sxs-lookup"><span data-stu-id="714d9-124">Static web content, such as HTML, CSS, and JavaScript files, are stored in Azure Blob Storage and served to clients by using [static website hosting][static-hosting].</span></span> <span data-ttu-id="714d9-125">Az összes dinamikus interakció a háttérrendszeri API-k hívása JavaScript-kód történik.</span><span class="sxs-lookup"><span data-stu-id="714d9-125">All dynamic interaction happens through JavaScript code making calls to the backend APIs.</span></span> <span data-ttu-id="714d9-126">Nincs kiszolgálóoldali kód megjeleníteni a weblapot.</span><span class="sxs-lookup"><span data-stu-id="714d9-126">There is no server-side code to render the web page.</span></span> <span data-ttu-id="714d9-127">Index dokumentumok és egyéni 404-es hibalapok statikus webhelyüzemeltetésre támogatja.</span><span class="sxs-lookup"><span data-stu-id="714d9-127">Static website hosting supports index documents and custom 404 error pages.</span></span>

> [!NOTE]
> <span data-ttu-id="714d9-128">Statikus webhely üzemeltetése jelenleg [előzetes][static-hosting-preview].</span><span class="sxs-lookup"><span data-stu-id="714d9-128">Static website hosting is currently in [preview][static-hosting-preview].</span></span>

<span data-ttu-id="714d9-129">**CDN**.</span><span class="sxs-lookup"><span data-stu-id="714d9-129">**CDN**.</span></span> <span data-ttu-id="714d9-130">Használat [Azure Content Delivery Network] [ cdn] (CDN) a gyorsítótár a kisebb késés és a gyorsabb tartalomkézbesítés a tartalom, valamint biztosító HTTPS-végpontokat.</span><span class="sxs-lookup"><span data-stu-id="714d9-130">Use [Azure Content Delivery Network][cdn] (CDN) to cache content for lower latency and faster delivery of content, as well as providing an HTTPS endpoint.</span></span>

<span data-ttu-id="714d9-131">**Function Apps**.</span><span class="sxs-lookup"><span data-stu-id="714d9-131">**Function Apps**.</span></span> <span data-ttu-id="714d9-132">[Az Azure Functions] [ functions] kiszolgáló nélküli számítási megoldás.</span><span class="sxs-lookup"><span data-stu-id="714d9-132">[Azure Functions][functions] is a serverless compute option.</span></span> <span data-ttu-id="714d9-133">Az eseményvezérelt modellt használ, ahol a kódrészleteket (a "function") egy eseményindító hív.</span><span class="sxs-lookup"><span data-stu-id="714d9-133">It uses an event-driven model, where a piece of code (a "function") is invoked by a trigger.</span></span> <span data-ttu-id="714d9-134">Ebben az architektúrában a függvény akkor aktiválódnak, ha egy ügyfél HTTP-kérést küld.</span><span class="sxs-lookup"><span data-stu-id="714d9-134">In this architecture, the function is invoked when a client makes an HTTP request.</span></span> <span data-ttu-id="714d9-135">A kérelem API-átjáró, az alábbiakban mindig továbbít.</span><span class="sxs-lookup"><span data-stu-id="714d9-135">The request is always routed through an API gateway, described below.</span></span>

<span data-ttu-id="714d9-136">**Az API Management**.</span><span class="sxs-lookup"><span data-stu-id="714d9-136">**API Management**.</span></span> <span data-ttu-id="714d9-137">[Az API Management] [ apim] helyezkedik el a HTTP-függvényt egy API-átjárót nyújt.</span><span class="sxs-lookup"><span data-stu-id="714d9-137">[API Management][apim] provides a API gateway that sits in front of the HTTP function.</span></span> <span data-ttu-id="714d9-138">Az API Management segítségével közzétehet és kezelhet az ügyfélalkalmazások által használt API-k.</span><span class="sxs-lookup"><span data-stu-id="714d9-138">You can use API Management to publish and manage APIs used by client applications.</span></span> <span data-ttu-id="714d9-139">Egy átjáró használatával segít leválasztja az előtér-alkalmazást a háttérrendszeri API-kon keresztül.</span><span class="sxs-lookup"><span data-stu-id="714d9-139">Using a gateway helps to decouple the front-end application from the back-end APIs.</span></span> <span data-ttu-id="714d9-140">Például az API Management újraírási URL-címek, kérelmek átalakítása, mielőtt elérnék a háttér, kérelem vagy válasz fejlécek beállítása és így tovább.</span><span class="sxs-lookup"><span data-stu-id="714d9-140">For example, API Management can rewrite URLs, transform requests before they reach the backend, set request or response headers, and so forth.</span></span>

<span data-ttu-id="714d9-141">Az API Management is használható például általános megfontolások megvalósításához:</span><span class="sxs-lookup"><span data-stu-id="714d9-141">API Management can also be used to implement cross-cutting concerns such as:</span></span>

- <span data-ttu-id="714d9-142">Korlátozza a használati kvótákat és a sebesség kényszerítése</span><span class="sxs-lookup"><span data-stu-id="714d9-142">Enforcing usage quotas and rate limits</span></span>
- <span data-ttu-id="714d9-143">Az OAuth-jogkivonatok hitelesítés ellenőrzése</span><span class="sxs-lookup"><span data-stu-id="714d9-143">Validating OAuth tokens for authentication</span></span>
- <span data-ttu-id="714d9-144">Eltérő eredetű kérelmek (CORS) engedélyezése</span><span class="sxs-lookup"><span data-stu-id="714d9-144">Enabling cross-origin requests (CORS)</span></span>
- <span data-ttu-id="714d9-145">Válaszok gyorsítótárazásának</span><span class="sxs-lookup"><span data-stu-id="714d9-145">Caching responses</span></span>
- <span data-ttu-id="714d9-146">Monitorozási és naplózási kéréseket</span><span class="sxs-lookup"><span data-stu-id="714d9-146">Monitoring and logging requests</span></span>  

<span data-ttu-id="714d9-147">Ha már nincs szüksége az összes az API Management által biztosított funkciókat, egy másik lehetőség, hogy használja [Functions-proxyk][functions-proxy].</span><span class="sxs-lookup"><span data-stu-id="714d9-147">If you don't need all of the functionality provided by API Management, another option is to use [Functions Proxies][functions-proxy].</span></span> <span data-ttu-id="714d9-148">Ez a funkció az Azure Functions lehetővé teszi, hogy egyetlen API-felületet több függvényalkalmazásra háttér-funkciók útvonalak létrehozásával meghatározhatja.</span><span class="sxs-lookup"><span data-stu-id="714d9-148">This feature of Azure Functions lets you define a single API surface for multiple function apps, by creating routes to back-end functions.</span></span> <span data-ttu-id="714d9-149">Függvényproxykat korlátozott átalakításokat is elvégezheti a HTTP-kérés és válasz.</span><span class="sxs-lookup"><span data-stu-id="714d9-149">Function proxies can also perform limited transformations on the HTTP request and response.</span></span> <span data-ttu-id="714d9-150">Azonban nem biztosítanak azonos gazdag csoportházirend-alapú képességeit az API Management.</span><span class="sxs-lookup"><span data-stu-id="714d9-150">However, they don't provide the same rich policy-based capabilities of API Management.</span></span>

<span data-ttu-id="714d9-151">**A cosmos DB**.</span><span class="sxs-lookup"><span data-stu-id="714d9-151">**Cosmos DB**.</span></span> <span data-ttu-id="714d9-152">[A cosmos DB] [ cosmosdb] többmodelles adatbázis-szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="714d9-152">[Cosmos DB][cosmosdb] is a multi-model database  service.</span></span> <span data-ttu-id="714d9-153">A jelen esetben a függvény alkalmazás olvas be dokumentumok Cosmos DB az ügyfél HTTP GET kérések válaszul.</span><span class="sxs-lookup"><span data-stu-id="714d9-153">For this scenario, the function application fetches documents from Cosmos DB in response to HTTP GET requests from the client.</span></span>

<span data-ttu-id="714d9-154">**Azure Active Directory** (Azure AD).</span><span class="sxs-lookup"><span data-stu-id="714d9-154">**Azure Active Directory** (Azure AD).</span></span> <span data-ttu-id="714d9-155">Felhasználók jelentkezzen be a webalkalmazás az Azure AD hitelesítő adatait.</span><span class="sxs-lookup"><span data-stu-id="714d9-155">Users sign into the web application by using their Azure AD credentials.</span></span> <span data-ttu-id="714d9-156">Az Azure AD hozzáférési jogkivonatot az API-hoz, a webes alkalmazás használó API-kérések hitelesítéséhez adja vissza. (lásd: [hitelesítési](#authentication)).</span><span class="sxs-lookup"><span data-stu-id="714d9-156">Azure AD returns an access token for the API, which the web application uses to authenticate API requests (see [Authentication](#authentication)).</span></span>

<span data-ttu-id="714d9-157">**Az Azure Monitor**.</span><span class="sxs-lookup"><span data-stu-id="714d9-157">**Azure Monitor**.</span></span> <span data-ttu-id="714d9-158">[A figyelő] [ monitor] teljesítmény-mérőszámokat a megoldásban üzembe helyezett Azure-szolgáltatásokkal gyűjti.</span><span class="sxs-lookup"><span data-stu-id="714d9-158">[Monitor][monitor] collects performance metrics about the Azure services deployed in the solution.</span></span> <span data-ttu-id="714d9-159">Ezek az irányítópult vizualizációjával képet is kaphat a megoldás állapotát.</span><span class="sxs-lookup"><span data-stu-id="714d9-159">By visualizing these in a dashboard, you can get visibility into the health of the solution.</span></span> <span data-ttu-id="714d9-160">Azt is gyűjti az alkalmazásnaplókat.</span><span class="sxs-lookup"><span data-stu-id="714d9-160">It also collected application logs.</span></span>

<span data-ttu-id="714d9-161">**Az Azure folyamatok**.</span><span class="sxs-lookup"><span data-stu-id="714d9-161">**Azure Pipelines**.</span></span> <span data-ttu-id="714d9-162">[A folyamatok] [ pipelines] van egy folyamatos integrációs (CI) és a folyamatos továbbítás (CD) a buildek esetében teszteket, szolgáltatást, és központilag telepíti az alkalmazást.</span><span class="sxs-lookup"><span data-stu-id="714d9-162">[Pipelines][pipelines] is a continuous integration (CI) and continuous delivery (CD) service that builds, tests, and deploys the application.</span></span>

## <a name="recommendations"></a><span data-ttu-id="714d9-163">Javaslatok</span><span class="sxs-lookup"><span data-stu-id="714d9-163">Recommendations</span></span>

### <a name="function-app-plans"></a><span data-ttu-id="714d9-164">Függvényalkalmazás-csomagok</span><span class="sxs-lookup"><span data-stu-id="714d9-164">Function App plans</span></span>

<span data-ttu-id="714d9-165">Az Azure Functions támogatja a két üzemeltetési modell.</span><span class="sxs-lookup"><span data-stu-id="714d9-165">Azure Functions supports two hosting models.</span></span> <span data-ttu-id="714d9-166">Az a **használatalapú csomag**, számítási teljesítmény lefoglalása automatikusan történik meg, amikor a kódja fut.</span><span class="sxs-lookup"><span data-stu-id="714d9-166">With the **consumption plan**, compute power is automatically allocated when your code is running.</span></span>  <span data-ttu-id="714d9-167">Az a **App Service-ben** csomag, a virtuális gépek lefoglalásának a kódot.</span><span class="sxs-lookup"><span data-stu-id="714d9-167">With the **App Service** plan, a set of VMs are allocated for your code.</span></span> <span data-ttu-id="714d9-168">Az App Service-csomag határozza meg, hogy a virtuális gépek számát és a Virtuálisgép-méretet.</span><span class="sxs-lookup"><span data-stu-id="714d9-168">The App Service plan defines the number of VMs and the VM size.</span></span> 

<span data-ttu-id="714d9-169">Vegye figyelembe, hogy az App Service-csomag nem feltétlenül *kiszolgáló nélküli*, a fent megadott definíció szerint.</span><span class="sxs-lookup"><span data-stu-id="714d9-169">Note that the App Service plan is not strictly *serverless*, according to the definition given above.</span></span> <span data-ttu-id="714d9-170">A programozási modell megegyezik, azonban &mdash; függvény ugyanazt a kódot futtathatja a használatalapú és App Service-csomag.</span><span class="sxs-lookup"><span data-stu-id="714d9-170">The programming model is the same, however &mdash; the same function code can run in both a consumption plan and an App Service plan.</span></span>

<span data-ttu-id="714d9-171">Íme néhány tényező, hogy milyen típusú a csomag használatára kiválasztásakor vegye figyelembe:</span><span class="sxs-lookup"><span data-stu-id="714d9-171">Here are some factors to consider when choosing which type of plan to use:</span></span>

- <span data-ttu-id="714d9-172">**Hidegindítási**.</span><span class="sxs-lookup"><span data-stu-id="714d9-172">**Cold start**.</span></span> <span data-ttu-id="714d9-173">A használatalapú csomagok esetében a függvény, amely még nem lett meghívva nemrég számítunk fel némi késést a következő futásakor.</span><span class="sxs-lookup"><span data-stu-id="714d9-173">With the consumption plan, a function that hasn't been invoked recently will incur some additional latency the next time it runs.</span></span> <span data-ttu-id="714d9-174">Erre a további késésre felosztására, és a futásidejű környezet előkészítése okozza.</span><span class="sxs-lookup"><span data-stu-id="714d9-174">This additional latency is due to allocating and preparing the runtime environment.</span></span> <span data-ttu-id="714d9-175">A szolgáltatás általában sorrendjéről másodperc, de számos tényezőtől függ, többek között a tartalomfüggőségeket, ezt be kell.</span><span class="sxs-lookup"><span data-stu-id="714d9-175">It is usually on the order of seconds but depends on several factors, including the number of dependencies that need to be loaded.</span></span> <span data-ttu-id="714d9-176">További információkért lásd: [ismertetése kiszolgáló nélküli hideg Start][functions-cold-start].</span><span class="sxs-lookup"><span data-stu-id="714d9-176">For more information, see [Understanding Serverless Cold Start][functions-cold-start].</span></span> <span data-ttu-id="714d9-177">Hidegindítási oka az, általában több, interaktív számítási feladatai (HTTP-eseményindítók) szempont aszinkron üzenet-alapú számítási feladatokhoz (üzenetsor vagy az event hubs eseményindítók), mint a további késleltetés a felhasználók közvetlenül figyelhető meg.</span><span class="sxs-lookup"><span data-stu-id="714d9-177">Cold start is usually more of a concern for interactive workloads (HTTP triggers) than asynchronous message-driven workloads (queue or event hubs triggers), because the additional latency is directly observed by users.</span></span>
- <span data-ttu-id="714d9-178">**Időkorlát**.</span><span class="sxs-lookup"><span data-stu-id="714d9-178">**Timeout period**.</span></span>  <span data-ttu-id="714d9-179">A használatalapú csomagban után időtúllépés egy függvény végrehajtását egy [konfigurálható] [ functions-timeout] , (és a egy legfeljebb 10 perces) időszak</span><span class="sxs-lookup"><span data-stu-id="714d9-179">In the consumption plan, a function execution times out after a [configurable][functions-timeout] period of time (to a maximum of 10 minutes)</span></span>
- <span data-ttu-id="714d9-180">**Virtuális hálózat elkülönítési**.</span><span class="sxs-lookup"><span data-stu-id="714d9-180">**Virtual network isolation**.</span></span> <span data-ttu-id="714d9-181">App Service-csomag használatával lehetővé teszi, hogy a függvények futását található egy [App Service Environment-környezet][ase], azaz egy dedikált és elkülönített üzemeltetési környezet.</span><span class="sxs-lookup"><span data-stu-id="714d9-181">Using an App Service plan allows functions to run inside of an [App Service Environment][ase], which is a dedicated and isolated hosting environment.</span></span>
- <span data-ttu-id="714d9-182">**Díjszabási modell**.</span><span class="sxs-lookup"><span data-stu-id="714d9-182">**Pricing model**.</span></span> <span data-ttu-id="714d9-183">A használatalapú csomag a végrehajtások száma és erőforrás-használat alapján történik (memória &times; végrehajtási idő).</span><span class="sxs-lookup"><span data-stu-id="714d9-183">The consumption plan is billed by the number of executions and resource consumption (memory &times; execution time).</span></span> <span data-ttu-id="714d9-184">Az App Service-csomag Virtuálisgép-példány Termékváltozat óraszám alapján számítjuk fel.</span><span class="sxs-lookup"><span data-stu-id="714d9-184">The App Service plan is billed hourly based on VM instance SKU.</span></span> <span data-ttu-id="714d9-185">Gyakran előfordul a használatalapú csomag lehet olcsóbb, mint az App Service-csomag, mert csak kell fizetnie a számítási erőforrásokat, amelyekkel.</span><span class="sxs-lookup"><span data-stu-id="714d9-185">Often, the consumption plan can be cheaper than an App Service plan, because you pay only for the compute resources that you use.</span></span> <span data-ttu-id="714d9-186">Ez különösen igaz, ha a forgalom csúcsok és csatornák.</span><span class="sxs-lookup"><span data-stu-id="714d9-186">This is especially true if your traffic experiences peaks and troughs.</span></span> <span data-ttu-id="714d9-187">Azonban ha egy alkalmazás állandó nagy átviteli sebességet, az App Service-csomag Előfordulhat, hogy kevesebb költséggel jár, mint a használatalapú csomag.</span><span class="sxs-lookup"><span data-stu-id="714d9-187">However, if an application experiences constant high-volume throughput, an App Service plan may cost less than the consumption plan.</span></span>
- <span data-ttu-id="714d9-188">**Skálázás**.</span><span class="sxs-lookup"><span data-stu-id="714d9-188">**Scaling**.</span></span> <span data-ttu-id="714d9-189">Egy a használatalapú modell nagy előnye az, hogy méretezés dinamikusan igény alapján a bejövő forgalmat.</span><span class="sxs-lookup"><span data-stu-id="714d9-189">A big advantage of the consumption model is that it scales dynamically as needed, based on the incoming traffic.</span></span> <span data-ttu-id="714d9-190">Bár a skálázás gyorsan történik, akkor van még mindig készüljön fel.</span><span class="sxs-lookup"><span data-stu-id="714d9-190">While this scaling occurs quickly, there is still a ramp-up period.</span></span> <span data-ttu-id="714d9-191">Bizonyos számítási feladatokhoz érdemes szándékosan overprovision a virtuális gépeket, hogy a szolgáltatás a forgalom a nulla készüljön fel időt kezelheti.</span><span class="sxs-lookup"><span data-stu-id="714d9-191">For some workloads, you might want to deliberately overprovision the VMs, so that you can handle bursts of traffic with zero ramp-up time.</span></span> <span data-ttu-id="714d9-192">Ebben az esetben fontolja meg az App Service-csomag.</span><span class="sxs-lookup"><span data-stu-id="714d9-192">In that case, consider an App Service plan.</span></span>

### <a name="function-app-boundaries"></a><span data-ttu-id="714d9-193">Függvény alkalmazás határok</span><span class="sxs-lookup"><span data-stu-id="714d9-193">Function App boundaries</span></span>

<span data-ttu-id="714d9-194">A *függvényalkalmazás* végrehajtásához egy vagy több szükséges gazdaszolgáltatást *funkciók*.</span><span class="sxs-lookup"><span data-stu-id="714d9-194">A *function app* hosts the execution of one or more *functions*.</span></span> <span data-ttu-id="714d9-195">Függvényalkalmazás segítségével számos funkciót csoportosíthat egy logikai egységként.</span><span class="sxs-lookup"><span data-stu-id="714d9-195">You can use a function app to group several functions together as a logical unit.</span></span> <span data-ttu-id="714d9-196">A functions belül egy függvényalkalmazást, ossza meg az ugyanazon alkalmazás beállításait, futtatási csomagot, és a központi telepítés életciklusa.</span><span class="sxs-lookup"><span data-stu-id="714d9-196">Within a function app, the functions share the same application settings, hosting plan, and deployment lifecycle.</span></span> <span data-ttu-id="714d9-197">Minden függvény alkalmazás rendelkezik a saját állomásnevet.</span><span class="sxs-lookup"><span data-stu-id="714d9-197">Each function app has its own hostname.</span></span>  

<span data-ttu-id="714d9-198">Függvényalkalmazások csoport funkciók, amelyek életciklusa és beállításokat használja.</span><span class="sxs-lookup"><span data-stu-id="714d9-198">Use function apps to group functions that share the same lifecycle and settings.</span></span> <span data-ttu-id="714d9-199">Másik függvényalkalmazás a függvények, amelyek nem azonos életciklussal üzemeltetve lesz.</span><span class="sxs-lookup"><span data-stu-id="714d9-199">Functions that don't share the same lifecycle should be hosted in different function apps.</span></span> 

<span data-ttu-id="714d9-200">Fontolja meg a mikroszolgáltatási megközelítést, ahol a minden függvényalkalmazáshoz egy mikroszolgáltatásban valószínűleg álló számos kapcsolódó funkciókat jelenti.</span><span class="sxs-lookup"><span data-stu-id="714d9-200">Consider taking a microservices approach, where each function app represents one microservice, possibly consisting of several related functions.</span></span> <span data-ttu-id="714d9-201">A mikroszolgáltatási architektúrában a szolgáltatások laza összekapcsolással és magas működési kohézióval kell rendelkeznie.</span><span class="sxs-lookup"><span data-stu-id="714d9-201">In a microservices architecture, services should have loose coupling and high functional cohesion.</span></span> <span data-ttu-id="714d9-202">*Lazán* összefüggő azt jelenti, hogy egy szolgáltatás anélkül, hogy más szolgáltatások egyszerre frissítendő módosíthatja.</span><span class="sxs-lookup"><span data-stu-id="714d9-202">*Loosely* coupled means you can change one service without requiring other services to be updated at the same time.</span></span> <span data-ttu-id="714d9-203">*Javul* jelenti, hogy egy szolgáltatás egyetlen, jól definiált céllal rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="714d9-203">*Cohesive* means a service has a single, well-defined purpose.</span></span> <span data-ttu-id="714d9-204">Ezek ötleteket további ismertetéséhez lásd: [mikroszolgáltatások tervezése: tartományelemzés][microservices-domain-analysis].</span><span class="sxs-lookup"><span data-stu-id="714d9-204">For more discussion of these ideas, see [Designing microservices: Domain analysis][microservices-domain-analysis].</span></span>

### <a name="function-bindings"></a><span data-ttu-id="714d9-205">Függvény-kötések</span><span class="sxs-lookup"><span data-stu-id="714d9-205">Function bindings</span></span>

<span data-ttu-id="714d9-206">Függvények [kötések] [ functions-bindings] amikor csak lehetséges.</span><span class="sxs-lookup"><span data-stu-id="714d9-206">Use Functions [bindings][functions-bindings] when possible.</span></span> <span data-ttu-id="714d9-207">Kötések kódját csatlakozhat az adatokhoz és más Azure-szolgáltatásokkal integrálható deklaratív módszert biztosítanak.</span><span class="sxs-lookup"><span data-stu-id="714d9-207">Bindings provide a declarative way to connect your code to data and integrate with other Azure services.</span></span> <span data-ttu-id="714d9-208">Bemeneti kötés tölti fel a bemeneti paraméter egy külső adatforrásból.</span><span class="sxs-lookup"><span data-stu-id="714d9-208">An input binding populates an input parameter from an external data source.</span></span> <span data-ttu-id="714d9-209">Kimeneti kötés elküldi a függvény visszaadott értékének fogadására, például egy adatbázis vagy üzenetsor.</span><span class="sxs-lookup"><span data-stu-id="714d9-209">An output binding sends the function's return value to a data sink, such as a queue or database.</span></span>

<span data-ttu-id="714d9-210">Ha például a `GetStatus` függvény a referenciaimplementációt a használja a Cosmos DB [bemeneti kötést][cosmosdb-input-binding].</span><span class="sxs-lookup"><span data-stu-id="714d9-210">For example, the `GetStatus` function in the reference implementation uses the Cosmos DB [input binding][cosmosdb-input-binding].</span></span> <span data-ttu-id="714d9-211">Ez a kötés kereshet meg egy dokumentumot a Cosmos DB lekérdezési paraméterek, amelyeket a rendszer a HTTP-kérelem lekérdezési karakterlánc használatával van konfigurálva.</span><span class="sxs-lookup"><span data-stu-id="714d9-211">This binding is configured to look up a document in Cosmos DB, using query parameters that are taken from the query string in the HTTP request.</span></span> <span data-ttu-id="714d9-212">Ha a dokumentum megtalálható, átadva a függvénynek paraméterként.</span><span class="sxs-lookup"><span data-stu-id="714d9-212">If the document is found, it is passed to the function as a parameter.</span></span>

```csharp
[FunctionName("GetStatusFunction")]
public static Task<IActionResult> Run(
    [HttpTrigger(AuthorizationLevel.Function, "get", Route = null)] HttpRequest req, 
    [CosmosDB(
        databaseName: "%COSMOSDB_DATABASE_NAME%",
        collectionName: "%COSMOSDB_DATABASE_COL%",
        ConnectionStringSetting = "COSMOSDB_CONNECTION_STRING",
        Id = "{Query.deviceId}",
        PartitionKey = "{Query.deviceId}")] dynamic deviceStatus, 
    ILogger log)
{
    ...
}
```

<span data-ttu-id="714d9-213">Kötések használata esetén nem kell közvetlenül a szolgáltatást, amely egyszerűbbé teszi a függvénykódot és az az adatforrás vagy a fogadó adatait is kivonatolja műsorgazdája kód írására.</span><span class="sxs-lookup"><span data-stu-id="714d9-213">By using bindings, you don't need to write code that talks directly to the service, which makes the function code simpler and also abstracts the details of the data source or sink.</span></span> <span data-ttu-id="714d9-214">Bizonyos esetekben azonban szükség lehet a kötés biztosít összetettségű logikát.</span><span class="sxs-lookup"><span data-stu-id="714d9-214">In some cases, however, you may need more complex logic than the binding provides.</span></span> <span data-ttu-id="714d9-215">Ebben az esetben használja közvetlenül az Azure-ügyfél SDK-k.</span><span class="sxs-lookup"><span data-stu-id="714d9-215">In that case, use the Azure client SDKs directly.</span></span>

## <a name="scalability-considerations"></a><span data-ttu-id="714d9-216">Méretezési szempontok</span><span class="sxs-lookup"><span data-stu-id="714d9-216">Scalability considerations</span></span>

<span data-ttu-id="714d9-217">**Függvények**.</span><span class="sxs-lookup"><span data-stu-id="714d9-217">**Functions**.</span></span> <span data-ttu-id="714d9-218">A használatalapú csomag esetében a HTTP-eseményindítóval skálázható alapján, a forgalmat.</span><span class="sxs-lookup"><span data-stu-id="714d9-218">For the consumption plan, the HTTP trigger scales based on the traffic.</span></span> <span data-ttu-id="714d9-219">Az egyidejű függvény példányok száma korlátozva van, de minden példány egyszerre egynél több kérést is feldolgozni.</span><span class="sxs-lookup"><span data-stu-id="714d9-219">There is a limit to the number of concurrent function instances, but each instance can process more than one request at a time.</span></span> <span data-ttu-id="714d9-220">Az App Service-csomag a HTTP-eseményindítóval méretezi a Virtuálisgép-példányok, rögzített érték vagy teljesítményigényektől függ az automatikus skálázási szabályok száma szerint.</span><span class="sxs-lookup"><span data-stu-id="714d9-220">For an App Service plan, the HTTP trigger scales according to the number of VM instances, which can be a fixed value or can autoscale based on a set of autoscaling rules.</span></span> <span data-ttu-id="714d9-221">További információ: [Azure Functions méretezése és üzemeltetése][functions-scale].</span><span class="sxs-lookup"><span data-stu-id="714d9-221">For information, see [Azure Functions scale and hosting][functions-scale].</span></span> 

<span data-ttu-id="714d9-222">**A cosmos DB**.</span><span class="sxs-lookup"><span data-stu-id="714d9-222">**Cosmos DB**.</span></span> <span data-ttu-id="714d9-223">A Cosmos DB átviteli kapacitás mérése [kérelemegység] [ ru] (RU).</span><span class="sxs-lookup"><span data-stu-id="714d9-223">Throughput capacity for Cosmos DB is measured in [Request Units][ru] (RU).</span></span> <span data-ttu-id="714d9-224">Egy 1 – RU átviteli sebesség egy 1 KB méretű dokumentum beolvasásához szükséges átviteli felel meg.</span><span class="sxs-lookup"><span data-stu-id="714d9-224">A 1-RU throughput corresponds to the throughput need to GET a 1KB document.</span></span> <span data-ttu-id="714d9-225">Annak érdekében, hogy az elmúlt 10 000-et egy Cosmos DB-tárolók skálázása RU, meg kell adnia egy [partíciókulcs] [ partition-key] amikor hozza létre a tárolót, és a partíciókulcs tartalmazza minden egyes dokumentum létrehozott.</span><span class="sxs-lookup"><span data-stu-id="714d9-225">In order to scale a Cosmos DB container past 10,000 RU, you must specify a [partition key][partition-key] when you create the container and include the partition key in every document that you create.</span></span> <span data-ttu-id="714d9-226">Partíciókulcsok kapcsolatos további információkért lásd: [particionálási és horizontális az Azure Cosmos DB][cosmosdb-scale].</span><span class="sxs-lookup"><span data-stu-id="714d9-226">For more information about partition keys, see [Partition and scale in Azure Cosmos DB][cosmosdb-scale].</span></span>

<span data-ttu-id="714d9-227">**Az API Management**.</span><span class="sxs-lookup"><span data-stu-id="714d9-227">**API Management**.</span></span> <span data-ttu-id="714d9-228">Az API Management horizontálisan, és támogatja a szabályalapú automatikus skálázást.</span><span class="sxs-lookup"><span data-stu-id="714d9-228">API Management can scale out and supports rule-based autoscaling.</span></span> <span data-ttu-id="714d9-229">Vegye figyelembe, hogy a méretezési tart legalább 20 perc.</span><span class="sxs-lookup"><span data-stu-id="714d9-229">Note that the scaling process takes at least 20 minutes.</span></span> <span data-ttu-id="714d9-230">Ha a forgalom beül, a várt maximális burst forgalom kell kiépítenie.</span><span class="sxs-lookup"><span data-stu-id="714d9-230">If your traffic is bursty, you should provision for the maximum burst traffic that you expect.</span></span> <span data-ttu-id="714d9-231">Az automatikus skálázás azonban hasznos óránkénti vagy napi változata, a forgalom kezelésére.</span><span class="sxs-lookup"><span data-stu-id="714d9-231">However, autoscaling is useful for handling hourly or daily variations in traffic.</span></span> <span data-ttu-id="714d9-232">További információkért lásd: [automatikus skálázása az Azure API Management-példány][apim-scale].</span><span class="sxs-lookup"><span data-stu-id="714d9-232">For more information, see [Automatically scale an Azure API Management instance][apim-scale].</span></span>

## <a name="disaster-recovery-considerations"></a><span data-ttu-id="714d9-233">Vészhelyreállítási szempontok</span><span class="sxs-lookup"><span data-stu-id="714d9-233">Disaster recovery considerations</span></span>

<span data-ttu-id="714d9-234">Az üzembe helyezés itt látható egy adott Azure-régióban található.</span><span class="sxs-lookup"><span data-stu-id="714d9-234">The deployment shown here resides in a single Azure region.</span></span> <span data-ttu-id="714d9-235">A vész-helyreállítási rugalmasabb módszer, a földrajzi elosztás funkcióinak kihasználása a különböző szolgáltatások:</span><span class="sxs-lookup"><span data-stu-id="714d9-235">For a more resilient approach to disaster-recovery, take advantage of the geo-distribution features in the various services:</span></span>

- <span data-ttu-id="714d9-236">Az API Management támogatja a több régióból álló üzemelő, amely tetszőleges számú Azure-régiók között oszthatja el a egyetlen API Management-példány is használható.</span><span class="sxs-lookup"><span data-stu-id="714d9-236">API Management supports multi-region deployment, which can be used to distribute a single API Management instance across any number of Azure regions.</span></span> <span data-ttu-id="714d9-237">További információkért lásd: [egy Azure API Management-szolgáltatáspéldány üzembe helyezése több Azure-régióban][api-geo].</span><span class="sxs-lookup"><span data-stu-id="714d9-237">For more information, see [How to deploy an Azure API Management service instance to multiple Azure regions][api-geo].</span></span>

- <span data-ttu-id="714d9-238">Használat [Traffic Manager] [ tm] HTTP kérelmeket az elsődleges régióba.</span><span class="sxs-lookup"><span data-stu-id="714d9-238">Use [Traffic Manager][tm] to route HTTP requests to the primary region.</span></span> <span data-ttu-id="714d9-239">Ha az adott régióban futó a Függvényalkalmazás nem érhető el, a Traffic Manager feladatátvételt végezhet egy másodlagos régióba.</span><span class="sxs-lookup"><span data-stu-id="714d9-239">If the Function App running in that region becomes unavailable, Traffic Manager can fail over to a secondary region.</span></span>

- <span data-ttu-id="714d9-240">A cosmos DB támogatja a [több fő régióban][cosmosdb-geo], amely lehetővé teszi, hogy minden olyan régióban, adja hozzá a Cosmos DB-fiókot az írási műveletek.</span><span class="sxs-lookup"><span data-stu-id="714d9-240">Cosmos DB supports [multiple master regions][cosmosdb-geo], which enables writes to any region that you add to your Cosmos DB account.</span></span> <span data-ttu-id="714d9-241">Ha nem engedélyezi több főkiszolgálós, továbbra is adhatók át az elsődleges írási régió.</span><span class="sxs-lookup"><span data-stu-id="714d9-241">If you don't enable multi-master, you can still fail over the primary write region.</span></span> <span data-ttu-id="714d9-242">A Cosmos DB ügyféloldali SDK-kkal és az Azure-függvény kötések automatikusan kezeli a feladatátvételt, így nem kell minden olyan alkalmazás konfigurációs beállításainak frissítése.</span><span class="sxs-lookup"><span data-stu-id="714d9-242">The Cosmos DB client SDKs and the Azure Function bindings automatically handle the failover, so you don't need to update any application configuration settings.</span></span>

## <a name="security-considerations"></a><span data-ttu-id="714d9-243">Biztonsági szempontok</span><span class="sxs-lookup"><span data-stu-id="714d9-243">Security considerations</span></span>

### <a name="authentication"></a><span data-ttu-id="714d9-244">Hitelesítés</span><span class="sxs-lookup"><span data-stu-id="714d9-244">Authentication</span></span>

<span data-ttu-id="714d9-245">A `GetStatus` API-referencia megvalósítása az Azure AD-kérések hitelesítéséhez.</span><span class="sxs-lookup"><span data-stu-id="714d9-245">The `GetStatus` API in the reference implementation uses Azure AD to authenticate requests.</span></span> <span data-ttu-id="714d9-246">Az Azure AD támogatja az Open ID Connect protokollal, ami egy olyan hitelesítési protokoll az OAuth 2 protokoll épülnek.</span><span class="sxs-lookup"><span data-stu-id="714d9-246">Azure AD supports the Open ID Connect protocol, which is an authentication protocol built on top of the OAuth 2 protocol.</span></span>

<span data-ttu-id="714d9-247">Ebben az architektúrában az ügyfélalkalmazás egy egyoldalas alkalmazás (SPA), amely futtatja a böngészőben.</span><span class="sxs-lookup"><span data-stu-id="714d9-247">In this architecture, the client application is a single-page application (SPA) that runs in the browser.</span></span> <span data-ttu-id="714d9-248">Így az implicit engedélyezési folyamat megfelelő ügyfélalkalmazás az ilyen típusú ügyfélkódot vagy az engedélyezési kódot, rejtett, nem vezetnek.</span><span class="sxs-lookup"><span data-stu-id="714d9-248">This type of client application cannot keep a client secret or an authorization code hidden, so the implicit grant flow is appropriate.</span></span> <span data-ttu-id="714d9-249">(Lásd: [melyik OAuth 2.0-s folyamat használjam?] [oauth-flow]).</span><span class="sxs-lookup"><span data-stu-id="714d9-249">(See [Which OAuth 2.0 flow should I use?][oauth-flow]).</span></span> <span data-ttu-id="714d9-250">Itt látható a teljes folyamat:</span><span class="sxs-lookup"><span data-stu-id="714d9-250">Here's the overall flow:</span></span>

1. <span data-ttu-id="714d9-251">A felhasználó a "Bejelentkezés" hivatkozásra a webalkalmazás kattint.</span><span class="sxs-lookup"><span data-stu-id="714d9-251">The user clicks the "Sign in" link in the web application.</span></span>
1. <span data-ttu-id="714d9-252">A böngészőben a rendszer átirányítja az Azure AD bejelentkezési oldal.</span><span class="sxs-lookup"><span data-stu-id="714d9-252">The browser is redirected the Azure AD sign in page.</span></span> 
1. <span data-ttu-id="714d9-253">A felhasználó bejelentkezik.</span><span class="sxs-lookup"><span data-stu-id="714d9-253">The user signs in.</span></span>
1. <span data-ttu-id="714d9-254">Az Azure AD vissza az ügyfélalkalmazás, beleértve a hozzáférési jogkivonatot az URL-cím töredék irányítja át.</span><span class="sxs-lookup"><span data-stu-id="714d9-254">Azure AD redirects back to the client application, including an access token in the URL fragment.</span></span>
1. <span data-ttu-id="714d9-255">A webalkalmazás az API-t hív meg, ha a hozzáférési jogkivonat szerepel a hitelesítési fejlécet.</span><span class="sxs-lookup"><span data-stu-id="714d9-255">When the web application calls the API, it includes the access token in the Authentication header.</span></span> <span data-ttu-id="714d9-256">Az Alkalmazásazonosítót, a hozzáférési jogkivonatot a jogcím a célközönség (aud) zajlik.</span><span class="sxs-lookup"><span data-stu-id="714d9-256">The application ID is sent as the audience ('aud') claim in the access token.</span></span> 
1. <span data-ttu-id="714d9-257">A háttérrendszeri API érvényesíti a hozzáférési jogkivonatot.</span><span class="sxs-lookup"><span data-stu-id="714d9-257">The backend API validates the access token.</span></span>

<span data-ttu-id="714d9-258">Hitelesítés konfigurálása:</span><span class="sxs-lookup"><span data-stu-id="714d9-258">To configure authentication:</span></span>

- <span data-ttu-id="714d9-259">Alkalmazás regisztrálása az Azure AD-bérlőben.</span><span class="sxs-lookup"><span data-stu-id="714d9-259">Register an application in your Azure AD tenant.</span></span> <span data-ttu-id="714d9-260">Ez létrehoz egy Alkalmazásazonosítót, amely az ügyfél tartalmazza a bejelentkezési URL-címmel.</span><span class="sxs-lookup"><span data-stu-id="714d9-260">This generates an application ID, which the client includes with the login URL.</span></span>

- <span data-ttu-id="714d9-261">A függvény alkalmazás Azure AD-hitelesítés engedélyezéséhez.</span><span class="sxs-lookup"><span data-stu-id="714d9-261">Enable Azure AD authentication inside the Function App.</span></span> <span data-ttu-id="714d9-262">További információkért lásd: [hitelesítése és engedélyezése Azure App Service-ben][app-service-auth].</span><span class="sxs-lookup"><span data-stu-id="714d9-262">For more information, see [Authentication and authorization in Azure App Service][app-service-auth].</span></span>

- <span data-ttu-id="714d9-263">Szabályzat hozzáadása és az API Management az előzetes engedélyezéshez érvényesítésével azonosítsa a hozzáférési jogkivonat a kérelem:</span><span class="sxs-lookup"><span data-stu-id="714d9-263">Add a policy to API Management to pre-authorize the request by validating the access token:</span></span>

    ```xml
    <validate-jwt header-name="Authorization" failed-validation-httpcode="401" failed-validation-error-message="Unauthorized. Access token is missing or invalid.">
        <openid-config url="https://login.microsoftonline.com/[Azure AD tenant ID]/.well-known/openid-configuration" />
        <required-claims>
            <claim name="aud">
                <value>[Application ID]</value>
            </claim>
        </required-claims>
    </validate-jwt>
    ```

<span data-ttu-id="714d9-264">További részletekért tekintse meg a [GitHub információs][readme].</span><span class="sxs-lookup"><span data-stu-id="714d9-264">For more details, see the [GitHub readme][readme].</span></span>

### <a name="authorization"></a><span data-ttu-id="714d9-265">Engedélyezés</span><span class="sxs-lookup"><span data-stu-id="714d9-265">Authorization</span></span>

<span data-ttu-id="714d9-266">Számos alkalmazásban a háttérrendszeri API ellenőriznie kell, hogy egy felhasználó jogosult-e egy adott művelet végrehajtásához szükséges engedéllyel.</span><span class="sxs-lookup"><span data-stu-id="714d9-266">In many applications, the backend API must check whether a user has permission to perform a given action.</span></span> <span data-ttu-id="714d9-267">Azt javasoljuk, hogy használjon [jogcímalapú engedélyezési][claims], amelyben a felhasználó adatai van az identitásszolgáltató (esetünkben az Azure AD) által közölt és használt engedélyezési döntésekhez.</span><span class="sxs-lookup"><span data-stu-id="714d9-267">It's recommended to use [claims-based authorization][claims], where information about the user is conveyed by the identity provider (in this case, Azure AD) and used to make authorization decisions.</span></span> 

<span data-ttu-id="714d9-268">Egyes jogcímek biztosított belül az azonosító jogkivonat, amely az Azure AD és az ügyfél ad vissza.</span><span class="sxs-lookup"><span data-stu-id="714d9-268">Some claims are provided inside the ID token that Azure AD returns to the client.</span></span> <span data-ttu-id="714d9-269">Ezeket a jogcímeket a belül a függvényalkalmazás az X-MS-CLIENT-egyszerű a kérelemben szereplő tartományfejléc megvizsgálásával kérheti le.</span><span class="sxs-lookup"><span data-stu-id="714d9-269">You can get these claims from within the function app by examining the X-MS-CLIENT-PRINCIPAL header in the request.</span></span> <span data-ttu-id="714d9-270">Egyéb jogcímek használata [Microsoft Graph] [ graph] lekérdezése az Azure ad-ben (szükséges felhasználói beleegyezés bejelentkezés során).</span><span class="sxs-lookup"><span data-stu-id="714d9-270">For other claims, use [Microsoft Graph][graph] to query Azure AD (requires user consent during sign-in).</span></span> 

<span data-ttu-id="714d9-271">Például ha egy alkalmazás az Azure ad-ben regisztrálja, meghatározhatja egy alkalmazás-szerepkörök készletét regisztrációs alkalmazásjegyzékben.</span><span class="sxs-lookup"><span data-stu-id="714d9-271">For example, when you register an application in Azure AD, you can define a set of application roles in the application's registration manifest.</span></span> <span data-ttu-id="714d9-272">Amikor egy felhasználó bejelentkezik az alkalmazásba, az Azure AD tartalmaz egy "szerepkör" jogcím az egyes szerepkörökhöz, amelyek a felhasználó megkapta-e (beleértve a csoporttagság örökölt szerepkörök).</span><span class="sxs-lookup"><span data-stu-id="714d9-272">When a user signs into the application, Azure AD includes a "roles" claim for each role that the user has been granted (including roles that are inherited through group membership).</span></span> 

<span data-ttu-id="714d9-273">A referenciaimplementációt, a függvény ellenőrzi, hogy a hitelesített felhasználó tagja a `GetStatus` alkalmazás-szerepkörökhöz.</span><span class="sxs-lookup"><span data-stu-id="714d9-273">In the reference implementation, the function checks whether the authenticated user is a member of the `GetStatus` application role.</span></span> <span data-ttu-id="714d9-274">Ha nem, a függvény egy HTTP jogosulatlan (401-es) választ ad vissza.</span><span class="sxs-lookup"><span data-stu-id="714d9-274">If not, the function returns an HTTP Unauthorized (401) response.</span></span> 

```csharp
[FunctionName("GetStatusFunction")]
public static Task<IActionResult> Run(
    [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req, 
    [CosmosDB(
        databaseName: "%COSMOSDB_DATABASE_NAME%",
        collectionName: "%COSMOSDB_DATABASE_COL%",
        ConnectionStringSetting = "COSMOSDB_CONNECTION_STRING",
        Id = "{Query.deviceId}",
        PartitionKey = "{Query.deviceId}")] dynamic deviceStatus, 
    ILogger log)
{
    log.LogInformation("Processing GetStatus request.");

    return req.HandleIfAuthorizedForRoles(new[] { GetDeviceStatusRoleName },
        async () =>
        {
            string deviceId = req.Query["deviceId"];
            if (deviceId == null)
            {
                return new BadRequestObjectResult("Missing DeviceId");
            }

            return await Task.FromResult<IActionResult>(deviceStatus != null
                    ? (ActionResult)new OkObjectResult(deviceStatus)
                    : new NotFoundResult());
        },
        log);
}
```

<span data-ttu-id="714d9-275">Ez a Kódpélda az `HandleIfAuthorizedForRoles` bővítmény módszerrel, amely ellenőrzi, hogy a szerepkör jogcím és a HTTP 401-es adja vissza, ha a jogcím nem található.</span><span class="sxs-lookup"><span data-stu-id="714d9-275">In this code example, `HandleIfAuthorizedForRoles` is an extension method that checks for the role claim and returns HTTP 401 if the claim isn't found.</span></span> <span data-ttu-id="714d9-276">A forráskód annak [Itt][HttpRequestAuthorizationExtensions].</span><span class="sxs-lookup"><span data-stu-id="714d9-276">You can find the source code [here][HttpRequestAuthorizationExtensions].</span></span> <span data-ttu-id="714d9-277">Figyelje meg, hogy `HandleIfAuthorizedForRoles` vesz igénybe egy `ILogger` paraméter.</span><span class="sxs-lookup"><span data-stu-id="714d9-277">Notice that `HandleIfAuthorizedForRoles` takes an `ILogger` parameter.</span></span> <span data-ttu-id="714d9-278">Jogosulatlan kérelmek naplózni kell, hogy egy naplóban, és segítségével diagnosztizálhatja a problémákat, ha szükséges.</span><span class="sxs-lookup"><span data-stu-id="714d9-278">You should log unauthorized requests so that you have an audit trail and can diagnose issues if needed.</span></span> <span data-ttu-id="714d9-279">Egy időben kerülje a kiszivárgását a HTTP 401-es válasz lévő bármely részletes információkat.</span><span class="sxs-lookup"><span data-stu-id="714d9-279">At the same time, avoid leaking any detailed information inside the HTTP 401 response.</span></span>

### <a name="cors"></a><span data-ttu-id="714d9-280">CORS</span><span class="sxs-lookup"><span data-stu-id="714d9-280">CORS</span></span>

<span data-ttu-id="714d9-281">Ez a referenciaarchitektúra a a webalkalmazás és az API nem osztoznak az azonos forrásból.</span><span class="sxs-lookup"><span data-stu-id="714d9-281">In this reference architecture, the web application and the API do not share the same origin.</span></span> <span data-ttu-id="714d9-282">Ez azt jelenti, amikor az alkalmazás meghívja az API-t, hogy az eltérő eredetű kérelem.</span><span class="sxs-lookup"><span data-stu-id="714d9-282">That means when the application calls the API, it is a cross-origin request.</span></span> <span data-ttu-id="714d9-283">A böngésző biztonsági beállításai megakadályozzák, hogy egy weblap AJAX-kérelmeket küldjön egy másik tartományba.</span><span class="sxs-lookup"><span data-stu-id="714d9-283">Browser security prevents a web page from making AJAX requests to another domain.</span></span> <span data-ttu-id="714d9-284">Ez a korlátozás nevezzük a *azonoseredet-* és megakadályozza, hogy egy rosszindulatú webhely érzékeny adatok olvasása a másik helyről.</span><span class="sxs-lookup"><span data-stu-id="714d9-284">This restriction is called the *same-origin policy* and prevents a malicious site from reading sensitive data from another site.</span></span> <span data-ttu-id="714d9-285">Eltérő eredetű kérelem engedélyezéséhez adjon hozzá egy eltérő eredetű erőforrások megosztása (CORS) [házirend] [ cors-policy] , az API Management-átjáró:</span><span class="sxs-lookup"><span data-stu-id="714d9-285">To enable a cross-origin request, add a Cross-Origin Resource Sharing (CORS) [policy][cors-policy] to the API Management gateway:</span></span>

```xml
<cors allow-credentials="true">
    <allowed-origins>
        <origin>[Website URL]</origin>
    </allowed-origins>
    <allowed-methods>
        <method>GET</method>
    </allowed-methods>
    <allowed-headers>
        <header>*</header>
    </allowed-headers>
</cors>
```

<span data-ttu-id="714d9-286">Ebben a példában a **engedélyezése – hitelesítő adatok** attribútum **igaz**.</span><span class="sxs-lookup"><span data-stu-id="714d9-286">In this example, the **allow-credentials** attribute is **true**.</span></span> <span data-ttu-id="714d9-287">Ez engedélyezi a böngésző (beleértve a cookie-k) hitelesítő adatok küldése a kérelemmel.</span><span class="sxs-lookup"><span data-stu-id="714d9-287">This authorizes the browser to send credentials (including cookies) with the request.</span></span> <span data-ttu-id="714d9-288">Ellenkező esetben alapértelmezés szerint a böngésző nem küld egy eltérő eredetű kérelem hitelesítő adatokat.</span><span class="sxs-lookup"><span data-stu-id="714d9-288">Otherwise, by default the browser does not send credentials with a cross-origin request.</span></span>

> [!NOTE] 
> <span data-ttu-id="714d9-289">Legyen nagyon körültekintő beállítással kapcsolatos **engedélyezése – hitelesítő adatok** való **igaz**, mert azt jelenti, hogy egy webhely is küldhetnek a felhasználó hitelesítő adatait az API-t, a felhasználó nevében, nem a felhasználó nem is tud.</span><span class="sxs-lookup"><span data-stu-id="714d9-289">Be very careful about setting **allow-credentials** to **true**, because it means a website can send the user's credentials to your API on the user's behalf, without the user being aware.</span></span> <span data-ttu-id="714d9-290">Meg kell bíznia az engedélyezett forrása.</span><span class="sxs-lookup"><span data-stu-id="714d9-290">You must trust the allowed origin.</span></span>

### <a name="enforce-https"></a><span data-ttu-id="714d9-291">HTTPS kényszerítése</span><span class="sxs-lookup"><span data-stu-id="714d9-291">Enforce HTTPS</span></span>

<span data-ttu-id="714d9-292">A maximális biztonság érdekében van szükség a kérelem folyamata során HTTPS:</span><span class="sxs-lookup"><span data-stu-id="714d9-292">For maximum security, require HTTPS throughout the request pipeline:</span></span>

- <span data-ttu-id="714d9-293">**CDN**.</span><span class="sxs-lookup"><span data-stu-id="714d9-293">**CDN**.</span></span> <span data-ttu-id="714d9-294">Az Azure CDN a HTTPS támogatja a `*.azureedge.net` altartomány alapértelmezés szerint.</span><span class="sxs-lookup"><span data-stu-id="714d9-294">Azure CDN supports HTTPS on the `*.azureedge.net` subdomain by default.</span></span> <span data-ttu-id="714d9-295">A CDN-t az egyéni tartománynevek a HTTPS engedélyezéséhez tekintse [oktatóanyag: HTTPS konfigurálása Azure CDN egyéni tartományon][cdn-https].</span><span class="sxs-lookup"><span data-stu-id="714d9-295">To enable HTTPS in the CDN for custom domain names, see [Tutorial: Configure HTTPS on an Azure CDN custom domain][cdn-https].</span></span> 

- <span data-ttu-id="714d9-296">**Statikus webhely üzemeltetése**.</span><span class="sxs-lookup"><span data-stu-id="714d9-296">**Static website hosting**.</span></span> <span data-ttu-id="714d9-297">Engedélyezze a "[biztonságos átvitelre van szükség][storage-https]" lehetőséget a tárfiók.</span><span class="sxs-lookup"><span data-stu-id="714d9-297">Enable the "[Secure transfer required][storage-https]" option on the Storage account.</span></span> <span data-ttu-id="714d9-298">Ha ez a beállítás engedélyezve van, a storage-fiókot csak lehetővé teszi a biztonságos HTTPS-kapcsolatok érkező kérelmeket.</span><span class="sxs-lookup"><span data-stu-id="714d9-298">When this option is enabled, the storage account only allows requests from secure HTTPS connections.</span></span> 

- <span data-ttu-id="714d9-299">**Az API Management**.</span><span class="sxs-lookup"><span data-stu-id="714d9-299">**API Management**.</span></span> <span data-ttu-id="714d9-300">Az API-k csak a HTTPS protokoll használatára konfigurálja.</span><span class="sxs-lookup"><span data-stu-id="714d9-300">Configure the APIs to use HTTPS protocol only.</span></span> <span data-ttu-id="714d9-301">Az Azure Portalon, vagy egy Resource Manager-sablon segítségével konfigurálható:</span><span class="sxs-lookup"><span data-stu-id="714d9-301">You can configure this in the Azure portal or through a Resource Manager template:</span></span>

    ```json
    {
        "apiVersion": "2018-01-01",
        "type": "apis",
        "name": "dronedeliveryapi",
        "dependsOn": [
            "[concat('Microsoft.ApiManagement/service/', variables('apiManagementServiceName'))]"
        ],
        "properties": {
            "displayName": "Drone Delivery API",
            "description": "Drone Delivery API",
            "path": "api",
            "protocols": [ "HTTPS" ]
        },
        ...
    }
    ```

- <span data-ttu-id="714d9-302">**Az Azure Functions**.</span><span class="sxs-lookup"><span data-stu-id="714d9-302">**Azure Functions**.</span></span> <span data-ttu-id="714d9-303">Engedélyezze a "[csak HTTPS][functions-https]" beállítást.</span><span class="sxs-lookup"><span data-stu-id="714d9-303">Enable the "[HTTPS Only][functions-https]" setting.</span></span> 

### <a name="lock-down-the-function-app"></a><span data-ttu-id="714d9-304">A függvényalkalmazás zárolását</span><span class="sxs-lookup"><span data-stu-id="714d9-304">Lock down the function app</span></span>

<span data-ttu-id="714d9-305">A függvény összes hívást végre kell hajtania az API-átjáró.</span><span class="sxs-lookup"><span data-stu-id="714d9-305">All calls to the function should go through the API gateway.</span></span> <span data-ttu-id="714d9-306">Akkor érhető el, a következőképpen:</span><span class="sxs-lookup"><span data-stu-id="714d9-306">You can achieve this as follows:</span></span>

- <span data-ttu-id="714d9-307">Egy függvény kulcs megkövetelése a függvényalkalmazás konfigurálása.</span><span class="sxs-lookup"><span data-stu-id="714d9-307">Configure the function app to require a function key.</span></span> <span data-ttu-id="714d9-308">Az API Management-átjáró a függvény kulcsot fogja tartalmazni, amikor meghívja a függvényalkalmazás.</span><span class="sxs-lookup"><span data-stu-id="714d9-308">The API Management gateway will include the function key when it calls the function app.</span></span> <span data-ttu-id="714d9-309">Ez megakadályozza, hogy az ügyfelek a függvény közvetlenül, az átjáró kihagyásával.</span><span class="sxs-lookup"><span data-stu-id="714d9-309">This prevents clients from calling the function directly, bypassing the gateway.</span></span> 

- <span data-ttu-id="714d9-310">Az API Management gateway rendelkezik egy [statikus IP-cím][apim-ip].</span><span class="sxs-lookup"><span data-stu-id="714d9-310">The API Management gateway has a [static IP address][apim-ip].</span></span> <span data-ttu-id="714d9-311">Az Azure-függvényt, hogy csak a statikus IP-címről indított hívások korlátozása.</span><span class="sxs-lookup"><span data-stu-id="714d9-311">Restrict the Azure Function to allow only calls from that static IP address.</span></span> <span data-ttu-id="714d9-312">További információkért lásd: [Azure App Service statikus IP-korlátozások][app-service-ip-restrictions].</span><span class="sxs-lookup"><span data-stu-id="714d9-312">For more information, see [Azure App Service Static IP Restrictions][app-service-ip-restrictions].</span></span> <span data-ttu-id="714d9-313">(Ez a funkció csak a Standard szintű szolgáltatások esetében érhető el.)</span><span class="sxs-lookup"><span data-stu-id="714d9-313">(This feature is available for Standard tier services only.)</span></span> 

### <a name="protect-application-secrets"></a><span data-ttu-id="714d9-314">Titkos alkalmazáskulcsok védelme</span><span class="sxs-lookup"><span data-stu-id="714d9-314">Protect application secrets</span></span>

<span data-ttu-id="714d9-315">Ne tároljon az alkalmazások titkos adatait, például az adatbázis hitelesítő adatait, a kód vagy a konfigurációs fájlokban.</span><span class="sxs-lookup"><span data-stu-id="714d9-315">Don't store application secrets, such as database credentials, in your code or configuration files.</span></span> <span data-ttu-id="714d9-316">Ehelyett használja az alkalmazásbeállításokat, amelyeket a rendszer titkosítja az Azure-ban.</span><span class="sxs-lookup"><span data-stu-id="714d9-316">Instead, use App settings, which are stored encrypted in Azure.</span></span> <span data-ttu-id="714d9-317">További információkért lásd: [biztonság az Azure App Service és az Azure Functions][app-service-security].</span><span class="sxs-lookup"><span data-stu-id="714d9-317">For more information, see [Security in Azure App Service and Azure Functions][app-service-security].</span></span>

<span data-ttu-id="714d9-318">Azt is megteheti a titkos alkalmazáskulcsok tárolhatja a Key Vaultban.</span><span class="sxs-lookup"><span data-stu-id="714d9-318">Alternatively, you can store application secrets in Key Vault.</span></span> <span data-ttu-id="714d9-319">Ez lehetővé teszi, hogy a titkos kulcsok tárolására központosítása, a terjesztési, és hogyan és mikor rálátást titkos kulcsok figyelése.</span><span class="sxs-lookup"><span data-stu-id="714d9-319">This allows you to centralize the storage of secrets, control their distribution, and monitor how and when secrets are being accessed.</span></span> <span data-ttu-id="714d9-320">További információkért lásd: [konfigurálása az Azure-webalkalmazások titkos Key vault olvasásához][key-vault-web-app].</span><span class="sxs-lookup"><span data-stu-id="714d9-320">For more information, see [Configure an Azure web application to read a secret from Key Vault][key-vault-web-app].</span></span> <span data-ttu-id="714d9-321">Vegye azonban figyelembe, hogy Functions eseményindítók és kötések betölteni a konfigurációs beállítások az alkalmazás beállításait.</span><span class="sxs-lookup"><span data-stu-id="714d9-321">However, note that Functions triggers and bindings load their configuration settings from app settings.</span></span> <span data-ttu-id="714d9-322">Nincs beépített mód konfigurálása az eseményindítók és kötések használata a Key Vault titkos kulcsok.</span><span class="sxs-lookup"><span data-stu-id="714d9-322">There is no built-in way to configure the triggers and bindings to use Key Vault secrets.</span></span>

## <a name="devops-considerations"></a><span data-ttu-id="714d9-323">Fejlesztési és üzemeltetési szempontok</span><span class="sxs-lookup"><span data-stu-id="714d9-323">DevOps considerations</span></span>

### <a name="api-versioning"></a><span data-ttu-id="714d9-324">API-verziószámozás</span><span class="sxs-lookup"><span data-stu-id="714d9-324">API versioning</span></span>

<span data-ttu-id="714d9-325">Egy API-ját egy szolgáltatás és -ügyfelek vagy ügyfél között.</span><span class="sxs-lookup"><span data-stu-id="714d9-325">An API is a contract between a service and clients or consumers of that service.</span></span> <span data-ttu-id="714d9-326">Verziókezelés támogatja az API-szerződés.</span><span class="sxs-lookup"><span data-stu-id="714d9-326">Support versioning in your API contract.</span></span> <span data-ttu-id="714d9-327">Ha egy API-t használhatatlanná tévő változást, vezessen be egy új API-verzió.</span><span class="sxs-lookup"><span data-stu-id="714d9-327">If you introduce a breaking API change, introduce a new API version.</span></span> <span data-ttu-id="714d9-328">Helyezze üzembe az új verzió-párhuzamos egy külön függvényalkalmazásban az eredeti verzióval.</span><span class="sxs-lookup"><span data-stu-id="714d9-328">Deploy the new version side-by-side with the original version, in a separate Function App.</span></span> <span data-ttu-id="714d9-329">Ez lehetővé teszi a meglévő ügyfelek áttelepítését az új API ügyfélalkalmazások megszakítása nélkül.</span><span class="sxs-lookup"><span data-stu-id="714d9-329">This lets you migrate existing clients to the new API without breaking client applications.</span></span> <span data-ttu-id="714d9-330">Végül, a korábbi verziót is kivezetjük.</span><span class="sxs-lookup"><span data-stu-id="714d9-330">Eventually, you can deprecate the previous version.</span></span> <span data-ttu-id="714d9-331">API-k verziókezelése kapcsolatos további információkért lásd: [Versioning webes RESTful API][api-versioning].</span><span class="sxs-lookup"><span data-stu-id="714d9-331">For more information about API versioning, see [Versioning a RESTful web API][api-versioning].</span></span>

<span data-ttu-id="714d9-332">API-módosítás ne sérüljenek frissítések központi telepítése az új verzió ugyanaz a Függvényalkalmazás az előkészítési pont.</span><span class="sxs-lookup"><span data-stu-id="714d9-332">For updates that are not breaking API changes, deploy the new version to a staging slot in the same Function App.</span></span> <span data-ttu-id="714d9-333">Ellenőrizze a telepítés sikeres volt, és majd felcserélheti a manuálisan előkészített verzió éles verziójával.</span><span class="sxs-lookup"><span data-stu-id="714d9-333">Verify the deployment succeeded and then swap the staged version with the production version.</span></span>

## <a name="deploy-the-solution"></a><span data-ttu-id="714d9-334">A megoldás üzembe helyezése</span><span class="sxs-lookup"><span data-stu-id="714d9-334">Deploy the solution</span></span>

<span data-ttu-id="714d9-335">Ez a referenciaarchitektúra üzembe helyezéséhez keresse meg a [GitHub információs][readme].</span><span class="sxs-lookup"><span data-stu-id="714d9-335">To deploy this reference architecture, view the [GitHub readme][readme].</span></span> 

<!-- links -->

[api-versioning]: ../../best-practices/api-design.md#versioning-a-restful-web-api
[apim]: /azure/api-management/api-management-key-concepts
[apim-ip]: /azure/api-management/api-management-faq#is-the-api-management-gateway-ip-address-constant-can-i-use-it-in-firewall-rules
[api-geo]: /azure/api-management/api-management-howto-deploy-multi-region
[apim-scale]: /azure/api-management/api-management-howto-autoscale
[app-service-auth]: /azure/app-service/app-service-authentication-overview
[app-service-ip-restrictions]: /azure/app-service/app-service-ip-restrictions
[app-service-security]: /azure/app-service/app-service-security
[ase]: /azure/app-service/environment/intro
[azure-messaging]: /azure/event-grid/compare-messaging-services
[claims]: https://en.wikipedia.org/wiki/Claims-based_identity
[cdn]: https://azure.microsoft.com/services/cdn/
[cdn-https]: /azure/cdn/cdn-custom-ssl
[cors-policy]: /azure/api-management/api-management-cross-domain-policies
[cosmosdb]: /azure/cosmos-db/introduction
[cosmosdb-geo]: /azure/cosmos-db/distribute-data-globally
[cosmosdb-input-binding]: /azure/azure-functions/functions-bindings-cosmosdb-v2#input
[cosmosdb-scale]: /azure/cosmos-db/partition-data
[event-driven]: ../../guide/architecture-styles/event-driven.md
[functions]: /azure/azure-functions/functions-overview
[functions-bindings]: /azure/azure-functions/functions-triggers-bindings
[functions-cold-start]: https://blogs.msdn.microsoft.com/appserviceteam/2018/02/07/understanding-serverless-cold-start/
[functions-https]: /azure/app-service/app-service-web-tutorial-custom-ssl#enforce-https
[functions-proxy]: /azure-functions/functions-proxies
[functions-scale]: /azure/azure-functions/functions-scale
[functions-timeout]: /azure/azure-functions/functions-scale#consumption-plan
[graph]: https://developer.microsoft.com/graph/docs/concepts/overview
[key-vault-web-app]: /azure/key-vault/tutorial-web-application-keyvault
[microservices-domain-analysis]: ../../microservices/domain-analysis.md
[monitor]: /azure/azure-monitor/overview
[oauth-flow]: https://auth0.com/docs/api-auth/which-oauth-flow-to-use
[partition-key]: /azure/cosmos-db/partition-data
[pipelines]: /azure/devops/pipelines/index
[ru]: /azure/cosmos-db/request-units
[static-hosting]: /azure/storage/blobs/storage-blob-static-website
[static-hosting-preview]: https://azure.microsoft.com/blog/azure-storage-static-web-hosting-public-preview/
[storage-https]: /azure/storage/common/storage-require-secure-transfer
[tm]: /azure/traffic-manager/traffic-manager-overview

[github]: https://github.com/mspnp/serverless-reference-implementation
[HttpRequestAuthorizationExtensions]: https://github.com/mspnp/serverless-reference-implementation/blob/master/src/DroneStatus/dotnet/DroneStatusFunctionApp/HttpRequestAuthorizationExtensions.cs
[readme]: https://github.com/mspnp/serverless-reference-implementation/blob/master/README.md