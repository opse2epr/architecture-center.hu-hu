---
title: API-tervezés
description: Mikroszolgáltatás-alapú API-k tervezése
author: MikeWasson
ms.date: 10/23/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: 01f774773b2d2a653e52c9ee961f12c5b9fc833a
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 01/23/2019
ms.locfileid: "54485978"
---
# <a name="designing-microservices-api-design"></a><span data-ttu-id="6770d-103">Mikroszolgáltatások tervezése: API-tervezés</span><span class="sxs-lookup"><span data-stu-id="6770d-103">Designing microservices: API design</span></span>

<span data-ttu-id="6770d-104">Jó API-tervezés fontos a mikroszolgáltatási architektúrákban, mert az összes adatcsere-szolgáltatások közötti üzenetek, illetve az API-hívások keresztül történik.</span><span class="sxs-lookup"><span data-stu-id="6770d-104">Good API design is important in a microservices architecture, because all data exchange between services happens either through messages or API calls.</span></span> <span data-ttu-id="6770d-105">API-kat kell lennie, ne hozzon létre hatékony [forgalmas I/O](../antipatterns/chatty-io/index.md).</span><span class="sxs-lookup"><span data-stu-id="6770d-105">APIs must be efficient to avoid creating [chatty I/O](../antipatterns/chatty-io/index.md).</span></span> <span data-ttu-id="6770d-106">Mivel a szolgáltatások egymástól függetlenül működik-e csoportok készültek, API-k rendelkeznie kell jól definiált szemantika és a verziókezelés rendszerek, úgy, hogy a frissítések nem felosztása más szolgáltatások.</span><span class="sxs-lookup"><span data-stu-id="6770d-106">Because services are designed by teams working independently, APIs must have well-defined semantics and versioning schemes, so that updates don't break other services.</span></span>

![A mikroszolgáltatás-alapú API-tervezés](./images/api-design.png)

<span data-ttu-id="6770d-108">Fontos, hogy két típusú API között:</span><span class="sxs-lookup"><span data-stu-id="6770d-108">It's important to distinguish between two types of API:</span></span>

- <span data-ttu-id="6770d-109">Nyilvános API-kat, amelyek meg az ügyfélalkalmazások számára.</span><span class="sxs-lookup"><span data-stu-id="6770d-109">Public APIs that client applications call.</span></span>
- <span data-ttu-id="6770d-110">Háttérbeli API-k által használt szolgáltatások közötti kommunikáció.</span><span class="sxs-lookup"><span data-stu-id="6770d-110">Backend APIs that are used for interservice communication.</span></span>

<span data-ttu-id="6770d-111">E két használati esetek némiképp eltérő követelmények vonatkozhatnak.</span><span class="sxs-lookup"><span data-stu-id="6770d-111">These two use cases have somewhat different requirements.</span></span> <span data-ttu-id="6770d-112">Nyilvános API-t az ügyfélalkalmazások, általában böngészőalkalmazásokban vagy natív mobilalkalmazások kompatibilisnek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="6770d-112">A public API must be compatible with client applications, typically browser applications or native mobile applications.</span></span> <span data-ttu-id="6770d-113">A legtöbb esetben azt jelenti, hogy a nyilvános API-t a REST használata HTTP-n keresztül.</span><span class="sxs-lookup"><span data-stu-id="6770d-113">Most of the time, that means the public API will use REST over HTTP.</span></span> <span data-ttu-id="6770d-114">A háttérrendszeri API-khoz, az azonban Önnek kell tennie a hálózati teljesítmény-fiókba.</span><span class="sxs-lookup"><span data-stu-id="6770d-114">For the backend APIs, however, you need to take network performance into account.</span></span> <span data-ttu-id="6770d-115">A szolgáltatások részletességétől függően közötti kommunikációt eredményezhet nagy hálózati forgalmat eredményezhet.</span><span class="sxs-lookup"><span data-stu-id="6770d-115">Depending on the granularity of your services, interservice communication can result in a lot of network traffic.</span></span> <span data-ttu-id="6770d-116">Szolgáltatások gyorsan válhat i/o kötve.</span><span class="sxs-lookup"><span data-stu-id="6770d-116">Services can quickly become I/O bound.</span></span> <span data-ttu-id="6770d-117">Éppen ezért több fontossá válik például a sebesség és a hasznos adat mérete szerializálási szempontok.</span><span class="sxs-lookup"><span data-stu-id="6770d-117">For that reason, considerations such as serialization speed and payload size become more important.</span></span> <span data-ttu-id="6770d-118">Néhány népszerű más REST használatával HTTP protokollon keresztül gRPC Apache Avro és Apache Thrift tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="6770d-118">Some popular alternatives to using REST over HTTP include gRPC, Apache Avro, and Apache Thrift.</span></span> <span data-ttu-id="6770d-119">Ezeket a protokollokat támogatja a bináris szerializálási, és általában hatékonyabb, mint a HTTP.</span><span class="sxs-lookup"><span data-stu-id="6770d-119">These protocols support binary serialization and are generally more efficient than HTTP.</span></span>

## <a name="considerations"></a><span data-ttu-id="6770d-120">Megfontolandó szempontok</span><span class="sxs-lookup"><span data-stu-id="6770d-120">Considerations</span></span>

<span data-ttu-id="6770d-121">Az alábbiakban néhány dolgot kell vennie, amikor kiválasztja, hogyan valósíthat meg egy API-t.</span><span class="sxs-lookup"><span data-stu-id="6770d-121">Here are some things to think about when choosing how to implement an API.</span></span>

<span data-ttu-id="6770d-122">**REST-vs RPC**.</span><span class="sxs-lookup"><span data-stu-id="6770d-122">**REST vs RPC**.</span></span> <span data-ttu-id="6770d-123">Fontolja meg egy REST-stílusú felhasználói felületén és a egy RPC stílusú felület kompromisszumokat.</span><span class="sxs-lookup"><span data-stu-id="6770d-123">Consider the tradeoffs between using a REST-style interface versus an RPC-style interface.</span></span>

- <span data-ttu-id="6770d-124">REST-modellek erőforrásokat, amelyek a természetes módon lehet a tartományi modellben express.</span><span class="sxs-lookup"><span data-stu-id="6770d-124">REST models resources, which can be a natural way express your domain model.</span></span> <span data-ttu-id="6770d-125">Meghatározza egy egységes felületet alapján a HTTP-műveletek, amelyek arra ösztönzi a evolvability.</span><span class="sxs-lookup"><span data-stu-id="6770d-125">It defines a uniform interface based on HTTP verbs, which encourages evolvability.</span></span> <span data-ttu-id="6770d-126">Idempotens, mellékhatása és válaszkódok jól definiált szemantikával rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="6770d-126">It has well-defined semantics in terms of idempotency, side effects, and response codes.</span></span> <span data-ttu-id="6770d-127">És állapot nélküli kommunikációhoz, amely javítja a skálázhatóságot érvényesít.</span><span class="sxs-lookup"><span data-stu-id="6770d-127">And it enforces stateless communication, which improves scalability.</span></span>

- <span data-ttu-id="6770d-128">RPC több orientált, műveleteket, illetve parancsok körül.</span><span class="sxs-lookup"><span data-stu-id="6770d-128">RPC is more oriented around operations or commands.</span></span> <span data-ttu-id="6770d-129">RPC felületek néz ki helyi metódust hívja, mert vezethet, a túlságosan forgalmas API-k tervezéséhez.</span><span class="sxs-lookup"><span data-stu-id="6770d-129">Because RPC interfaces look like local method calls, it may lead you to design overly chatty APIs.</span></span> <span data-ttu-id="6770d-130">Azonban ez nem jelenti azt RPC forgalmas kell lennie.</span><span class="sxs-lookup"><span data-stu-id="6770d-130">However, that doesn't mean RPC must be chatty.</span></span> <span data-ttu-id="6770d-131">Csak akkor körültekintően járjon el a felületen tervezésekor kell.</span><span class="sxs-lookup"><span data-stu-id="6770d-131">It just means you need to use care when designing the interface.</span></span>

<span data-ttu-id="6770d-132">Egy RESTful interfészről a leggyakrabban használt, amely REST JSON használatával HTTP protokollon keresztül.</span><span class="sxs-lookup"><span data-stu-id="6770d-132">For a RESTful interface, the most common choice is REST over HTTP using JSON.</span></span> <span data-ttu-id="6770d-133">RPC stílusú illesztőfelületet számos népszerű keretrendszereket gRPC Apache Avro és Apache Thrift is vannak.</span><span class="sxs-lookup"><span data-stu-id="6770d-133">For an RPC-style interface, there are several popular frameworks, including gRPC, Apache Avro, and Apache Thrift.</span></span>

<span data-ttu-id="6770d-134">**Hatékonyság**.</span><span class="sxs-lookup"><span data-stu-id="6770d-134">**Efficiency**.</span></span> <span data-ttu-id="6770d-135">Fontolja meg a hatékonyság sebességét, a memória és a hasznos adat mérete tekintetében.</span><span class="sxs-lookup"><span data-stu-id="6770d-135">Consider efficiency in terms of speed, memory, and payload size.</span></span> <span data-ttu-id="6770d-136">A gRPC felületen általában gyorsabb, mint a többi HTTP protokollon keresztül.</span><span class="sxs-lookup"><span data-stu-id="6770d-136">Typically a gRPC-based interface is faster than REST over HTTP.</span></span>

<span data-ttu-id="6770d-137">**Definíció nyelven (IDL) csatoló**.</span><span class="sxs-lookup"><span data-stu-id="6770d-137">**Interface definition language (IDL)**.</span></span> <span data-ttu-id="6770d-138">Egy IDL szolgál a módszereket, paraméterek, és API-KHOZ értékeit adja vissza.</span><span class="sxs-lookup"><span data-stu-id="6770d-138">An IDL is used to define the methods, parameters, and return values of an API.</span></span> <span data-ttu-id="6770d-139">Egy IDL Ügyfélkód szerializálási kód és API-dokumentáció létrehozásához használható.</span><span class="sxs-lookup"><span data-stu-id="6770d-139">An IDL can be used to generate client code, serialization code, and API documentation.</span></span> <span data-ttu-id="6770d-140">IDLs tesztelési eszközök, például a Postman API is képes használni.</span><span class="sxs-lookup"><span data-stu-id="6770d-140">IDLs can also be consumed by API testing tools such as Postman.</span></span> <span data-ttu-id="6770d-141">Keretrendszereket, mint a gRPC Avro és Thrift saját IDL specifikációk meghatározása.</span><span class="sxs-lookup"><span data-stu-id="6770d-141">Frameworks such as gRPC, Avro, and Thrift define their own IDL specifications.</span></span> <span data-ttu-id="6770d-142">HTTP-n keresztül REST nincs szabványos IDL formátumban, de egy közös megválasztása OpenAPI (korábbi nevén Swagger).</span><span class="sxs-lookup"><span data-stu-id="6770d-142">REST over HTTP does not have a standard IDL format, but a common choice is OpenAPI (formerly Swagger).</span></span> <span data-ttu-id="6770d-143">Egy HTTP REST API-t egy hivatalos munkafolyamatdefiníciós nyelv használata nélkül is létrehozhat, de majd elveszíti a kód létrehozását és a tesztelés előnyeit.</span><span class="sxs-lookup"><span data-stu-id="6770d-143">You can also create an HTTP REST API without using a formal definition language, but then you lose the benefits of code generation and testing.</span></span>

<span data-ttu-id="6770d-144">**Szerializálási**.</span><span class="sxs-lookup"><span data-stu-id="6770d-144">**Serialization**.</span></span> <span data-ttu-id="6770d-145">Hogyan objektumok szerializálva vannak a hálózaton keresztül?</span><span class="sxs-lookup"><span data-stu-id="6770d-145">How are objects serialized over the wire?</span></span> <span data-ttu-id="6770d-146">A lehetőségek között (elsősorban JSON) formátumú szöveges és bináris formátumban, például a protokoll puffer.</span><span class="sxs-lookup"><span data-stu-id="6770d-146">Options include text-based formats (primarily JSON) and binary formats such as protocol buffer.</span></span> <span data-ttu-id="6770d-147">Bináris formátumok általában gyorsabb, mint a szöveges formátumban.</span><span class="sxs-lookup"><span data-stu-id="6770d-147">Binary formats are generally faster than text-based formats.</span></span> <span data-ttu-id="6770d-148">Azonban JSON, együttműködési képességgel rendelkezik, előnyöket, mert a legtöbb nyelvet és keretrendszert támogatja a JSON-szerializálást.</span><span class="sxs-lookup"><span data-stu-id="6770d-148">However, JSON has advantages in terms of interoperability, because most languages and frameworks support JSON serialization.</span></span> <span data-ttu-id="6770d-149">Némelyik szerializációs formátum van szükség rögzített sémát, és néhány fájl fordítása.</span><span class="sxs-lookup"><span data-stu-id="6770d-149">Some serialization formats require a fixed schema, and some require compiling a schema definition file.</span></span> <span data-ttu-id="6770d-150">Ebben az esetben szüksége ebben a lépésben a build-folyamatoknak építsen be.</span><span class="sxs-lookup"><span data-stu-id="6770d-150">In that case, you'll need to incorporate this step into your build process.</span></span>

<span data-ttu-id="6770d-151">**Keretrendszer és a nyelvi támogatás**.</span><span class="sxs-lookup"><span data-stu-id="6770d-151">**Framework and language support**.</span></span> <span data-ttu-id="6770d-152">HTTP szinte minden keretrendszer és nyelv támogatott.</span><span class="sxs-lookup"><span data-stu-id="6770d-152">HTTP is supported in nearly every framework and language.</span></span> <span data-ttu-id="6770d-153">gRPC, Avro és Thrift összes rendelkezik a könyvtárak a C++, C#, Java és Python.</span><span class="sxs-lookup"><span data-stu-id="6770d-153">gRPC, Avro, and Thrift all have libraries for C++, C#, Java, and Python.</span></span> <span data-ttu-id="6770d-154">Thrift és gRPC is támogatja a Go.</span><span class="sxs-lookup"><span data-stu-id="6770d-154">Thrift and gRPC also support Go.</span></span>

<span data-ttu-id="6770d-155">**Kompatibilitás és együttműködés**.</span><span class="sxs-lookup"><span data-stu-id="6770d-155">**Compatibility and interoperability**.</span></span> <span data-ttu-id="6770d-156">Ha például a gRPC protokoll, szükség lehet a nyilvános API-t és a háttérrendszer közötti protokoll fordítási rétegben.</span><span class="sxs-lookup"><span data-stu-id="6770d-156">If you choose a protocol like gRPC, you may need a protocol translation layer between the public API and the back end.</span></span> <span data-ttu-id="6770d-157">A [átjáró](./gateway.md) hajthat végre a kívánt függvényt.</span><span class="sxs-lookup"><span data-stu-id="6770d-157">A [gateway](./gateway.md) can perform that function.</span></span> <span data-ttu-id="6770d-158">Ha egy szolgáltatás háló használ, fontolja meg, mely protokollok kompatibilisek-e a szolgáltatás háló.</span><span class="sxs-lookup"><span data-stu-id="6770d-158">If you are using a service mesh, consider which protocols are compatible with the service mesh.</span></span> <span data-ttu-id="6770d-159">Például a linkerd HTTP Thrift és gRPC beépített támogatással rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="6770d-159">For example, linkerd has built-in support for HTTP, Thrift, and gRPC.</span></span>

<span data-ttu-id="6770d-160">Az alapkonfiguráció ajánljuk, hogy válassza ki a REST HTTP-n keresztül, kivéve, ha egy bináris protokoll által nyújtott van szüksége.</span><span class="sxs-lookup"><span data-stu-id="6770d-160">Our baseline recommendation is to choose REST over HTTP unless you need the performance benefits of a binary protocol.</span></span> <span data-ttu-id="6770d-161">HTTP-n keresztül REST speciális szalagtár van szükség.</span><span class="sxs-lookup"><span data-stu-id="6770d-161">REST over HTTP requires no special libraries.</span></span> <span data-ttu-id="6770d-162">Hoz létre a minimális kapcsolási hívó nem kell egy ügyfél helyettes a szolgáltatással való kommunikációra.</span><span class="sxs-lookup"><span data-stu-id="6770d-162">It creates minimal coupling, because callers don't need a client stub to communicate with the service.</span></span> <span data-ttu-id="6770d-163">Nincs gazdag rendszereit eszközök támogatásához sémadefiníciók, tesztelése és figyelése a RESTful HTTP-végpontokat.</span><span class="sxs-lookup"><span data-stu-id="6770d-163">There is rich ecosystems of tools to support schema definitions, testing, and monitoring of RESTful HTTP endpoints.</span></span> <span data-ttu-id="6770d-164">Végül HTTP esetén webböngésző-ügyfelek számára, így Önnek nem kell egy protokoll fordítási réteg az ügyfél és a háttérrendszer között.</span><span class="sxs-lookup"><span data-stu-id="6770d-164">Finally, HTTP is compatible with browser clients, so you don't need a protocol translation layer between the client and the backend.</span></span>

<span data-ttu-id="6770d-165">Azonban ha REST HTTP-n keresztül, kell hajtsa végre a teljesítmény és terheléses tesztelés, megállapítani, hogy e, illetve a forgatókönyv elvégzi a fejlesztési folyamat korai szakaszaiban.</span><span class="sxs-lookup"><span data-stu-id="6770d-165">However, if you choose REST over HTTP, you should do performance and load testing early in the development process, to validate whether it performs well enough for your scenario.</span></span>

## <a name="restful-api-design"></a><span data-ttu-id="6770d-166">RESTful API-tervezés</span><span class="sxs-lookup"><span data-stu-id="6770d-166">RESTful API design</span></span>

<span data-ttu-id="6770d-167">Számos forrásanyag RESTful API-k tervezéséhez.</span><span class="sxs-lookup"><span data-stu-id="6770d-167">There are many resources for designing RESTful APIs.</span></span> <span data-ttu-id="6770d-168">Íme néhány hasznos lehet:</span><span class="sxs-lookup"><span data-stu-id="6770d-168">Here are some that you might find helpful:</span></span>

- [<span data-ttu-id="6770d-169">API-tervezés</span><span class="sxs-lookup"><span data-stu-id="6770d-169">API design</span></span>](../best-practices/api-design.md)

- [<span data-ttu-id="6770d-170">API-implementáció</span><span class="sxs-lookup"><span data-stu-id="6770d-170">API implementation</span></span>](../best-practices/api-implementation.md)

- [<span data-ttu-id="6770d-171">A Microsoft REST API-irányelvek</span><span class="sxs-lookup"><span data-stu-id="6770d-171">Microsoft REST API Guidelines</span></span>](https://github.com/Microsoft/api-guidelines)

<span data-ttu-id="6770d-172">Az alábbiakban néhány konkrét szempontot figyelembe kell venni.</span><span class="sxs-lookup"><span data-stu-id="6770d-172">Here are some specific considerations to keep in mind.</span></span>

- <span data-ttu-id="6770d-173">Figyelje, hogy az API-k, amelyek nyilvánosságra kerüljenek a belső implementáció részleteit, vagy egyszerűen csak tükrözik az egy belső adatbázissémát.</span><span class="sxs-lookup"><span data-stu-id="6770d-173">Watch out for APIs that leak internal implementation details or simply mirror an internal database schema.</span></span> <span data-ttu-id="6770d-174">Az API-t a tartományt kell modellezniük.</span><span class="sxs-lookup"><span data-stu-id="6770d-174">The API should model the domain.</span></span> <span data-ttu-id="6770d-175">Szolgáltatások közötti szerződés, és új funkciók hozzáadásakor, nem csak, mert néhány kódot refactored, vagy egy adatbázistábla soraihoz normalized ideális csak módosítsa.</span><span class="sxs-lookup"><span data-stu-id="6770d-175">It's a contract between services, and ideally should only change when new functionality is added, not just because you refactored some code or normalized a database table.</span></span>

- <span data-ttu-id="6770d-176">Különböző típusú ügyfelet, például a mobilalkalmazás- és asztali webböngésző, a másik hasznos adat mérete vagy interakció minták lehet szükség.</span><span class="sxs-lookup"><span data-stu-id="6770d-176">Different types of client, such as mobile application and desktop web browser, may require different payload sizes or interaction patterns.</span></span> <span data-ttu-id="6770d-177">Fontolja meg a [háttérrendszerek és Előtérrendszerek minta](../patterns/backends-for-frontends.md) külön háttérrendszerek létrehozásához, hogy az ügyfél számára tegye elérhetővé a optimális illesztőfelületet, minden ügyfél számára.</span><span class="sxs-lookup"><span data-stu-id="6770d-177">Consider using the [Backends for Frontends pattern](../patterns/backends-for-frontends.md) to create separate backends for each client, that expose an optimal interface for that client.</span></span>

- <span data-ttu-id="6770d-178">A mellékhatással műveletek fontolja meg a minősítené idempotens, és azok megvalósítását, PUT-metódusok.</span><span class="sxs-lookup"><span data-stu-id="6770d-178">For operations with side effects, consider making them idempotent and implementing them as PUT methods.</span></span> <span data-ttu-id="6770d-179">Amely lehetővé teszi a biztonságos újrapróbálkozás, és javíthatja a rugalmasság.</span><span class="sxs-lookup"><span data-stu-id="6770d-179">That will enable safe retries and can improve resiliency.</span></span> <span data-ttu-id="6770d-180">A fejezetei [adatfeldolgozás és munkafolyamatok](./ingestion-workflow.md#idempotent-vs-non-idempotent-operations) és [szolgáltatások közötti kommunikáció](./interservice-communication.md) probléma részletesebben tárgyalják.</span><span class="sxs-lookup"><span data-stu-id="6770d-180">The chapters [Ingestion and workflow](./ingestion-workflow.md#idempotent-vs-non-idempotent-operations) and [Interservice communication](./interservice-communication.md) discuss this issue in more detail.</span></span>

- <span data-ttu-id="6770d-181">HTTP-metódusok aszinkron szemantikát, ahol a metódus azonnal visszatér a választ, de a szolgáltatás aszinkron módon végrehajtja a műveletet is rendelkezhet.</span><span class="sxs-lookup"><span data-stu-id="6770d-181">HTTP methods can have asynchronous semantics, where the method returns a response immediately, but the service carries out the operation asynchronously.</span></span> <span data-ttu-id="6770d-182">Ebben az esetben adja vissza a metódus egy [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) válaszkód, ami azt jelenti, hogy a kérés elfogadva feldolgozásra, de a feldolgozása még nem fejeződött be.</span><span class="sxs-lookup"><span data-stu-id="6770d-182">In that case, the method should return an [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) response code, which indicates the request was accepted for processing, but the processing is not yet completed.</span></span>

## <a name="mapping-rest-to-ddd-patterns"></a><span data-ttu-id="6770d-183">REST leképezése DDD-minták</span><span class="sxs-lookup"><span data-stu-id="6770d-183">Mapping REST to DDD patterns</span></span>

<span data-ttu-id="6770d-184">Entitás, aggregációs és érték objektum hasonló minták célja, hogy bizonyos korlátozások az objektumok elhelyezése a tartományi modellben.</span><span class="sxs-lookup"><span data-stu-id="6770d-184">Patterns such as entity, aggregate, and value object are designed to place certain constraints on the objects in your domain model.</span></span> <span data-ttu-id="6770d-185">DDD számos vitafórumokban a minták modellezése eltér az objektum-orientált (Fájlmegosztásain) nyelvi fogalmak például konstruktorok vagy tulajdonság beolvasókat és beállítókat használatával.</span><span class="sxs-lookup"><span data-stu-id="6770d-185">In many discussions of DDD, the patterns are modeled using object-oriented (OO) language concepts like constructors or property getters and setters.</span></span> <span data-ttu-id="6770d-186">Ha például *érték-objektumok* is lehet a nem módosítható.</span><span class="sxs-lookup"><span data-stu-id="6770d-186">For example, *value objects* are supposed to be immutable.</span></span> <span data-ttu-id="6770d-187">Egy Fájlmegosztásain programozási nyelven, akkor ennek kényszerítése a hozzárendelése az értékeket a konstruktorban, és a tulajdonságok csak olvasható:</span><span class="sxs-lookup"><span data-stu-id="6770d-187">In an OO programming language, you would enforce this by assigning the values in the constructor and making the properties read-only:</span></span>

```ts
export class Location {
    readonly latitude: number;
    readonly longitude: number;

    constructor(latitude: number, longitude: number) {
        if (latitude < -90 || latitude > 90) {
            throw new RangeError('latitude must be between -90 and 90');
        }
        if (longitude < -180 || longitude > 180) {
            throw new RangeError('longitude must be between -180 and 180');
        }
        this.latitude = latitude;
        this.longitude = longitude;
    }
}
```

<span data-ttu-id="6770d-188">A kódolási módszereket is számos különösen fontosak, egy hagyományos monolitikus alkalmazások készítése során.</span><span class="sxs-lookup"><span data-stu-id="6770d-188">These sorts of coding practices are particularly important when building a traditional monolithic application.</span></span> <span data-ttu-id="6770d-189">A nagy méretű kódbázis esetén számos alrendszerek használatakor előfordulhat, hogy a `Location` objektumot, ezért fontos helyes működése kényszerítése az objektumhoz.</span><span class="sxs-lookup"><span data-stu-id="6770d-189">With a large code base, many subsystems might use the `Location` object, so it's important for the object to enforce correct behavior.</span></span>

<span data-ttu-id="6770d-190">Egy másik példa a tárház mintát, amely biztosítja, hogy az alkalmazás egyéb részei közvetlen olvasási vagy írási, vagy az adatok tárolására ne:</span><span class="sxs-lookup"><span data-stu-id="6770d-190">Another example is the Repository pattern, which ensures that other parts of the application do not make direct reads or writes to the data store:</span></span>

![Egy Drónt tárház ábrája](./images/repository.png)

<span data-ttu-id="6770d-192">A mikroszolgáltatási architektúra azonban szolgáltatások nem adjuk ki azonos kódbázisra és nem megosztásához adattárakban.</span><span class="sxs-lookup"><span data-stu-id="6770d-192">In a microservices architecture, however, services don't share the same code base and don't share data stores.</span></span> <span data-ttu-id="6770d-193">Ehelyett kommunikáció API-kon keresztül.</span><span class="sxs-lookup"><span data-stu-id="6770d-193">Instead, they communicate through APIs.</span></span> <span data-ttu-id="6770d-194">Fontolja meg az eset, ahol a Scheduler szolgáltatás kér a Drone szolgáltatásból egy drónt kapcsolatos információkat.</span><span class="sxs-lookup"><span data-stu-id="6770d-194">Consider the case where the Scheduler service requests information about a drone from the Drone service.</span></span> <span data-ttu-id="6770d-195">A Drone szolgáltatásnak van egy drónt, ki, a kód, a belső modelljét.</span><span class="sxs-lookup"><span data-stu-id="6770d-195">The Drone service has its internal model of a drone, expressed through code.</span></span> <span data-ttu-id="6770d-196">Azonban az ütemező nem látható.</span><span class="sxs-lookup"><span data-stu-id="6770d-196">But the Scheduler doesn't see that.</span></span> <span data-ttu-id="6770d-197">Ehelyett azt visszakap egy *ábrázolás* a drone entitás &mdash; HTTP-választ talán egy JSON-objektumában.</span><span class="sxs-lookup"><span data-stu-id="6770d-197">Instead, it gets back a *representation* of the drone entity &mdash; perhaps a JSON object in an HTTP response.</span></span>

![A Drone szolgáltatás ábrája](./images/ddd-rest.png)

<span data-ttu-id="6770d-199">A Scheduler szolgáltatás nem lehet módosítani a Drone szolgáltatás belső modelljei, vagy a Drone szolgáltatás adattár írni.</span><span class="sxs-lookup"><span data-stu-id="6770d-199">The Scheduler service can't modify the Drone service's internal models, or write to the Drone service's data store.</span></span> <span data-ttu-id="6770d-200">Ez azt jelenti, hogy a kódot, amely megvalósítja a Drone szolgáltatás rendelkezik egy kisebb elérhető felület, a hagyományos mikroszolgáltatásokká kódokkal képest.</span><span class="sxs-lookup"><span data-stu-id="6770d-200">That means the code that implements the Drone service has a smaller exposed surface area, compared with code in a traditional monolith.</span></span> <span data-ttu-id="6770d-201">Ha egy helyen az osztály a Drone szolgáltatás, a hatókör osztály korlátozódik &mdash; egyetlen más szolgáltatás közvetlenül fog felhasználni a osztály.</span><span class="sxs-lookup"><span data-stu-id="6770d-201">If the Drone service defines a Location class, the scope of that class is limited &mdash; no other service will directly consume the class.</span></span>

<span data-ttu-id="6770d-202">Ebből kifolyólag ez az útmutató nem összpontosítani nagy részét a kódolási módszereket is, mivel a taktikai DDD-minták kapcsolódnak.</span><span class="sxs-lookup"><span data-stu-id="6770d-202">For these reasons, this guidance doesn't focus much on coding practices as they relate to the tactical DDD patterns.</span></span> <span data-ttu-id="6770d-203">De azt tapasztaltuk, hogy is modellezheti számos, a DDD-minták – REST API-kon keresztül.</span><span class="sxs-lookup"><span data-stu-id="6770d-203">But it turns out that you can also model many of the DDD patterns through REST APIs.</span></span>

<span data-ttu-id="6770d-204">Példa:</span><span class="sxs-lookup"><span data-stu-id="6770d-204">For example:</span></span>

- <span data-ttu-id="6770d-205">Természetesen a térkép összesítések *erőforrások* a REST-ben.</span><span class="sxs-lookup"><span data-stu-id="6770d-205">Aggregates map naturally to *resources* in REST.</span></span> <span data-ttu-id="6770d-206">Például a Tartalomkézbesítési összesítés lenne kell által elérhetővé tett erőforrásként a kézbesítési API.</span><span class="sxs-lookup"><span data-stu-id="6770d-206">For example, the Delivery aggregate would be exposed as a resource by the Delivery API.</span></span>

- <span data-ttu-id="6770d-207">Összesítések konzisztencia határok.</span><span class="sxs-lookup"><span data-stu-id="6770d-207">Aggregates are consistency boundaries.</span></span> <span data-ttu-id="6770d-208">Műveletek az összesítések soha nem hagyja aggregátum inkonzisztens állapotban.</span><span class="sxs-lookup"><span data-stu-id="6770d-208">Operations on aggregates should never leave an aggregate in an inconsistent state.</span></span> <span data-ttu-id="6770d-209">Ezért kerülje létrehozása API-k, amelyek lehetővé teszik az ügyfél segítségével kezelheti a belső állapotot az összesítést.</span><span class="sxs-lookup"><span data-stu-id="6770d-209">Therefore, you should avoid creating APIs that allow a client to manipulate the internal state of an aggregate.</span></span> <span data-ttu-id="6770d-210">Ehelyett alkalmazást coarse-grained API-k, amelyek összesítések erőforrásként teszik közzé.</span><span class="sxs-lookup"><span data-stu-id="6770d-210">Instead, favor coarse-grained APIs that expose aggregates as resources.</span></span>

- <span data-ttu-id="6770d-211">Az entitásnak egyedi azonosítói.</span><span class="sxs-lookup"><span data-stu-id="6770d-211">Entities have unique identities.</span></span> <span data-ttu-id="6770d-212">REST, az erőforrások URL-címek formájában egyedi azonosítók rendelkeznek.</span><span class="sxs-lookup"><span data-stu-id="6770d-212">In REST, resources have unique identifiers in the form of URLs.</span></span> <span data-ttu-id="6770d-213">Erőforrás URL-címek, amelyek megfelelnek egy entitás tartomány identitás létrehozása.</span><span class="sxs-lookup"><span data-stu-id="6770d-213">Create resource URLs that correspond to an entity's domain identity.</span></span> <span data-ttu-id="6770d-214">Előfordulhat, hogy a tartomány identitás URL-címről a hozzárendelést átlátszatlan ügyfélnek.</span><span class="sxs-lookup"><span data-stu-id="6770d-214">The mapping from URL to domain identity may be opaque to client.</span></span>

- <span data-ttu-id="6770d-215">Gyermekentitások az összesítést a gyökérszintű entitás navigálva érhető el.</span><span class="sxs-lookup"><span data-stu-id="6770d-215">Child entities of an aggregate can be reached by navigating from the root entity.</span></span> <span data-ttu-id="6770d-216">Ha követi [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS) elvek, gyermekentitások is ügyfélszolgálatán keresztül érhető el a szülőentitás reprezentációja hivatkozásokat.</span><span class="sxs-lookup"><span data-stu-id="6770d-216">If you follow [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS) principles, child entities can be reached via links in the representation of the parent entity.</span></span>

- <span data-ttu-id="6770d-217">Érték objektumok nem módosíthatók, mert a frissítések a teljes értéket objektum lecserélésével történik.</span><span class="sxs-lookup"><span data-stu-id="6770d-217">Because value objects are immutable, updates are performed by replacing the entire value object.</span></span> <span data-ttu-id="6770d-218">REST, a megvalósítása a PUT vagy PATCH-kérések frissítéseit.</span><span class="sxs-lookup"><span data-stu-id="6770d-218">In REST, implement updates through PUT or PATCH requests.</span></span>

- <span data-ttu-id="6770d-219">Egy adattár lehetővé teszi, hogy az ügyfelek lekérdezés hozzáadása vagy eltávolítása az objektumok egy gyűjteményben paltformfüggetlen az alapul szolgáló adattár részletei.</span><span class="sxs-lookup"><span data-stu-id="6770d-219">A repository lets clients query, add, or remove objects in a collection, abstracting the details of the underlying data store.</span></span> <span data-ttu-id="6770d-220">REST egy gyűjtemény lehet egy egyedi erőforrást, módszerekkel, a gyűjtemény lekérdezése vagy új entitásokat ad hozzá a gyűjteményhez.</span><span class="sxs-lookup"><span data-stu-id="6770d-220">In REST, a collection can be a distinct resource, with methods for querying the collection or adding new entities to the collection.</span></span>

<span data-ttu-id="6770d-221">Az API-k tervezésekor gondolja át hogyan, express, hogy a tartományi modellben, nem csak az adatokat a modellben, de is az üzleti műveletek és a megkötések az adatokon belül.</span><span class="sxs-lookup"><span data-stu-id="6770d-221">When you design your APIs, think about how they express the domain model, not just the data inside the model, but also the business operations and the constraints on the data.</span></span>

| <span data-ttu-id="6770d-222">DDD fogalma</span><span class="sxs-lookup"><span data-stu-id="6770d-222">DDD concept</span></span> | <span data-ttu-id="6770d-223">REST-megfelelője</span><span class="sxs-lookup"><span data-stu-id="6770d-223">REST equivalent</span></span> | <span data-ttu-id="6770d-224">Példa</span><span class="sxs-lookup"><span data-stu-id="6770d-224">Example</span></span> |
|-------------|-----------------|---------|
| <span data-ttu-id="6770d-225">Aggregálás</span><span class="sxs-lookup"><span data-stu-id="6770d-225">Aggregate</span></span> | <span data-ttu-id="6770d-226">Erőforrás</span><span class="sxs-lookup"><span data-stu-id="6770d-226">Resource</span></span> | `{ "1":1234, "status":"pending"... }` |
| <span data-ttu-id="6770d-227">Identitás</span><span class="sxs-lookup"><span data-stu-id="6770d-227">Identity</span></span> | <span data-ttu-id="6770d-228">URL-cím</span><span class="sxs-lookup"><span data-stu-id="6770d-228">URL</span></span> | `https://delivery-service/deliveries/1` |
| <span data-ttu-id="6770d-229">Gyermekentitások</span><span class="sxs-lookup"><span data-stu-id="6770d-229">Child entities</span></span> | <span data-ttu-id="6770d-230">Hivatkozások</span><span class="sxs-lookup"><span data-stu-id="6770d-230">Links</span></span> | `{ "href": "/deliveries/1/confirmation" }` |
| <span data-ttu-id="6770d-231">Érték objektumok</span><span class="sxs-lookup"><span data-stu-id="6770d-231">Update value objects</span></span> | <span data-ttu-id="6770d-232">PUT vagy PATCH</span><span class="sxs-lookup"><span data-stu-id="6770d-232">PUT or PATCH</span></span> | `PUT https://delivery-service/deliveries/1/dropoff` |
| <span data-ttu-id="6770d-233">Tárház</span><span class="sxs-lookup"><span data-stu-id="6770d-233">Repository</span></span> | <span data-ttu-id="6770d-234">Gyűjtemény</span><span class="sxs-lookup"><span data-stu-id="6770d-234">Collection</span></span> | `https://delivery-service/deliveries?status=pending` |

## <a name="api-versioning"></a><span data-ttu-id="6770d-235">API-verziószámozás</span><span class="sxs-lookup"><span data-stu-id="6770d-235">API versioning</span></span>

<span data-ttu-id="6770d-236">Egy API-ját egy szolgáltatás és -ügyfelek vagy ügyfél között.</span><span class="sxs-lookup"><span data-stu-id="6770d-236">An API is a contract between a service and clients or consumers of that service.</span></span> <span data-ttu-id="6770d-237">Ha egy API megváltozik, akkor annak a kockázata, az API-t, a függő ügyfelek használhatatlanná tévő azokat, hogy-e külső ügyfelek vagy egyéb mikroszolgáltatás-alapú.</span><span class="sxs-lookup"><span data-stu-id="6770d-237">If an API changes, there is a risk of breaking clients that depend on the API, whether those are external clients or other microservices.</span></span> <span data-ttu-id="6770d-238">Emiatt tanácsos API módosításai számának csökkentése érdekében.</span><span class="sxs-lookup"><span data-stu-id="6770d-238">Therefore, it's a good idea to minimize the number of API changes that you make.</span></span> <span data-ttu-id="6770d-239">Az alapul szolgáló implementációs változásait gyakran, nem szükséges módosítania kellene az API-t.</span><span class="sxs-lookup"><span data-stu-id="6770d-239">Often, changes in the underlying implementation don't require any changes to the API.</span></span> <span data-ttu-id="6770d-240">Reálisan azonban bizonyos ponton célszerű új funkciók vagy módosítása egy meglévő API-t igénylő új képességek hozzáadása.</span><span class="sxs-lookup"><span data-stu-id="6770d-240">Realistically, however, at some point you will want to add new features or new capabilities that require changing an existing API.</span></span>

<span data-ttu-id="6770d-241">Lehetséges, ellenőrizze API minden alkalommal, amikor megváltozik a visszamenőlegesen kompatibilis.</span><span class="sxs-lookup"><span data-stu-id="6770d-241">Whenever possible, make API changes backward compatible.</span></span> <span data-ttu-id="6770d-242">Például ne eltávolítása egy mezőt a modellből, mert, hogy az ügyfelek, amelyek hatással vannak a mező nincs, azzal.</span><span class="sxs-lookup"><span data-stu-id="6770d-242">For example, avoid removing a field from a model, because that can break clients that expect the field to be there.</span></span> <span data-ttu-id="6770d-243">Mező hozzáadása tilos megszüntetnie kompatibilitási, mert az ügyfél figyelmen kívül hagyja a válasz nem ismerik mezőket.</span><span class="sxs-lookup"><span data-stu-id="6770d-243">Adding a field does not break compatibility, because clients should ignore any fields they don't understand in a response.</span></span> <span data-ttu-id="6770d-244">A szolgáltatás azonban a helyzet, amelyben egy régebbi ügyfél az áttekinthetőség kedvéért kihagyja az új mezőt a kérelem kell kezelnie.</span><span class="sxs-lookup"><span data-stu-id="6770d-244">However, the service must handle the case where an older client omits the new field in a request.</span></span>

<span data-ttu-id="6770d-245">Verziókezelés támogatja az API-szerződés.</span><span class="sxs-lookup"><span data-stu-id="6770d-245">Support versioning in your API contract.</span></span> <span data-ttu-id="6770d-246">Ha egy API-t használhatatlanná tévő változást, vezessen be egy új API-verzió.</span><span class="sxs-lookup"><span data-stu-id="6770d-246">If you introduce a breaking API change, introduce a new API version.</span></span> <span data-ttu-id="6770d-247">Továbbra is támogatja a korábbi verziót, és megadásakor az ügyfelek mely meghívásához-verziónak a kiválasztása.</span><span class="sxs-lookup"><span data-stu-id="6770d-247">Continue to support the previous version, and let clients select which version to call.</span></span> <span data-ttu-id="6770d-248">Nincsenek ehhez többféleképpen.</span><span class="sxs-lookup"><span data-stu-id="6770d-248">There are a couple of ways to do this.</span></span> <span data-ttu-id="6770d-249">Egyik egyszerűen elérhetővé mindkét verziót, egyazon szolgáltatáson belül.</span><span class="sxs-lookup"><span data-stu-id="6770d-249">One is simply to expose both versions in the same service.</span></span> <span data-ttu-id="6770d-250">Egy másik lehetőség, hogy a szolgáltatás egymás melletti két verzióját futtassa, és irányíthatja a kérelmeket az egyik vagy a más verziót, HTTP-útválasztási szabályok alapján.</span><span class="sxs-lookup"><span data-stu-id="6770d-250">Another option is to run two versions of the service side-by-side, and route requests to one or the other version, based on HTTP routing rules.</span></span>

![Verziókezelés](./images/versioning1.svg)

<span data-ttu-id="6770d-252">Nincs több verzió, fejlesztői idő, a tesztelés és üzemeltetési terheit támogató díjat fizetni.</span><span class="sxs-lookup"><span data-stu-id="6770d-252">There's a cost to supporting multiple versions, in terms of developer time, testing, and operational overhead.</span></span> <span data-ttu-id="6770d-253">Ezért, fontos a lehető leggyorsabban kivezetjük a régi verziók.</span><span class="sxs-lookup"><span data-stu-id="6770d-253">Therefore, it's good to deprecate old versions as quickly as possible.</span></span> <span data-ttu-id="6770d-254">A belső API-k az API-t birtokló csoport más csapatokkal, amelyekkel az új verzióra történő migrálása is dolgozhat.</span><span class="sxs-lookup"><span data-stu-id="6770d-254">For internal APIs, the team that owns the API can work with other teams to help them migrate to the new version.</span></span> <span data-ttu-id="6770d-255">Ez akkor, ha a fejlesztőcsapatok közötti cégirányítási folyamat kellene hasznos.</span><span class="sxs-lookup"><span data-stu-id="6770d-255">This is when having a cross-team governance process is useful.</span></span> <span data-ttu-id="6770d-256">A külső (nyilvános) API-k azok nehezebben kivezetjük az API-verziót, különösen akkor, ha az API a natív ügyfélalkalmazások vagy harmadik fél által felhasznált.</span><span class="sxs-lookup"><span data-stu-id="6770d-256">For external (public) APIs, it can be harder to deprecate an API version, especially if the API is consumed by third parties or by native client applications.</span></span>

<span data-ttu-id="6770d-257">Ha a szolgáltatás megvalósítása módosításait, hasznos címkézése a módosítás verzióját.</span><span class="sxs-lookup"><span data-stu-id="6770d-257">When a service implementation changes, it's useful to tag the change with a version.</span></span> <span data-ttu-id="6770d-258">A verzió fontos információkat tartalmaz a hibák elhárítása során.</span><span class="sxs-lookup"><span data-stu-id="6770d-258">The version provides important information when troubleshooting errors.</span></span> <span data-ttu-id="6770d-259">A kiváltó okok elemzését tudni, hogy pontosan a szolgáltatás melyik verziója lett meghívva nagyon hasznos lehet.</span><span class="sxs-lookup"><span data-stu-id="6770d-259">It can be very helpful for root cause analysis to know exactly which version of the service was called.</span></span> <span data-ttu-id="6770d-260">Fontolja meg [Szemantikus verziószámozást](https://semver.org/) esetében.</span><span class="sxs-lookup"><span data-stu-id="6770d-260">Consider using [semantic versioning](https://semver.org/) for service versions.</span></span> <span data-ttu-id="6770d-261">Szemantikus verziószámozást használ egy *jelentős. KISEBB. JAVÍTÁS* formátumban.</span><span class="sxs-lookup"><span data-stu-id="6770d-261">Semantic versioning uses a *MAJOR.MINOR.PATCH* format.</span></span> <span data-ttu-id="6770d-262">Azonban az ügyfelek csak válassza a fő verziószáma, vagy esetleg a alverzió API van-e jelentős (de nem kompatibilitástörő) változások alverziót között.</span><span class="sxs-lookup"><span data-stu-id="6770d-262">However, clients should only select an API by the major version number, or possibly the minor version if there are significant (but non-breaking) changes between minor versions.</span></span> <span data-ttu-id="6770d-263">Más szóval, akkor ésszerű-ügyfelek 1-es és 2-es verziójú API-választhat, de nem 2.1.3-verziónak a kiválasztása.</span><span class="sxs-lookup"><span data-stu-id="6770d-263">In other words, it's reasonable for clients to select between version 1 and version 2 of an API, but not to select version 2.1.3.</span></span> <span data-ttu-id="6770d-264">Ha engedélyezi a részletesség szintjét, kockázati, nem kell egy elterjedése verziókat támogatja.</span><span class="sxs-lookup"><span data-stu-id="6770d-264">If you allow that level of granularity, you risk having to support a proliferation of versions.</span></span>

<span data-ttu-id="6770d-265">Az API-k verziókezelése további leírását lásd: [Versioning webes RESTful API](../best-practices/api-design.md#versioning-a-restful-web-api).</span><span class="sxs-lookup"><span data-stu-id="6770d-265">For further discussion of API versioning, see [Versioning a RESTful web API](../best-practices/api-design.md#versioning-a-restful-web-api).</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="6770d-266">Adatfeldolgozás és munkafolyamatok</span><span class="sxs-lookup"><span data-stu-id="6770d-266">Ingestion and workflow</span></span>](./ingestion-workflow.md)
