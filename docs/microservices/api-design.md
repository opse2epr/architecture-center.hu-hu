---
title: API-tervezés
description: API-k a mikroszolgáltatások tervezése
author: MikeWasson
ms.date: 12/08/2017
ms.openlocfilehash: d85407f3092ddb5f77aacfea8def2784c4741eb9
ms.sourcegitcommit: 786bafefc731245414c3c1510fc21027afe303dc
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 12/12/2017
---
# <a name="designing-microservices-api-design"></a><span data-ttu-id="42aa7-103">Mikroszolgáltatások tervezése: API-Tervező</span><span class="sxs-lookup"><span data-stu-id="42aa7-103">Designing microservices: API design</span></span>

<span data-ttu-id="42aa7-104">Tervezési API fontos mikroszolgáltatások architektúra esetén, mert az összes adatcsere-szolgáltatások közötti üzenetek, illetve az API-hívásokban keresztül történik.</span><span class="sxs-lookup"><span data-stu-id="42aa7-104">Good API design is important in a microservices architecture, because all data exchange between services happens either through messages or API calls.</span></span> <span data-ttu-id="42aa7-105">Lehet, hogy API-k hatékony, hogy ne hozzon létre [chatty i/o](../antipatterns/chatty-io/index.md).</span><span class="sxs-lookup"><span data-stu-id="42aa7-105">APIs must be efficient to avoid creating [chatty I/O](../antipatterns/chatty-io/index.md).</span></span> <span data-ttu-id="42aa7-106">Szolgáltatásait Önre terveztük csoportok egymástól függetlenül működik, mert API-k rendelkeznie jól meghatározott szemantikáját és versioning rendszerek, úgy, hogy a frissítések ne szakítsa egyéb szolgáltatásokat.</span><span class="sxs-lookup"><span data-stu-id="42aa7-106">Because services are designed by teams working independently, APIs must have well-defined semantics and versioning schemes, so that updates don't break other services.</span></span>

![](./images/api-design.png)

<span data-ttu-id="42aa7-107">Fontos, hogy API kétféle megkülönböztetni:</span><span class="sxs-lookup"><span data-stu-id="42aa7-107">It's important to distinguish between two types of API:</span></span>

- <span data-ttu-id="42aa7-108">Nyilvános API-ügyfélalkalmazások hívható meg.</span><span class="sxs-lookup"><span data-stu-id="42aa7-108">Public APIs that client applications call.</span></span> 
- <span data-ttu-id="42aa7-109">Háttér értekezleteire kommunikációhoz használt API-k.</span><span class="sxs-lookup"><span data-stu-id="42aa7-109">Backend APIs that are used for interservice communication.</span></span>

<span data-ttu-id="42aa7-110">E két használati esetek némileg különböző követelményekkel rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="42aa7-110">These two use cases have somewhat different requirements.</span></span> <span data-ttu-id="42aa7-111">A nyilvános API ügyfélalkalmazások, általában böngészőalkalmazásokban vagy natív mobilalkalmazások kompatibilisnek kell lennie.</span><span class="sxs-lookup"><span data-stu-id="42aa7-111">A public API must be compatible with client applications, typically browser applications or native mobile applications.</span></span> <span data-ttu-id="42aa7-112">Az esetek többségében, amely azt jelenti, hogy a nyilvános API-t fogja használni a többi HTTP Protokollon keresztül.</span><span class="sxs-lookup"><span data-stu-id="42aa7-112">Most of the time, that means the public API will use REST over HTTP.</span></span> <span data-ttu-id="42aa7-113">A háttérkiszolgáló API-kat azonban meg kell tennie a hálózati teljesítmény figyelembe.</span><span class="sxs-lookup"><span data-stu-id="42aa7-113">For the backend APIs, however, you need to take network performance into account.</span></span> <span data-ttu-id="42aa7-114">Attól függően, hogy a szolgáltatások granularitásán értekezleteire kommunikációs nagy mennyiségű hálózati forgalmat eredményezhet.</span><span class="sxs-lookup"><span data-stu-id="42aa7-114">Depending on the granularity of your services, interservice communication can result in a lot of network traffic.</span></span> <span data-ttu-id="42aa7-115">Szolgáltatások vehet i/o kötött.</span><span class="sxs-lookup"><span data-stu-id="42aa7-115">Services can quickly become I/O bound.</span></span> <span data-ttu-id="42aa7-116">Ezért például szerializálási sebesség és a tartalom szempontok fontosabb válik.</span><span class="sxs-lookup"><span data-stu-id="42aa7-116">For that reason, considerations such as serialization speed and payload size become more important.</span></span> <span data-ttu-id="42aa7-117">Néhány népszerű más REST HTTP Protokollon keresztül gRPC, Apache Avro és Apache Thrift tartalmazza.</span><span class="sxs-lookup"><span data-stu-id="42aa7-117">Some popular alternatives to using REST over HTTP include gRPC, Apache Avro, and Apache Thrift.</span></span> <span data-ttu-id="42aa7-118">Ezeket a protokollokat támogatja a bináris szerializálást, és amelyek általában hatékonyabb, mint a HTTP.</span><span class="sxs-lookup"><span data-stu-id="42aa7-118">These protocols support binary serialization and are generally more efficient than HTTP.</span></span>

## <a name="considerations"></a><span data-ttu-id="42aa7-119">Megfontolandó szempontok</span><span class="sxs-lookup"><span data-stu-id="42aa7-119">Considerations</span></span>

<span data-ttu-id="42aa7-120">Az alábbiakban néhány dolgot gondolja át az API-k megvalósítása kiválasztásakor.</span><span class="sxs-lookup"><span data-stu-id="42aa7-120">Here are some things to think about when choosing how to implement an API.</span></span>

<span data-ttu-id="42aa7-121">**REST vs RPC**.</span><span class="sxs-lookup"><span data-stu-id="42aa7-121">**REST vs RPC**.</span></span> <span data-ttu-id="42aa7-122">Vegye figyelembe a mellékhatásokkal RPC stílusú illesztőfelület és egy REST-stílusú felület használata között.</span><span class="sxs-lookup"><span data-stu-id="42aa7-122">Consider the tradeoffs between using a REST-style interface versus an RPC-style interface.</span></span>

- <span data-ttu-id="42aa7-123">REST-modellek erőforrásokat, amelyek természetes mód a modell express.</span><span class="sxs-lookup"><span data-stu-id="42aa7-123">REST models resources, which can be a natural way express your domain model.</span></span> <span data-ttu-id="42aa7-124">Egy egységes felületet alapján a HTTP-műveleteket, amelyek könnyen létrejöhetnek evolvability határoz meg.</span><span class="sxs-lookup"><span data-stu-id="42aa7-124">It defines a uniform interface based on HTTP verbs, which encourages evolvability.</span></span> <span data-ttu-id="42aa7-125">Jól meghatározott szemantikáját idempotencia, hatásai és válaszkódot rendelkezik.</span><span class="sxs-lookup"><span data-stu-id="42aa7-125">It has well-defined semantics in terms of idempotency, side effects, and response codes.</span></span> <span data-ttu-id="42aa7-126">És érvényesíti a állapot nélküli kommunikációhoz, fejleszti a méretezhetőséget.</span><span class="sxs-lookup"><span data-stu-id="42aa7-126">And it enforces stateless communication, which improves scalability.</span></span> 

- <span data-ttu-id="42aa7-127">RPC több célú műveletek vagy parancsok körül.</span><span class="sxs-lookup"><span data-stu-id="42aa7-127">RPC is more oriented around operations or commands.</span></span> <span data-ttu-id="42aa7-128">RPC felületek néz helyi metódushívások, mert túlságosan chatty API-k alakíthat okozhatja.</span><span class="sxs-lookup"><span data-stu-id="42aa7-128">Because RPC interfaces look like local method calls, it may lead you to design overly chatty APIs.</span></span> <span data-ttu-id="42aa7-129">Azonban, hogy nem jelenti azt RPC chatty kell lennie.</span><span class="sxs-lookup"><span data-stu-id="42aa7-129">However, that doesn't mean RPC must be chatty.</span></span> <span data-ttu-id="42aa7-130">Csak akkor kell használni a figyelmet a felület tervezésekor.</span><span class="sxs-lookup"><span data-stu-id="42aa7-130">It just means you need to use care when designing the interface.</span></span>

<span data-ttu-id="42aa7-131">Egy RESTful felület esetében a leggyakrabban használt rendszer REST JSON használatával HTTP Protokollon keresztül.</span><span class="sxs-lookup"><span data-stu-id="42aa7-131">For a RESTful interface, the most common choice is REST over HTTP using JSON.</span></span> <span data-ttu-id="42aa7-132">Egy RPC-style felület számos népszerű keretrendszerekre, beleértve a gRPC, Apache Avro és Apache Thrift vannak.</span><span class="sxs-lookup"><span data-stu-id="42aa7-132">For an RPC-style interface, there are several popular frameworks, including gRPC, Apache  Avro, and Apache Thrift.</span></span>

<span data-ttu-id="42aa7-133">**Hatékonyságát**.</span><span class="sxs-lookup"><span data-stu-id="42aa7-133">**Efficiency**.</span></span> <span data-ttu-id="42aa7-134">Vegye figyelembe a hatékonyság sebességét, a memória és a tartalom mérete tekintetében.</span><span class="sxs-lookup"><span data-stu-id="42aa7-134">Consider efficiency in terms of speed, memory, and payload size.</span></span> <span data-ttu-id="42aa7-135">A gRPC-alapú felület általában gyorsabb, mint a többi HTTP Protokollon keresztül.</span><span class="sxs-lookup"><span data-stu-id="42aa7-135">Typically a gRPC-based interface is faster than REST over HTTP.</span></span>

<span data-ttu-id="42aa7-136">**Illesztő definíciójának nyelven (IDL)**.</span><span class="sxs-lookup"><span data-stu-id="42aa7-136">**Interface definition language (IDL)**.</span></span> <span data-ttu-id="42aa7-137">Egy IDL határozza meg a metódusok paramétereit, és visszatérési értékek egy API segítségével.</span><span class="sxs-lookup"><span data-stu-id="42aa7-137">An IDL is used to define the methods, parameters, and return values of an API.</span></span> <span data-ttu-id="42aa7-138">Egy IDL ügyfélkódot, a szerializálási kód és az API-JÁNAK dokumentációja létrehozásához használható.</span><span class="sxs-lookup"><span data-stu-id="42aa7-138">An IDL can be used to generate client code, serialization code, and API documentation.</span></span> <span data-ttu-id="42aa7-139">Tesztelési eszközöket, például a Postman API is képes használni IDLs.</span><span class="sxs-lookup"><span data-stu-id="42aa7-139">IDLs can also be consumed by API testing tools such as Postman.</span></span> <span data-ttu-id="42aa7-140">Keretrendszerek, például a gRPC Avro és Thrift saját IDL specifikációk meghatározása.</span><span class="sxs-lookup"><span data-stu-id="42aa7-140">Frameworks such as gRPC, Avro, and Thrift define their own IDL specifications.</span></span> <span data-ttu-id="42aa7-141">HTTP Protokollon keresztül REST nincs szabványos IDL formátumban, de egy közös választott OpenAPI (korábbi nevén Swagger).</span><span class="sxs-lookup"><span data-stu-id="42aa7-141">REST over HTTP does not have a standard IDL format, but a common choice is OpenAPI (formerly Swagger).</span></span> <span data-ttu-id="42aa7-142">Egy HTTP REST API műveletek formális definíciója nyelv használata nélkül is létrehozhat, de a kód létrehozását és tesztelését előnyeit elvesznek majd.</span><span class="sxs-lookup"><span data-stu-id="42aa7-142">You can also create an HTTP REST API without using a formal definition language, but then you lose the benefits of code generation and testing.</span></span>

<span data-ttu-id="42aa7-143">**Szerializálási**.</span><span class="sxs-lookup"><span data-stu-id="42aa7-143">**Serialization**.</span></span> <span data-ttu-id="42aa7-144">Hogyan objektumok szerializálva vannak a hálózaton?</span><span class="sxs-lookup"><span data-stu-id="42aa7-144">How are objects serialized over the wire?</span></span> <span data-ttu-id="42aa7-145">A választható lehetőségek szöveges formátumban (elsősorban JSON) vagy bináris formátumban, például a protokoll puffer.</span><span class="sxs-lookup"><span data-stu-id="42aa7-145">Options include text-based formats (primarily JSON) and binary formats such as protocol buffer.</span></span> <span data-ttu-id="42aa7-146">Bináris formátuma nem általában gyorsabb, mint a szöveges formátumú.</span><span class="sxs-lookup"><span data-stu-id="42aa7-146">Binary formats are generally faster than text-based formats.</span></span> <span data-ttu-id="42aa7-147">Azonban JSON előnye is van tekintetében együttműködési képesség, mivel a legtöbb nyelv és keretrendszer támogatja a JSON-szerializálást.</span><span class="sxs-lookup"><span data-stu-id="42aa7-147">However, JSON has advantages in terms of interoperability, because most languages and frameworks support JSON serialization.</span></span> <span data-ttu-id="42aa7-148">Némelyik szerializálási formátum van szükség egy rögzített sémájába, és néhány fájl fordítása.</span><span class="sxs-lookup"><span data-stu-id="42aa7-148">Some serialization formats require a fixed schema, and some require compiling a schema definition file.</span></span> <span data-ttu-id="42aa7-149">Ebben az esetben szüksége lesz a felépítési folyamat funkcióját beépítse ezt a lépést.</span><span class="sxs-lookup"><span data-stu-id="42aa7-149">In that case, you'll need to incorporate this step into your build process.</span></span> 

<span data-ttu-id="42aa7-150">**Keretrendszer és a nyelvi támogatás**.</span><span class="sxs-lookup"><span data-stu-id="42aa7-150">**Framework and language support**.</span></span> <span data-ttu-id="42aa7-151">A HTTP szinte minden keretrendszer és a nyelv támogatott.</span><span class="sxs-lookup"><span data-stu-id="42aa7-151">HTTP is supported in nearly every framework and language.</span></span> <span data-ttu-id="42aa7-152">gRPC, Avro és Thrift összes van szalagtárak C++, C#, Java és Python.</span><span class="sxs-lookup"><span data-stu-id="42aa7-152">gRPC, Avro, and Thrift all have libraries for C++, C#, Java, and Python.</span></span> <span data-ttu-id="42aa7-153">Thrift és gRPC is támogatja a nyissa meg.</span><span class="sxs-lookup"><span data-stu-id="42aa7-153">Thrift and gRPC also support Go.</span></span> 

<span data-ttu-id="42aa7-154">**Kompatibilitás és együttműködés**.</span><span class="sxs-lookup"><span data-stu-id="42aa7-154">**Compatibility and interoperability**.</span></span> <span data-ttu-id="42aa7-155">Ha például a gRPC protokoll, szükség lehet a fordítási réteg protokoll a nyilvános API és a háttérrendszer között.</span><span class="sxs-lookup"><span data-stu-id="42aa7-155">If you choose a protocol like gRPC, you may need a protocol translation layer between the public API and the back end.</span></span> <span data-ttu-id="42aa7-156">A [átjáró](./gateway.md) is, hogy a művelet végrehajtására szolgál(nak).</span><span class="sxs-lookup"><span data-stu-id="42aa7-156">A [gateway](./gateway.md) can perform that function.</span></span> <span data-ttu-id="42aa7-157">Ha szolgáltatás rácsvonal használ, fontolja meg, mely protokollok kompatibilisek-e a szolgáltatás háló.</span><span class="sxs-lookup"><span data-stu-id="42aa7-157">If you are using a service mesh, consider which protocols are compatible with the service mesh.</span></span> <span data-ttu-id="42aa7-158">Például linkerd rendelkezik HTTP Thrift és gRPC beépített támogatása.</span><span class="sxs-lookup"><span data-stu-id="42aa7-158">For example, linkerd has built-in support for HTTP, Thrift, and gRPC.</span></span> 

<span data-ttu-id="42aa7-159">Az alapkonfiguráció javasoljuk, hogy REST módot HTTP Protokollon keresztül, ha a bináris protokoll által van szüksége.</span><span class="sxs-lookup"><span data-stu-id="42aa7-159">Our baseline recommendation is to choose REST over HTTP unless you need the performance benefits of a binary protocol.</span></span> <span data-ttu-id="42aa7-160">HTTP Protokollon keresztül REST különleges függvénytárak igényel.</span><span class="sxs-lookup"><span data-stu-id="42aa7-160">REST over HTTP requires no special libraries.</span></span> <span data-ttu-id="42aa7-161">Létrehoz minimális kapcsolási, mert a hívó nem kell egy ügyfél helyettes a szolgáltatással való kommunikációra.</span><span class="sxs-lookup"><span data-stu-id="42aa7-161">It creates minimal coupling, because callers don't need a client stub to communicate with the service.</span></span> <span data-ttu-id="42aa7-162">Nincs gazdag ökoszisztéma eszközök sémadefiníciók, tesztelése és figyelése a RESTful HTTP-végpontok támogatásához.</span><span class="sxs-lookup"><span data-stu-id="42aa7-162">There is rich ecosystems of tools to support schema definitions, testing, and monitoring of RESTful HTTP endpoints.</span></span> <span data-ttu-id="42aa7-163">Végezetül HTTP összeegyeztethető webböngésző-ügyfelek számára, így nem kell az ügyfél és a háttérkiszolgáló közötti protokoll fordítási rétegben.</span><span class="sxs-lookup"><span data-stu-id="42aa7-163">Finally, HTTP is compatible with browser clients, so you don't need a protocol translation layer between the client and the backend.</span></span> 

<span data-ttu-id="42aa7-164">Azonban ha REST HTTP Protokollon keresztül, inkább hajtsa végre a teljesítmény és terheléses tesztelés korai szakaszában a fejlesztési folyamat, ellenőrizze, hogy elég esetén a forgatókönyv segítségével végzi.</span><span class="sxs-lookup"><span data-stu-id="42aa7-164">However, if you choose REST over HTTP, you should do performance and load testing early in the development process, to validate whether it performs well enough for your scenario.</span></span>

## <a name="restful-api-design"></a><span data-ttu-id="42aa7-165">RESTful API-Tervező</span><span class="sxs-lookup"><span data-stu-id="42aa7-165">RESTful API design</span></span>

<span data-ttu-id="42aa7-166">Nincsenek számos olyan forrás RESTful API-k tervezéséhez.</span><span class="sxs-lookup"><span data-stu-id="42aa7-166">There are many resources for designing RESTful APIs.</span></span> <span data-ttu-id="42aa7-167">Íme néhány hasznos előfordulhat:</span><span class="sxs-lookup"><span data-stu-id="42aa7-167">Here are some that you might find helpful:</span></span>

- [<span data-ttu-id="42aa7-168">API-Tervező</span><span class="sxs-lookup"><span data-stu-id="42aa7-168">API design</span></span>](../best-practices/api-design.md) 

- [<span data-ttu-id="42aa7-169">API-implementáció</span><span class="sxs-lookup"><span data-stu-id="42aa7-169">API implementation</span></span>](../best-practices/api-implementation.md) 

- [<span data-ttu-id="42aa7-170">Microsoft REST API-irányelvek</span><span class="sxs-lookup"><span data-stu-id="42aa7-170">Microsoft REST API Guidelines</span></span>](https://github.com/Microsoft/api-guidelines)

<span data-ttu-id="42aa7-171">Az alábbiakban néhány figyelembe kell venni bizonyos szem előtt tartani.</span><span class="sxs-lookup"><span data-stu-id="42aa7-171">Here are some specific considerations to keep in mind.</span></span>

- <span data-ttu-id="42aa7-172">Figyeljen az API-t szivárgás lépett fel, belső megvalósítás részletei vagy egy belső adatbázisséma egyszerűen tükrözik.</span><span class="sxs-lookup"><span data-stu-id="42aa7-172">Watch out for APIs that leak internal implementation details or simply mirror an internal database schema.</span></span> <span data-ttu-id="42aa7-173">Az API-t a tartomány kell modell.</span><span class="sxs-lookup"><span data-stu-id="42aa7-173">The API should model the domain.</span></span> <span data-ttu-id="42aa7-174">Szolgáltatások között, és amikor új funkciókat ad hozzá, nem csak, mert néhány kódot átkerült vagy egy adatbázis tábláinak normalizált ideális csak módosítsa.</span><span class="sxs-lookup"><span data-stu-id="42aa7-174">It's a contract between services, and ideally should only change when new functionality is added, not just because you refactored some code or normalized a database table.</span></span> 

- <span data-ttu-id="42aa7-175">Ügyfél, például a mobilalkalmazás- és asztali böngészőben, különböző típusú különböző hasznos méretek vagy interakció minták lehet szükség.</span><span class="sxs-lookup"><span data-stu-id="42aa7-175">Different types of client, such as mobile application and desktop web browser, may require different payload sizes or interaction patterns.</span></span> <span data-ttu-id="42aa7-176">Érdemes lehet a [Frontends minta háttérkiszolgálókon](../patterns/backends-for-frontends.md) külön háttérkiszolgálókon létrehozása az egyes ügyfelekhez, optimális illesztőfelület visszaállítását, hogy az ügyfélszámítógépek számára.</span><span class="sxs-lookup"><span data-stu-id="42aa7-176">Consider using the [Backends for Frontends pattern](../patterns/backends-for-frontends.md) to create separate backends for each client, that expose an optimal interface for that client.</span></span>

- <span data-ttu-id="42aa7-177">A mellékhatással működő műveleteket fontolja meg az idempotent minősítené, és azok PUT módszerként megvalósítását.</span><span class="sxs-lookup"><span data-stu-id="42aa7-177">For operations with side effects, consider making them idempotent and implementing them as PUT methods.</span></span> <span data-ttu-id="42aa7-178">Amely lehetővé teszi a biztonságos újrapróbálkozások, és javíthatja a rugalmasságot.</span><span class="sxs-lookup"><span data-stu-id="42aa7-178">That will enable safe retries and can improve resiliency.</span></span> <span data-ttu-id="42aa7-179">A fejezetek [adatfeldolgozást és a munkafolyamat](./ingestion-workflow.md#idempotent-vs-non-idempotent-operations) és [kommunikációs Interservice](./interservice-communication.md) probléma részletesebben ismertetik.</span><span class="sxs-lookup"><span data-stu-id="42aa7-179">The chapters [Ingestion and workflow](./ingestion-workflow.md#idempotent-vs-non-idempotent-operations) and [Interservice communication](./interservice-communication.md) discuss this issue in more detail.</span></span>

- <span data-ttu-id="42aa7-180">HTTP-metódus lehet aszinkron szemantikáját, amikor a metódus azonnal visszaadja a választ, de a szolgáltatás aszinkron módon végrehajtja a műveletet.</span><span class="sxs-lookup"><span data-stu-id="42aa7-180">HTTP methods can have asynchronous semantics, where the method returns a response immediately, but the service carries out the operation asynchronously.</span></span> <span data-ttu-id="42aa7-181">Ebben az esetben a metódus visszaadja-e egy [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) válaszkód, ami azt jelenti, hogy a kérés elfogadva feldolgozásra, de a feldolgozás nem fejeződött be.</span><span class="sxs-lookup"><span data-stu-id="42aa7-181">In that case, the method should return an [HTTP 202](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html) response code, which indicates the request was accepted for processing, but the processing is not yet completed.</span></span>

## <a name="mapping-rest-to-ddd-patterns"></a><span data-ttu-id="42aa7-182">REST leképezése DDD minták</span><span class="sxs-lookup"><span data-stu-id="42aa7-182">Mapping REST to DDD patterns</span></span>

<span data-ttu-id="42aa7-183">Például érték objektum, entitás vagy Összesítés minták úgy tervezték, hogy az objektumok bizonyos megkötéseknek helyez a modell.</span><span class="sxs-lookup"><span data-stu-id="42aa7-183">Patterns such as entity, aggregate, and value object are designed to place certain constraints on the objects in your domain model.</span></span> <span data-ttu-id="42aa7-184">Sok beszélgetéseket, DDD a minta van modellezve, objektumorientált (OO) nyelvi fogalmak például konstruktorok vagy tulajdonság beolvasókat és Setter elemek használatával.</span><span class="sxs-lookup"><span data-stu-id="42aa7-184">In many discussions of DDD, the patterns are modeled using object-oriented (OO) language concepts like constructors or property getters and setters.</span></span> <span data-ttu-id="42aa7-185">Például *objektumok érték* nem módosítható elvileg.</span><span class="sxs-lookup"><span data-stu-id="42aa7-185">For example, *value objects* are supposed to be immutable.</span></span> <span data-ttu-id="42aa7-186">Egy OO programozási nyelven szeretné kényszeríti Ez a konstruktor értékeket rendel, és a tulajdonságok csak olvasható:</span><span class="sxs-lookup"><span data-stu-id="42aa7-186">In an OO programming language, you would enforce this by assigning the values in the constructor and making the properties read-only:</span></span>

```ts
export class Location {
    readonly latitude: number;
    readonly longitude: number;

    constructor(latitude: number, longitude: number) {
        if (latitude < -90 || latitude > 90) {
            throw new RangeError('latitude must be between -90 and 90');
        }
        if (longitude < -180 || longitude > 180) {
            throw new RangeError('longitude must be between -180 and 180');
        }
        this.latitude = latitude;
        this.longitude = longitude;
    }
}
```

<span data-ttu-id="42aa7-187">Ezek rendezi a kódolási eljárások különösen fontosak, egy hagyományos egységes alkalmazás felépítése közben.</span><span class="sxs-lookup"><span data-stu-id="42aa7-187">These sorts of coding practices are particularly important when building a traditional monolithic application.</span></span> <span data-ttu-id="42aa7-188">A nagyméretű kódbázis, sok alrendszereket használhatja a `Location` objektum, ezért fontos az objektum helyes működése érvényesítését.</span><span class="sxs-lookup"><span data-stu-id="42aa7-188">With a large code base, many subsystems might use the `Location` object, so it's important for the object to enforce correct behavior.</span></span> 

<span data-ttu-id="42aa7-189">Egy másik példa a tárház mintát, amely biztosítja, hogy az alkalmazás egyéb elemeinek közvetlen olvasási vagy írási műveleteket ad ki az adatok tárolására ne:</span><span class="sxs-lookup"><span data-stu-id="42aa7-189">Another example is the Repository pattern, which ensures that other parts of the application do not make direct reads or writes to the data store:</span></span>

![](./images/repository.png)

<span data-ttu-id="42aa7-190">Mikroszolgáltatások architektúra esetén azonban szolgáltatások ne ossza meg az azonos kódbázisra és ne ossza meg adattárolókhoz.</span><span class="sxs-lookup"><span data-stu-id="42aa7-190">In a microservices architecture, however, services don't share the same code base and don't share data stores.</span></span> <span data-ttu-id="42aa7-191">Ehelyett kommunikáció API-k segítségével.</span><span class="sxs-lookup"><span data-stu-id="42aa7-191">Instead, they communicate through APIs.</span></span> <span data-ttu-id="42aa7-192">Vegye figyelembe az esetet, ahol a Feladatütemező szolgáltatás kéri le a dron szolgáltatás egy dron kapcsolatos információkat.</span><span class="sxs-lookup"><span data-stu-id="42aa7-192">Consider the case where the Scheduler service requests information about a drone from the Drone service.</span></span> <span data-ttu-id="42aa7-193">A dron szolgáltatás a belső egy dron kód kifejezett-modellhez tartozik.</span><span class="sxs-lookup"><span data-stu-id="42aa7-193">The Drone service has its internal model of a drone, expressed through code.</span></span> <span data-ttu-id="42aa7-194">De az ütemező, hogy nem látható.</span><span class="sxs-lookup"><span data-stu-id="42aa7-194">But the Scheduler doesn't see that.</span></span> <span data-ttu-id="42aa7-195">Ehelyett azt vissza lekérdezi egy *ábrázolását* dron entitás &mdash; lehet, hogy egy JSON-objektum a HTTP-válasz.</span><span class="sxs-lookup"><span data-stu-id="42aa7-195">Instead, it gets back a *representation* of the drone entity &mdash; perhaps a JSON object in an HTTP response.</span></span>

![](./images/ddd-rest.png)

<span data-ttu-id="42aa7-196">A Feladatütemező szolgáltatás nem módosítható a dron szolgáltatás belső modelljei vagy a dron szolgáltatás adattár írni.</span><span class="sxs-lookup"><span data-stu-id="42aa7-196">The Scheduler service can't modify the Drone service's internal models, or write to the Drone service's data store.</span></span> <span data-ttu-id="42aa7-197">Amely azt jelenti, hogy a kód a dron szolgáltatást kisebb kitett terület, a hagyományos monolit kód képest.</span><span class="sxs-lookup"><span data-stu-id="42aa7-197">That means the code that implements the Drone service has a smaller exposed surface area, compared with code in a traditional monolith.</span></span> <span data-ttu-id="42aa7-198">Ha a dron szolgáltatás helye definiálja, amely hatóköre korlátozódik &mdash; nincs más szolgáltatás közvetlenül fog használni az osztály.</span><span class="sxs-lookup"><span data-stu-id="42aa7-198">If the Drone service defines a Location class, the scope of that class is limited &mdash; no other service will directly consume the class.</span></span> 

<span data-ttu-id="42aa7-199">Ezen okok miatt ez az útmutató nem összpontosítson, nagy a kódolási eljárások, mivel taktikai DDD mintázatokat kapcsolódnak.</span><span class="sxs-lookup"><span data-stu-id="42aa7-199">For these reasons, this guidance doesn't focus much on coding practices as they relate to the tactical DDD patterns.</span></span> <span data-ttu-id="42aa7-200">De változik, hogy is modellezhető DDD mintázatokat REST API-k segítségével számos.</span><span class="sxs-lookup"><span data-stu-id="42aa7-200">But it turns out that you can also model many of the DDD patterns through REST APIs.</span></span> 

<span data-ttu-id="42aa7-201">Példa:</span><span class="sxs-lookup"><span data-stu-id="42aa7-201">For example:</span></span>

- <span data-ttu-id="42aa7-202">Összesíti a természetes leképezése *erőforrások* többi.</span><span class="sxs-lookup"><span data-stu-id="42aa7-202">Aggregates map naturally to *resources* in REST.</span></span> <span data-ttu-id="42aa7-203">Például a kézbesítési összesítés volna elérhetővé tehető erőforrásként a kézbesítési API.</span><span class="sxs-lookup"><span data-stu-id="42aa7-203">For example, the Delivery aggregate would be exposed as a resource by the Delivery API.</span></span>

- <span data-ttu-id="42aa7-204">Aggregátumok konzisztencia határok.</span><span class="sxs-lookup"><span data-stu-id="42aa7-204">Aggregates are consistency boundaries.</span></span> <span data-ttu-id="42aa7-205">Aggregátumok műveletek soha nem hagyja összesítő inkonzisztens állapotú.</span><span class="sxs-lookup"><span data-stu-id="42aa7-205">Operations on aggregates should never leave an aggregate in an inconsistent state.</span></span> <span data-ttu-id="42aa7-206">Ezért ne API-k, amelyek lehetővé teszik egy ügyfél segítségével kezelheti a belső állapotot, az összesítés létrehozásakor.</span><span class="sxs-lookup"><span data-stu-id="42aa7-206">Therefore, you should avoid creating APIs that allow a client to manipulate the internal state of an aggregate.</span></span> <span data-ttu-id="42aa7-207">Ehelyett alkalmazást coarse-grained API aggregátumok erőforrásként visszaállítását.</span><span class="sxs-lookup"><span data-stu-id="42aa7-207">Instead, favor coarse-grained APIs that expose aggregates as resources.</span></span>

- <span data-ttu-id="42aa7-208">Az entitásnak egyedi azonosítói.</span><span class="sxs-lookup"><span data-stu-id="42aa7-208">Entities have unique identities.</span></span> <span data-ttu-id="42aa7-209">A többi erőforrások URL-címek formájában egyedi azonosítói rendelkeznek.</span><span class="sxs-lookup"><span data-stu-id="42aa7-209">In REST, resources have unique identifiers in the form of URLs.</span></span> <span data-ttu-id="42aa7-210">Hozzon létre erőforrás URL-címek, amelyek megfelelnek egy entitás tartomány identitása.</span><span class="sxs-lookup"><span data-stu-id="42aa7-210">Create resource URLs that correspond to an entity's domain identity.</span></span> <span data-ttu-id="42aa7-211">Lehet, hogy a leképezés URL-cím a tartomány identitása nem átlátszó ügyfélnek.</span><span class="sxs-lookup"><span data-stu-id="42aa7-211">The mapping from URL to domain identity may be opaque to client.</span></span>

- <span data-ttu-id="42aa7-212">Gyermek entitások az összesítés a legfelső szintű entitásból útvonalon elérhető.</span><span class="sxs-lookup"><span data-stu-id="42aa7-212">Child entities of an aggregate can be reached by navigating from the root entity.</span></span> <span data-ttu-id="42aa7-213">Ha követi [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS) alapelvek, gyermek entitások elérhető a szülőentitás ábrázolását a kapcsolaton keresztül.</span><span class="sxs-lookup"><span data-stu-id="42aa7-213">If you follow [HATEOAS](https://en.wikipedia.org/wiki/HATEOAS) principles, child entities can be reached via links in the representation of the parent entity.</span></span> 

- <span data-ttu-id="42aa7-214">Érték objektumok nem módosíthatók, mert frissítések megtörténik a teljes érték objektum cseréli.</span><span class="sxs-lookup"><span data-stu-id="42aa7-214">Because value objects are immutable, updates are performed by replacing the entire value object.</span></span> <span data-ttu-id="42aa7-215">Többi PUT vagy javítás kéréseken keresztüli frissítések végrehajtása.</span><span class="sxs-lookup"><span data-stu-id="42aa7-215">In REST, implement updates through PUT or PATCH requests.</span></span> 

- <span data-ttu-id="42aa7-216">A tárház lehetővé teszi, hogy az ügyfelek lekérdezés, hozzáadhat és eltávolíthat objektumok egy gyűjtemény, absztrakt módon megjelenítve az alapul szolgáló adattár részleteit.</span><span class="sxs-lookup"><span data-stu-id="42aa7-216">A repository lets clients query, add, or remove objects in a collection, abstracting the details of the underlying data store.</span></span> <span data-ttu-id="42aa7-217">A többi egy gyűjtemény lehet különböző erőforrás, a gyűjtemény lekérdezése, illetve új entitásokat a gyűjteményhez való hozzáadása a.</span><span class="sxs-lookup"><span data-stu-id="42aa7-217">In REST, a collection can be a distinct resource, with methods for querying the collection or adding new entities to the collection.</span></span>

<span data-ttu-id="42aa7-218">Az API-k tervezésekor gondolniuk hogyan azok express a modell, nem csupán azokat az adatokat a modellt, de is az üzleti tevékenységre és a megkötések az adatokon belül.</span><span class="sxs-lookup"><span data-stu-id="42aa7-218">When you design your APIs, think about how they express the domain model, not just the data inside the model, but also the business operations and the constraints on the data.</span></span>

| <span data-ttu-id="42aa7-219">DDD koncepció</span><span class="sxs-lookup"><span data-stu-id="42aa7-219">DDD concept</span></span> | <span data-ttu-id="42aa7-220">REST-megfelelője</span><span class="sxs-lookup"><span data-stu-id="42aa7-220">REST equivalent</span></span> | <span data-ttu-id="42aa7-221">Példa</span><span class="sxs-lookup"><span data-stu-id="42aa7-221">Example</span></span> | 
|-------------|-----------------|---------|
| <span data-ttu-id="42aa7-222">Összesítés</span><span class="sxs-lookup"><span data-stu-id="42aa7-222">Aggregate</span></span> | <span data-ttu-id="42aa7-223">Erőforrás</span><span class="sxs-lookup"><span data-stu-id="42aa7-223">Resource</span></span> | `{ "1":1234, "status":"pending"... }` | 
| <span data-ttu-id="42aa7-224">Identitás</span><span class="sxs-lookup"><span data-stu-id="42aa7-224">Identity</span></span> | <span data-ttu-id="42aa7-225">URL</span><span class="sxs-lookup"><span data-stu-id="42aa7-225">URL</span></span> | `http://delivery-service/deliveries/1` |
| <span data-ttu-id="42aa7-226">Gyermek entitások</span><span class="sxs-lookup"><span data-stu-id="42aa7-226">Child entities</span></span> | <span data-ttu-id="42aa7-227">Hivatkozások</span><span class="sxs-lookup"><span data-stu-id="42aa7-227">Links</span></span> | `{ "href": "/deliveries/1/confirmation" }` |
| <span data-ttu-id="42aa7-228">Frissítési érték objektumok</span><span class="sxs-lookup"><span data-stu-id="42aa7-228">Update value objects</span></span> | <span data-ttu-id="42aa7-229">PUT vagy rendszerhez – javítás</span><span class="sxs-lookup"><span data-stu-id="42aa7-229">PUT or PATCH</span></span> | `PUT http://delivery-service/deliveries/1/dropoff` |
| <span data-ttu-id="42aa7-230">Tárház</span><span class="sxs-lookup"><span data-stu-id="42aa7-230">Repository</span></span> | <span data-ttu-id="42aa7-231">Gyűjtemény</span><span class="sxs-lookup"><span data-stu-id="42aa7-231">Collection</span></span> | `http://delivery-service/deliveries?status=pending` |


## <a name="api-versioning"></a><span data-ttu-id="42aa7-232">API-versioning</span><span class="sxs-lookup"><span data-stu-id="42aa7-232">API versioning</span></span>

<span data-ttu-id="42aa7-233">Az API-k egy szolgáltatás és az ügyfelek, illetve az adott szolgáltatás fogyasztóknak között.</span><span class="sxs-lookup"><span data-stu-id="42aa7-233">An API is a contract between a service and clients or consumers of that service.</span></span> <span data-ttu-id="42aa7-234">Ha megváltoztatja az API-k, fennáll a kockázata, az API-t, a függő ügyfelek megtörje van hogy külső ügyfelek vagy egyéb mikroszolgáltatások-e azokat.</span><span class="sxs-lookup"><span data-stu-id="42aa7-234">If an API changes, there is a risk of breaking clients that depend on the API, whether those are external clients or other microservices.</span></span> <span data-ttu-id="42aa7-235">Emiatt tanácsos API végrehajtott módosítások számának minimalizálása érdekében.</span><span class="sxs-lookup"><span data-stu-id="42aa7-235">Therefore, it's a good idea to minimize the number of API changes that you make.</span></span> <span data-ttu-id="42aa7-236">Az alapul szolgáló implementáció változásai gyakran, nem igényel módosításokat az az API-t.</span><span class="sxs-lookup"><span data-stu-id="42aa7-236">Often, changes in the underlying implementation don't require any changes to the API.</span></span> <span data-ttu-id="42aa7-237">Reálisan nézve azonban egy bizonyos ponton érdemes adja hozzá az új funkciók és egy meglévő API módosítását igénylő új képességek.</span><span class="sxs-lookup"><span data-stu-id="42aa7-237">Realistically, however, at some point you will want to add new features or new capabilities that require changing an existing API.</span></span>

<span data-ttu-id="42aa7-238">Lehetséges, ellenőrizze API, amikor megváltozik a visszamenőlegesen kompatibilis.</span><span class="sxs-lookup"><span data-stu-id="42aa7-238">Whenever possible, make API changes backward compatible.</span></span> <span data-ttu-id="42aa7-239">Például ne eltávolítása egy mezőt a modellből az ügyfelek, a mező nem várt, amely érvénytelenné mert.</span><span class="sxs-lookup"><span data-stu-id="42aa7-239">For example, avoid removing a field from a model, because that can break clients that expect the field to be there.</span></span> <span data-ttu-id="42aa7-240">Amikor felvettek egy mezőt nem törik kompatibilitási, mert az ügyfelek a válasz nem ismerniük mezőket figyelmen kívül hagyja.</span><span class="sxs-lookup"><span data-stu-id="42aa7-240">Adding a field does not break compatibility, because clients should ignore any fields they don't understand in a response.</span></span> <span data-ttu-id="42aa7-241">A szolgáltatás azonban kezelni kell az esetben, ha egy régebbi ügyfél kihagyja az új mező a kérelemben.</span><span class="sxs-lookup"><span data-stu-id="42aa7-241">However, the service must handle the case where an older client omits the new field in a request.</span></span> 

<span data-ttu-id="42aa7-242">Az API egyezmény versioning támogatja.</span><span class="sxs-lookup"><span data-stu-id="42aa7-242">Support versioning in your API contract.</span></span> <span data-ttu-id="42aa7-243">Ha API-t használhatatlanná tévő változást, akkor egy új API-verzió.</span><span class="sxs-lookup"><span data-stu-id="42aa7-243">If you introduce a breaking API change, introduce a new API version.</span></span> <span data-ttu-id="42aa7-244">Továbbra is támogatja a korábbi verziót, és engedélyezheti, hogy válassza ki, melyik verzióját hívására ügyfelek.</span><span class="sxs-lookup"><span data-stu-id="42aa7-244">Continue to support the previous version, and let clients select which version to call.</span></span> <span data-ttu-id="42aa7-245">Többféle módszer.</span><span class="sxs-lookup"><span data-stu-id="42aa7-245">There are a couple of ways to do this.</span></span> <span data-ttu-id="42aa7-246">Egyik egyszerűen teszi közzé a mindkét verziója ugyanazt a szolgáltatást.</span><span class="sxs-lookup"><span data-stu-id="42aa7-246">One is simply to expose both versions in the same service.</span></span> <span data-ttu-id="42aa7-247">Egy másik lehetőség, hogy a szolgáltatás-mellé két verzióit, és átirányíthatja kérelmek egyik vagy a más verziót, HTTP-útválasztási szabályok alapján.</span><span class="sxs-lookup"><span data-stu-id="42aa7-247">Another option is to run two versions of the service side-by-side, and route requests to one or the other version, based on HTTP routing rules.</span></span> 

![](./images/versioning1.svg)

<span data-ttu-id="42aa7-248">Nincs több verziót, fejlesztői idejét, a tesztelés és a működési munkaterhelés támogató költséget.</span><span class="sxs-lookup"><span data-stu-id="42aa7-248">There's a cost to supporting multiple versions, in terms of developer time, testing, and operational overhead.</span></span> <span data-ttu-id="42aa7-249">Ezért célszerű minél gyorsabban érvényteleníthető régi változatainak helyes.</span><span class="sxs-lookup"><span data-stu-id="42aa7-249">Therefore, it's good to deprecate old versions as quickly as possible.</span></span> <span data-ttu-id="42aa7-250">Belső API-k esetében az API-t birtokló csoport használható együtt más csapatokkal az segítséget nyújthatnak az új verziójára való áttérést.</span><span class="sxs-lookup"><span data-stu-id="42aa7-250">For internal APIs, the team that owns the API can work with other teams to help them migrate to the new version.</span></span> <span data-ttu-id="42aa7-251">Ez akkor, ha egy csoportközi irányítás folyamatot, akkor lehet hasznos.</span><span class="sxs-lookup"><span data-stu-id="42aa7-251">This is when having a cross-team governance process is useful.</span></span> <span data-ttu-id="42aa7-252">Külső (nyilvános) API-k esetében azok nehezebben érvényteleníthető az API-verziót, különösen akkor, ha az API-t natív ügyfélalkalmazások vagy harmadik felek által felhasznált.</span><span class="sxs-lookup"><span data-stu-id="42aa7-252">For external (public) APIs, it can be harder to deprecate an API version, especially if the API is consumed by third parties or by native client applications.</span></span> 

<span data-ttu-id="42aa7-253">A szolgáltatás megvalósítási változásokat esetén hasznos, ha szeretné, hogy a módosítás verziójával címkét.</span><span class="sxs-lookup"><span data-stu-id="42aa7-253">When a service implementation changes, it's useful to tag the change with a version.</span></span> <span data-ttu-id="42aa7-254">A verzió nyújtó fontos információkról, amikor kapcsolatos hibák elhárítása.</span><span class="sxs-lookup"><span data-stu-id="42aa7-254">The version provides important information when troubleshooting errors.</span></span> <span data-ttu-id="42aa7-255">A kiváltó okának elemzése tudni, hogy pontosan melyik verzióját a service hívták nagyon hasznos lehet.</span><span class="sxs-lookup"><span data-stu-id="42aa7-255">It can be very helpful for root cause analysis to know exactly which version of the service was called.</span></span> <span data-ttu-id="42aa7-256">Érdemes lehet [szemantikai versioning](https://semver.org/) szolgáltatás verzióihoz.</span><span class="sxs-lookup"><span data-stu-id="42aa7-256">Consider using [semantic versioning](https://semver.org/) for service versions.</span></span> <span data-ttu-id="42aa7-257">Szemantikai versioning használ egy *jelentős. KISEBB. JAVÍTÁS* formátumban.</span><span class="sxs-lookup"><span data-stu-id="42aa7-257">Semantic versioning uses a *MAJOR.MINOR.PATCH* format.</span></span> <span data-ttu-id="42aa7-258">Azonban az ügyfelek csak válassza az API-k által a fő verziószáma, vagy esetleg a alverziója esetén jelentős (de nem törhető) módosítások alverziót között.</span><span class="sxs-lookup"><span data-stu-id="42aa7-258">However, clients should only select an API by the major version number, or possibly the minor version if there are significant (but non-breaking) changes between minor versions.</span></span> <span data-ttu-id="42aa7-259">Ez azt jelenti akkor ésszerű ügyfelek válassza az 1-es és 2-es verziójának az API-k között, de nem 2.1.3 verzió kiválasztása.</span><span class="sxs-lookup"><span data-stu-id="42aa7-259">In other words, it's reasonable for clients to select between version 1 and version 2 of an API, but not to select version 2.1.3.</span></span> <span data-ttu-id="42aa7-260">Ha engedélyezi a ekkora szintű részletességű, kockázatok, nem kell egy elterjedése verziók támogatják.</span><span class="sxs-lookup"><span data-stu-id="42aa7-260">If you allow that level of granularity, you risk having to support a proliferation of versions.</span></span> 

<span data-ttu-id="42aa7-261">Az API-versioning további leírását lásd: [Versioning egy RESTful webes API](../best-practices/api-design.md#versioning-a-restful-web-api).</span><span class="sxs-lookup"><span data-stu-id="42aa7-261">For further discussion of API versioning, see [Versioning a RESTful web API](../best-practices/api-design.md#versioning-a-restful-web-api).</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="42aa7-262">Adatfeldolgozást és a munkafolyamat</span><span class="sxs-lookup"><span data-stu-id="42aa7-262">Ingestion and workflow</span></span>](./ingestion-workflow.md)