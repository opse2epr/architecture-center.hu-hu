---
title: Az adatok mikroszolgáltatások kapcsolatos szempontok
description: Mikroszolgáltatás-alapú adatok szempontjai.
author: MikeWasson
ms.date: 02/25/2019
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: dd620cdcb6cb3a06d4fae4fb34eeb086ec17b4c5
ms.sourcegitcommit: c053e6edb429299a0ad9b327888d596c48859d4a
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 03/20/2019
ms.locfileid: "58298425"
---
# <a name="data-considerations-for-microservices"></a><span data-ttu-id="6a6ee-103">Az adatok mikroszolgáltatások kapcsolatos szempontok</span><span class="sxs-lookup"><span data-stu-id="6a6ee-103">Data considerations for microservices</span></span>

<span data-ttu-id="6a6ee-104">Ez a cikk ismerteti a mikroszolgáltatási architektúrákban adatkezelési szempontok.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-104">This article describes considerations for managing data in a microservices architecture.</span></span> <span data-ttu-id="6a6ee-105">Mivel minden mikroszolgáltatás kezeli a saját adatai, a adatintegritásának és adatkonzisztencia kritikus kihívásokat is.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-105">Because every microservice manages its own data, data integrity and data consistency are critical challenges.</span></span>

<span data-ttu-id="6a6ee-106">A mikroszolgáltatások egyik alapelve, hogy mindegyik szolgáltatás a saját adatait felügyeli.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-106">A basic principle of microservices is that each service manages its own data.</span></span> <span data-ttu-id="6a6ee-107">Két szolgáltatást kell ossza meg a tárolóban.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-107">Two services should not share a data store.</span></span> <span data-ttu-id="6a6ee-108">Ehelyett minden egyes szolgáltatás a saját személyes adattár, amely más szolgáltatások közvetlenül nem férnek hozzá felelős.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-108">Instead, each service is responsible for its own private data store, which other services cannot access directly.</span></span>

<span data-ttu-id="6a6ee-109">Ez a szabály az az oka, hogy kerülje a szolgáltatások, amelyek okozhat, ha a szolgáltatások megosztása az azonos mögöttes adatsémák véletlen összekapcsolását.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-109">The reason for this rule is to avoid unintentional coupling between services, which can result if services share the same underlying data schemas.</span></span> <span data-ttu-id="6a6ee-110">Az adatséma változás történik, ha a módosítást kell koordinált összes támaszkodik, hogy az adatbázis-szolgáltatás között.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-110">If there is a change to the data schema, the change must be coordinated across every service that relies on that database.</span></span> <span data-ttu-id="6a6ee-111">Minden egyes szolgáltatás adattárát elkülönítésével azt is módosítása hatókörének korlátozása, és valóban független üzembe helyezések rugalmasságának megőrzése.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-111">By isolating each service's data store, we can limit the scope of change, and preserve the agility of truly independent deployments.</span></span> <span data-ttu-id="6a6ee-112">Egy másik oka, hogy mindegyik mikroszolgáltatás előfordulhat, hogy rendelkezik a saját adatmodellt, a lekérdezések, vagy olvasási/írási mintákat.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-112">Another reason is that each microservice may have its own data models, queries, or read/write patterns.</span></span> <span data-ttu-id="6a6ee-113">A megosztott tárolóban használata korlátozza az egyes csapatok lehetővé teszi az adott szolgáltatáshoz adatok a tárolási költségek optimalizálására.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-113">Using a shared data store limits each team's ability to optimize data storage for their particular service.</span></span>

![A CQRS nem megfelelő megközelítést bemutató ábra](../../guide/architecture-styles/images/cqrs-microservices-wrong.png)

<span data-ttu-id="6a6ee-115">Ezt a megközelítést vezet természetes módon [polyglot-adatmegőrzés](https://martinfowler.com/bliki/PolyglotPersistence.html) &mdash; több egy alkalmazáson belül adattárolási technológiák használatát.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-115">This approach naturally leads to [polyglot persistence](https://martinfowler.com/bliki/PolyglotPersistence.html) &mdash; the use of multiple data storage technologies within a single application.</span></span> <span data-ttu-id="6a6ee-116">Egy szolgáltatás szükség lehet a dokumentum-adatbázis az olvasási séma képességeit.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-116">One service might require the schema-on-read capabilities of a document database.</span></span> <span data-ttu-id="6a6ee-117">Egy másik szükség lehet a RDBMS által biztosított hivatkozási integritást.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-117">Another might need the referential integrity provided by an RDBMS.</span></span> <span data-ttu-id="6a6ee-118">Minden egyes csapat díjmentes, hogy a szolgáltatás a legjobb választás.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-118">Each team is free to make the best choice for their service.</span></span> <span data-ttu-id="6a6ee-119">Az általános elvet polyglot-adatmegőrzés kapcsolatos további információkért lásd: [a feladathoz legmegfelelőbb adattárat használja](../../guide/design-principles/use-the-best-data-store.md).</span><span class="sxs-lookup"><span data-stu-id="6a6ee-119">For more about the general principle of polyglot persistence, see [Use the best data store for the job](../../guide/design-principles/use-the-best-data-store.md).</span></span>

> [!NOTE]
> <span data-ttu-id="6a6ee-120">Ez nem okoz gondot szolgáltatások ugyanazon fizikai adatbázis-kiszolgáló megosztásához.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-120">It's fine for services to share the same physical database server.</span></span> <span data-ttu-id="6a6ee-121">A probléma akkor fordul elő, amikor a szolgáltatások megosztani ugyanazzal a sémával vagy olvasási és írási ugyanazokat az adatbázistáblák.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-121">The problem occurs when services share the same schema, or read and write to the same set of database tables.</span></span>

## <a name="challenges"></a><span data-ttu-id="6a6ee-122">Problémák</span><span class="sxs-lookup"><span data-stu-id="6a6ee-122">Challenges</span></span>

<span data-ttu-id="6a6ee-123">Ez a megközelítés elosztott áttekinthet néhány problémát, adatkezelési merülnek fel.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-123">Some challenges arise from this distributed approach to managing data.</span></span> <span data-ttu-id="6a6ee-124">Először is előfordulhatnak redundancia különböző adattárakban, és az azonos elem több helyen jelennek meg adatok.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-124">First, there may be redundancy across the data stores, with the same item of data appearing in multiple places.</span></span> <span data-ttu-id="6a6ee-125">Például adatok előfordulhat, hogy lehet egy tranzakció részeként tárolja, majd Analytics, a jelentésben, vagy archiválása máshol tárolt.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-125">For example, data might be stored as part of a transaction, then stored elsewhere for analytics, reporting, or archiving.</span></span> <span data-ttu-id="6a6ee-126">Ismétlődik vagy particionált adatok is az adatok integritásának megőrzése, és a konzisztencia problémákat okozhat.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-126">Duplicated or partitioned data can lead to issues of data integrity and consistency.</span></span> <span data-ttu-id="6a6ee-127">Adatkapcsolatok span több szolgáltatást, amikor kényszeríteni a kapcsolatokat a hagyományos felügyeleti technikák nem használható.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-127">When data relationships span multiple services, you can't use traditional data management techniques to enforce the relationships.</span></span>

<span data-ttu-id="6a6ee-128">A hagyományos modellezési használja a szabály az "egy tény egy helyen."</span><span class="sxs-lookup"><span data-stu-id="6a6ee-128">Traditional data modeling uses the rule of "one fact in one place."</span></span> <span data-ttu-id="6a6ee-129">Minden entitás pontosan egyszer jelenik meg a sémában.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-129">Every entity appears exactly once in the schema.</span></span> <span data-ttu-id="6a6ee-130">Más entitások hivatkozásokat tartalmaznak, de nem másolhatja.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-130">Other entities may hold references to it but not duplicate it.</span></span> <span data-ttu-id="6a6ee-131">A nyilvánvaló hagyományos megközelítés előnye, hogy egyetlen helyen, és elkerülhetők a problémák az adatok konzisztenciájának végrehajtott frissítések.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-131">The obvious advantage to the traditional approach is that updates are made in a single place, which avoids problems with data consistency.</span></span> <span data-ttu-id="6a6ee-132">A mikroszolgáltatási architektúrákban akkor fontolja meg, hogyan frissítések szolgáltatás lépnek, és hogyan kezelje az erős konzisztencia nélkül több helyen jelenik meg adat végleges konzisztencia.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-132">In a microservices architecture, you have to consider how updates are propagated across services, and how to manage eventual consistency when data appears in multiple places without strong consistency.</span></span>

## <a name="approaches-to-managing-data"></a><span data-ttu-id="6a6ee-133">Módszerek az adatok kezelése</span><span class="sxs-lookup"><span data-stu-id="6a6ee-133">Approaches to managing data</span></span>

<span data-ttu-id="6a6ee-134">Nincs egyetlen módszer, amely minden esetben helyes van, de Íme néhány általános irányelveket a mikroszolgáltatási architektúrákban adatok kezeléséhez.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-134">There is no single approach that's correct in all cases, but here are some general guidelines for managing data in a microservices architecture.</span></span>

- <span data-ttu-id="6a6ee-135">Ahol lehetséges, támogassa a végső konzisztenciát.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-135">Embrace eventual consistency where possible.</span></span> <span data-ttu-id="6a6ee-136">Ismerje meg a helyek, a rendszer, ahol erős konzisztencia vagy ACID-tranzakciókat, és a helyeket, ahol a végleges konzisztencia fogadható el kell.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-136">Understand the places in the system where you need strong consistency or ACID transactions, and the places where eventual consistency is acceptable.</span></span>

- <span data-ttu-id="6a6ee-137">Erős konzisztencia megvalósulásának van szüksége, amikor egy szolgáltatás jelöl az adott entitások, amelyek egy API-n keresztül közvetlenül hiteles forráshoz.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-137">When you need strong consistency guarantees, one service may represent the source of truth for a given entity, which is exposed through an API.</span></span> <span data-ttu-id="6a6ee-138">Egyéb szolgáltatások olyan saját maguk az adatok másolatát, vagy az adatok, idővel konzisztenssé váljanak a törzsadatok, de nem veszi figyelembe a hiteles forrásaként egy részét.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-138">Other services might hold their own copy of the data, or a subset of the data, that is eventually consistent with the master data but not considered the source of truth.</span></span> <span data-ttu-id="6a6ee-139">Képzeljünk el például egy e-kereskedelmi rendszerben egy rendelés ügyfélszolgálat és a egy szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-139">For example, imagine an e-commerce system with a customer order service and a recommendation service.</span></span> <span data-ttu-id="6a6ee-140">A szolgáltatás-események előfordulhat, hogy figyelése a rendelés szolgáltatásból, de az ügyfél kéri a visszatérítés, hogy a rendelés szolgáltatás, nem a javaslat szolgáltatás, amely rendelkezik a teljes tranzakció előzmények.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-140">The recommendation service might listen to events from the order service, but if a customer requests a refund, it is the order service, not the recommendation service, that has the complete transaction history.</span></span>

- <span data-ttu-id="6a6ee-141">Tranzakció, használjon minták például [Feladatütemező ügynök felügyeleti](../../patterns/scheduler-agent-supervisor.md) és [kompenzáló tranzakció](../../patterns/compensating-transaction.md) és konzisztens adatokat több szolgáltatás között.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-141">For transactions, use patterns such as [Scheduler Agent Supervisor](../../patterns/scheduler-agent-supervisor.md) and [Compensating Transaction](../../patterns/compensating-transaction.md) to keep data consistent across several services.</span></span>  <span data-ttu-id="6a6ee-142">Szükség lehet tárolásához egy további adat, amely egy, több szolgáltatást, többek között több szolgáltatást részleges hiba elkerülése érdekében kiterjedő munkaegység állapotát rögzíti.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-142">You may need to store an additional piece of data that captures the state of a unit of work that spans multiple services, to avoid partial failure among multiple services.</span></span> <span data-ttu-id="6a6ee-143">Például, hogy egy munkaelemet az tartós üzenetsor amíg folyamatban van egy több lépésből álló tranzakció.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-143">For example, keep a work item on a durable queue while a multi-step transaction is in progress.</span></span>

- <span data-ttu-id="6a6ee-144">Store csak a szolgáltatás szükséges adatokat.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-144">Store only the data that a service needs.</span></span> <span data-ttu-id="6a6ee-145">Szolgáltatás előfordulhat, hogy elegendő információ egy tartományi entitás egy része.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-145">A service might only need a subset of information about a domain entity.</span></span> <span data-ttu-id="6a6ee-146">Például a szállítási, amelyet a környezetben, azt kell tudni, hogy melyik ügyfél egy adott kézbesítési társítva.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-146">For example, in the Shipping bounded context, we need to know which customer is associated to a particular delivery.</span></span> <span data-ttu-id="6a6ee-147">Az ügyfél számlázási cím nincs szükségünk, de &mdash; , amely a fiók, amelyet környezet kezeli.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-147">But we don't need the customer's billing address &mdash; that's managed by the Accounts bounded context.</span></span> <span data-ttu-id="6a6ee-148">A tartomány gondosan mértékegységeként és DDD módszerével, itt is segítségével.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-148">Thinking carefully about the domain, and using a DDD approach, can help here.</span></span>

- <span data-ttu-id="6a6ee-149">Vegye figyelembe, hogy a szolgáltatások-e következetes és lazán összekapcsoltak.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-149">Consider whether your services are coherent and loosely coupled.</span></span> <span data-ttu-id="6a6ee-150">Ha a két szolgáltatás folyamatosan cserél információt egymással, forgalmas API-kat, így szükség lehet újrarajzolja a szolgáltatások határait egyesítése a két szolgáltatás vagy funkció újrabontás.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-150">If two services are continually exchanging information with each other, resulting in chatty APIs, you may need to redraw your service boundaries, by merging two services or refactoring their functionality.</span></span>

- <span data-ttu-id="6a6ee-151">Használja az [eseményvezérelt architektúra stílusának](../../guide/architecture-styles/event-driven.md).</span><span class="sxs-lookup"><span data-stu-id="6a6ee-151">Use an [event driven architecture style](../../guide/architecture-styles/event-driven.md).</span></span> <span data-ttu-id="6a6ee-152">Ezt az architektúrastílust, a szolgáltatás egy eseményt, amikor a nyilvános modellek és entitások mértékben tesz közzé.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-152">In this architecture style, a service publishes an event when there are changes to its public models or entities.</span></span> <span data-ttu-id="6a6ee-153">Az érintett szolgáltatások előfizethetnek ezeket az eseményeket.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-153">Interested services can subscribe to these events.</span></span> <span data-ttu-id="6a6ee-154">Ha például egy másik szolgáltatás használatával az események hozhatnak létre, amely több lehetővé teszi az adatok materializált nézet.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-154">For example, another service could use the events to construct a materialized view of the data that is more suitable for querying.</span></span>

- <span data-ttu-id="6a6ee-155">Egy szolgáltatás, amely a tulajdonában lévő események tegyen közzé egy sémát, amely segítségével automatizálhatja a szerializálásához és deszerializálásához az események között a kiadók és -előfizetők szoros összekapcsolódást elkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-155">A service that owns events should publish a schema that can be used to automate serializing and deserializing the events, to avoid tight coupling between publishers and subscribers.</span></span> <span data-ttu-id="6a6ee-156">Gondolja át, JSON-sémájában vagy keretrendszert, például [Microsoft Bond](https://github.com/Microsoft/bond), Protopuf, vagy avro-hoz.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-156">Consider JSON schema or a framework like [Microsoft Bond](https://github.com/Microsoft/bond), Protobuf, or Avro.</span></span>

- <span data-ttu-id="6a6ee-157">Nagy adatmennyiség esetén események a rendszer szűk keresztmetszetté válik, ezért érdemes az összesítést használ, vagy a teljes terhelés csökkentésére, kötegelés.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-157">At high scale, events can become a bottleneck on the system, so consider using aggregation or batching to reduce the total load.</span></span>

## <a name="example-choosing-data-stores-for-the-drone-delivery-application"></a><span data-ttu-id="6a6ee-158">Példa: A Drone Delivery alkalmazás lehetőséget választva adattárak</span><span class="sxs-lookup"><span data-stu-id="6a6ee-158">Example: Choosing data stores for the Drone Delivery application</span></span>

<span data-ttu-id="6a6ee-159">A sorozat előző cikkek egy drónos szállítási szolgáltatást egy futó példaként tárgyalják.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-159">The previous articles in this series discuss a drone delivery service as a running example.</span></span> <span data-ttu-id="6a6ee-160">Talál további információt a forgatókönyv és a megfelelő megvalósításának hivatkozhat [Itt](./index.md).</span><span class="sxs-lookup"><span data-stu-id="6a6ee-160">You can read more about the scenario and the corresponding reference implementation [here](./index.md).</span></span>

<span data-ttu-id="6a6ee-161">Recap, hogy az alkalmazás több mikroszolgáltatások a kézbesítések ütemezését, a drone határozza meg.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-161">To recap, this application defines several microservices for scheduling deliveries by drone.</span></span> <span data-ttu-id="6a6ee-162">Amikor egy felhasználó egy új szállítási ütemezi, az ügyfél kérése tartalmaz, például a méret és a súlyozást a csomag és a szállítási begyűjtést és dropoff helyeket, például vonatkozó információkat.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-162">When a user schedules a new delivery, the client request includes information about the delivery, such as pickup and dropoff locations, and about the package, such as size and weight.</span></span> <span data-ttu-id="6a6ee-163">Ezt az információt adott munkaegység határozza meg.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-163">This information defines a unit of work.</span></span>

<span data-ttu-id="6a6ee-164">A különböző háttérrendszerekhez érdeklik a különböző részeit az adatokat a kérésben és is rendelkezik különböző olvasási és írási profilok.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-164">The various backend services care about different portions of the information in the request, and also have different read and write profiles.</span></span>

![Az adatok kapcsolatos szempontok ábrája](../images/data-considerations.png)

### <a name="delivery-service"></a><span data-ttu-id="6a6ee-166">Kézbesítési szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="6a6ee-166">Delivery service</span></span>

<span data-ttu-id="6a6ee-167">A kézbesítési szolgáltatás minden teljesítés jelenleg ütemezett kapcsolatos és folyamatban lévő információkat tárolja.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-167">The Delivery service stores information about every delivery that is currently scheduled or in progress.</span></span> <span data-ttu-id="6a6ee-168">Figyeli a drónok-eseményfolyam megtekintéséhez a, és nyomon követi a folyamatban lévő kézbesítések állapotát.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-168">It listens for events from the drones, and tracks the status of deliveries that are in progress.</span></span> <span data-ttu-id="6a6ee-169">Tartományi események kézbesítési állapotának frissítése is elküldi.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-169">It also sends domain events with delivery status updates.</span></span>

<span data-ttu-id="6a6ee-170">Valószínű, hogy a felhasználók gyakran abban az esetben ellenőrizze a kézbesítési állapotát, amíg a csomag várnak.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-170">It's expected that users will frequently check the status of a delivery while they are waiting for their package.</span></span> <span data-ttu-id="6a6ee-171">Ezért a kézbesítési szolgáltatás igényel, amelyek kiemelik átviteli (olvasási és írási) keresztül hosszú távú tárolás a tárolóban.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-171">Therefore, the Delivery service requires a data store that emphasizes throughput (read and write) over long-term storage.</span></span> <span data-ttu-id="6a6ee-172">Emellett a kézbesítési szolgáltatás nem hajt végre semmilyen összetettebb lekérdezések vagy az analysis, egyszerűen lekéri a legfrissebb állapotát egy adott szállítási.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-172">Also, the Delivery service does not perform any complex queries or analysis, it simply fetches the latest status for a given delivery.</span></span> <span data-ttu-id="6a6ee-173">A kézbesítés service csapatának Azure Redis Cache választotta, a magas olvasási és írási teljesítmény.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-173">The Delivery service team chose Azure Redis Cache for its high read-write performance.</span></span> <span data-ttu-id="6a6ee-174">A redis tárolt adatok viszonylag rövid életű.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-174">The information stored in Redis is relatively short-lived.</span></span> <span data-ttu-id="6a6ee-175">A kézbesítési befejezése után a a szállítás előzményei szolgáltatás a rendszerben.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-175">Once a delivery is complete, the Delivery History service is the system of record.</span></span>

### <a name="delivery-history-service"></a><span data-ttu-id="6a6ee-176">Előzmények szolgáltatásra</span><span class="sxs-lookup"><span data-stu-id="6a6ee-176">Delivery History service</span></span>

<span data-ttu-id="6a6ee-177">A szállítás előzményei szolgáltatás figyeli a kézbesítési szolgáltatás eseményeit, szállítási állapot.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-177">The Delivery History service listens for delivery status events from the Delivery service.</span></span> <span data-ttu-id="6a6ee-178">A hosszú távú tárolás tárolja ezeket az adatokat.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-178">It stores this data in long-term storage.</span></span> <span data-ttu-id="6a6ee-179">Nincsenek két különböző használati esetek korábbi adatok, amelyek eltérő tárolási követelményekkel rendelkeznek.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-179">There are two different use-cases for this historical data, which have different data storage requirements.</span></span>

<span data-ttu-id="6a6ee-180">Az első forgatókönyv összesíti az adatokat a data-elemzések, optimalizálhatja az üzleti vagy a szolgáltatás minőségének javítása érdekében.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-180">The first scenario is aggregating the data for the purpose of data analytics, in order to optimize the business or improve the quality of the service.</span></span> <span data-ttu-id="6a6ee-181">Vegye figyelembe, hogy a szállítás előzményei szolgáltatás nem hajtja végre a tényleges adatok elemzése.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-181">Note that the Delivery History service doesn't perform the actual analysis of the data.</span></span> <span data-ttu-id="6a6ee-182">Csak feladata a feldolgozási és tárolási.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-182">It's only responsible for the ingestion and storage.</span></span> <span data-ttu-id="6a6ee-183">A jelen esetben a storage kell optimalizálni adatelemzés keresztül adatokat, egy olvasási séma megközelítést befogadására, adatforrások különböző nagy készletét.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-183">For this scenario, the storage must be optimized for data analysis over a large set of data, using a schema-on-read approach to accommodate a variety of data sources.</span></span> <span data-ttu-id="6a6ee-184">[Az Azure Data Lake Store](/azure/data-lake-store/) van egy jó választás a ebben a forgatókönyvben.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-184">[Azure Data Lake Store](/azure/data-lake-store/) is a good fit for this scenario.</span></span> <span data-ttu-id="6a6ee-185">Data Lake Store az Apache Hadoop-fájlrendszer az a Hadoop elosztott fájlrendszer (HDFS) kompatibilis, és a nagy teljesítményt nyújtson az adatelemzési forgatókönyvekben.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-185">Data Lake Store is an Apache Hadoop file system compatible with Hadoop Distributed File System (HDFS), and is tuned for performance for data analytics scenarios.</span></span>

<span data-ttu-id="6a6ee-186">A bármilyen más forgatókönyvhöz van így a felhasználók a kézbesítési befejeződése után keresse ki egy kézbesítési előzményeit.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-186">The other scenario is enabling users to look up the history of a delivery after the delivery is completed.</span></span> <span data-ttu-id="6a6ee-187">Az Azure Data Lake különösen nincs optimalizálva az ebben a forgatókönyvben.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-187">Azure Data Lake is not particularly optimized for this scenario.</span></span> <span data-ttu-id="6a6ee-188">Az optimális teljesítmény érdekében a Microsoft azt javasolja, a Data Lake dátum alapján particionált mappákban idősorozat-adatok tárolására.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-188">For optimal performance, Microsoft recommends storing time-series data in Data Lake in folders partitioned by date.</span></span> <span data-ttu-id="6a6ee-189">(Lásd: [a teljesítmény hangolása az Azure Data Lake Store](/azure/data-lake-store/data-lake-store-performance-tuning-guidance)).</span><span class="sxs-lookup"><span data-stu-id="6a6ee-189">(See [Tuning Azure Data Lake Store for performance](/azure/data-lake-store/data-lake-store-performance-tuning-guidance)).</span></span> <span data-ttu-id="6a6ee-190">Struktúra viszont nem optimális által az egyes rekordok keresése</span><span class="sxs-lookup"><span data-stu-id="6a6ee-190">However, that structure is not optimal for looking up individual records by ID.</span></span> <span data-ttu-id="6a6ee-191">Ha is tudja a timestamp, a keresés azonosító alapján szükséges, vizsgálata a teljes gyűjteményt.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-191">Unless you also know the timestamp, a lookup by ID requires scanning the entire collection.</span></span> <span data-ttu-id="6a6ee-192">Ezért a szállítás előzményei szolgáltatás is tárolja a korábbi adatok egy részét Cosmos DB-ben a gyorsabb keresés.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-192">Therefore, the Delivery History service also stores a subset of the historical data in Cosmos DB for quicker lookup.</span></span> <span data-ttu-id="6a6ee-193">A rekordok nem kell a Cosmos DB-ben határozatlan ideig marad.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-193">The records don't need to stay in Cosmos DB indefinitely.</span></span> <span data-ttu-id="6a6ee-194">Régebbi kézbesítések archiválhatók &mdash; egy hónap után mondja ki.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-194">Older deliveries can be archived &mdash; say, after a month.</span></span> <span data-ttu-id="6a6ee-195">Ezt megteheti egy alkalmi kötegfolyamat futtatásával.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-195">This could be done by running an occasional batch process.</span></span>

### <a name="package-service"></a><span data-ttu-id="6a6ee-196">Szolgáltatási csomag</span><span class="sxs-lookup"><span data-stu-id="6a6ee-196">Package service</span></span>

<span data-ttu-id="6a6ee-197">A csomag szolgáltatás az összes olyan csomagot adatait tárolja.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-197">The Package service stores information about all of the packages.</span></span> <span data-ttu-id="6a6ee-198">A csomag tárolási követelményei a következők:</span><span class="sxs-lookup"><span data-stu-id="6a6ee-198">The storage requirements for the Package are:</span></span>

- <span data-ttu-id="6a6ee-199">Hosszú távú tároláshoz.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-199">Long-term storage.</span></span>
- <span data-ttu-id="6a6ee-200">Nagy mennyiségű, csomagok, nagy írási teljesítményt igénylő kezelésére képes.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-200">Able to handle a high volume of packages, requiring high write throughput.</span></span>
- <span data-ttu-id="6a6ee-201">Támogatja az egyszerű lekérdezések csomagazonosítót.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-201">Support simple queries by package ID.</span></span> <span data-ttu-id="6a6ee-202">Nem bonyolult illesztésekre vagy a hivatkozásintegritás.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-202">No complex joins or requirements for referential integrity.</span></span>

<span data-ttu-id="6a6ee-203">Mivel a csomag adatai nem relációs, dokumentum-orientált adatbázis megfelelő, és Cosmos DB nagyon nagy átviteli sebességet érhet el horizontálisan skálázott gyűjtemények használatával.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-203">Because the package data is not relational, a document oriented database is appropriate, and Cosmos DB can achieve very high throughput by using sharded collections.</span></span> <span data-ttu-id="6a6ee-204">A csoport, amely a csomag szolgáltatás működik tisztában van-e a MEAN-verem (MongoDB, szolgáló Express.js, AngularJS és Node.js), így azok válassza ki a [MongoDB API-val](/azure/cosmos-db/mongodb-introduction) Cosmos DB-hez készült.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-204">The team that works on the Package service is familiar with the MEAN stack (MongoDB, Express.js, AngularJS, and Node.js), so they select the [MongoDB API](/azure/cosmos-db/mongodb-introduction) for Cosmos DB.</span></span> <span data-ttu-id="6a6ee-205">Amely lehetővé teszi a MongoDB, ez egy felügyelt Azure-szolgáltatás a Cosmos DB előnyeit beolvasása közben meglévő élményt kiaknázását.</span><span class="sxs-lookup"><span data-stu-id="6a6ee-205">That lets them leverage their existing experience with MongoDB, while getting the benefits of Cosmos DB, which is a managed Azure service.</span></span>
