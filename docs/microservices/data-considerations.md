---
title: Mikroszolgáltatások adatok szempontjai
description: Mikroszolgáltatások adatok szempontjai
author: MikeWasson
ms.date: 12/08/2017
ms.openlocfilehash: 9bd7a8424309b5753b42cfb70559836288a3ce9d
ms.sourcegitcommit: c7f46b14ad7d55cf553b2d0b01045c9c25aefcdb
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 12/09/2017
---
# <a name="designing-microservices-data-considerations"></a><span data-ttu-id="d7578-103">Mikroszolgáltatások tervezése: adatok kapcsolatos szempontok</span><span class="sxs-lookup"><span data-stu-id="d7578-103">Designing microservices: Data considerations</span></span>

<span data-ttu-id="d7578-104">Ez a fejezet mikroszolgáltatások architektúra adatok kezelésével kapcsolatos szempontokat ismerteti.</span><span class="sxs-lookup"><span data-stu-id="d7578-104">This chapter describes considerations for managing data in a microservices architecture.</span></span> <span data-ttu-id="d7578-105">Minden mikroszolgáltatási kezeli a saját adatok, mert adatintegritást és az adatok konzisztenciájának áttekinthet kritikus.</span><span class="sxs-lookup"><span data-stu-id="d7578-105">Because every microservice manages its own data, data integrity and data consistency are critical challenges.</span></span>

![](./images/data-considerations.png)

<span data-ttu-id="d7578-106">Egy alapszintű mikroszolgáltatások lényege, hogy minden egyes szolgáltatás kezeli a saját adatok.</span><span class="sxs-lookup"><span data-stu-id="d7578-106">A basic principle of microservices is that each service manages its own data.</span></span> <span data-ttu-id="d7578-107">Két szolgáltatást nem kell ugyanazt a tárolóban.</span><span class="sxs-lookup"><span data-stu-id="d7578-107">Two services should not share a data store.</span></span> <span data-ttu-id="d7578-108">Ehelyett minden a szolgáltatás felelős a saját személyes adattároló, amely más szolgáltatások nem tud közvetlenül hozzáférni.</span><span class="sxs-lookup"><span data-stu-id="d7578-108">Instead, each service is responsible for its own private data store, which other services cannot access directly.</span></span>

<span data-ttu-id="d7578-109">Ez a szabály oka közötti szolgáltatásokat, amelyek okozhat, ha a szolgáltatások megosztani az azonos alapjául szolgáló adatok sémák nem szándékos kapcsoló elkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="d7578-109">The reason for this rule is to avoid unintentional coupling between services, which can result if services share the same underlying data schemas.</span></span> <span data-ttu-id="d7578-110">Ha az adatok séma módosítva lett, a módosítás minden szolgáltatásban, amely támaszkodik, hogy az adatbázis össze kell hangolni.</span><span class="sxs-lookup"><span data-stu-id="d7578-110">If there is a change to the data schema, the change must be coordinated across every service that relies on that database.</span></span> <span data-ttu-id="d7578-111">Minden szolgáltatás adattár elkülönítésével azt is korlátozza a módosítás következményeivel, és valóban független központi telepítések agilitást megőrzése.</span><span class="sxs-lookup"><span data-stu-id="d7578-111">By isolating each service's data store, we can limit the scope of change, and preserve the agility of truly independent deployments.</span></span> <span data-ttu-id="d7578-112">Egy másik oka az, hogy minden egyes mikroszolgáltatási előfordulhat, hogy a saját adatok modellek, a lekérdezések, vagy olvasási/írási kombinációját.</span><span class="sxs-lookup"><span data-stu-id="d7578-112">Another reason is that each microservice may have its own data models, queries, or read/write patterns.</span></span> <span data-ttu-id="d7578-113">Minden team képességét az adott szolgáltatáshoz adattárolás optimalizálása érdekében a megosztott tároló használata korlátozza.</span><span class="sxs-lookup"><span data-stu-id="d7578-113">Using a shared data store limits each team's ability to optimize data storage for their particular service.</span></span> 

![](../guide/architecture-styles/images/cqrs-microservices-wrong.png)

<span data-ttu-id="d7578-114">Ezt a megközelítést vezet természetes [polyglot adatmegőrzési](https://martinfowler.com/bliki/PolyglotPersistence.html) &mdash; több adatok tárolási technológiákat belül egyetlen alkalmazás használatát.</span><span class="sxs-lookup"><span data-stu-id="d7578-114">This approach naturally leads to [polyglot persistence](https://martinfowler.com/bliki/PolyglotPersistence.html) &mdash; the use of multiple data storage technologies within a single application.</span></span> <span data-ttu-id="d7578-115">Egy szolgáltatási dokumentum-adatbázis a séma-a-olvasási képességek lehet szükség.</span><span class="sxs-lookup"><span data-stu-id="d7578-115">One service might require the schema-on-read capabilities of a document database.</span></span> <span data-ttu-id="d7578-116">Egy másik módosítania kell a hivatkozási integritás egy RDBMS által biztosított.</span><span class="sxs-lookup"><span data-stu-id="d7578-116">Another might need the referential integrity provided by an RDBMS.</span></span> <span data-ttu-id="d7578-117">Minden csoport, így a szolgáltatás a legjobb választás.</span><span class="sxs-lookup"><span data-stu-id="d7578-117">Each team is free to make the best choice for their service.</span></span> <span data-ttu-id="d7578-118">Az általános elvet polyglot adatmegőrzési kapcsolatban bővebben lásd: [használjon a legjobb adatok tárolásához a feladat](../guide/design-principles/use-the-best-data-store.md).</span><span class="sxs-lookup"><span data-stu-id="d7578-118">For more about the general principle of polyglot persistence, see [Use the best data store for the job](../guide/design-principles/use-the-best-data-store.md).</span></span> 

> [!NOTE]
> <span data-ttu-id="d7578-119">Azt megosztása ugyanazon fizikai adatbázis-kiszolgáló szolgáltatások rendben.</span><span class="sxs-lookup"><span data-stu-id="d7578-119">It's fine for services to share the same physical database server.</span></span> <span data-ttu-id="d7578-120">A probléma akkor fordul elő, amikor szolgáltatások megosztása ugyanazon séma, vagy olvasási és írási ugyanazokat a adatbázistáblák.</span><span class="sxs-lookup"><span data-stu-id="d7578-120">The problem occurs when services share the same schema, or read and write to the same set of database tables.</span></span>


## <a name="challenges"></a><span data-ttu-id="d7578-121">Kihívásai</span><span class="sxs-lookup"><span data-stu-id="d7578-121">Challenges</span></span>

<span data-ttu-id="d7578-122">Ez a megközelítés elosztott némi kihívást adatok kezelésének merülhetnek fel.</span><span class="sxs-lookup"><span data-stu-id="d7578-122">Some challenges arise from this distributed approach to managing data.</span></span> <span data-ttu-id="d7578-123">Első lépésként lehet redundancia az adattároló, az azonos elem több helyen jelennek meg adatok között.</span><span class="sxs-lookup"><span data-stu-id="d7578-123">First, there may be redundancy across the data stores, with the same item of data appearing in multiple places.</span></span> <span data-ttu-id="d7578-124">Például adatok előfordulhat, hogy lehet egy tranzakció részeként tárolja, majd az elemzés, reporting, vagy a máshol tárolt.</span><span class="sxs-lookup"><span data-stu-id="d7578-124">For example, data might be stored as part of a transaction, then stored elsewhere for analytics, reporting, or archiving.</span></span> <span data-ttu-id="d7578-125">Ismétlődik vagy particionált adatok adatintegritást és konzisztencia vezethet.</span><span class="sxs-lookup"><span data-stu-id="d7578-125">Duplicated or partitioned data can lead to issues of data integrity and consistency.</span></span> <span data-ttu-id="d7578-126">Adatok kapcsolatok span több szolgáltatásra, amikor a hagyományos technikák kényszeríteni a kapcsolatok nem használhat.</span><span class="sxs-lookup"><span data-stu-id="d7578-126">When data relationships span multiple services, you can't use traditional data management techniques to enforce the relationships.</span></span>

<span data-ttu-id="d7578-127">Hagyományos modellezési használja a szabály az "egy kapcsolattény egyetlen helyen."</span><span class="sxs-lookup"><span data-stu-id="d7578-127">Traditional data modeling uses the rule of "one fact in one place."</span></span> <span data-ttu-id="d7578-128">Minden entitás pontosan egyszer jelenik meg a sémában.</span><span class="sxs-lookup"><span data-stu-id="d7578-128">Every entity appears exactly once in the schema.</span></span> <span data-ttu-id="d7578-129">Egyéb entitások hivatkoznak rá tárolására, de nem ismétlődő.</span><span class="sxs-lookup"><span data-stu-id="d7578-129">Other entities may hold references to it but not duplicate it.</span></span> <span data-ttu-id="d7578-130">A nyilvánvaló a hagyományos megközelítés előnye, hogy frissítések válnak, egyetlen helyen, és elkerülhetők a problémák az adatok konzisztenciájának.</span><span class="sxs-lookup"><span data-stu-id="d7578-130">The obvious advantage to the traditional approach is that updates are made in a single place, which avoids problems with data consistency.</span></span> <span data-ttu-id="d7578-131">Mikroszolgáltatások architektúra esetén meg kell figyelembe venni, hogyan frissítések továbbítódnak szolgáltatásban, és kezelése a végleges konzisztencia, amikor adatok nélkül az erős konzisztencia több helyen jelennek meg.</span><span class="sxs-lookup"><span data-stu-id="d7578-131">In a microservices architecture, you have to consider how updates are propagated across services, and how to manage eventual consistency when data appears in multiple places without strong consistency.</span></span> 

## <a name="approaches-to-managing-data"></a><span data-ttu-id="d7578-132">Az adatkezelés megközelítése</span><span class="sxs-lookup"><span data-stu-id="d7578-132">Approaches to managing data</span></span>

<span data-ttu-id="d7578-133">Nincs egyetlen módszert alkalmaz, amely minden esetben helyes van, de az alábbiakban néhány általános irányelveket mikroszolgáltatások architektúra adatok kezeléséhez.</span><span class="sxs-lookup"><span data-stu-id="d7578-133">There is no single approach that's correct in all cases, but here are some general guidelines for managing data in a microservices architecture.</span></span>

- <span data-ttu-id="d7578-134">Vezessék be a végleges konzisztencia, ahol csak lehetséges.</span><span class="sxs-lookup"><span data-stu-id="d7578-134">Embrace eventual consistency where possible.</span></span> <span data-ttu-id="d7578-135">Ismerje meg a helyek, a rendszer, ahol az erős konzisztencia vagy ACID-tranzakciókat és a helyeken, ahol a végleges konzisztencia elfogadható kell.</span><span class="sxs-lookup"><span data-stu-id="d7578-135">Understand the places in the system where you need strong consistency or ACID transactions, and the places where eventual consistency is acceptable.</span></span>

- <span data-ttu-id="d7578-136">Ha módosítania kell az erős konzisztencia biztosítja, egy szolgáltatás jelöl egy adott entitás, amely fel van fedve egy API-n keresztül igazság forrását.</span><span class="sxs-lookup"><span data-stu-id="d7578-136">When you need strong consistency guarantees, one service may represent the source of truth for a given entity, which is exposed through an API.</span></span> <span data-ttu-id="d7578-137">Egyéb szolgáltatások előfordulhat, hogy rendelkezik, saját az adatok másolatát, vagy az adatok, idővel konzisztenssé váljanak a törzsadatok, de nem tekinthető igazság forrását egy részét.</span><span class="sxs-lookup"><span data-stu-id="d7578-137">Other services might hold their own copy of the data, or a subset of the data, that is eventually consistent with the master data but not considered the source of truth.</span></span> <span data-ttu-id="d7578-138">Tegyük fel az elektronikus kereskedelmi rendszer rendelés ügyfélszolgálata és a javaslási szolgáltatása.</span><span class="sxs-lookup"><span data-stu-id="d7578-138">For example, imagine an e-commerce system with a customer order service and a recommendation service.</span></span> <span data-ttu-id="d7578-139">A javaslat szolgáltatás események sorrendben szolgáltatásból előfordulhat, hogy figyelésére, de az ügyfél a vételár kérelmek esetén a rendelés szolgáltatás, nem a javaslat szolgáltatást, a teljes tranzakció előzmények.</span><span class="sxs-lookup"><span data-stu-id="d7578-139">The recommendation service might listen to events from the order service, but if a customer requests a refund, it is the order service, not the recommendation service, that has the complete transaction history.</span></span>

- <span data-ttu-id="d7578-140">Az egyes tranzakciókra vonatkozóan, használjon minták például [Feladatütemező ügynök felügyelő](../patterns/scheduler-agent-supervisor.md) és [Compensating tranzakció](../patterns/compensating-transaction.md) és konzisztens adatok több szolgáltatásban.</span><span class="sxs-lookup"><span data-stu-id="d7578-140">For transactions, use patterns such as [Scheduler Agent Supervisor](../patterns/scheduler-agent-supervisor.md) and [Compensating Transaction](../patterns/compensating-transaction.md) to keep data consistent across several services.</span></span>  <span data-ttu-id="d7578-141">Előfordulhat, hogy kell tárolni egy további adat, amely több szolgáltatásra, több szolgáltatás között részleges hiba elkerülése érdekében kiterjedő munkaegység állapotát rögzíti.</span><span class="sxs-lookup"><span data-stu-id="d7578-141">You may need to store an additional piece of data that captures the state of a unit of work that spans multiple services, to avoid partial failure among multiple services.</span></span> <span data-ttu-id="d7578-142">Munkaelem például tárolása tartós várólista, amíg folyamatban van egy több tranzakció.</span><span class="sxs-lookup"><span data-stu-id="d7578-142">For example, keep a work item on a durable queue while a multi-step transaction is in progress.</span></span> 

- <span data-ttu-id="d7578-143">Csak a szolgáltatás igénylő adatainak tárolására.</span><span class="sxs-lookup"><span data-stu-id="d7578-143">Store only the data that a service needs.</span></span> <span data-ttu-id="d7578-144">A szolgáltatás csak módosítania kell a tartomány entitás információt egy részét.</span><span class="sxs-lookup"><span data-stu-id="d7578-144">A service might only need a subset of information about a domain entity.</span></span> <span data-ttu-id="d7578-145">Például a szállítási, amelyet a környezetben, azt kell tudni, hogy mely ügyfelek egy adott kézbesítési társítva.</span><span class="sxs-lookup"><span data-stu-id="d7578-145">For example, in the Shipping bounded context, we need to know which customer is associated to a particular delivery.</span></span> <span data-ttu-id="d7578-146">Nem szükséges az ügyfél számlázási címét, de &mdash; , amely kezeli a fiók, amelyet a környezetben.</span><span class="sxs-lookup"><span data-stu-id="d7578-146">But we don't need the customer's billing address &mdash; that's managed by the Accounts bounded context.</span></span> <span data-ttu-id="d7578-147">Itt gondosan gondolat a tartományhoz, és egy DDD megközelítéssel segítségével.</span><span class="sxs-lookup"><span data-stu-id="d7578-147">Thinking carefully about the domain, and using a DDD approach, can help here.</span></span> 

- <span data-ttu-id="d7578-148">Vegye figyelembe, hogy a szolgáltatások következetes és lazán összekapcsolt-e.</span><span class="sxs-lookup"><span data-stu-id="d7578-148">Consider whether your services are coherent and loosely coupled.</span></span> <span data-ttu-id="d7578-149">Ha két szolgáltatást folyamatosan cserél információt egymással, chatty API-k, ami esetleg a szolgáltatás határok újbóli egyesítése két szolgáltatás vagy funkció újrabontása.</span><span class="sxs-lookup"><span data-stu-id="d7578-149">If two services are continually exchanging information with each other, resulting in chatty APIs, you may need to redraw your service boundaries, by merging two services or refactoring their functionality.</span></span>

- <span data-ttu-id="d7578-150">Használjon egy [eseményvezérelt architektúra stílus](../guide/architecture-styles/event-driven.md).</span><span class="sxs-lookup"><span data-stu-id="d7578-150">Use an [event driven architecture style](../guide/architecture-styles/event-driven.md).</span></span> <span data-ttu-id="d7578-151">A architektúra stílusát, a szolgáltatás közzéteszi a egy eseményt, amikor az nyilvános modellek és entitások módosultak.</span><span class="sxs-lookup"><span data-stu-id="d7578-151">In this architecture style, a service publishes an event when there are changes to its public models or entities.</span></span> <span data-ttu-id="d7578-152">Érintett szolgáltatások ezeket az eseményeket is kérheti.</span><span class="sxs-lookup"><span data-stu-id="d7578-152">Interested services can subscribe to these events.</span></span> <span data-ttu-id="d7578-153">Azt jelzi, például egy másik szolgáltatás használhatja-e az adatok lekérdezése több megfelelő materializált nézet létrehozásához az eseményeket.</span><span class="sxs-lookup"><span data-stu-id="d7578-153">For example, another service could use the events to construct a materialized view of the data that is more suitable for querying.</span></span> 

- <span data-ttu-id="d7578-154">Egy szolgáltatás események birtokló közzé kell tennie egy séma, amely segítségével automatizálhatja a szerializálása és deszerializálása események, gyártók és előfizetők közötti szoros kapcsoló elkerülése érdekében.</span><span class="sxs-lookup"><span data-stu-id="d7578-154">A service that owns events should publish a schema that can be used to automate serializing and deserializing the events, to avoid tight coupling between publishers and subscribers.</span></span> <span data-ttu-id="d7578-155">Távolítsa el a JSON-séma vagy a keretrendszer például [Microsoft Bond](https://github.com/Microsoft/bond), Protobuf vagy Avro.</span><span class="sxs-lookup"><span data-stu-id="d7578-155">Consider JSON schema or a framework like [Microsoft Bond](https://github.com/Microsoft/bond), Protobuf, or Avro.</span></span>  
 
- <span data-ttu-id="d7578-156">Nagy adatmennyiség esetén események keresztmetszetet jelenthet a rendszer, ezért fontolja meg az összesítés használatával, vagy a teljes terhelés csökkentésére kötegelés.</span><span class="sxs-lookup"><span data-stu-id="d7578-156">At high scale, events can become a bottleneck on the system, so consider using aggregation or batching to reduce the total load.</span></span> 

## <a name="drone-delivery-choosing-the-data-stores"></a><span data-ttu-id="d7578-157">Dron kézbesítési: Az adattároló kiválasztása</span><span class="sxs-lookup"><span data-stu-id="d7578-157">Drone Delivery: Choosing the data stores</span></span> 

<span data-ttu-id="d7578-158">Csak néhány szolgáltatások használatát, még a szállítás, amelyet a környezetben mutatja be, az ebben a szakaszban tárgyalt pontok számos.</span><span class="sxs-lookup"><span data-stu-id="d7578-158">Even with only a few services, the Shipping bounded context illustrates several of the points discussed in this section.</span></span> 

<span data-ttu-id="d7578-159">Amikor egy felhasználó egy új kézbesítési ütemezi, az ügyfél kérésében tartalmazza a mindkét a kézbesítési, például a felvétel és dropoff helyeket, és a csomag, például a méret és a súlyozást.</span><span class="sxs-lookup"><span data-stu-id="d7578-159">When a user schedules a new delivery, the client request includes information about the both the delivery, such as the pickup and dropoff locations, and about the package, such as the size and weight.</span></span> <span data-ttu-id="d7578-160">Ez az információ munkaegység, amely a adatfeldolgozást szolgáltatás küld az Event Hubs határozza meg.</span><span class="sxs-lookup"><span data-stu-id="d7578-160">This information defines a unit of work, which the Ingestion service sends to Event Hubs.</span></span> <span data-ttu-id="d7578-161">Fontos, hogy a munkaegység marad az állandó tároló közben a Feladatütemező szolgáltatás végrehajtja a munkafolyamatot, hogy a kézbesítési kérelmek nem elvesznek.</span><span class="sxs-lookup"><span data-stu-id="d7578-161">It's important that the unit of work stays in persistent storage while the Scheduler service is executing the workflow, so that no delivery requests are lost.</span></span> <span data-ttu-id="d7578-162">A munkafolyamat több leírását lásd: [adatfeldolgozást és a munkafolyamat](./ingestion-workflow.md).</span><span class="sxs-lookup"><span data-stu-id="d7578-162">For more discussion of the workflow, see [Ingestion and workflow](./ingestion-workflow.md).</span></span> 

<span data-ttu-id="d7578-163">A különböző háttér-szolgáltatások különböző részei a kérelemben szereplő információk érdeklik és is rendelkezik különböző olvasási és írási profilok.</span><span class="sxs-lookup"><span data-stu-id="d7578-163">The various backend services care about different portions of the information in the request, and also have different read and write profiles.</span></span> 

### <a name="delivery-service"></a><span data-ttu-id="d7578-164">Kézbesítési szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="d7578-164">Delivery service</span></span>

<span data-ttu-id="d7578-165">A kézbesítési szolgáltatás kapcsolatos minden jelenleg ütemezett kézbesítését vagy a folyamatban lévő adatait tárolja.</span><span class="sxs-lookup"><span data-stu-id="d7578-165">The Delivery service stores information about every delivery that is currently scheduled or in progress.</span></span> <span data-ttu-id="d7578-166">A dronok származó eseményeket figyeli, és nyomon követi a folyamatban lévő kézbesítések állapotát.</span><span class="sxs-lookup"><span data-stu-id="d7578-166">It listens for events from the drones, and tracks the status of deliveries that are in progress.</span></span> <span data-ttu-id="d7578-167">Is küld a tartományhoz események kézbesítési állapotának frissítése.</span><span class="sxs-lookup"><span data-stu-id="d7578-167">It also sends domain events with delivery status updates.</span></span>

<span data-ttu-id="d7578-168">Valószínű, hogy a felhasználók gyakran abban az esetben ellenőrizze a kézbesítési állapotát, amíg a csomag vár.</span><span class="sxs-lookup"><span data-stu-id="d7578-168">It's expected that users will frequently check the status of a delivery while they are waiting for their package.</span></span> <span data-ttu-id="d7578-169">A kézbesítési szolgáltatás, ezért a tárolóban, amely emeli ki átviteli (olvasási és írási) keresztül hosszú távú tárolás szükséges.</span><span class="sxs-lookup"><span data-stu-id="d7578-169">Therefore, the Delivery service requires a data store that emphasizes throughput (read and write) over long-term storage.</span></span> <span data-ttu-id="d7578-170">Emellett a kézbesítési szolgáltatás nem végez semmilyen összetett lekérdezéseknél, illetve elemzési, egyszerűen kéri le a legfrissebb állapotát egy adott szállítási.</span><span class="sxs-lookup"><span data-stu-id="d7578-170">Also, the Delivery service does not perform any complex queries or analysis, it simply fetches the latest status for a given delivery.</span></span> <span data-ttu-id="d7578-171">A szállítási csoport számára a nagy írási és olvasási teljesítményt Azure Redis Cache választott.</span><span class="sxs-lookup"><span data-stu-id="d7578-171">The Delivery service team chose Azure Redis Cache for its high read-write performance.</span></span> <span data-ttu-id="d7578-172">A Redis tárolt információk viszonylag rövid élettartamú.</span><span class="sxs-lookup"><span data-stu-id="d7578-172">The information stored in Redis is relatively short-lived.</span></span> <span data-ttu-id="d7578-173">A szállítási végrehajtása után a kézbesítési előzmények szolgáltatás a rendszer rekord.</span><span class="sxs-lookup"><span data-stu-id="d7578-173">Once a delivery is complete, the Delivery History service is the system of record.</span></span>

### <a name="delivery-history-service"></a><span data-ttu-id="d7578-174">Kézbesítési előzmények szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="d7578-174">Delivery History service</span></span>

<span data-ttu-id="d7578-175">A szállítási előzmények szolgáltatás figyeli a kézbesítési állapoteseményeit a kézbesítési szolgáltatásból.</span><span class="sxs-lookup"><span data-stu-id="d7578-175">The Delivery History service listens for delivery status events from the Delivery service.</span></span> <span data-ttu-id="d7578-176">Ezek az adatok hosszú távú tárolás tárolja.</span><span class="sxs-lookup"><span data-stu-id="d7578-176">It stores this data in long-term storage.</span></span> <span data-ttu-id="d7578-177">Nincsenek két különböző használati esetek a korábbi adatok, amelyek különböző adattárolási követelmények.</span><span class="sxs-lookup"><span data-stu-id="d7578-177">There are two different use-cases for this historical data, which have different data storage requirements.</span></span> 

<span data-ttu-id="d7578-178">Az első forgatókönyv összesítése van az adatok az üzleti optimalizálás, vagy a szolgáltatások minőségének javítása érdekében a adatelemzés céljából.</span><span class="sxs-lookup"><span data-stu-id="d7578-178">The first scenario is aggregating the data for the purpose of data analytics, in order to optimize the business or improve the quality of the service.</span></span> <span data-ttu-id="d7578-179">Vegye figyelembe, hogy a kézbesítési előzmények szolgáltatás nem hajtja végre a tényleges adatok elemzése.</span><span class="sxs-lookup"><span data-stu-id="d7578-179">Note that the Delivery History service doesn't perform the actual analysis of the data.</span></span> <span data-ttu-id="d7578-180">Csak felelős adatfeldolgozást és tárolására.</span><span class="sxs-lookup"><span data-stu-id="d7578-180">It's only responsible for the ingestion and storage.</span></span> <span data-ttu-id="d7578-181">Ebben a forgatókönyvben a tárolót kell optimalizálni adatelemzés adatokat, a séma-a-olvasási megközelítés adatforrások számos olyan számos keresztül.</span><span class="sxs-lookup"><span data-stu-id="d7578-181">For this scenario, the storage must be optimized for data analysis over a large set of data, using a schema-on-read approach to accommodate a variety of data sources.</span></span> <span data-ttu-id="d7578-182">[Azure Data Lake Store](/azure/data-lake-store/) jó alkalmas ebben a forgatókönyvben.</span><span class="sxs-lookup"><span data-stu-id="d7578-182">[Azure Data Lake Store](/azure/data-lake-store/) is a good fit for this scenario.</span></span> <span data-ttu-id="d7578-183">Data Lake Store a Hadoop elosztott fájlrendszerrel (HDFS) kompatibilis Apache Hadoop fájl rendszer, és a teljesítmény adatok analytics forgatókönyvek van beállítva.</span><span class="sxs-lookup"><span data-stu-id="d7578-183">Data Lake Store is an Apache Hadoop file system compatible with Hadoop Distributed File System (HDFS), and is tuned for performance for data analytics scenarios.</span></span> 

<span data-ttu-id="d7578-184">A más forgatókönyv van így a felhasználók egy kézbesítési előzményeinek keresse meg a szállítási befejezése után.</span><span class="sxs-lookup"><span data-stu-id="d7578-184">The other scenario is enabling users to look up the history of a delivery after the delivery is completed.</span></span> <span data-ttu-id="d7578-185">Azure Data Lake különösen nincs optimalizálva ehhez a forgatókönyvhöz.</span><span class="sxs-lookup"><span data-stu-id="d7578-185">Azure Data Lake is not particularly optimized for this scenario.</span></span> <span data-ttu-id="d7578-186">Az optimális teljesítmény érdekében a Microsoft azt javasolja, Data Lake dátum szerint particionálva mappákban idősorozat adatok tárolására.</span><span class="sxs-lookup"><span data-stu-id="d7578-186">For optimal performance, Microsoft recommends storing time-series data in Data Lake in folders partitioned by date.</span></span> <span data-ttu-id="d7578-187">(Lásd: [hangolása Azure Data Lake Store a teljesítmény](/azure/data-lake-store/data-lake-store-performance-tuning-guidance)).</span><span class="sxs-lookup"><span data-stu-id="d7578-187">(See [Tuning Azure Data Lake Store for performance](/azure/data-lake-store/data-lake-store-performance-tuning-guidance)).</span></span> <span data-ttu-id="d7578-188">Struktúra azonban nem optimális gyűjtéséhez az egyes rekordok azonosítóját.</span><span class="sxs-lookup"><span data-stu-id="d7578-188">However, that structure is not optimal for looking up individual records by ID.</span></span> <span data-ttu-id="d7578-189">Csak is tudja a timestamp,-azonosító szerinti keresés igényel, a teljes gyűjteményt vizsgálatát.</span><span class="sxs-lookup"><span data-stu-id="d7578-189">Unless you also know the timestamp, a lookup by ID requires scanning the entire collection.</span></span> <span data-ttu-id="d7578-190">Emiatt a küldési előzményeinek szolgáltatás is tárolja a korábbi adatok egy részét Cosmos DB gyorsabb kereséshez.</span><span class="sxs-lookup"><span data-stu-id="d7578-190">Therefore, the Delivery History service also stores a subset of the historical data in Cosmos DB for quicker lookup.</span></span> <span data-ttu-id="d7578-191">A rekordok nem kell ahhoz, hogy határozatlan ideig maradjanak az Cosmos-Adatbázisba.</span><span class="sxs-lookup"><span data-stu-id="d7578-191">The records don't need to stay in Cosmos DB indefinitely.</span></span> <span data-ttu-id="d7578-192">Régebbi kézbesítések archiválhatók &mdash; tegyük fel például, egy hónap után.</span><span class="sxs-lookup"><span data-stu-id="d7578-192">Older deliveries can be archived &mdash; say, after a month.</span></span> <span data-ttu-id="d7578-193">Ezt megteheti az alkalmi kötegelt folyamat futtatásával.</span><span class="sxs-lookup"><span data-stu-id="d7578-193">This could be done by running an occasional batch process.</span></span>

### <a name="package-service"></a><span data-ttu-id="d7578-194">Csomag szolgáltatás</span><span class="sxs-lookup"><span data-stu-id="d7578-194">Package service</span></span>

<span data-ttu-id="d7578-195">A csomag szolgáltatás csomagokat kapcsolatos információkat tárolja.</span><span class="sxs-lookup"><span data-stu-id="d7578-195">The Package service stores information about all of the packages.</span></span> <span data-ttu-id="d7578-196">A csomag tárolási követelményei a következők:</span><span class="sxs-lookup"><span data-stu-id="d7578-196">The storage requirements for the Package are:</span></span> 

- <span data-ttu-id="d7578-197">Hosszú távú tároláshoz.</span><span class="sxs-lookup"><span data-stu-id="d7578-197">Long-term storage.</span></span>
- <span data-ttu-id="d7578-198">Nagy írási teljesítményt igénylő, a csomagok nagy mennyiségű kezelésére képes.</span><span class="sxs-lookup"><span data-stu-id="d7578-198">Able to handle a high volume of packages, requiring high write throughput.</span></span>
- <span data-ttu-id="d7578-199">Támogatja az egyszerű lekérdezések csomagazonosító.</span><span class="sxs-lookup"><span data-stu-id="d7578-199">Support simple queries by package ID.</span></span> <span data-ttu-id="d7578-200">Nincs bonyolult illesztésekre vagy a hivatkozási integritás követelményei.</span><span class="sxs-lookup"><span data-stu-id="d7578-200">No complex joins or requirements for referential integrity.</span></span>

<span data-ttu-id="d7578-201">Mivel a csomagban található adat nem relációs, egy Dokumentumközpontú adatbázis megfelelő, és Cosmos DB a szilánkos gyűjtemények segítségével nagyon nagy átviteli sebesség érhető el.</span><span class="sxs-lookup"><span data-stu-id="d7578-201">Because the package data is not relational, a document oriented database is appropriate, and Cosmos DB can achieve very high throughput by using sharded collections.</span></span> <span data-ttu-id="d7578-202">A csoport, amely a csomag szolgáltatásban működik, és melyik ismeri a átlagos verem (MongoDB, Express.js, AngularJS és Node.js), a a [MongoDB API](/azure/cosmos-db/mongodb-introduction) Cosmos-adatbázis számára.</span><span class="sxs-lookup"><span data-stu-id="d7578-202">The team that works on the Package service is familiar with the MEAN stack (MongoDB, Express.js, AngularJS, and Node.js), so they select the [MongoDB API](/azure/cosmos-db/mongodb-introduction) for Cosmos DB.</span></span> <span data-ttu-id="d7578-203">Amely lehetővé teszi, hogy kihasználja a meglévő tapasztalataikat a MongoDB, amely egy olyan felügyelt Azure szolgáltatás Cosmos DB előnyei lekérése közben.</span><span class="sxs-lookup"><span data-stu-id="d7578-203">That lets them leverage their existing experience with MongoDB, while getting the benefits of Cosmos DB, which is a managed Azure service.</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="d7578-204">Értekezleteire kommunikáció</span><span class="sxs-lookup"><span data-stu-id="d7578-204">Interservice communication</span></span>](./interservice-communication.md)