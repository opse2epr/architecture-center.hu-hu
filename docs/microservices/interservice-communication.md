---
title: Mikroszolgáltatások értekezleteire kommunikáció
description: Mikroszolgáltatások értekezleteire kommunikáció
author: MikeWasson
ms.date: 12/08/2017
ms.openlocfilehash: aff2fb7b2be25ca32d6224cee15363880cfb1488
ms.sourcegitcommit: a8453c4bc7c870fa1a12bb3c02e3b310db87530c
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 12/29/2017
---
# <a name="designing-microservices-interservice-communication"></a><span data-ttu-id="42bc1-103">Mikroszolgáltatások tervezése: Interservice kommunikáció</span><span class="sxs-lookup"><span data-stu-id="42bc1-103">Designing microservices: Interservice communication</span></span>

<span data-ttu-id="42bc1-104">Mikroszolgáltatások közötti kommunikáció hatékony és nagy teljesítményű kell lennie.</span><span class="sxs-lookup"><span data-stu-id="42bc1-104">Communication between microservices must be efficient and robust.</span></span> <span data-ttu-id="42bc1-105">A sok kisméretű szolgáltatások közötti kommunikáció során egyetlen tranzakció végrehajtásához kihívást is lehet.</span><span class="sxs-lookup"><span data-stu-id="42bc1-105">With lots of small services interacting to complete a single transaction, this can be a challenge.</span></span> <span data-ttu-id="42bc1-106">Ebben a fejezetben úgy tekintünk között szinkron API-k és aszinkron üzenetkezelési mellékhatásokkal is.</span><span class="sxs-lookup"><span data-stu-id="42bc1-106">In this chapter, we look at the tradeoffs between asynchronous messaging versus synchronous APIs.</span></span> <span data-ttu-id="42bc1-107">Ezután úgy tekintünk, néhány a kihívásokat tervezésének rugalmas értekezleteire kommunikációra és a szerepkör, amely a szolgáltatás rácsvonal játszhatja le.</span><span class="sxs-lookup"><span data-stu-id="42bc1-107">Then we look at some of the challenges in designing resilient interservice communication, and the role that a service mesh can play.</span></span>

![](./images/interservice-communication.png)

## <a name="challenges"></a><span data-ttu-id="42bc1-108">Kihívásai</span><span class="sxs-lookup"><span data-stu-id="42bc1-108">Challenges</span></span> 

<span data-ttu-id="42bc1-109">Az alábbiakban néhány fő kihívása szolgáltatások közötti kommunikációs eredő.</span><span class="sxs-lookup"><span data-stu-id="42bc1-109">Here are some of the main challenges arising from service-to-service communication.</span></span> <span data-ttu-id="42bc1-110">Szolgáltatás rácsvonalak, ez a fejezet ismerteti úgy tervezték, hogy ezek a kihívások számos kezelni.</span><span class="sxs-lookup"><span data-stu-id="42bc1-110">Service meshes, described later in this chapter, are designed to handle many of these challenges.</span></span>

<span data-ttu-id="42bc1-111">**Rugalmasság.**</span><span class="sxs-lookup"><span data-stu-id="42bc1-111">**Resiliency.**</span></span> <span data-ttu-id="42bc1-112">Lehetséges, hogy több tucatnyi vagy akár több száz bármely adott mikroszolgáltatási példányai.</span><span class="sxs-lookup"><span data-stu-id="42bc1-112">There may be dozens or even hundreds of instances of any given microservice.</span></span> <span data-ttu-id="42bc1-113">Egy példányát minden számos oka lehet sikertelen.</span><span class="sxs-lookup"><span data-stu-id="42bc1-113">An instance can fail for any number of reasons.</span></span> <span data-ttu-id="42bc1-114">Csomópont-szintű hiba, például hardverhiba vagy egy virtuális gép újraindítása lehet.</span><span class="sxs-lookup"><span data-stu-id="42bc1-114">There can be a node-level failure, such as a hardware failure or a VM reboot.</span></span> <span data-ttu-id="42bc1-115">Egy példány lehet, hogy összeomlás, vagy egyszerre az által, és nem lehet új kérelmeket feldolgozni.</span><span class="sxs-lookup"><span data-stu-id="42bc1-115">An instance might crash, or be overwhelmed with requests and unable to process any new requests.</span></span> <span data-ttu-id="42bc1-116">Ezek az események bármelyike okozhatja hálózati hívás sikertelen lesz.</span><span class="sxs-lookup"><span data-stu-id="42bc1-116">Any of these events can cause a network call to fail.</span></span> <span data-ttu-id="42bc1-117">Két tervezési mintáról olvashat, amelyek rugalmasabb teheti a hálózati szolgáltatások közötti hívások van:</span><span class="sxs-lookup"><span data-stu-id="42bc1-117">There are two design patterns that can help make service-to-service network calls more resilient:</span></span>

- <span data-ttu-id="42bc1-118">**[Próbálja meg újra](../patterns/retry.md)**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-118">**[Retry](../patterns/retry.md)**.</span></span> <span data-ttu-id="42bc1-119">Hálózati hívása sikertelen lehet, hogy megbizonyosodjon önmagában átmeneti hiba miatt.</span><span class="sxs-lookup"><span data-stu-id="42bc1-119">A network call may fail because of a transient fault that goes away by itself.</span></span> <span data-ttu-id="42bc1-120">Helyett nem végleges, az a hívó érdemes újra megpróbálnia a művelet bizonyos számú alkalommal, vagy amíg a konfigurált időkorlát lejárta általában.</span><span class="sxs-lookup"><span data-stu-id="42bc1-120">Rather than fail outright, the caller should typically retry the operation a certain number of times, or until a configured time-out period elapses.</span></span> <span data-ttu-id="42bc1-121">Azonban ha egy művelet nem idempotent, újrapróbálkozások okozhat, nem kívánt hatásai.</span><span class="sxs-lookup"><span data-stu-id="42bc1-121">However, if an operation is not idempotent, retries can cause unintended side effects.</span></span> <span data-ttu-id="42bc1-122">Az eredeti hívás sikeres lehet, de a hívó soha nem kap választ.</span><span class="sxs-lookup"><span data-stu-id="42bc1-122">The original call might succeed, but the caller never gets a response.</span></span> <span data-ttu-id="42bc1-123">Ha a hívó újrapróbálkozik, a művelet lehet, hogy hívható meg kétszer.</span><span class="sxs-lookup"><span data-stu-id="42bc1-123">If the caller retries, the operation may be invoked twice.</span></span> <span data-ttu-id="42bc1-124">Általában nincs biztonságos, majd ismételje meg a POST vagy javítás módszerek, mert ezek nem garantált, hogy az idempotent lehet.</span><span class="sxs-lookup"><span data-stu-id="42bc1-124">Generally, it's not safe to retry POST or PATCH methods, because these are not guaranteed to be idempotent.</span></span>

- <span data-ttu-id="42bc1-125">**[Áramköri megszakító](../patterns/circuit-breaker.md)**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-125">**[Circuit Breaker](../patterns/circuit-breaker.md)**.</span></span> <span data-ttu-id="42bc1-126">Túl sok sikertelen kérelem a szűk keresztmetszetek, függőben lévő kérelmek gyűlik össze a várólista okozhat.</span><span class="sxs-lookup"><span data-stu-id="42bc1-126">Too many failed requests can cause a bottleneck, as pending requests accumulate in the queue.</span></span> <span data-ttu-id="42bc1-127">Ezek a blokkolt kérelmek olyan kritikus rendszererőforrásokat akadályozhatnak, mint a memória, szálak, adatbázis-kapcsolatok stb., ezáltal pedig kaszkádolt meghibásodásokhoz vezethetnek.</span><span class="sxs-lookup"><span data-stu-id="42bc1-127">These blocked requests might hold critical system resources such as memory, threads, database connections, and so on, which can cause cascading failures.</span></span> <span data-ttu-id="42bc1-128">Az áramköri megszakító mintát megakadályozhatja, hogy a szolgáltatás ismételten közben, valószínűleg sikertelen művelet.</span><span class="sxs-lookup"><span data-stu-id="42bc1-128">The Circuit Breaker pattern can prevent a service from repeatedly trying an operation that is likely to fail.</span></span> 

<span data-ttu-id="42bc1-129">**Terheléselosztás**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-129">**Load balancing**.</span></span> <span data-ttu-id="42bc1-130">Ha a szolgáltatás "A" hívja service "B", a kérelem egy futó példány szolgáltatás "B" kell elérnie.</span><span class="sxs-lookup"><span data-stu-id="42bc1-130">When service "A" calls service "B", the request must reach a running instance of service "B".</span></span> <span data-ttu-id="42bc1-131">A Kubernetes a `Service` erőforrástípust biztosít egy stabil IP-címet három munkaállomás-csoporttal csoportja.</span><span class="sxs-lookup"><span data-stu-id="42bc1-131">In Kubernetes, the `Service` resource type provides a stable IP address for a group of pods.</span></span> <span data-ttu-id="42bc1-132">A szolgáltatás IP-címre a hálózati forgalom iptable szabályok segítségével lekérdezi egy pod továbbítja.</span><span class="sxs-lookup"><span data-stu-id="42bc1-132">Network traffic to the service's IP address gets forwarded to a pod by means of iptable rules.</span></span> <span data-ttu-id="42bc1-133">Alapértelmezés szerint egy véletlenszerű pod van kiválasztva.</span><span class="sxs-lookup"><span data-stu-id="42bc1-133">By default, a random pod is chosen.</span></span> <span data-ttu-id="42bc1-134">(Lásd alább) szolgáltatás rácsvonal biztosíthat intelligensebb terheléselosztási algoritmusok megfigyelt késést és más metrikák alapján.</span><span class="sxs-lookup"><span data-stu-id="42bc1-134">A service mesh (see below) can provide more intelligent load balancing algorithms based on observed latency or other metrics.</span></span>

<span data-ttu-id="42bc1-135">**Nyomkövetés elosztott**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-135">**Distributed tracing**.</span></span> <span data-ttu-id="42bc1-136">Egy tranzakció lehet, hogy span több szolgáltatásra.</span><span class="sxs-lookup"><span data-stu-id="42bc1-136">A single transaction may span multiple services.</span></span> <span data-ttu-id="42bc1-137">Amely teheti rögzített általános teljesítménye és a rendszer állapotának figyelésére.</span><span class="sxs-lookup"><span data-stu-id="42bc1-137">That can make it hard to monitor the overall performance and health of the system.</span></span> <span data-ttu-id="42bc1-138">Akkor is, ha minden szolgáltatások készítsenek-naplók és a metrikák nélkül alkalmazássá őket, hogy bármilyen módon korlátozott használat vannak.</span><span class="sxs-lookup"><span data-stu-id="42bc1-138">Even if every service generates logs and metrics, without some way to tie them together, they are of limited use.</span></span> <span data-ttu-id="42bc1-139">A fejezet [naplózás és figyelés](./logging-monitoring.md) megbeszélések arról elosztott nyomkövetés, de azt említse meg itt a kérdés.</span><span class="sxs-lookup"><span data-stu-id="42bc1-139">The chapter [Logging and monitoring](./logging-monitoring.md) talks more about distributed tracing, but we mention it here as a challenge.</span></span>

<span data-ttu-id="42bc1-140">**Service versioning**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-140">**Service versioning**.</span></span> <span data-ttu-id="42bc1-141">Egy csoport szolgáltatás új verzióját telepíti, ha el kell kerülni, szolgáltatások vagy külső ügyfelek esetében, függnek tőle.</span><span class="sxs-lookup"><span data-stu-id="42bc1-141">When a team deploys a new version of a service, they must avoid breaking any other services or external clients that depend on it.</span></span> <span data-ttu-id="42bc1-142">Emellett érdemes egy adott verzióra különböző verzióinak a szolgáltatás-párhuzamos és útvonal-kérelmek futtatásához.</span><span class="sxs-lookup"><span data-stu-id="42bc1-142">In addition, you might want to run multiple versions of a service side-by-side, and route requests to a particular version.</span></span> <span data-ttu-id="42bc1-143">Lásd: [API Versioning](./api-design.md#api-versioning) ennek a problémának a további leírását.</span><span class="sxs-lookup"><span data-stu-id="42bc1-143">See [API Versioning](./api-design.md#api-versioning) for more discussion of this issue.</span></span>

<span data-ttu-id="42bc1-144">**TLS-titkosítás és a kölcsönös TLS hitelesítés**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-144">**TLS encryption and mutual TLS authentication**.</span></span> <span data-ttu-id="42bc1-145">Biztonsági okokból érdemes lehet a TLS-szolgáltatások közötti forgalom titkosításához és TLS kölcsönös hitelesítés hitelesítéshez használni kívánt hívókat.</span><span class="sxs-lookup"><span data-stu-id="42bc1-145">For security reasons, you may want to encrypt traffic between services with TLS, and use mutual TLS authentication to authenticate callers.</span></span>

## <a name="synchronous-versus-asynchronous-messaging"></a><span data-ttu-id="42bc1-146">Szinkron és aszinkron üzenetkezelési</span><span class="sxs-lookup"><span data-stu-id="42bc1-146">Synchronous versus asynchronous messaging</span></span>

<span data-ttu-id="42bc1-147">Nincsenek két alapvető üzenetkezelési mintát, mikroszolgáltatások létrehozására használhat más mikroszolgáltatások folytatott kommunikációhoz.</span><span class="sxs-lookup"><span data-stu-id="42bc1-147">There are two basic messaging patterns that microservices can use to communicate with other microservices.</span></span> 

1. <span data-ttu-id="42bc1-148">Szinkron kommunikációt.</span><span class="sxs-lookup"><span data-stu-id="42bc1-148">Synchronous communication.</span></span> <span data-ttu-id="42bc1-149">Ebben a mintában a szolgáltatás hívja az API-t, amely egy másik szolgáltatás elérhetővé teszi, például a http- vagy gRPC protokoll használatát.</span><span class="sxs-lookup"><span data-stu-id="42bc1-149">In this pattern, a service calls an API that another service exposes, using a protocol such as HTTP or gRPC.</span></span> <span data-ttu-id="42bc1-150">Ez a beállítás nem egy aszinkron üzenettovábbítási mintának, mert a hívó a fogadó válaszára várakozik.</span><span class="sxs-lookup"><span data-stu-id="42bc1-150">This option is a synchronous messaging pattern because the caller waits for a response from the receiver.</span></span> 

2. <span data-ttu-id="42bc1-151">Aszinkron üzenettovábbítási.</span><span class="sxs-lookup"><span data-stu-id="42bc1-151">Asynchronous message passing.</span></span> <span data-ttu-id="42bc1-152">Ebben a mintában a szolgáltatás üzenetet küld a válaszra való várakozás nélkül, és egy vagy több szolgáltatás aszinkron módon feldolgozni az üzenetet.</span><span class="sxs-lookup"><span data-stu-id="42bc1-152">In this pattern, a service sends message without waiting for a response, and one or more services process the message asynchronously.</span></span>

<span data-ttu-id="42bc1-153">Fontos aszinkron i/o- és egy aszinkron protokoll megkülönböztetésére.</span><span class="sxs-lookup"><span data-stu-id="42bc1-153">It's important to distinguish between asynchronous I/O and an asynchronous protocol.</span></span> <span data-ttu-id="42bc1-154">Aszinkron I/O azt jelenti, hogy a hívó szál nincs letiltva, amíg az i/o-végzi.</span><span class="sxs-lookup"><span data-stu-id="42bc1-154">Asynchronous I/O means the calling thread is not blocked while the I/O completes.</span></span> <span data-ttu-id="42bc1-155">Amely fontos a teljesítmény, de egy megvalósítási részletes architektúrája tekintetében.</span><span class="sxs-lookup"><span data-stu-id="42bc1-155">That's important for performance, but is an implementation detail in terms of the architecture.</span></span> <span data-ttu-id="42bc1-156">Egy aszinkron protokoll azt jelenti, hogy a küldő nem várja meg a választ.</span><span class="sxs-lookup"><span data-stu-id="42bc1-156">An asynchronous protocol means the sender doesn't wait for a response.</span></span> <span data-ttu-id="42bc1-157">HTTP egy szinkron protokoll, annak ellenére, hogy a HTTP-ügyfelek használhatják aszinkron i/o kérelmet küld.</span><span class="sxs-lookup"><span data-stu-id="42bc1-157">HTTP is a synchronous protocol, even though an HTTP client may use asynchronous I/O when it sends a request.</span></span> 

<span data-ttu-id="42bc1-158">Nincsenek mellékhatásokkal minden típus.</span><span class="sxs-lookup"><span data-stu-id="42bc1-158">There are tradeoffs to each pattern.</span></span> <span data-ttu-id="42bc1-159">Kérelem-válasz egy jól érthető összeállítást,, így a több mint egy üzenetkezelési rendszerek tervezése természetes tervezése az API-k érezhetik.</span><span class="sxs-lookup"><span data-stu-id="42bc1-159">Request/response is a well-understood paradigm, so designing an API may feel more natural than designing a messaging system.</span></span> <span data-ttu-id="42bc1-160">Azonban aszinkron üzenetkezelési előnye is van bizonyos mikroszolgáltatások architektúra nagyon hasznosak lehetnek:</span><span class="sxs-lookup"><span data-stu-id="42bc1-160">However, asynchronous messaging has some advantages that can be very useful in a microservices architecture:</span></span>

- <span data-ttu-id="42bc1-161">**Kapcsolási csökkenteni**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-161">**Reduced coupling**.</span></span> <span data-ttu-id="42bc1-162">Az üzenet küldője nem kell tudnia a fogyasztó.</span><span class="sxs-lookup"><span data-stu-id="42bc1-162">The message sender does not need to know about the consumer.</span></span> 

- <span data-ttu-id="42bc1-163">**Több előfizető**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-163">**Multiple subscribers**.</span></span> <span data-ttu-id="42bc1-164">Egy pub/sub modellt használ, több felhasználóból is kérheti események.</span><span class="sxs-lookup"><span data-stu-id="42bc1-164">Using a pub/sub model, multiple consumers can subscribe to receive events.</span></span> <span data-ttu-id="42bc1-165">Lásd: [eseményvezérelt architektúra stílus](/azure/architecture/guide/architecture-styles/event-driven).</span><span class="sxs-lookup"><span data-stu-id="42bc1-165">See [Event-driven architecture style](/azure/architecture/guide/architecture-styles/event-driven).</span></span>

- <span data-ttu-id="42bc1-166">**Hiba elkülönítési**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-166">**Failure isolation**.</span></span> <span data-ttu-id="42bc1-167">Ha a fogyasztó nem sikerül, a küldő továbbra is küldhet üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="42bc1-167">If the consumer fails, the sender can still send messages.</span></span> <span data-ttu-id="42bc1-168">Az üzenetek fog felvenni, ha a fogyasztó állítja helyre.</span><span class="sxs-lookup"><span data-stu-id="42bc1-168">The messages will be picked up when the consumer recovers.</span></span> <span data-ttu-id="42bc1-169">Ez a lehetőség akkor különösen hasznos mikroszolgáltatások architektúra esetén, mert minden egyes szolgáltatás saját életciklus.</span><span class="sxs-lookup"><span data-stu-id="42bc1-169">This ability is especially useful in a microservices architecture, because each service has its own lifecycle.</span></span> <span data-ttu-id="42bc1-170">A szolgáltatás elérhetetlenné válik, vagy egy adott időpontban lecserél egy újabb verzióra.</span><span class="sxs-lookup"><span data-stu-id="42bc1-170">A service could become unavailable or be replaced with a newer version at any given time.</span></span> <span data-ttu-id="42bc1-171">Aszinkron üzenetkezelési időszakos állásidő képes kezelni.</span><span class="sxs-lookup"><span data-stu-id="42bc1-171">Asynchronous messaging can handle intermittent downtime.</span></span> <span data-ttu-id="42bc1-172">Szinkron API-k, másrészt megkövetelése az alárendelt szolgáltatás elérhető legyen, vagy a művelet sikertelen lesz.</span><span class="sxs-lookup"><span data-stu-id="42bc1-172">Synchronous APIs, on the other hand, require the downstream service to be available or the operation fails.</span></span> 
 
- <span data-ttu-id="42bc1-173">**Válaszkészsége**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-173">**Responsiveness**.</span></span> <span data-ttu-id="42bc1-174">Egy fölérendelt szolgáltatás gyorsabb válaszolhatnak, ha várja meg az alárendelt szolgáltatásokkal.</span><span class="sxs-lookup"><span data-stu-id="42bc1-174">An upstream service can reply faster if it does not wait on downstream services.</span></span> <span data-ttu-id="42bc1-175">Ez különösen fontos mikroszolgáltatások architektúra.</span><span class="sxs-lookup"><span data-stu-id="42bc1-175">This is especially useful in a microservices architecture.</span></span> <span data-ttu-id="42bc1-176">Ha (A B kiszolgálóra, amely meghívja a C, és így tovább) hívásokról függőségei láncolata, vár a szinkron hívások adhat hozzá késés mennyiségű nem fogadható el.</span><span class="sxs-lookup"><span data-stu-id="42bc1-176">If there is a chain of service dependencies (service A calls B, which calls C, and so on), waiting on synchronous calls can add unacceptable amounts of latency.</span></span>

- <span data-ttu-id="42bc1-177">**Terheléskiegyenlítés**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-177">**Load leveling**.</span></span> <span data-ttu-id="42bc1-178">A várólista működhet, és a munkaterhelés szinten puffert, hogy a fogadók a saját díj üzenetek feldolgozásához.</span><span class="sxs-lookup"><span data-stu-id="42bc1-178">A queue can act as a buffer to level the workload, so that receivers can process messages at their own rate.</span></span> 

- <span data-ttu-id="42bc1-179">**Munkafolyamatok**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-179">**Workflows**.</span></span> <span data-ttu-id="42bc1-180">Várólisták segítségével kezelheti a munkafolyamat jelölőnégyzet-mutat, az üzenet a munkafolyamat minden lépése után.</span><span class="sxs-lookup"><span data-stu-id="42bc1-180">Queues can be used to manage a workflow, by check-pointing the message after each step in the workflow.</span></span>

<span data-ttu-id="42bc1-181">Van azonban is használatával hatékonyan aszinkron üzenetkezelési némi kihívást.</span><span class="sxs-lookup"><span data-stu-id="42bc1-181">However, there are also some challenges to using asynchronous messaging effectively.</span></span>

- <span data-ttu-id="42bc1-182">**Az üzenetkezelési infrastruktúra kapcsoló**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-182">**Coupling with the messaging infrastructure**.</span></span> <span data-ttu-id="42bc1-183">Egy adott üzenetkezelési infrastruktúra használatával, hogy az infrastrukturális szoros kapcsoló okozhat.</span><span class="sxs-lookup"><span data-stu-id="42bc1-183">Using a particular messaging infrastructure may cause tight coupling with that infrastructure.</span></span> <span data-ttu-id="42bc1-184">Akkor nehezebben fogok tudni váltani egy másik üzenetkezelési infrastruktúra később lesz.</span><span class="sxs-lookup"><span data-stu-id="42bc1-184">It will be difficult to switch to another messaging infrastructure later.</span></span>

- <span data-ttu-id="42bc1-185">**Késés**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-185">**Latency**.</span></span> <span data-ttu-id="42bc1-186">Végpontok közötti késés művelet válhat, ha az üzenet-várólistákból feltöltve.</span><span class="sxs-lookup"><span data-stu-id="42bc1-186">End-to-end latency for an operation may become high if the message queues fill up.</span></span>  

- <span data-ttu-id="42bc1-187">**Költség**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-187">**Cost**.</span></span> <span data-ttu-id="42bc1-188">Magas teljesítmények, jelentős hatással lehet a az üzenetkezelési infrastruktúra költségét.</span><span class="sxs-lookup"><span data-stu-id="42bc1-188">At high throughputs, the monetary cost of the messaging infrastructure could be significant.</span></span>

- <span data-ttu-id="42bc1-189">**Összetettség**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-189">**Complexity**.</span></span> <span data-ttu-id="42bc1-190">Aszinkron üzenetkezelési kezelése értéke nem egy jelentéktelen feladat.</span><span class="sxs-lookup"><span data-stu-id="42bc1-190">Handling asynchronous messaging is not a trivial task.</span></span> <span data-ttu-id="42bc1-191">Duplikált üzenetek, például való másolásával vagy azáltal, hogy a műveletek az idempotent kell kezelni.</span><span class="sxs-lookup"><span data-stu-id="42bc1-191">For example, you must handle duplicated messages, either by de-duplicating or by making operations idempotent.</span></span> <span data-ttu-id="42bc1-192">Egyúttal rögzített kérés-válasz szemantika használatával aszinkron üzenetkezelési végrehajtásához.</span><span class="sxs-lookup"><span data-stu-id="42bc1-192">It's also hard to implement request-response semantics using asynchronous messaging.</span></span> <span data-ttu-id="42bc1-193">Visszajelzés küldése szüksége van egy másik várólistához, valamint olyan módon, és választ üzeneteket összefüggéseket.</span><span class="sxs-lookup"><span data-stu-id="42bc1-193">To send a response, you need another queue, plus a way to correlate request and response messages.</span></span>

- <span data-ttu-id="42bc1-194">**Átviteli sebesség**.</span><span class="sxs-lookup"><span data-stu-id="42bc1-194">**Throughput**.</span></span> <span data-ttu-id="42bc1-195">Ha üzenetek szükséges *szemantikáját várólistára*, a várólista szűk keresztmetszetet jelenthet a rendszerben.</span><span class="sxs-lookup"><span data-stu-id="42bc1-195">If messages require *queue semantics*, the queue can become a bottleneck in the system.</span></span> <span data-ttu-id="42bc1-196">Minden üzenet megköveteli, hogy legalább egy várólista működését, és egy created műveletet.</span><span class="sxs-lookup"><span data-stu-id="42bc1-196">Each message requires at least one queue operation and one dequeue operation.</span></span> <span data-ttu-id="42bc1-197">Ezenkívül várólista szemantikáját általában valamilyen zárolás belül az üzenetkezelési infrastruktúra szükséges.</span><span class="sxs-lookup"><span data-stu-id="42bc1-197">Moreover, queue semantics generally require some kind of locking inside the messaging infrastructure.</span></span> <span data-ttu-id="42bc1-198">Ha a várólista egy felügyelt szolgáltatás, előfordulhat további késést, mert a várólista külső a fürt virtuális hálózathoz.</span><span class="sxs-lookup"><span data-stu-id="42bc1-198">If the queue is a managed service, there may be additional latency, because the queue is external to the cluster's virtual network.</span></span> <span data-ttu-id="42bc1-199">Ezek a problémák mérséklésére vonatkozó útmutatások kötegelés üzenetek által, de, amely növeli a kódot.</span><span class="sxs-lookup"><span data-stu-id="42bc1-199">You can mitigate these issues by batching messages, but that complicates the code.</span></span> <span data-ttu-id="42bc1-200">Ha az üzenetek nem feltétlenül szükséges várólista szemantikáját, valószínűleg létre tudja esemény használandó *adatfolyam* helyett a sor.</span><span class="sxs-lookup"><span data-stu-id="42bc1-200">If the messages don't require queue semantics, you might be able to use an event *stream* instead of a queue.</span></span> <span data-ttu-id="42bc1-201">További információkért lásd: [architekturális stílus eseményvezérelt](../guide/architecture-styles/event-driven.md).</span><span class="sxs-lookup"><span data-stu-id="42bc1-201">For more information, see [Event-driven architectural style](../guide/architecture-styles/event-driven.md).</span></span>  

## <a name="drone-delivery-choosing-the-messaging-patterns"></a><span data-ttu-id="42bc1-202">Dron kézbesítési: Az üzenetkezelési mintát kiválasztása</span><span class="sxs-lookup"><span data-stu-id="42bc1-202">Drone Delivery: Choosing the messaging patterns</span></span>

<span data-ttu-id="42bc1-203">E szempontok figyelembe vételével a fejlesztői csapat végzett a következő tervezési döntések ütköznek azokkal a dron továbbítási alkalmazást hozhat létre a</span><span class="sxs-lookup"><span data-stu-id="42bc1-203">With these considerations in mind, the development team made the following design choices for the Drone Delivery application</span></span>

- <span data-ttu-id="42bc1-204">Az adatfeldolgozást szolgáltatás közzétesz egy nyilvános REST API ütemezése, frissítésére, vagy szakítsa meg a kézbesítések használó ügyfélalkalmazások.</span><span class="sxs-lookup"><span data-stu-id="42bc1-204">The Ingestion service exposes a public REST API that client applications use to schedule, update, or cancel deliveries.</span></span>

- <span data-ttu-id="42bc1-205">Az adatfeldolgozást szolgáltatás Event Hubs aszinkron üzeneteket küldhet a Feladatütemező szolgáltatás használja.</span><span class="sxs-lookup"><span data-stu-id="42bc1-205">The Ingestion service uses Event Hubs to send asynchronous messages to the Scheduler service.</span></span> <span data-ttu-id="42bc1-206">Aszinkron üzenetek is végre kell hajtani a terhelés-simítás adatfeldolgozást szükséges.</span><span class="sxs-lookup"><span data-stu-id="42bc1-206">Asynchronous messages are necessary to implement the load-leveling that is required for ingestion.</span></span> <span data-ttu-id="42bc1-207">Hogyan működnek együtt a adatfeldolgozást és a Feladatütemező szolgáltatás a részletekért lásd: [adatfeldolgozást és a munkafolyamat][ingestion-workflow].</span><span class="sxs-lookup"><span data-stu-id="42bc1-207">For details on how the Ingestion and Scheduler services interact, see [Ingestion and workflow][ingestion-workflow].</span></span>

- <span data-ttu-id="42bc1-208">Összes fiókot, a kézbesítési, a csomag, a dron és a külső átviteli szolgáltatások teszi közzé a belső REST API-k.</span><span class="sxs-lookup"><span data-stu-id="42bc1-208">The Account, Delivery, Package, Drone, and Third-party Transport services all expose internal REST APIs.</span></span> <span data-ttu-id="42bc1-209">A Feladatütemező szolgáltatás meghívja az ezen API-k egy felhasználói kérelem végrehajtásához.</span><span class="sxs-lookup"><span data-stu-id="42bc1-209">The Scheduler service calls these APIs to carry out a user request.</span></span> <span data-ttu-id="42bc1-210">Egy szinkron API-k használatára szükség, hogy a Feladatütemező kell az alárendelt szolgáltatások kapott választ.</span><span class="sxs-lookup"><span data-stu-id="42bc1-210">One reason to use synchronous APIs is that the Scheduler needs to get a response from each of the downstream services.</span></span> <span data-ttu-id="42bc1-211">Az alsóbb rétegbeli szolgáltatásai bármelyikének hibája miatt azt jelenti, hogy a teljes művelet sikertelen volt.</span><span class="sxs-lookup"><span data-stu-id="42bc1-211">A failure in any of the downstream services means the entire operation failed.</span></span> <span data-ttu-id="42bc1-212">Azonban lehetséges probléma a mértékű késés, a háttér-szolgáltatások meghívásával bevezetett.</span><span class="sxs-lookup"><span data-stu-id="42bc1-212">However, a potential issue is the amount of latency that is introduced by calling the backend services.</span></span> 

- <span data-ttu-id="42bc1-213">Ha bármely alárendelt szolgáltatás nem átmeneti hiba, a teljes tranzakció sikertelenként kell megjelölni.</span><span class="sxs-lookup"><span data-stu-id="42bc1-213">If any downstream service has a non-transient failure, the entire transaction should be marked as failed.</span></span> <span data-ttu-id="42bc1-214">Ebben az esetben kezelni, a Feladatütemező szolgáltatás aszinkron üzenetet küld a felügyelő, hogy a felügyelő ütemezhet kompenzációs tranzakciók a fejezetben leírtak [adatfeldolgozást és a munkafolyamat] [ ingestion-workflow].</span><span class="sxs-lookup"><span data-stu-id="42bc1-214">To handle this case, the Scheduler service sends an asynchronous message to the Supervisor, so that the Supervisor can schedule compensating transactions, as described in the chapter [Ingestion and workflow][ingestion-workflow].</span></span>   

- <span data-ttu-id="42bc1-215">A kézbesítési szolgáltatás közzétesz egy nyilvános API, amellyel az ügyfelek a szállítási állapotának beolvasása.</span><span class="sxs-lookup"><span data-stu-id="42bc1-215">The Delivery service exposes a public API that clients can use to get the status of a delivery.</span></span> <span data-ttu-id="42bc1-216">A fejezet [API átjáró](./gateway.md), hogyan egy API-átjáró az ügyféltől a mögöttes szolgáltatás elrejtése is tárgyaljuk, így az ügyfél nem szükséges tudni, hogy mely szolgáltatások elérhetővé mely API-k.</span><span class="sxs-lookup"><span data-stu-id="42bc1-216">In the chapter [API gateway](./gateway.md), we discuss how an API gateway can hide the underlying services from the client, so the client doesn't need to know which services expose which APIs.</span></span> 

- <span data-ttu-id="42bc1-217">Míg egy dron útban, akkor a dron szolgáltatás események, amelyek tartalmazzák a dron aktuális hely és az állapot küld.</span><span class="sxs-lookup"><span data-stu-id="42bc1-217">While a drone is in flight, the Drone service sends events that contain the drone's current location and status.</span></span> <span data-ttu-id="42bc1-218">A kézbesítési szolgáltatás figyeli a ezeket az eseményeket egy kézbesítési állapotának nyomon követése érdekében.</span><span class="sxs-lookup"><span data-stu-id="42bc1-218">The Delivery service listens to these events in order to track the status of a delivery.</span></span>

- <span data-ttu-id="42bc1-219">A kézbesítési állapotának megváltozásakor a kézbesítési szolgáltatás például küld-e a kézbesítési állapot eseményt `DeliveryCreated` vagy `DeliveryCompleted`.</span><span class="sxs-lookup"><span data-stu-id="42bc1-219">When the status of a delivery changes, the Delivery service sends a delivery status event, such as `DeliveryCreated` or `DeliveryCompleted`.</span></span> <span data-ttu-id="42bc1-220">Minden szolgáltatás fizethet ezeket az eseményeket.</span><span class="sxs-lookup"><span data-stu-id="42bc1-220">Any service can subscribe to these events.</span></span> <span data-ttu-id="42bc1-221">Az aktuális terv a kézbesítési szolgáltatás csak előfizető, de lehet más előfizetők később.</span><span class="sxs-lookup"><span data-stu-id="42bc1-221">In the current design, the Delivery service is the only subscriber, but there might be other subscribers later.</span></span> <span data-ttu-id="42bc1-222">Az események kódhiba például egy valós idejű elemzési szolgáltatás.</span><span class="sxs-lookup"><span data-stu-id="42bc1-222">For example, the events might go to a real-time analytics service.</span></span> <span data-ttu-id="42bc1-223">És a válaszra való várakozás a Feladatütemező nem kell, mert további előfizetők hozzáadása nem befolyásolja a fő munkafolyamat elérési útját.</span><span class="sxs-lookup"><span data-stu-id="42bc1-223">And because the Scheduler doesn't have to wait for a response, adding more subscribers doesn't affect the main workflow path.</span></span>

![](./images/drone-communication.png)

<span data-ttu-id="42bc1-224">Figyelje meg, hogy kézbesítési állapoteseményeit származó dron hely események.</span><span class="sxs-lookup"><span data-stu-id="42bc1-224">Notice that delivery status events are derived from drone location events.</span></span> <span data-ttu-id="42bc1-225">Például ha egy csomag csökken egy dron eléri a kézbesítési hely, a kézbesítési szolgáltatás fordítja le ez a DeliveryCompleted esemény.</span><span class="sxs-lookup"><span data-stu-id="42bc1-225">For example, when a drone reaches a delivery location and drops off a package, the Delivery service translates this into a DeliveryCompleted event.</span></span> <span data-ttu-id="42bc1-226">Ez az tekintetében tartomány modellek számbavétele példát.</span><span class="sxs-lookup"><span data-stu-id="42bc1-226">This is an example of thinking in terms of domain models.</span></span> <span data-ttu-id="42bc1-227">A fentebb leírt módon dron felügyeleti külön kötött környezetben tartozik.</span><span class="sxs-lookup"><span data-stu-id="42bc1-227">As described earlier, Drone Management belongs in a separate bounded context.</span></span> <span data-ttu-id="42bc1-228">A dron események átadja egy dron fizikai helyét.</span><span class="sxs-lookup"><span data-stu-id="42bc1-228">The drone events convey the physical location of a drone.</span></span> <span data-ttu-id="42bc1-229">Kézbesítési eseményeket, másrészt a kézbesítési, amely a különböző üzleti egységek bekövetkező változások jelölik.</span><span class="sxs-lookup"><span data-stu-id="42bc1-229">The delivery events, on the other hand, represent changes in the status of a delivery, which is a different business entity.</span></span>

## <a name="using-a-service-mesh"></a><span data-ttu-id="42bc1-230">A szolgáltatás háló használatával</span><span class="sxs-lookup"><span data-stu-id="42bc1-230">Using a service mesh</span></span>

<span data-ttu-id="42bc1-231">A *háló szolgáltatás* van, amely kezeli a szolgáltatások közötti kommunikáció software réteg.</span><span class="sxs-lookup"><span data-stu-id="42bc1-231">A *service mesh* is a software layer that handles service-to-service communication.</span></span> <span data-ttu-id="42bc1-232">Az előző szakaszban felsorolt fontos szempont számos megoldására, és helyezze át a problémák elhagyja a mikroszolgáltatások magukat, és egy megosztott rétegbe felelősséget szolgáltatás rácsvonalak úgy lettek kialakítva.</span><span class="sxs-lookup"><span data-stu-id="42bc1-232">Service meshes are designed to address many of the concerns listed in the previous section, and to move responsibility for these concerns away from the microservices themselves and into a shared layer.</span></span> <span data-ttu-id="42bc1-233">A szolgáltatás háló, amely elfogja a fürt mikroszolgáltatások közötti hálózati kommunikációhoz proxyként funkcionál.</span><span class="sxs-lookup"><span data-stu-id="42bc1-233">The service mesh acts as a proxy that intercepts network communication between microservices in the cluster.</span></span> 

> [!NOTE]
> <span data-ttu-id="42bc1-234">Szolgáltatás háló látható egy példa a [diplomata mintát](../patterns/ambassador.md) &mdash; egy segítő szolgáltatás által a hálózati kérelmek, az alkalmazás nevében.</span><span class="sxs-lookup"><span data-stu-id="42bc1-234">Service mesh is an example of the [Ambassador pattern](../patterns/ambassador.md) &mdash; a helper service that sends network requests on behalf of the application.</span></span> 

<span data-ttu-id="42bc1-235">Most, a fő lehetőség közül választhat a Kubernetes szolgáltatás rácsvonal [linkerd](https://linkerd.io/) és [Istio](https://istio.io/).</span><span class="sxs-lookup"><span data-stu-id="42bc1-235">Right now, the main options for a service mesh in Kubernetes are [linkerd](https://linkerd.io/) and [Istio](https://istio.io/).</span></span> <span data-ttu-id="42bc1-236">Mindkét technológiát vannak fejlesztik gyorsan.</span><span class="sxs-lookup"><span data-stu-id="42bc1-236">Both of these technologies are evolving rapidly.</span></span> <span data-ttu-id="42bc1-237">Jelenleg a korábban megírt ebben az útmutatóban Istio legújabb kiadásának 0,2, így továbbra is nagyon új.</span><span class="sxs-lookup"><span data-stu-id="42bc1-237">At the time we wrote this guide, the latest Istio release is 0.2, so it is still very new.</span></span> <span data-ttu-id="42bc1-238">Azonban az linkerd és Istio is rendelkezik közös bizonyos funkciókat tartalmazza:</span><span class="sxs-lookup"><span data-stu-id="42bc1-238">However, some features that both linkerd and Istio have in common include:</span></span> 

- <span data-ttu-id="42bc1-239">Terheléselosztás munkamenet szinten, a megfigyelt késések vagy a függőben lévő kérelmek száma alapján.</span><span class="sxs-lookup"><span data-stu-id="42bc1-239">Load balancing at the session level, based on observed latencies or number of outstanding requests.</span></span> <span data-ttu-id="42bc1-240">A réteg-4 terheléselosztás Kubernetes által biztosított keresztül javíthatja a teljesítményt.</span><span class="sxs-lookup"><span data-stu-id="42bc1-240">This can improve performance over the layer-4 load balancing that is provided by Kubernetes.</span></span> 

- <span data-ttu-id="42bc1-241">Réteg-7 útválasztási URL-címe, állomásfejléc, API-verzió vagy más alkalmazásszintű szabályok alapján.</span><span class="sxs-lookup"><span data-stu-id="42bc1-241">Layer-7 routing based on URL path, Host header, API version, or other application-level rules.</span></span>

- <span data-ttu-id="42bc1-242">Próbálja meg újra a sikertelen kérelmek.</span><span class="sxs-lookup"><span data-stu-id="42bc1-242">Retry of failed requests.</span></span> <span data-ttu-id="42bc1-243">Egy szolgáltatás háló HTTP hibakódok megértette, és automatikusan újra a sikertelen kérelmek.</span><span class="sxs-lookup"><span data-stu-id="42bc1-243">A service mesh understands HTTP error codes, and can automatically retry failed requests.</span></span> <span data-ttu-id="42bc1-244">Beállíthatja, hogy a maximális számú újrapróbálkozást, a határidőn ahhoz, hogy a maximális késleltetés kötött együtt.</span><span class="sxs-lookup"><span data-stu-id="42bc1-244">You can configure that maximum number of retries, along with a timeout period in order to bound the maximum latency.</span></span> 

- <span data-ttu-id="42bc1-245">Kör legfrissebb.</span><span class="sxs-lookup"><span data-stu-id="42bc1-245">Circuit breaking.</span></span> <span data-ttu-id="42bc1-246">Ha példány következetesen sikertelen kérelmek, a szolgáltatás háló fog ideiglenesen megjelölése nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="42bc1-246">If an instance consistently fails requests, the service mesh will temporarily mark it as unavailable.</span></span> <span data-ttu-id="42bc1-247">A leállási idő után újra megpróbálja a a példányt.</span><span class="sxs-lookup"><span data-stu-id="42bc1-247">After a backoff period, it will try the instance again.</span></span> <span data-ttu-id="42bc1-248">Konfigurálhatja az áramköri megszakító különböző feltételek, például az egymást követő hibák száma alapján</span><span class="sxs-lookup"><span data-stu-id="42bc1-248">You can configure the circuit breaker based on various criteria, such as the number of consecutive failures,</span></span>  

- <span data-ttu-id="42bc1-249">Szolgáltatás háló értekezleteire indított, például a kérést, a késés, a hiba és annak sikeressége díjszabás és a válasz méretek kapcsolatos metrikákat rögzíti.</span><span class="sxs-lookup"><span data-stu-id="42bc1-249">Service mesh captures metrics about interservice calls, such as the request volume, latency, error and success rates, and response sizes.</span></span> <span data-ttu-id="42bc1-250">Szolgáltatás háló is lehetővé teszi, hogy elosztott nyomkövetés korrelációs adatokat az egyes ugrások hozzáadásával a kérelemben.</span><span class="sxs-lookup"><span data-stu-id="42bc1-250">The service mesh also enables distributed tracing by adding correlation information for each hop in a request.</span></span>

- <span data-ttu-id="42bc1-251">Szolgáltatások közötti hívások kölcsönös TLS hitelesítés.</span><span class="sxs-lookup"><span data-stu-id="42bc1-251">Mutual TLS Authentication for service-to-service calls.</span></span>

<span data-ttu-id="42bc1-252">Kell-e a szolgáltatás háló?</span><span class="sxs-lookup"><span data-stu-id="42bc1-252">Do you need a service mesh?</span></span> <span data-ttu-id="42bc1-253">Elosztott rendszer megnövelik értéke alapértékekkel kényszerítő.</span><span class="sxs-lookup"><span data-stu-id="42bc1-253">The value they add to a distributed system is certainly compelling.</span></span> <span data-ttu-id="42bc1-254">Ha nem rendelkezik a szolgáltatás rácsvonal, szüksége lesz figyelembe kell venni a fejezet elején említett kihívásai mindegyikének.</span><span class="sxs-lookup"><span data-stu-id="42bc1-254">If you don't have a service mesh, you will need to consider each of the challenges mentioned at the beginning of the chapter.</span></span> <span data-ttu-id="42bc1-255">Megoldható problémák, mint például az újra gombra, áramköri megszakító és elosztott nyomkövetési szolgáltatás rácsvonal nélkül, de a szolgáltatás háló helyezi át a problémák kívül az egyes szolgáltatások és egy dedikált rétegbe.</span><span class="sxs-lookup"><span data-stu-id="42bc1-255">You can solve problems like retry, circuit breaker, and distributed tracing without a service mesh, but a service mesh moves these concerns out of the individual services and into a dedicated layer.</span></span> <span data-ttu-id="42bc1-256">Szolgáltatás rácsvonalak, másrészt viszonylag új technológia, amely még lejáró.</span><span class="sxs-lookup"><span data-stu-id="42bc1-256">On the other hand, service meshes are a relatively new technology that is still maturing.</span></span> <span data-ttu-id="42bc1-257">A telepítő és a fürt konfigurációjának telepítése egy szolgáltatás háló hozzáadja összetettségét.</span><span class="sxs-lookup"><span data-stu-id="42bc1-257">Deploying a service mesh adds complexity to the setup and configuration of the cluster.</span></span> <span data-ttu-id="42bc1-258">Előfordulhatnak teljesítményre gyakorolt hatása, mivel a kérelmek most beolvasása keresztül történik a háló proxy, és mivel a felesleges szolgáltatások futnak a fürt minden csomópontján.</span><span class="sxs-lookup"><span data-stu-id="42bc1-258">There may be performance implications, because requests now get routed through the service mesh proxy, and because extra services are now running on every node in the cluster.</span></span> <span data-ttu-id="42bc1-259">Hajtsa végre az alapos teljesítmény kell, és terheléses tesztelés szolgáltatás rácsvonal éles környezetben üzembe helyezése előtt.</span><span class="sxs-lookup"><span data-stu-id="42bc1-259">You should do thorough performance and load testing before deploying a service mesh in production.</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="42bc1-260">API-Tervező</span><span class="sxs-lookup"><span data-stu-id="42bc1-260">API design</span></span>](./api-design.md)

<!-- links -->

[ingestion-workflow]: ./ingestion-workflow.md
