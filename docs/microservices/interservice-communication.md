---
title: Szolgáltatások közötti kommunikáció a mikroszolgáltatások
description: Szolgáltatások közötti kommunikáció a mikroszolgáltatások
author: MikeWasson
ms.date: 10/23/2018
ms.topic: guide
ms.service: architecture-center
ms.subservice: reference-architecture
ms.custom: microservices
ms.openlocfilehash: 7b1a5d7d6d386f707ff0842c08ff342dc5a1bbbd
ms.sourcegitcommit: 1b50810208354577b00e89e5c031b774b02736e2
ms.translationtype: MT
ms.contentlocale: hu-HU
ms.lasthandoff: 01/23/2019
ms.locfileid: "54480640"
---
# <a name="designing-microservices-interservice-communication"></a><span data-ttu-id="2ccde-103">Mikroszolgáltatások tervezése: Szolgáltatások közötti kommunikáció</span><span class="sxs-lookup"><span data-stu-id="2ccde-103">Designing microservices: Interservice communication</span></span>

<span data-ttu-id="2ccde-104">Mikroszolgáltatások közötti kommunikáció hatékony és robusztus kell lennie.</span><span class="sxs-lookup"><span data-stu-id="2ccde-104">Communication between microservices must be efficient and robust.</span></span> <span data-ttu-id="2ccde-105">Sok kis szolgáltatások egyetlen tranzakció végrehajtásához használja ez kihívást jelenthet.</span><span class="sxs-lookup"><span data-stu-id="2ccde-105">With lots of small services interacting to complete a single transaction, this can be a challenge.</span></span> <span data-ttu-id="2ccde-106">Ebben a fejezetben áttekintjük az aszinkron üzenetkezelés és szinkron API-k érvényesíthető kompromisszumokat.</span><span class="sxs-lookup"><span data-stu-id="2ccde-106">In this chapter, we look at the tradeoffs between asynchronous messaging versus synchronous APIs.</span></span> <span data-ttu-id="2ccde-107">Ezután hogy tekintsen meg néhányat a rugalmas közötti kommunikációt eredményezhet, és a szerepkör, amely a szolgáltatás rácsvonal lejátszható kialakításának is kihívást jelent.</span><span class="sxs-lookup"><span data-stu-id="2ccde-107">Then we look at some of the challenges in designing resilient interservice communication, and the role that a service mesh can play.</span></span>

![Szolgáltatások közötti kommunikációt eredményezhet ábrája](./images/interservice-communication.png)

## <a name="challenges"></a><span data-ttu-id="2ccde-109">Problémák</span><span class="sxs-lookup"><span data-stu-id="2ccde-109">Challenges</span></span>

<span data-ttu-id="2ccde-110">Íme néhány fő kihívása merül fel a szolgáltatások közötti kommunikációt.</span><span class="sxs-lookup"><span data-stu-id="2ccde-110">Here are some of the main challenges arising from service-to-service communication.</span></span> <span data-ttu-id="2ccde-111">Szolgáltatás rácsvonalak, ebben a fejezetben ismertetett számos, ezek a kihívások kezelésére tervezték.</span><span class="sxs-lookup"><span data-stu-id="2ccde-111">Service meshes, described later in this chapter, are designed to handle many of these challenges.</span></span>

<span data-ttu-id="2ccde-112">**Rugalmasság**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-112">**Resiliency**.</span></span> <span data-ttu-id="2ccde-113">Lehetséges, hogy több tucat vagy akár több száz bármely adott mikroszolgáltatás-példányok.</span><span class="sxs-lookup"><span data-stu-id="2ccde-113">There may be dozens or even hundreds of instances of any given microservice.</span></span> <span data-ttu-id="2ccde-114">Egy példány nem sikerül, számtalan.</span><span class="sxs-lookup"><span data-stu-id="2ccde-114">An instance can fail for any number of reasons.</span></span> <span data-ttu-id="2ccde-115">Csomópont-szintű hiba, például egy hardverhiba vagy a virtuális gép újraindítását is lehet.</span><span class="sxs-lookup"><span data-stu-id="2ccde-115">There can be a node-level failure, such as a hardware failure or a VM reboot.</span></span> <span data-ttu-id="2ccde-116">Egy példány lehet, hogy az összeomlási, vagy kihasznált, a kérelmek és az új kérések feldolgozása nem sikerült.</span><span class="sxs-lookup"><span data-stu-id="2ccde-116">An instance might crash, or be overwhelmed with requests and unable to process any new requests.</span></span> <span data-ttu-id="2ccde-117">Ezek az események bármelyikét okozhatja hálózati hívása sikertelen.</span><span class="sxs-lookup"><span data-stu-id="2ccde-117">Any of these events can cause a network call to fail.</span></span> <span data-ttu-id="2ccde-118">Nincsenek elősegítheti a hálózati szolgáltatások közötti hívások rugalmasabb két kialakítási minta:</span><span class="sxs-lookup"><span data-stu-id="2ccde-118">There are two design patterns that can help make service-to-service network calls more resilient:</span></span>

- <span data-ttu-id="2ccde-119">**[Ismételje meg](../patterns/retry.md)**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-119">**[Retry](../patterns/retry.md)**.</span></span> <span data-ttu-id="2ccde-120">Egy hálózati hívások meghiúsulhatnak, ami újbóli próbálkozással megszűnik önmagában átmeneti hiba miatt.</span><span class="sxs-lookup"><span data-stu-id="2ccde-120">A network call may fail because of a transient fault that goes away by itself.</span></span> <span data-ttu-id="2ccde-121">Helyett tudnának sikertelen, az a hívó kell próbálja megismételni a műveletet egy bizonyos szám, ahányszor, vagy amíg a beállított időkorlát lejárta általában.</span><span class="sxs-lookup"><span data-stu-id="2ccde-121">Rather than fail outright, the caller should typically retry the operation a certain number of times, or until a configured time-out period elapses.</span></span> <span data-ttu-id="2ccde-122">Azonban ha egy művelet nem idempotens, az újrapróbálkozások okozhat, nem kívánt mellékhatásokkal.</span><span class="sxs-lookup"><span data-stu-id="2ccde-122">However, if an operation is not idempotent, retries can cause unintended side effects.</span></span> <span data-ttu-id="2ccde-123">Az eredeti hívás sikeres lehet, de a hívó soha nem kap választ.</span><span class="sxs-lookup"><span data-stu-id="2ccde-123">The original call might succeed, but the caller never gets a response.</span></span> <span data-ttu-id="2ccde-124">A hívó újrapróbálkozik, ha a művelet kétszer is érvényesíthetők.</span><span class="sxs-lookup"><span data-stu-id="2ccde-124">If the caller retries, the operation may be invoked twice.</span></span> <span data-ttu-id="2ccde-125">Általában nem biztonságos az újrapróbálkozás POST és PATCH metódusokat, mert ezek nem garantált, hogy idempotensek legyenek.</span><span class="sxs-lookup"><span data-stu-id="2ccde-125">Generally, it's not safe to retry POST or PATCH methods, because these are not guaranteed to be idempotent.</span></span>

- <span data-ttu-id="2ccde-126">**[Áramkör-megszakító](../patterns/circuit-breaker.md)**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-126">**[Circuit Breaker](../patterns/circuit-breaker.md)**.</span></span> <span data-ttu-id="2ccde-127">Túl sok sikertelen kérelem okozhat a szűk keresztmetszet, mert függőben lévő kérelmek halmozódnak az üzenetsorban.</span><span class="sxs-lookup"><span data-stu-id="2ccde-127">Too many failed requests can cause a bottleneck, as pending requests accumulate in the queue.</span></span> <span data-ttu-id="2ccde-128">Ezek a blokkolt kérelmek olyan kritikus rendszererőforrásokat akadályozhatnak, mint a memória, szálak, adatbázis-kapcsolatok stb., ezáltal pedig kaszkádolt meghibásodásokhoz vezethetnek.</span><span class="sxs-lookup"><span data-stu-id="2ccde-128">These blocked requests might hold critical system resources such as memory, threads, database connections, and so on, which can cause cascading failures.</span></span> <span data-ttu-id="2ccde-129">Az áramkör-megszakítási minta megakadályozhatja, hogy a szolgáltatás próbáljon többször végrehajtani egy műveletet, amely nagy eséllyel lesz sikertelen.</span><span class="sxs-lookup"><span data-stu-id="2ccde-129">The Circuit Breaker pattern can prevent a service from repeatedly trying an operation that is likely to fail.</span></span>

<span data-ttu-id="2ccde-130">**Terheléselosztás**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-130">**Load balancing**.</span></span> <span data-ttu-id="2ccde-131">Service "A" "B" szolgáltatást hív meg, ha a kérelem egy futó példány a "B" szolgáltatás kell elérnie.</span><span class="sxs-lookup"><span data-stu-id="2ccde-131">When service "A" calls service "B", the request must reach a running instance of service "B".</span></span> <span data-ttu-id="2ccde-132">A Kubernetes a `Service` erőforrástípus egy stabil IP-címet biztosít a podok csoportja.</span><span class="sxs-lookup"><span data-stu-id="2ccde-132">In Kubernetes, the `Service` resource type provides a stable IP address for a group of pods.</span></span> <span data-ttu-id="2ccde-133">A szolgáltatás IP-címet a hálózati forgalom iptable szabályok segítségével lekérdezi továbbítani podot.</span><span class="sxs-lookup"><span data-stu-id="2ccde-133">Network traffic to the service's IP address gets forwarded to a pod by means of iptable rules.</span></span> <span data-ttu-id="2ccde-134">Alapértelmezés szerint egy véletlenszerű pod van kiválasztva.</span><span class="sxs-lookup"><span data-stu-id="2ccde-134">By default, a random pod is chosen.</span></span> <span data-ttu-id="2ccde-135">A szolgáltatás rácsvonal (lásd alább) biztosíthat intelligens terheléselosztási algoritmusok megfigyelt várakozási ideje vagy egyéb mérőszámok alapján.</span><span class="sxs-lookup"><span data-stu-id="2ccde-135">A service mesh (see below) can provide more intelligent load balancing algorithms based on observed latency or other metrics.</span></span>

<span data-ttu-id="2ccde-136">**Elosztott nyomkövetési**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-136">**Distributed tracing**.</span></span> <span data-ttu-id="2ccde-137">Egy tranzakció több szolgáltatást magában foglalhat.</span><span class="sxs-lookup"><span data-stu-id="2ccde-137">A single transaction may span multiple services.</span></span> <span data-ttu-id="2ccde-138">Amely megnehezítheti annak visszakövetését általános teljesítményt és a rendszer állapotának figyeléséhez.</span><span class="sxs-lookup"><span data-stu-id="2ccde-138">That can make it hard to monitor the overall performance and health of the system.</span></span> <span data-ttu-id="2ccde-139">Akkor is, ha minden szolgáltatás állít elő, naplókat és mérőszámokat, anélkül, hogy bármilyen módon összekapcsolása őket, csak korlátozottan használhatók legyenek.</span><span class="sxs-lookup"><span data-stu-id="2ccde-139">Even if every service generates logs and metrics, without some way to tie them together, they are of limited use.</span></span> <span data-ttu-id="2ccde-140">A fejezet [naplózást és figyelést](./logging-monitoring.md) előadások többet is megtudhat az elosztott nyomkövetést, de azt díjszabásunkban itt, kihívást.</span><span class="sxs-lookup"><span data-stu-id="2ccde-140">The chapter [Logging and monitoring](./logging-monitoring.md) talks more about distributed tracing, but we mention it here as a challenge.</span></span>

<span data-ttu-id="2ccde-141">**Service versioning**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-141">**Service versioning**.</span></span> <span data-ttu-id="2ccde-142">Ha egy csapat helyez üzembe egy szolgáltatás egy új verzióját, el kell kerülni, használhatatlanná tévő szolgáltatások vagy külső a tőle függő ügyfeleket.</span><span class="sxs-lookup"><span data-stu-id="2ccde-142">When a team deploys a new version of a service, they must avoid breaking any other services or external clients that depend on it.</span></span> <span data-ttu-id="2ccde-143">Emellett érdemes egy szolgáltatást egymás mellett, és átirányíthatja a kéréseket több verziójának futtatására egy meghatározott verzióra.</span><span class="sxs-lookup"><span data-stu-id="2ccde-143">In addition, you might want to run multiple versions of a service side-by-side, and route requests to a particular version.</span></span> <span data-ttu-id="2ccde-144">Lásd: [API-k verziókezelése](./api-design.md#api-versioning) további beszélgetéshez, a problémát.</span><span class="sxs-lookup"><span data-stu-id="2ccde-144">See [API Versioning](./api-design.md#api-versioning) for more discussion of this issue.</span></span>

<span data-ttu-id="2ccde-145">**A TLS-titkosítás és a kölcsönös TLS hitelesítés**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-145">**TLS encryption and mutual TLS authentication**.</span></span> <span data-ttu-id="2ccde-146">Biztonsági okokból érdemes a TLS-szolgáltatások közötti forgalom titkosításához, és használja a TLS kölcsönös hitelesítés hívóit hitelesítéséhez.</span><span class="sxs-lookup"><span data-stu-id="2ccde-146">For security reasons, you may want to encrypt traffic between services with TLS, and use mutual TLS authentication to authenticate callers.</span></span>

## <a name="synchronous-versus-asynchronous-messaging"></a><span data-ttu-id="2ccde-147">A szinkron és aszinkron üzenetkezelés</span><span class="sxs-lookup"><span data-stu-id="2ccde-147">Synchronous versus asynchronous messaging</span></span>

<span data-ttu-id="2ccde-148">Nincsenek két alapvető üzenetkezelési mintát, amely mikroszolgáltatások más mikroszolgáltatások folytatott kommunikációhoz használható.</span><span class="sxs-lookup"><span data-stu-id="2ccde-148">There are two basic messaging patterns that microservices can use to communicate with other microservices.</span></span>

1. <span data-ttu-id="2ccde-149">Szinkron kommunikációt.</span><span class="sxs-lookup"><span data-stu-id="2ccde-149">Synchronous communication.</span></span> <span data-ttu-id="2ccde-150">Ebben a mintában egy szolgáltatás meghív egy API, amely egy másik szolgáltatás, például a HTTP- vagy gRPC protokoll használatát.</span><span class="sxs-lookup"><span data-stu-id="2ccde-150">In this pattern, a service calls an API that another service exposes, using a protocol such as HTTP or gRPC.</span></span> <span data-ttu-id="2ccde-151">Ez a beállítás egy szinkron üzenetkezelési minta azért a hívó megvárja a címzett válaszát.</span><span class="sxs-lookup"><span data-stu-id="2ccde-151">This option is a synchronous messaging pattern because the caller waits for a response from the receiver.</span></span>

2. <span data-ttu-id="2ccde-152">Aszinkron üzenettovábbítási.</span><span class="sxs-lookup"><span data-stu-id="2ccde-152">Asynchronous message passing.</span></span> <span data-ttu-id="2ccde-153">Ebben a mintában egy szolgáltatás üzenetet küld a válaszra való várakozás nélkül, és a egy vagy több szolgáltatás aszinkron módon feldolgozni az üzenetet.</span><span class="sxs-lookup"><span data-stu-id="2ccde-153">In this pattern, a service sends message without waiting for a response, and one or more services process the message asynchronously.</span></span>

<span data-ttu-id="2ccde-154">Fontos, aszinkron i/o- és a egy aszinkron protokoll megkülönböztetésére.</span><span class="sxs-lookup"><span data-stu-id="2ccde-154">It's important to distinguish between asynchronous I/O and an asynchronous protocol.</span></span> <span data-ttu-id="2ccde-155">Aszinkron I/O azt jelenti, hogy a hívó szálat az I/O végrehajtása során nincs letiltva.</span><span class="sxs-lookup"><span data-stu-id="2ccde-155">Asynchronous I/O means the calling thread is not blocked while the I/O completes.</span></span> <span data-ttu-id="2ccde-156">Amely fontos a teljesítmény, de egy implementálási részlete az architektúra szempontjából.</span><span class="sxs-lookup"><span data-stu-id="2ccde-156">That's important for performance, but is an implementation detail in terms of the architecture.</span></span> <span data-ttu-id="2ccde-157">Egy aszinkron protokoll azt jelenti, hogy a küldő nem várniuk a válaszra.</span><span class="sxs-lookup"><span data-stu-id="2ccde-157">An asynchronous protocol means the sender doesn't wait for a response.</span></span> <span data-ttu-id="2ccde-158">HTTP egy szinkron protokoll, annak ellenére, hogy egy HTTP-alapú aszinkron i/o használhatja a kérelem elküldésekor.</span><span class="sxs-lookup"><span data-stu-id="2ccde-158">HTTP is a synchronous protocol, even though an HTTP client may use asynchronous I/O when it sends a request.</span></span>

<span data-ttu-id="2ccde-159">Mindegyik minta hátrányai is vannak.</span><span class="sxs-lookup"><span data-stu-id="2ccde-159">There are tradeoffs to each pattern.</span></span> <span data-ttu-id="2ccde-160">Kérés/válasz nem egy jól érthető paradigm, ezért a API-k tervezése úgy természetesebb, mint a üzenetkezelési rendszerek tervezése során.</span><span class="sxs-lookup"><span data-stu-id="2ccde-160">Request/response is a well-understood paradigm, so designing an API may feel more natural than designing a messaging system.</span></span> <span data-ttu-id="2ccde-161">Aszinkron üzenetkezelés azonban van néhány előnyeit, amelyek a mikroszolgáltatási architektúrákban nagyon hasznosak lehetnek:</span><span class="sxs-lookup"><span data-stu-id="2ccde-161">However, asynchronous messaging has some advantages that can be very useful in a microservices architecture:</span></span>

- <span data-ttu-id="2ccde-162">**Kapcsolási csökkentett**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-162">**Reduced coupling**.</span></span> <span data-ttu-id="2ccde-163">Az üzenet küldője nem kell tudnia a fogyasztó.</span><span class="sxs-lookup"><span data-stu-id="2ccde-163">The message sender does not need to know about the consumer.</span></span>

- <span data-ttu-id="2ccde-164">**Több előfizető**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-164">**Multiple subscribers**.</span></span> <span data-ttu-id="2ccde-165">A közzétételi és előfizetési modell használatával, több fogyasztó előfizethetnek események fogadására.</span><span class="sxs-lookup"><span data-stu-id="2ccde-165">Using a pub/sub model, multiple consumers can subscribe to receive events.</span></span> <span data-ttu-id="2ccde-166">Lásd: [eseményvezérelt architektúra stílusának](/azure/architecture/guide/architecture-styles/event-driven).</span><span class="sxs-lookup"><span data-stu-id="2ccde-166">See [Event-driven architecture style](/azure/architecture/guide/architecture-styles/event-driven).</span></span>

- <span data-ttu-id="2ccde-167">**Hiba elkülönítési**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-167">**Failure isolation**.</span></span> <span data-ttu-id="2ccde-168">Ha a feldolgozó meghibásodik, a küldő továbbra is küldhet üzeneteket.</span><span class="sxs-lookup"><span data-stu-id="2ccde-168">If the consumer fails, the sender can still send messages.</span></span> <span data-ttu-id="2ccde-169">Az üzenetek fog felvenni, amikor helyreállítja a felhasználói.</span><span class="sxs-lookup"><span data-stu-id="2ccde-169">The messages will be picked up when the consumer recovers.</span></span> <span data-ttu-id="2ccde-170">Ez a lehetőség különösen hasznos a mikroszolgáltatási architektúrákban, mert minden szolgáltatásnak van saját életciklusát.</span><span class="sxs-lookup"><span data-stu-id="2ccde-170">This ability is especially useful in a microservices architecture, because each service has its own lifecycle.</span></span> <span data-ttu-id="2ccde-171">Egy szolgáltatás elérhetetlenné válnak, vagy egy adott időpontban egy újabb verzióra kell cserélni.</span><span class="sxs-lookup"><span data-stu-id="2ccde-171">A service could become unavailable or be replaced with a newer version at any given time.</span></span> <span data-ttu-id="2ccde-172">Aszinkron üzenetkezelés időszakos állásidő képes kezelni.</span><span class="sxs-lookup"><span data-stu-id="2ccde-172">Asynchronous messaging can handle intermittent downtime.</span></span> <span data-ttu-id="2ccde-173">Szinkron API-k, másrészt megkövetelése az alárendelt szolgáltatás elérhető legyen, vagy a művelet sikertelen lesz.</span><span class="sxs-lookup"><span data-stu-id="2ccde-173">Synchronous APIs, on the other hand, require the downstream service to be available or the operation fails.</span></span>

- <span data-ttu-id="2ccde-174">**Válaszképességét**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-174">**Responsiveness**.</span></span> <span data-ttu-id="2ccde-175">Egy felsőbb szintű szolgáltatás gyorsabban választ is, ha várja meg az alárendelt szolgáltatásokkal.</span><span class="sxs-lookup"><span data-stu-id="2ccde-175">An upstream service can reply faster if it does not wait on downstream services.</span></span> <span data-ttu-id="2ccde-176">Ez különösen hasznos a mikroszolgáltatási architektúrákban.</span><span class="sxs-lookup"><span data-stu-id="2ccde-176">This is especially useful in a microservices architecture.</span></span> <span data-ttu-id="2ccde-177">Ha (szolgáltatás egy hívás B, amely meghívja a C, és így tovább) szolgáltatásfüggőségek láncolata, a szinkron hívások vár adhat hozzá késés elfogadhatatlan mennyiségű.</span><span class="sxs-lookup"><span data-stu-id="2ccde-177">If there is a chain of service dependencies (service A calls B, which calls C, and so on), waiting on synchronous calls can add unacceptable amounts of latency.</span></span>

- <span data-ttu-id="2ccde-178">**Terheléskiegyenlítés**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-178">**Load leveling**.</span></span> <span data-ttu-id="2ccde-179">Egy üzenetsor képes pufferként a terhelés kiegyenlítése érdekében, hogy a fogadók a saját ütemben üzenetek feldolgozásához.</span><span class="sxs-lookup"><span data-stu-id="2ccde-179">A queue can act as a buffer to level the workload, so that receivers can process messages at their own rate.</span></span>

- <span data-ttu-id="2ccde-180">**A munkafolyamatok**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-180">**Workflows**.</span></span> <span data-ttu-id="2ccde-181">Üzenetsorok ellenőrzőpontos az üzenetet a munkafolyamat minden lépése után egy munkafolyamatot kezeléséhez használható.</span><span class="sxs-lookup"><span data-stu-id="2ccde-181">Queues can be used to manage a workflow, by check-pointing the message after each step in the workflow.</span></span>

<span data-ttu-id="2ccde-182">Vannak azonban is áttekinthet néhány problémát, gyakorlatilag az aszinkron üzenetkezelés használatával.</span><span class="sxs-lookup"><span data-stu-id="2ccde-182">However, there are also some challenges to using asynchronous messaging effectively.</span></span>

- <span data-ttu-id="2ccde-183">**Az üzenetkezelési infrastruktúra a csatolási**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-183">**Coupling with the messaging infrastructure**.</span></span> <span data-ttu-id="2ccde-184">Egy adott üzenetkezelési infrastruktúrát használó szoros összekapcsolódást okozhat az infrastruktúrát.</span><span class="sxs-lookup"><span data-stu-id="2ccde-184">Using a particular messaging infrastructure may cause tight coupling with that infrastructure.</span></span> <span data-ttu-id="2ccde-185">Később átválthat egy másik üzenetküldési infrastruktúra nehéz lesz.</span><span class="sxs-lookup"><span data-stu-id="2ccde-185">It will be difficult to switch to another messaging infrastructure later.</span></span>

- <span data-ttu-id="2ccde-186">**Késés**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-186">**Latency**.</span></span> <span data-ttu-id="2ccde-187">Egy művelet végpontok közötti késés magas, ha az üzenet-várólistákból megtelnek válhat.</span><span class="sxs-lookup"><span data-stu-id="2ccde-187">End-to-end latency for an operation may become high if the message queues fill up.</span></span>

- <span data-ttu-id="2ccde-188">**Költség**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-188">**Cost**.</span></span> <span data-ttu-id="2ccde-189">Nagy sebességű jelentős hatással lehet a az üzenetkezelési infrastruktúra költségét.</span><span class="sxs-lookup"><span data-stu-id="2ccde-189">At high throughputs, the monetary cost of the messaging infrastructure could be significant.</span></span>

- <span data-ttu-id="2ccde-190">**Összetettség**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-190">**Complexity**.</span></span> <span data-ttu-id="2ccde-191">Aszinkron üzenetkezelés kezelése nem egy jelentéktelen feladat.</span><span class="sxs-lookup"><span data-stu-id="2ccde-191">Handling asynchronous messaging is not a trivial task.</span></span> <span data-ttu-id="2ccde-192">Ismétlődő üzenetek, például megszüntetéséhez másolásával vagy azáltal, hogy a művelet idempotens kell kezelnie.</span><span class="sxs-lookup"><span data-stu-id="2ccde-192">For example, you must handle duplicated messages, either by de-duplicating or by making operations idempotent.</span></span> <span data-ttu-id="2ccde-193">Emellett akkor is nehezen megvalósíthatók kérés-válasz szemantika aszinkron üzenetküldés segítségével.</span><span class="sxs-lookup"><span data-stu-id="2ccde-193">It's also hard to implement request-response semantics using asynchronous messaging.</span></span> <span data-ttu-id="2ccde-194">Visszajelzés küldése szüksége van egy másik üzenetsornak, és vesse össze a kérés-és válaszüzenetek lehetővé.</span><span class="sxs-lookup"><span data-stu-id="2ccde-194">To send a response, you need another queue, plus a way to correlate request and response messages.</span></span>

- <span data-ttu-id="2ccde-195">**Átviteli sebesség**.</span><span class="sxs-lookup"><span data-stu-id="2ccde-195">**Throughput**.</span></span> <span data-ttu-id="2ccde-196">Ha üzeneteket kell *szemantika várólistára*, az üzenetsor szűk keresztmetszetté válhat a rendszerben.</span><span class="sxs-lookup"><span data-stu-id="2ccde-196">If messages require *queue semantics*, the queue can become a bottleneck in the system.</span></span> <span data-ttu-id="2ccde-197">A szükséges minden üzenetet legalább egy várólista működését és a egy sorból.</span><span class="sxs-lookup"><span data-stu-id="2ccde-197">Each message requires at least one queue operation and one dequeue operation.</span></span> <span data-ttu-id="2ccde-198">Továbbá várólista szemantika általában valamilyen zárolás belül az üzenetkezelési infrastruktúra szükséges.</span><span class="sxs-lookup"><span data-stu-id="2ccde-198">Moreover, queue semantics generally require some kind of locking inside the messaging infrastructure.</span></span> <span data-ttu-id="2ccde-199">Ha egy felügyelt szolgáltatás, az üzenetsor előfordulhat késést, mert a várólista külső a fürt virtuális hálózathoz.</span><span class="sxs-lookup"><span data-stu-id="2ccde-199">If the queue is a managed service, there may be additional latency, because the queue is external to the cluster's virtual network.</span></span> <span data-ttu-id="2ccde-200">A kötegelés üzenetek csökkentheti ezeket a problémákat, de, amely bonyolultabbá teszi a kód.</span><span class="sxs-lookup"><span data-stu-id="2ccde-200">You can mitigate these issues by batching messages, but that complicates the code.</span></span> <span data-ttu-id="2ccde-201">Ha az üzenetek üzenetsorba szemantika nem igényelnek, fogja tudni használni az esemény *stream* helyett egy üzenetsorba.</span><span class="sxs-lookup"><span data-stu-id="2ccde-201">If the messages don't require queue semantics, you might be able to use an event *stream* instead of a queue.</span></span> <span data-ttu-id="2ccde-202">További információkért lásd: [architekturális stílus eseményvezérelt](../guide/architecture-styles/event-driven.md).</span><span class="sxs-lookup"><span data-stu-id="2ccde-202">For more information, see [Event-driven architectural style](../guide/architecture-styles/event-driven.md).</span></span>

## <a name="drone-delivery-choosing-the-messaging-patterns"></a><span data-ttu-id="2ccde-203">Drone Delivery: Az üzenetkezelési minták kiválasztása</span><span class="sxs-lookup"><span data-stu-id="2ccde-203">Drone Delivery: Choosing the messaging patterns</span></span>

<span data-ttu-id="2ccde-204">Ezeket a szempontokat szem előtt a fejlesztői csapat hozni a következő tervezési szempontokat a Drone Delivery alkalmazás</span><span class="sxs-lookup"><span data-stu-id="2ccde-204">With these considerations in mind, the development team made the following design choices for the Drone Delivery application</span></span>

- <span data-ttu-id="2ccde-205">A szolgáltatás nyilvános REST API-t használó ügyfélalkalmazások ütemezése, frissítenie vagy megszakítja a szállítások tesz elérhetővé.</span><span class="sxs-lookup"><span data-stu-id="2ccde-205">The Ingestion service exposes a public REST API that client applications use to schedule, update, or cancel deliveries.</span></span>

- <span data-ttu-id="2ccde-206">A szolgáltatás az Event Hubs aszinkron üzeneteket küldeni a Scheduler szolgáltatás használ.</span><span class="sxs-lookup"><span data-stu-id="2ccde-206">The Ingestion service uses Event Hubs to send asynchronous messages to the Scheduler service.</span></span> <span data-ttu-id="2ccde-207">Aszinkron üzenetekkel is végre kell hajtani a terhelés-kiegyenlítés szükséges támogatunk.</span><span class="sxs-lookup"><span data-stu-id="2ccde-207">Asynchronous messages are necessary to implement the load-leveling that is required for ingestion.</span></span> <span data-ttu-id="2ccde-208">A betöltési és a Scheduler szolgáltatás együttműködését a részletekért lásd: [adatfeldolgozás és munkafolyamatok][ingestion-workflow].</span><span class="sxs-lookup"><span data-stu-id="2ccde-208">For details on how the Ingestion and Scheduler services interact, see [Ingestion and workflow][ingestion-workflow].</span></span>

- <span data-ttu-id="2ccde-209">Minden fiók, a kézbesítési, a csomag, a Drónos és a külső átviteli szolgáltatások belső REST API-k elérhetővé tehet.</span><span class="sxs-lookup"><span data-stu-id="2ccde-209">The Account, Delivery, Package, Drone, and Third-party Transport services all expose internal REST APIs.</span></span> <span data-ttu-id="2ccde-210">A Scheduler szolgáltatás ezen API-k számára, egy felhasználói kérelem hív meg.</span><span class="sxs-lookup"><span data-stu-id="2ccde-210">The Scheduler service calls these APIs to carry out a user request.</span></span> <span data-ttu-id="2ccde-211">Egy szinkron API-k oka, hogy az ütemező kell az alsóbb rétegbeli minden kapott választ.</span><span class="sxs-lookup"><span data-stu-id="2ccde-211">One reason to use synchronous APIs is that the Scheduler needs to get a response from each of the downstream services.</span></span> <span data-ttu-id="2ccde-212">Hiba történt az alsóbb rétegbeli szolgáltatások azt jelenti, hogy a teljes művelet sikertelen volt.</span><span class="sxs-lookup"><span data-stu-id="2ccde-212">A failure in any of the downstream services means the entire operation failed.</span></span> <span data-ttu-id="2ccde-213">Azonban egy potenciális problémát, a késés, a háttérszolgáltatások meghívásával bevezetett mennyiségét.</span><span class="sxs-lookup"><span data-stu-id="2ccde-213">However, a potential issue is the amount of latency that is introduced by calling the backend services.</span></span>

- <span data-ttu-id="2ccde-214">Ha bármely alárendelt szolgáltatás nem átmeneti hiba, a teljes tranzakció kell megjelölve lennie nem sikerült.</span><span class="sxs-lookup"><span data-stu-id="2ccde-214">If any downstream service has a non-transient failure, the entire transaction should be marked as failed.</span></span> <span data-ttu-id="2ccde-215">Ebben az esetben kezelése érdekében a Scheduler szolgáltatás aszinkron üzenetet küld a felügyelő, hogy a felügyelő ütemezheti a kompenzáló tranzakciók, a fejezetben leírtak szerint [adatfeldolgozás és munkafolyamatok] [ ingestion-workflow].</span><span class="sxs-lookup"><span data-stu-id="2ccde-215">To handle this case, the Scheduler service sends an asynchronous message to the Supervisor, so that the Supervisor can schedule compensating transactions, as described in the chapter [Ingestion and workflow][ingestion-workflow].</span></span>

- <span data-ttu-id="2ccde-216">A kézbesítési szolgáltatás elérhetővé teszi a nyilvános API-t, amellyel az ügyfelek egy kézbesítési állapotának lekéréséhez.</span><span class="sxs-lookup"><span data-stu-id="2ccde-216">The Delivery service exposes a public API that clients can use to get the status of a delivery.</span></span> <span data-ttu-id="2ccde-217">A fejezet [API-átjáró](./gateway.md), bemutatjuk, hogyan API-átjáró elrejtheti az ügyféltől az alapul szolgáló szolgáltatások, így az ügyfél nem kell tudnia a mely szolgáltatások mely API-k elérhetővé.</span><span class="sxs-lookup"><span data-stu-id="2ccde-217">In the chapter [API gateway](./gateway.md), we discuss how an API gateway can hide the underlying services from the client, so the client doesn't need to know which services expose which APIs.</span></span>

- <span data-ttu-id="2ccde-218">Bár egy drónt útban, a Drone szolgáltatás küld eseményeket, amelyek tartalmazzák a drone aktuális helyét és állapotát.</span><span class="sxs-lookup"><span data-stu-id="2ccde-218">While a drone is in flight, the Drone service sends events that contain the drone's current location and status.</span></span> <span data-ttu-id="2ccde-219">A kézbesítési szolgáltatás egy kézbesítési állapotának nyomon követése érdekében ezeket az eseményeket figyeli.</span><span class="sxs-lookup"><span data-stu-id="2ccde-219">The Delivery service listens to these events in order to track the status of a delivery.</span></span>

- <span data-ttu-id="2ccde-220">Ha a szállítási állapota, a kézbesítési szolgáltatás például küld-e egy kézbesítési állapot esemény `DeliveryCreated` vagy `DeliveryCompleted`.</span><span class="sxs-lookup"><span data-stu-id="2ccde-220">When the status of a delivery changes, the Delivery service sends a delivery status event, such as `DeliveryCreated` or `DeliveryCompleted`.</span></span> <span data-ttu-id="2ccde-221">Bármely szolgáltatás előfizethetnek ezeket az eseményeket.</span><span class="sxs-lookup"><span data-stu-id="2ccde-221">Any service can subscribe to these events.</span></span> <span data-ttu-id="2ccde-222">A jelenlegi kialakítás a kézbesítési szolgáltatás nem az egyetlen előfizető, de lehet más előfizetőkkel később.</span><span class="sxs-lookup"><span data-stu-id="2ccde-222">In the current design, the Delivery service is the only subscriber, but there might be other subscribers later.</span></span> <span data-ttu-id="2ccde-223">Például egy valós idejű elemzési szolgáltatás az események előfordulhat, hogy lépjen.</span><span class="sxs-lookup"><span data-stu-id="2ccde-223">For example, the events might go to a real-time analytics service.</span></span> <span data-ttu-id="2ccde-224">És az ütemező nem kell várniuk a válaszra, mert az több előfizetők hozzáadása nem befolyásolja a munkafolyamat fő elérési útja.</span><span class="sxs-lookup"><span data-stu-id="2ccde-224">And because the Scheduler doesn't have to wait for a response, adding more subscribers doesn't affect the main workflow path.</span></span>

![Drónos kommunikációs ábrája](./images/drone-communication.png)

<span data-ttu-id="2ccde-226">Figyelje meg, hogy a kézbesítési állapotesemények drón helyét események származnak.</span><span class="sxs-lookup"><span data-stu-id="2ccde-226">Notice that delivery status events are derived from drone location events.</span></span> <span data-ttu-id="2ccde-227">Például ha csökken a csomag egy drónt eléri egy kézbesítési hely, a kézbesítési szolgáltatás fordítja le ez egy DeliveryCompleted esemény.</span><span class="sxs-lookup"><span data-stu-id="2ccde-227">For example, when a drone reaches a delivery location and drops off a package, the Delivery service translates this into a DeliveryCompleted event.</span></span> <span data-ttu-id="2ccde-228">Itt látható egy példa vélekedést tartománymodellek tekintetében.</span><span class="sxs-lookup"><span data-stu-id="2ccde-228">This is an example of thinking in terms of domain models.</span></span> <span data-ttu-id="2ccde-229">A fentebb leírt módon Drónos felügyeleti körülhatárolt kontextus egy külön tartozik.</span><span class="sxs-lookup"><span data-stu-id="2ccde-229">As described earlier, Drone Management belongs in a separate bounded context.</span></span> <span data-ttu-id="2ccde-230">A drone eseményeket továbbítja egy drónt fizikai helyét.</span><span class="sxs-lookup"><span data-stu-id="2ccde-230">The drone events convey the physical location of a drone.</span></span> <span data-ttu-id="2ccde-231">A kézbesítési esemény, másrészt egy kézbesítési, amely egy másik üzleti entitás állapotának változása képviseli.</span><span class="sxs-lookup"><span data-stu-id="2ccde-231">The delivery events, on the other hand, represent changes in the status of a delivery, which is a different business entity.</span></span>

## <a name="using-a-service-mesh"></a><span data-ttu-id="2ccde-232">A szolgáltatás rácsvonal használatával</span><span class="sxs-lookup"><span data-stu-id="2ccde-232">Using a service mesh</span></span>

<span data-ttu-id="2ccde-233">A *háló szolgáltatás* szoftver rétege, amely kezeli a szolgáltatások közötti kommunikációt.</span><span class="sxs-lookup"><span data-stu-id="2ccde-233">A *service mesh* is a software layer that handles service-to-service communication.</span></span> <span data-ttu-id="2ccde-234">Szolgáltatás rácsvonalak úgy tervezték, számos, az az előző szakaszban felsorolt problémák megoldása érdekében, és ezek a problémák távolabbi magukat a mikroszolgáltatás-alapú és a egy megosztott rétegre felelősséget áthelyezni.</span><span class="sxs-lookup"><span data-stu-id="2ccde-234">Service meshes are designed to address many of the concerns listed in the previous section, and to move responsibility for these concerns away from the microservices themselves and into a shared layer.</span></span> <span data-ttu-id="2ccde-235">A szolgáltatás háló proxyként működik, amely elfogja a mikroszolgáltatások a fürt közötti hálózati kommunikáció.</span><span class="sxs-lookup"><span data-stu-id="2ccde-235">The service mesh acts as a proxy that intercepts network communication between microservices in the cluster.</span></span>

> [!NOTE]
> <span data-ttu-id="2ccde-236">Szolgáltatás háló egyik példája a [Nagykövet minta](../patterns/ambassador.md) &mdash; segítő szolgáltatása, amely az alkalmazás nevében hálózati kéréseket küld.</span><span class="sxs-lookup"><span data-stu-id="2ccde-236">Service mesh is an example of the [Ambassador pattern](../patterns/ambassador.md) &mdash; a helper service that sends network requests on behalf of the application.</span></span>

<span data-ttu-id="2ccde-237">Most, a fő lehetőség áll rendelkezésre a Kubernetes szolgáltatás rácsvonal [linkerd](https://linkerd.io/) és [Istio](https://istio.io/).</span><span class="sxs-lookup"><span data-stu-id="2ccde-237">Right now, the main options for a service mesh in Kubernetes are [linkerd](https://linkerd.io/) and [Istio](https://istio.io/).</span></span> <span data-ttu-id="2ccde-238">Mindkét technológiát gyorsan fejlődő.</span><span class="sxs-lookup"><span data-stu-id="2ccde-238">Both of these technologies are evolving rapidly.</span></span> <span data-ttu-id="2ccde-239">Azonban néhány linkerd és Istio is rendelkező közös funkciók:</span><span class="sxs-lookup"><span data-stu-id="2ccde-239">However, some features that both linkerd and Istio have in common include:</span></span>

- <span data-ttu-id="2ccde-240">Terheléselosztás a munkamenet szintjén, a megfigyelt késéseket vagy a szálankénti függőben lévő kérelmek száma alapján.</span><span class="sxs-lookup"><span data-stu-id="2ccde-240">Load balancing at the session level, based on observed latencies or number of outstanding requests.</span></span> <span data-ttu-id="2ccde-241">Ezzel javítható a teljesítmény a 4. réteg terheléselosztását Kubernetes által biztosított keresztül.</span><span class="sxs-lookup"><span data-stu-id="2ccde-241">This can improve performance over the layer-4 load balancing that is provided by Kubernetes.</span></span>

- <span data-ttu-id="2ccde-242">7. rétegbeli útválasztási URL-cím, állomásfejlécet, API-verzió vagy egyéb alkalmazásszintű szabályok alapján.</span><span class="sxs-lookup"><span data-stu-id="2ccde-242">Layer-7 routing based on URL path, Host header, API version, or other application-level rules.</span></span>

- <span data-ttu-id="2ccde-243">Próbálkozzon újra a sikertelen kérelmek.</span><span class="sxs-lookup"><span data-stu-id="2ccde-243">Retry of failed requests.</span></span> <span data-ttu-id="2ccde-244">A szolgáltatás rácsvonal tisztában van azzal a HTTP-hibakódok, és automatikusan újra a sikertelen kérelmek.</span><span class="sxs-lookup"><span data-stu-id="2ccde-244">A service mesh understands HTTP error codes, and can automatically retry failed requests.</span></span> <span data-ttu-id="2ccde-245">Beállíthatja a maximális újrapróbálkozások számát, és a egy bizonyos időkorláton annak érdekében, hogy a maximális várakozási kötve.</span><span class="sxs-lookup"><span data-stu-id="2ccde-245">You can configure that maximum number of retries, along with a timeout period in order to bound the maximum latency.</span></span>

- <span data-ttu-id="2ccde-246">Áramkör-megszakítás.</span><span class="sxs-lookup"><span data-stu-id="2ccde-246">Circuit breaking.</span></span> <span data-ttu-id="2ccde-247">Ha egy példány folyamatosan sikertelen kérelmek, a szolgáltatás háló fogja ideiglenesen megjelölése nem érhető el.</span><span class="sxs-lookup"><span data-stu-id="2ccde-247">If an instance consistently fails requests, the service mesh will temporarily mark it as unavailable.</span></span> <span data-ttu-id="2ccde-248">A leállási idő elteltével újra megpróbálja a a példányt.</span><span class="sxs-lookup"><span data-stu-id="2ccde-248">After a backoff period, it will try the instance again.</span></span> <span data-ttu-id="2ccde-249">Beállíthatja, hogy az áramkör-megszakító különféle feltételek, például az egymást követő hibák száma alapján</span><span class="sxs-lookup"><span data-stu-id="2ccde-249">You can configure the circuit breaker based on various criteria, such as the number of consecutive failures,</span></span>  

- <span data-ttu-id="2ccde-250">Szolgáltatás háló eredményezhet hívássorozatot indított, például a kérés kötet, a késés, a hiba és a sikeres és a válaszok mérete metrikákat rögzíti.</span><span class="sxs-lookup"><span data-stu-id="2ccde-250">Service mesh captures metrics about interservice calls, such as the request volume, latency, error and success rates, and response sizes.</span></span> <span data-ttu-id="2ccde-251">A szolgáltatás háló is lehetővé teszi az elosztott nyomkövetést korrelációs adatokat az egyes ugrások hozzáadásával a kérelemben.</span><span class="sxs-lookup"><span data-stu-id="2ccde-251">The service mesh also enables distributed tracing by adding correlation information for each hop in a request.</span></span>

- <span data-ttu-id="2ccde-252">Szolgáltatások közötti hívások kölcsönös TLS hitelesítés.</span><span class="sxs-lookup"><span data-stu-id="2ccde-252">Mutual TLS Authentication for service-to-service calls.</span></span>

<span data-ttu-id="2ccde-253">Szükség van egy szolgáltatás háló?</span><span class="sxs-lookup"><span data-stu-id="2ccde-253">Do you need a service mesh?</span></span> <span data-ttu-id="2ccde-254">Adnak hozzá egy elosztott rendszer értéke természetesen meggyőző.</span><span class="sxs-lookup"><span data-stu-id="2ccde-254">The value they add to a distributed system is certainly compelling.</span></span> <span data-ttu-id="2ccde-255">Ha egy szolgáltatás háló nem rendelkezik, vegye figyelembe, egyes fejezet elején említett kihívást kell.</span><span class="sxs-lookup"><span data-stu-id="2ccde-255">If you don't have a service mesh, you will need to consider each of the challenges mentioned at the beginning of the chapter.</span></span> <span data-ttu-id="2ccde-256">Megoldható problémák, mint például az újrapróbálkozási, áramkör-megszakító és a egy szolgáltatás háló nélkül elosztott nyomkövetést, de a szolgáltatás rácsvonal helyezi át ezen kívül az egyes szolgáltatásokat és a egy dedikált rétegre vonatkozik.</span><span class="sxs-lookup"><span data-stu-id="2ccde-256">You can solve problems like retry, circuit breaker, and distributed tracing without a service mesh, but a service mesh moves these concerns out of the individual services and into a dedicated layer.</span></span> <span data-ttu-id="2ccde-257">Másrészről szolgáltatás rácsvonalak olyan viszonylag új technológia, amely továbbra is a lejáró.</span><span class="sxs-lookup"><span data-stu-id="2ccde-257">On the other hand, service meshes are a relatively new technology that is still maturing.</span></span> <span data-ttu-id="2ccde-258">A szolgáltatás-háló üzembe helyezése bonyolultabbá teszi a telepítés és a fürt konfigurációját.</span><span class="sxs-lookup"><span data-stu-id="2ccde-258">Deploying a service mesh adds complexity to the setup and configuration of the cluster.</span></span> <span data-ttu-id="2ccde-259">Előfordulhatnak teljesítményre gyakorolt hatása, mivel a kérelmek most már van irányítva a szolgáltatás háló proxyn keresztül, és mivel a felesleges szolgáltatások futnak a fürt minden csomópontján.</span><span class="sxs-lookup"><span data-stu-id="2ccde-259">There may be performance implications, because requests now get routed through the service mesh proxy, and because extra services are now running on every node in the cluster.</span></span> <span data-ttu-id="2ccde-260">Érdemes tegye alapos teljesítmény és a terheléses tesztelés éles környezetben a szolgáltatás-háló üzembe helyezése előtt.</span><span class="sxs-lookup"><span data-stu-id="2ccde-260">You should do thorough performance and load testing before deploying a service mesh in production.</span></span>

> [!div class="nextstepaction"]
> [<span data-ttu-id="2ccde-261">API-tervezés</span><span class="sxs-lookup"><span data-stu-id="2ccde-261">API design</span></span>](./api-design.md)

<!-- links -->

[ingestion-workflow]: ./ingestion-workflow.md
